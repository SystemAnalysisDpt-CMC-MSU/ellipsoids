classdef ReachTestCase < mlunit.test_case
    %
    properties (Constant, GetAccess = private)
        N_TIME_GRID_POINTS = 200;
        REL_TOL = 1e-5;
        ABS_TOL = 1e-6;
    end
    %
    properties (Access = private)
       testDataRootDir
    end
    %
    methods (Static)
        function dif = derivativeSupportFunction(t, x, aMat, bMat,...
                                                 pVec, pMat, nElem)
            y = x(1 : nElem);
            %
            dif = zeros(nElem + 1, 1);
            dif(1 : nElem) = -(aMat(t).') * y;
            dif(nElem + 1) =...
                (y.') * bMat(t) * pVec(t) +...
                sqrt((y.') * bMat(t) * pMat(t) * (bMat(t).') * y);
        end
    end
    %  
    methods
        function self = ReachTestCase(varargin)
            self = self@mlunit.test_case(varargin{:});
            [~, className] = modgen.common.getcallernameext(1);
            shortClassName = mfilename('classname');
            self.testDataRootDir =...
                [fileparts(which(className)), filesep,...
                'TestData', filesep, shortClassName];
        end
        %
        %% testing function reach(...)
        %
        % \dot{x}(\tau) = A x(\tau), B = 0
        % T = [0 t]
        function self = DISABLED_testStationarySystemWithoutControl(self)
            %%
            linsysAMat = eye(2);
            linsysBMat = zeros(2);
            configurationQMat = eye(2);
            controlBoundsUEll = ellipsoid(configurationQMat);
            stationaryLinsys =...
                elltool.core.control.LinSys(linsysAMat,...
                linsysBMat,...
                controlBoundsUEll,...
                zeros(2),...
                ellipsoid(zeros(2)));
            initialSetEll = ellipsoid(configurationQMat);
            initialDirectionsMat = [1 0; 0 1];
            timeIntervalVec = [0 1];    
            %%
            reachSet = elltool.core.control.Reach(stationaryLinsys,...
                             initialSetEll,...
                             initialDirectionsMat,...
                             timeIntervalVec);
            externalApproxMat = get_ea(reachSet);
            internalApproxMat = get_ia(reachSet);
            approxCenterMat = get_center(reachSet);
            approxDirectionsCMat = get_directions(reachSet);
            approxGoodCurvesCMat = get_goodcurves(reachSet);
            approxDirectionsMat = cell2mat(approxDirectionsCMat);
            approxGoodCurvesMat = cell2mat(approxGoodCurvesCMat);
            %%
            expExternalApproxVec = [];
            expInternalApproxVec = [];
            expDirectionsArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            expGoodCurvesArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            timeGridVec = linspace(timeIntervalVec(1),...
                                   timeIntervalVec(2),...
                                   self.N_TIME_GRID_POINTS);
            %%                
            for iTime = 1 : self.N_TIME_GRID_POINTS
                expExternalApproxVec =...
                    [expExternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expInternalApproxVec =...
                    [expInternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expDirectionsArray(:, iTime, 1) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 1);
                expDirectionsArray(:, iTime, 2) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 2);
                expGoodCurvesArray(:, iTime, 1) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1) ./...
                    sqrt(expDirectionsArray(:, iTime, 1).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1));
                expGoodCurvesArray(:, iTime, 2) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2) ./...
                    sqrt(expDirectionsArray(:, iTime, 2).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2));
            end
            %%
            expDirectionsMat =...
                reshape(expDirectionsArray, 2, 2 * self.N_TIME_GRID_POINTS);
            expGoodCurvesMat =...
                reshape(expGoodCurvesArray, 2, 2 * self.N_TIME_GRID_POINTS);
            %%
            % rows of ea (or ia) are equal in this test,
            % because nothing depends on L0:
            %%
            isExternalApproxEqualityVec =...
                expExternalApproxVec == externalApproxMat(1, :);
            isInternalApproxEqualityVec =...
                expInternalApproxVec == internalApproxMat(1, :);
            isApproxCenterEqualityMat =...
                approxCenterMat == zeros(size(approxCenterMat));
            isApproxDirectionsEqualityMat =...
                approxDirectionsMat == expDirectionsMat;
            isApproxGoodCurvesEqualityMat =...
                approxGoodCurvesMat == expGoodCurvesMat;
            isTestOk = all(isExternalApproxEqualityVec) &&...
                         all(isInternalApproxEqualityVec) &&...
                         all(isApproxCenterEqualityMat(:)) &&...
                         all(isApproxDirectionsEqualityMat(:)) &&...
                         all(isApproxGoodCurvesEqualityMat(:));
            mlunit.assert_equals(true, isTestOk);
        end
        %
        %% testing non stationary system
        %% here you can save your test in mat-file
        function self = DISABLED_testNonStationarySystem(self)
            %
            %% system initialization
            linsysACMat = {'0' '-10'; '2' '-8'};
            linsysBCMat = {'10' '0'; '0' '2'};
            configQVec = [0; 0];
            configQMat = [1e-4 0; 0 1e-4];
            controlBoundsMat = eye(2);
            controlBoundsUEll = ellipsoid(controlBoundsMat);
            nonStationaryLinsys =...
                elltool.linsys.LinSys(linsysACMat,...
                linsysBCMat, controlBoundsUEll);
            %% X0:
            initialSetEll = ellipsoid(configQVec, configQMat);
            %% L0:
            initDirectionsMat = [1 0; 0 1];
            %% time interval:
            t0 = 0;
            t1 = 10;
            timeIntervalVec = [t0 t1];
            %% approximation from Reach class
            reachSet = elltool.reach.ReachContinious(nonStationaryLinsys,...
                             initialSetEll,...
                             initDirectionsMat,...
                             timeIntervalVec);
            extApprMat = get_ea(reachSet);
            intApprMat = get_ia(reachSet);
            apprDirCMat = get_directions(reachSet);
            %% other initialization
            fAMatCalc = @(t) [0 -10; 2 -8];
            fBMatCalc = @(t) [10 0; 0 2];
            % control bounds:
            fPVecCalc = @(t) [0; 0];
            fPMatCalc = @(t) [1 0; 0 1];
            nElem = size(initDirectionsMat, 1);
            OdeOptionsStruct = odeset('RelTol', self.REL_TOL,...
                'AbsTol', self.ABS_TOL * ones(nElem + 1, 1));
%             saveFileStr = strcat(self.testDataRootDir, '/test8.mat');
%             save(saveFileStr,...
%                 'linsysAMat', 'linsysBMat', 'controlBoundsUEll',...
%                 'initialSetEll', 'initDirectionsMat', 'timeIntervalVec',...
%                 'fAMatCalc', 'fBMatCalc', 'fPVecCalc', 'fPMatCalc');
            %% checking loop
            isTestOk = true;
            for iDirect = 1 : size(initDirectionsMat, 2)
                supFun0 =...
                    rho(initialSetEll, initDirectionsMat(:, iDirect));
                [timeGridVec, expResVec] =...
                    ode45(@(t, x) self.derivativeSupportFunction(t, x,...
                    fAMatCalc, fBMatCalc, fPVecCalc, fPMatCalc, nElem),...
                    [t0 t1], [initDirectionsMat(:, iDirect).', supFun0],...
                    OdeOptionsStruct);
                gridNum = size(timeGridVec, 1);
                %% checking equality
                % need to check error
                expResNorm = norm(expResVec(gridNum, 1 : nElem));
                expResNormVec = expResVec(gridNum, 1 : nElem).' ./...
                    expResNorm;
                apprDirNorm = norm(apprDirCMat{iDirect}(:, end));
                apprDirNormVec = apprDirCMat{iDirect}(:, end) ./...
                    apprDirNorm;
                apprNormExtSupFun = rho(extApprMat(iDirect, end),...
                    apprDirCMat{iDirect}(:, end)) ./ apprDirNorm;
                apprNormIntSupFun = rho(intApprMat(iDirect, end),...
                    apprDirCMat{iDirect}(:, end)) ./ apprDirNorm;
                expNormSupFun = expResVec(gridNum, nElem + 1) ./...
                    apprDirNorm;             
                isTestOk = isTestOk &&...
                    (norm(expResNormVec -...
                    apprDirNormVec) <= self.REL_TOL) &&...
                    (apprNormExtSupFun - expNormSupFun <= self.REL_TOL) &&...
                    (apprNormIntSupFun - expNormSupFun <= self.REL_TOL);
            end
            mlunit.assert_equals(true, isTestOk);
        end
        %% testing non stationary systems by loading data
        function self = DISABLED_testSavedSystems(self)
            nTest = 7; % there are 7 saved tests now
            %% test loop
            isAllTestsOk = true;
            for iTest = 1 : nTest
                savedFileStr = strcat(self.testDataRootDir,...
                    '/test', num2str(iTest), '.mat');
                load(savedFileStr,...
                    'linsysACMat', 'linsysBCMat', 'controlBoundsUEll',...
                    'initialSetEll', 'initDirectionsMat', 'timeIntervalVec',...
                    'fAMatCalc', 'fBMatCalc', 'fPVecCalc', 'fPMatCalc');
                nonStationaryLinsys =...
                    elltool.linsys.LinSys(linsysACMat,...
                    linsysBCMat, controlBoundsUEll);
                reachSet =...
                    elltool.reach.ReachContinious(nonStationaryLinsys,...
                    initialSetEll, initDirectionsMat, timeIntervalVec);
                extApproxMat = get_ea(reachSet);
                intApproxMat = get_ia(reachSet);
                apprDirCMat = get_directions(reachSet);
                nElem = size(initDirectionsMat, 1);
                OdeOptionsStruct = odeset('RelTol', self.REL_TOL,...
                    'AbsTol', self.ABS_TOL * ones(nElem + 1, 1));
                isTestOk = true;
                for iDirect = 1 : size(initDirectionsMat, 2)
                    supFun0 =...
                        rho(initialSetEll, initDirectionsMat(:, iDirect));
                    [timeGridVec, expResVec] =...
                        ode45(@(t, x) self.derivativeSupportFunction(t, x,...
                        fAMatCalc, fBMatCalc, fPVecCalc, fPMatCalc, nElem),...
                        timeIntervalVec,...
                        [initDirectionsMat(:, iDirect).', supFun0],...
                        OdeOptionsStruct);
                    gridNum = size(timeGridVec, 1);
                    %% checking equality
                    isTestOk = isTestOk &&...
                        (norm(expResVec(gridNum, 1 : nElem).' -...
                        apprDirCMat{iDirect}(:, end)) <= self.REL_TOL) &&...
                        (norm(rho(extApproxMat(iDirect, end),...
                        apprDirCMat{iDirect}(:, end)) -...
                        expResVec(gridNum, nElem + 1)) <= self.REL_TOL) &&...
                        (norm(rho(intApproxMat(iDirect, end),...
                        apprDirCMat{iDirect}(:, end)) -...
                        expResVec(gridNum, nElem + 1)) <= self.REL_TOL);
                end
                isAllTestsOk = isAllTestsOk && isTestOk;
            end;
            mlunit.assert_equals(true, isAllTestsOk);
        end
        function self = testPropertyGetters(self)
            testAbsTol = 1;
            testRelTol = 2;
            testNPlot2dPoints = 3;
            testNPlot3dPoints = 4;
            testNTimeGridPoints = 5;
            %%
            linsysAMat = eye(2);
            linsysBMat = zeros(2);
            configurationQMat = eye(2);
            controlBoundsUEll = ellipsoid(configurationQMat);
            stationaryLinsys =...
                linsys(linsysAMat, linsysBMat, controlBoundsUEll);
            initialSetEll = ellipsoid(configurationQMat);
            initialDirectionsMat = [1 0; 0 1];
            timeIntervalVec = [0 1];  
            Options = struct('approximation',0,'save_all',0,'minmax',0);
            %%
            args = {stationaryLinsys,...
                             initialSetEll,...
                             initialDirectionsMat,...
                             timeIntervalVec,Options,'absTol',testAbsTol,'relTol',testRelTol,...
                             'nTimeGridPoints',testNTimeGridPoints,'nPlot2dPoints',testNPlot2dPoints,...
                             'nPlot3dPoints',testNPlot3dPoints};
            reachSetArr = [reach(args{:}) reach(args{:}); reach(args{:}) reach(args{:})];
            reachSetArr(:,:,2) = [reach(args{:}) reach(args{:}); reach(args{:}) reach(args{:})];
            sizeArr = size(reachSetArr);
            testAbsTolArr = repmat(testAbsTol,sizeArr);
            testRelTolArr = repmat(testRelTol,sizeArr);
            testNPlot2dPointsArr = repmat(testNPlot2dPoints,sizeArr);
            testNPlot3dPointsArr = repmat(testNPlot3dPoints,sizeArr);
            testNTimeGridPointsArr = repmat(testNTimeGridPoints,sizeArr);
            isOkArr = (testAbsTolArr == reachSetArr.getAbsTol()) &(testRelTolArr == reachSetArr.getRelTol()) &...
                   (testNPlot2dPointsArr == reachSetArr.getNPlot2dPoints()) &...
                   (testNPlot3dPointsArr == reachSetArr.getNPlot3dPoints()) & ...
                   (testNTimeGridPointsArr == reachSetArr.getNTimeGridPoints());
            isOk = all(isOkArr(:));
            mlunit.assert(isOk); 
        end
    end
end