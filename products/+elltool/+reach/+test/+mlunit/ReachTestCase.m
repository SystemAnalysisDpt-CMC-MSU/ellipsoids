classdef ReachTestCase < mlunit.test_case
    %
    properties (Constant, GetAccess = private)
        N_TIME_GRID_POINTS = 200;
    end
    %
    methods
        function self = ReachTestCase(varargin)
            self = self@mlunit.test_case(varargin{:});
        end
        %% testing function reach(...)
        %
        % \dot{x}(\tau) = A x(\tau), B = 0
        % T = [0 t]
        function self = testStationarySystemWithoutControl(self)
            %%
            linsysAMat = eye(2);
            linsysBMat = zeros(2);
            configurationQMat = eye(2);
            controlBoundsUEll = ellipsoid(configurationQMat);
            stationaryLinsys =...
                linsys(linsysAMat, linsysBMat, controlBoundsUEll);
            initialSetEll = ellipsoid(configurationQMat);
            initialDirectionsMat = [1 0; 0 1];
            timeIntervalVec = [0 1];
            %%
            reachSet = reach(stationaryLinsys,...
                             initialSetEll,...
                             initialDirectionsMat,...
                             timeIntervalVec);
            externalApproxMat = get_ea(reachSet);
            internalApproxMat = get_ia(reachSet);
            approxCenterMat = get_center(reachSet);
            approxDirectionsCMat = get_directions(reachSet);
            approxGoodCurvesCMat = get_goodcurves(reachSet);
            approxDirectionsMat = cell2mat(approxDirectionsCMat);
            approxGoodCurvesMat = cell2mat(approxGoodCurvesCMat);
            %%
            expExternalApproxVec = [];
            expInternalApproxVec = [];
            expDirectionsArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            expGoodCurvesArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            timeGridVec = linspace(timeIntervalVec(1),...
                                   timeIntervalVec(2),...
                                   self.N_TIME_GRID_POINTS);
            %%                
            for iTime = 1 : self.N_TIME_GRID_POINTS
                expExternalApproxVec =...
                    [expExternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expInternalApproxVec =...
                    [expInternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expDirectionsArray(:, iTime, 1) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 1);
                expDirectionsArray(:, iTime, 2) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 2);
                expGoodCurvesArray(:, iTime, 1) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1) ./...
                    sqrt(expDirectionsArray(:, iTime, 1).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1));
                expGoodCurvesArray(:, iTime, 2) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2) ./...
                    sqrt(expDirectionsArray(:, iTime, 2).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2));
            end
            %%
            expDirectionsMat =...
                reshape(expDirectionsArray, 2, 2 * self.N_TIME_GRID_POINTS);
            expGoodCurvesMat =...
                reshape(expGoodCurvesArray, 2, 2 * self.N_TIME_GRID_POINTS);
            %%
            % rows of ea (or ia) are equal in this test,
            % because nothing depends on L0:
            %%
            isExternalApproxEqualityVec =...
                expExternalApproxVec == externalApproxMat(1, :);
            isInternalApproxEqualityVec =...
                expInternalApproxVec == internalApproxMat(1, :);
            isApproxCenterEqualityMat =...
                approxCenterMat == zeros(size(approxCenterMat));
            isApproxDirectionsEqualityMat =...
                approxDirectionsMat == expDirectionsMat;
            isApproxGoodCurvesEqualityMat =...
                approxGoodCurvesMat == expGoodCurvesMat;
            testResult = all(isExternalApproxEqualityVec) &&...
                         all(isInternalApproxEqualityVec) &&...
                         all(isApproxCenterEqualityMat(:)) &&...
                         all(isApproxDirectionsEqualityMat(:)) &&...
                         all(isApproxGoodCurvesEqualityMat(:));
            mlunit.assert_equals(true, testResult);
        end
        %
        %% testing non stationary system
        function self = testNonStationarySystem(self)
            %% system initialization
            linsysAMat = {'cos(t)' '-sin(t)'; 'sin(t)' 'cos(t)'};
            linsysBMat = {'t' 't^2'; 't^2 + t^3' '-t^2'};
            configurationQMat = eye(2);
            configurationQVec = zeros(2, 1);
            controlBoundsUEll = ellipsoid(configurationQMat);
            nonStationaryLinsys =...
                linsys(linsysAMat, linsysBMat, controlBoundsUEll);
            %% X0:
            initialSetEll = ellipsoid(configurationQVec, configurationQMat);
            %% L0:
            initDirectionsMat = [1 0; 0 1];
            %% time interval:
            t0 = 0;
            t1 = 1;
            timeIntervalVec = [t0 t1];
            %% approximation from Reach class
            reachSet = reach(nonStationaryLinsys,...
                             initialSetEll,...
                             initDirectionsMat,...
                             timeIntervalVec);
            externalApproxMat = get_ea(reachSet);
            internalApproxMat = get_ia(reachSet);
            approxDirCMat = get_directions(reachSet);
            approxDirMat = cell2mat(approxDirCMat);
            %% other initialization
            aMat = @(t) [cos(t) -sin(t); sin(t) cos(t)];
            bMat = @(t) [t t^2; t^2 + t^3 -t^2];
            pVec = @(t) [0; 0];
            pMat = @(t) [1 0; 0 1];
            nElem = size(initDirectionsMat, 1);
            rel_tol = 1e-6;
            abs_tol = 1e-7;
            options = odeset('RelTol', rel_tol,...
                'AbsTol', abs_tol * ones(nElem + 1, 1));
            %% checking loop
            testResult = true;
            for iDirect = 1 : size(initDirectionsMat, 2)
                supFun0 =...
                    rho(initialSetEll, initDirectionsMat(:, iDirect));
                [T, expResultVec] =...
                    ode45(@(t, x) derivativesupportfunction(t, x,...
                    aMat, bMat, pVec, pMat, nElem), [t0 t1],...
                    [initDirectionsMat(:, iDirect).', supFun0], options);
                
                %% checking equality                
                testResult = testResult && (norm(...
                    expResultVec(size(T, 1), 1 : nElem).' -...
                    approxDirMat(:,...
                    self.N_TIME_GRID_POINTS * iDirect)) <= rel_tol) &&...
                    (norm(...
                    rho(externalApproxMat(iDirect,...
                    self.N_TIME_GRID_POINTS),...
                    approxDirMat(:, self.N_TIME_GRID_POINTS * iDirect)) -...
                    expResultVec(size(T, 1), nElem + 1)) <= rel_tol) &&...
                    (norm(...
                    rho(internalApproxMat(iDirect,...
                    self.N_TIME_GRID_POINTS),...
                    approxDirMat(:, self.N_TIME_GRID_POINTS * iDirect)) -...
                    expResultVec(size(T, 1), nElem + 1)) <= rel_tol);
            end
            mlunit.assert_equals(true, testResult);
        end
    end
end