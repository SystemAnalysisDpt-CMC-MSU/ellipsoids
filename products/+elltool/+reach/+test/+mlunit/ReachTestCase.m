classdef ReachTestCase < mlunit.test_case
    %
    properties (Constant, GetAccess = private)
        N_TIME_GRID_POINTS = 200;
        REL_TOL = 1e-6;
        ABS_TOL = 1e-7;
    end
    %
    properties (Access = private)
       testDataRootDir
    end
    %
    methods (Static)
        function dif = derivativeSupportFunction(t, x, aMat, bMat,...
                                                 pVec, pMat, nElem)
            y = x(1 : nElem);
            %
            dif = zeros(nElem + 1, 1);
            dif(1 : nElem) = -(aMat(t).') * y;
            dif(nElem + 1) =...
                (y.') * bMat(t) * pVec(t) +...
                sqrt((y.') * bMat(t) * pMat(t) * (bMat(t).') * y);
        end
    end
    %  
    methods
        function self = ReachTestCase(varargin)
            self = self@mlunit.test_case(varargin{:});
            [~, className] = modgen.common.getcallernameext(1);
            shortClassName = mfilename('classname');
            self.testDataRootDir =...
                [fileparts(which(className)), filesep,...
                'TestData', filesep, shortClassName];
        end
        %
        %% testing function reach(...)
        %
        % \dot{x}(\tau) = A x(\tau), B = 0
        % T = [0 t]
        function self = DISABLED_testStationarySystemWithoutControl(self)
            %%
            linsysAMat = eye(2);
            linsysBMat = zeros(2);
            configurationQMat = eye(2);
            controlBoundsUEll = ellipsoid(configurationQMat);
            stationaryLinsys =...
                linsys(linsysAMat, linsysBMat, controlBoundsUEll);
            initialSetEll = ellipsoid(configurationQMat);
            initialDirectionsMat = [1 0; 0 1];
            timeIntervalVec = [0 1];    
            %%
            reachSet = reach(stationaryLinsys,...
                             initialSetEll,...
                             initialDirectionsMat,...
                             timeIntervalVec);
            externalApproxMat = get_ea(reachSet);
            internalApproxMat = get_ia(reachSet);
            approxCenterMat = get_center(reachSet);
            approxDirectionsCMat = get_directions(reachSet);
            approxGoodCurvesCMat = get_goodcurves(reachSet);
            approxDirectionsMat = cell2mat(approxDirectionsCMat);
            approxGoodCurvesMat = cell2mat(approxGoodCurvesCMat);
            %%
            expExternalApproxVec = [];
            expInternalApproxVec = [];
            expDirectionsArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            expGoodCurvesArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            timeGridVec = linspace(timeIntervalVec(1),...
                                   timeIntervalVec(2),...
                                   self.N_TIME_GRID_POINTS);
            %%                
            for iTime = 1 : self.N_TIME_GRID_POINTS
                expExternalApproxVec =...
                    [expExternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expInternalApproxVec =...
                    [expInternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expDirectionsArray(:, iTime, 1) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 1);
                expDirectionsArray(:, iTime, 2) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 2);
                expGoodCurvesArray(:, iTime, 1) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1) ./...
                    sqrt(expDirectionsArray(:, iTime, 1).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1));
                expGoodCurvesArray(:, iTime, 2) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2) ./...
                    sqrt(expDirectionsArray(:, iTime, 2).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2));
            end
            %%
            expDirectionsMat =...
                reshape(expDirectionsArray, 2, 2 * self.N_TIME_GRID_POINTS);
            expGoodCurvesMat =...
                reshape(expGoodCurvesArray, 2, 2 * self.N_TIME_GRID_POINTS);
            %%
            % rows of ea (or ia) are equal in this test,
            % because nothing depends on L0:
            %%
            isExternalApproxEqualityVec =...
                expExternalApproxVec == externalApproxMat(1, :);
            isInternalApproxEqualityVec =...
                expInternalApproxVec == internalApproxMat(1, :);
            isApproxCenterEqualityMat =...
                approxCenterMat == zeros(size(approxCenterMat));
            isApproxDirectionsEqualityMat =...
                approxDirectionsMat == expDirectionsMat;
            isApproxGoodCurvesEqualityMat =...
                approxGoodCurvesMat == expGoodCurvesMat;
            isTestOk = all(isExternalApproxEqualityVec) &&...
                         all(isInternalApproxEqualityVec) &&...
                         all(isApproxCenterEqualityMat(:)) &&...
                         all(isApproxDirectionsEqualityMat(:)) &&...
                         all(isApproxGoodCurvesEqualityMat(:));
            mlunit.assert_equals(true, isTestOk);
        end
        %
        %% testing non stationary system
        %% here you can save your test in mat-file
        function self = DISABLED_testNonStationarySystem(self)
            %% system initialization
            linsysACMat = {'cos(t)' '-sin(t)'; 'sin(t)' 'cos(t)'};
            linsysBCMat = {'1' '0'; '0' '1'};
            configQVec = [0; 0];
            configQMat = [2 1; 1 2];
            controlBiundsMat = eye(2);
            controlBoundsUEll = ellipsoid(controlBiundsMat);
            nonStationaryLinsys =...
                linsys(linsysACMat, linsysBCMat, controlBoundsUEll);
            %% X0:
            initialSetEll = ellipsoid(configQVec, configQMat);
            %% L0:
            initDirectionsMat = [1 0; 0 1];
            %% time interval:
            t0 = 0;
            t1 = 2;
            timeIntervalVec = [t0 t1];
            %% approximation from Reach class
            reachSet = reach(nonStationaryLinsys,...
                             initialSetEll,...
                             initDirectionsMat,...
                             timeIntervalVec);
            externalApproxMat = get_ea(reachSet);
            internalApproxMat = get_ia(reachSet);
            approxDirCMat = get_directions(reachSet);
            approxDirMat = cell2mat(approxDirCMat);
            %% other initialization
            fAMatCalc = @(t) [cos(t) sin(t); sin(t) cos(t)];
            fBMatCalc = @(t) [1 0; 0 1];
            fPVecCalc = @(t) [0; 0];
            fPMatCalc = @(t) [2 1; 1 2];
            nElem = size(initDirectionsMat, 1);
            OdeOptionsStruct = odeset('RelTol', self.REL_TOL,...
                'AbsTol', self.ABS_TOL * ones(nElem + 1, 1));
            %saveFileStr = strcat(self.testDataRootDir, '/test8.mat');
            %save(saveFileStr,...
            %    'linsysAMat', 'linsysBMat', 'controlBoundsUEll',...
            %    'initialSetEll', 'initDirectionsMat', 'timeIntervalVec',...
            %    'aMat', 'bMat', 'pVec', 'pMat');
            %% checking loop
            isTestOk = true;
            for iDirect = 1 : size(initDirectionsMat, 2)
                supFun0 =...
                    rho(initialSetEll, initDirectionsMat(:, iDirect));
                [T, expResultVec] =...
                    ode45(@(t, x) self.derivativeSupportFunction(t, x,...
                    fAMatCalc, fBMatCalc, fPVecCalc, fPMatCalc, nElem),...
                    [t0 t1], [initDirectionsMat(:, iDirect).', supFun0],...
                    OdeOptionsStruct);
                %% checking equality
                iTimeGrid =  self.N_TIME_GRID_POINTS * iDirect;
                isTestOk = isTestOk &&...
                    (norm(expResultVec(size(T, 1), 1 : nElem).' -...
                    approxDirMat(:, iTimeGrid)) <= self.rel_tol) &&...
                    (norm(rho(externalApproxMat(iDirect,...
                    self.N_TIME_GRID_POINTS), approxDirMat(:, iTimeGrid)) -...
                    expResultVec(size(T, 1), nElem + 1)) <= self.rel_tol) &&...
                    (norm(rho(internalApproxMat(iDirect,...
                    self.N_TIME_GRID_POINTS), approxDirMat(:, iTimeGrid)) -...
                    expResultVec(size(T, 1), nElem + 1)) <= self.rel_tol);
            end
            mlunit.assert_equals(true, isTestOk);
        end
        %% testing non stationary systems by loading data
        function self = DISABLED_testSavedSystems(self)
            nTest = 7; % there are 7 saved tests now
            %% test loop
            isAllTestsOk = true;
            for iTest = 1 : nTest
                savedFileStr = strcat(self.testDataRootDir,...
                    '/test', num2str(iTest), '.mat');
                load(savedFileStr,...
                    'linsysACMat', 'linsysBCMat', 'controlBoundsUEll',...
                    'initialSetEll', 'initDirectionsMat', 'timeIntervalVec',...
                    'fAMatCalc', 'fBMatCalc', 'fPVecCalc', 'fPMatCalc');
                nonStationaryLinsys =...
                    linsys(linsysACMat, linsysBCMat, controlBoundsUEll);
                reachSet = reach(nonStationaryLinsys, initialSetEll,...
                    initDirectionsMat, timeIntervalVec);
                externalApproxMat = get_ea(reachSet);
                internalApproxMat = get_ia(reachSet);
                approxDirCMat = get_directions(reachSet);
                approxDirMat = cell2mat(approxDirCMat);
                nElem = size(initDirectionsMat, 1);
                OdeOptionsStruct = odeset('RelTol', self.REL_TOL,...
                    'AbsTol', self.ABS_TOL * ones(nElem + 1, 1));
                isTestOk = true;
                for iDirect = 1 : size(initDirectionsMat, 2)
                    supFun0 =...
                        rho(initialSetEll, initDirectionsMat(:, iDirect));
                    [T, expResultVec] =...
                        ode45(@(t, x) self.derivativeSupportFunction(t, x,...
                        fAMatCalc, fBMatCalc, fPVecCalc, fPMatCalc, nElem),...
                        timeIntervalVec,...
                        [initDirectionsMat(:, iDirect).', supFun0],...
                        OdeOptionsStruct);
                    %% checking equality
                    iTimeGrid =  self.N_TIME_GRID_POINTS * iDirect;
                    isTestOk = isTestOk &&...
                        (norm(expResultVec(size(T, 1), 1 : nElem).' -...
                        approxDirMat(:, iTimeGrid)) <= self.rel_tol) &&...
                        (norm(rho(externalApproxMat(iDirect,...
                        self.N_TIME_GRID_POINTS), approxDirMat(:,...
                        iTimeGrid)) - expResultVec(size(T, 1),...
                        nElem + 1)) <= self.rel_tol) &&...
                        (norm(rho(internalApproxMat(iDirect,...
                        self.N_TIME_GRID_POINTS), approxDirMat(:,...
                        iTimeGrid)) - expResultVec(size(T, 1),...
                        nElem + 1)) <= self.rel_tol);
                end
                isAllTestsOk = isAllTestsOk && isTestOk;
            end;
            mlunit.assert_equals(true, isAllTestsOk);
        end
        function self = testPropertyGetters(self)
            testAbsTol = 1;
            testRelTol = 2;
            testNPlot2dPoints = 3;
            testNPlot3dPoints = 4;
            testNTimeGridPoints = 5;
            %%
            linsysAMat = eye(2);
            linsysBMat = zeros(2);
            configurationQMat = eye(2);
            controlBoundsUEll = ellipsoid(configurationQMat);
            stationaryLinsys =...
                linsys(linsysAMat, linsysBMat, controlBoundsUEll);
            initialSetEll = ellipsoid(configurationQMat);
            initialDirectionsMat = [1 0; 0 1];
            timeIntervalVec = [0 1];  
            Options = struct('approximation',0,'save_all',0,'minmax',0);
            %%
            args = {stationaryLinsys,...
                             initialSetEll,...
                             initialDirectionsMat,...
                             timeIntervalVec,Options,'absTol',testAbsTol,'relTol',testRelTol,...
                             'nTimeGridPoints',testNTimeGridPoints,'nPlot2dPoints',testNPlot2dPoints,...
                             'nPlot3dPoints',testNPlot3dPoints};
            reachSetArr = [reach(args{:}) reach(args{:}); reach(args{:}) reach(args{:})];
            reachSetArr(:,:,2) = [reach(args{:}) reach(args{:}); reach(args{:}) reach(args{:})];
            sizeArr = size(reachSetArr);
            testAbsTolArr = repmat(testAbsTol,sizeArr);
            testRelTolArr = repmat(testRelTol,sizeArr);
            testNPlot2dPointsArr = repmat(testNPlot2dPoints,sizeArr);
            testNPlot3dPointsArr = repmat(testNPlot3dPoints,sizeArr);
            testNTimeGridPointsArr = repmat(testNTimeGridPoints,sizeArr);
            isOkArr = (testAbsTolArr == reachSetArr.getAbsTol()) &(testRelTolArr == reachSetArr.getRelTol()) &...
                   (testNPlot2dPointsArr == reachSetArr.getNPlot2dPoints()) &...
                   (testNPlot3dPointsArr == reachSetArr.getNPlot3dPoints()) & ...
                   (testNTimeGridPointsArr == reachSetArr.getNTimeGridPoints());
            isOk = all(isOkArr(:));
            mlunit.assert(isOk); 
        end
    end
end