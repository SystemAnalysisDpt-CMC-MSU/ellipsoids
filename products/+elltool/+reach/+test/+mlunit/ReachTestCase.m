classdef ReachTestCase < mlunit.test_case
    %
    properties (Constant, GetAccess = private)
        N_TIME_GRID_POINTS = 200;
        rel_tol = 1e-6;
        abs_tol = 1e-7;
    end
    %
    methods
        function self = ReachTestCase(varargin)
            self = self@mlunit.test_case(varargin{:});
        end
        %% testing function reach(...)
        %
        % \dot{x}(\tau) = A x(\tau), B = 0
        % T = [0 t]
        function self = testStationarySystemWithoutControl(self)
            %%
            linsysAMat = eye(2);
            linsysBMat = zeros(2);
            configurationQMat = eye(2);
            controlBoundsUEll = ellipsoid(configurationQMat);
            stationaryLinsys =...
                linsys(linsysAMat, linsysBMat, controlBoundsUEll);
            initialSetEll = ellipsoid(configurationQMat);
            initialDirectionsMat = [1 0; 0 1];
            timeIntervalVec = [0 1];    
            %%
            reachSet = reach(stationaryLinsys,...
                             initialSetEll,...
                             initialDirectionsMat,...
                             timeIntervalVec);
            externalApproxMat = get_ea(reachSet);
            internalApproxMat = get_ia(reachSet);
            approxCenterMat = get_center(reachSet);
            approxDirectionsCMat = get_directions(reachSet);
            approxGoodCurvesCMat = get_goodcurves(reachSet);
            approxDirectionsMat = cell2mat(approxDirectionsCMat);
            approxGoodCurvesMat = cell2mat(approxGoodCurvesCMat);
            %%
            expExternalApproxVec = [];
            expInternalApproxVec = [];
            expDirectionsArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            expGoodCurvesArray = zeros(2, self.N_TIME_GRID_POINTS, 2);
            timeGridVec = linspace(timeIntervalVec(1),...
                                   timeIntervalVec(2),...
                                   self.N_TIME_GRID_POINTS);
            %%                
            for iTime = 1 : self.N_TIME_GRID_POINTS
                expExternalApproxVec =...
                    [expExternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expInternalApproxVec =...
                    [expInternalApproxVec...
                    ellipsoid(exp(2 * timeGridVec(iTime)) * eye(2))];
                expDirectionsArray(:, iTime, 1) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 1);
                expDirectionsArray(:, iTime, 2) =...
                    [exp(-timeGridVec(iTime)) 0;...
                     0 exp(-timeGridVec(iTime))] *...
                    initialDirectionsMat(:, 2);
                expGoodCurvesArray(:, iTime, 1) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1) ./...
                    sqrt(expDirectionsArray(:, iTime, 1).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 1));
                expGoodCurvesArray(:, iTime, 2) =...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2) ./...
                    sqrt(expDirectionsArray(:, iTime, 2).' *...
                    [exp(2 * timeGridVec(iTime)) 0;...
                     0 exp(2 * timeGridVec(iTime))] *...
                    expDirectionsArray(:, iTime, 2));
            end
            %%
            expDirectionsMat =...
                reshape(expDirectionsArray, 2, 2 * self.N_TIME_GRID_POINTS);
            expGoodCurvesMat =...
                reshape(expGoodCurvesArray, 2, 2 * self.N_TIME_GRID_POINTS);
            %%
            % rows of ea (or ia) are equal in this test,
            % because nothing depends on L0:
            %%
            isExternalApproxEqualityVec =...
                expExternalApproxVec == externalApproxMat(1, :);
            isInternalApproxEqualityVec =...
                expInternalApproxVec == internalApproxMat(1, :);
            isApproxCenterEqualityMat =...
                approxCenterMat == zeros(size(approxCenterMat));
            isApproxDirectionsEqualityMat =...
                approxDirectionsMat == expDirectionsMat;
            isApproxGoodCurvesEqualityMat =...
                approxGoodCurvesMat == expGoodCurvesMat;
            testResult = all(isExternalApproxEqualityVec) &&...
                         all(isInternalApproxEqualityVec) &&...
                         all(isApproxCenterEqualityMat(:)) &&...
                         all(isApproxDirectionsEqualityMat(:)) &&...
                         all(isApproxGoodCurvesEqualityMat(:));
            mlunit.assert_equals(true, testResult);
        end
        %
        %% testing non stationary system
        %% here you can save your test in mat-file
        function self = testNonStationarySystem(self)
            %% system initialization
            linsysAMat = {'t' '-sin(t)'; 'sin(t^3)' 't*cos(t)'};
            linsysBMat = {'t' '0'; '-0.5' 't-sin(t)'};
            configQVec = [1; 1];
            configQMat = [2 1; 1 2];
            controlBiundsMat = eye(2);
            controlBoundsUEll = ellipsoid(controlBiundsMat);
            nonStationaryLinsys =...
                linsys(linsysAMat, linsysBMat, controlBoundsUEll);
            %% X0:
            initialSetEll = ellipsoid(configQVec, configQMat);
            %% L0:
            initDirectionsMat = [1 0; 0 1];
            %% time interval:
            t0 = 0;
            t1 = 2;
            timeIntervalVec = [t0 t1];
            %% approximation from Reach class
            reachSet = reach(nonStationaryLinsys,...
                             initialSetEll,...
                             initDirectionsMat,...
                             timeIntervalVec);
            externalApproxMat = get_ea(reachSet);
            internalApproxMat = get_ia(reachSet);
            approxDirCMat = get_directions(reachSet);
            approxDirMat = cell2mat(approxDirCMat);
            %% other initialization
            aMat = @(t) [t -sin(t); sin(t^3) t*cos(t)];
            bMat = @(t) [t 0; -0.5 t-sin(t)];
            pVec = @(t) [1; 1];
            pMat = @(t) [2 1; 1 2];
            nElem = size(initDirectionsMat, 1);
            options = odeset('RelTol', self.rel_tol,...
                'AbsTol', self.abs_tol * ones(nElem + 1, 1));
            %saveFileStr = 'test8.mat';
            %save(saveFileStr,...
            %    'linsysAMat', 'linsysBMat', 'controlBoundsUEll',...
            %    'initialSetEll', 'initDirectionsMat', 'timeIntervalVec',...
            %    'aMat', 'bMat', 'pVec', 'pMat');
            %% checking loop
            isTestOk = true;
            for iDirect = 1 : size(initDirectionsMat, 2)
                supFun0 =...
                    rho(initialSetEll, initDirectionsMat(:, iDirect));
                [T, expResultVec] =...
                    ode45(@(t, x) derivativesupportfunction(t, x,...
                    aMat, bMat, pVec, pMat, nElem), [t0 t1],...
                    [initDirectionsMat(:, iDirect).', supFun0], options);
                %% checking equality                
                isTestOk = isTestOk && (norm(...
                    expResultVec(size(T, 1), 1 : nElem).' -...
                    approxDirMat(:,...
                    self.N_TIME_GRID_POINTS * iDirect)) <= self.rel_tol) &&...
                    (norm(...
                    rho(externalApproxMat(iDirect,...
                    self.N_TIME_GRID_POINTS),...
                    approxDirMat(:, self.N_TIME_GRID_POINTS * iDirect)) -...
                    expResultVec(size(T, 1), nElem + 1)) <= self.rel_tol) &&...
                    (norm(...
                    rho(internalApproxMat(iDirect,...
                    self.N_TIME_GRID_POINTS),...
                    approxDirMat(:, self.N_TIME_GRID_POINTS * iDirect)) -...
                    expResultVec(size(T, 1), nElem + 1)) <= self.rel_tol);
            end
            mlunit.assert_equals(true, isTestOk);
        end
        %% testing non stationary systems by loading data
        function self = testSavedSystems(self)
            nTest = 7; % there are 7 saved tests now
            %% test loop
            isAllTestsOk = true;
            for iTest = 1 : nTest
                saveFileStr = strcat('test', num2str(iTest), '.mat');
                load(saveFileStr,...
                    'linsysAMat', 'linsysBMat', 'controlBoundsUEll',...
                    'initialSetEll', 'initDirectionsMat',...
                    'timeIntervalVec', 'aMat', 'bMat', 'pVec', 'pMat');
                nonStationaryLinsys =...
                    linsys(linsysAMat, linsysBMat, controlBoundsUEll);
                reachSet = reach(nonStationaryLinsys, initialSetEll,...
                    initDirectionsMat, timeIntervalVec);
                externalApproxMat = get_ea(reachSet);
                internalApproxMat = get_ia(reachSet);
                approxDirCMat = get_directions(reachSet);
                approxDirMat = cell2mat(approxDirCMat);
                nElem = size(initDirectionsMat, 1);
                options = odeset('RelTol', self.rel_tol,...
                    'AbsTol', self.abs_tol * ones(nElem + 1, 1));
                isTestOk = true;
                for iDirect = 1 : size(initDirectionsMat, 2)
                    supFun0 =...
                        rho(initialSetEll, initDirectionsMat(:, iDirect));
                    [T, expResultVec] =...
                        ode45(@(t, x) derivativesupportfunction(t, x,...
                        aMat, bMat, pVec, pMat, nElem), timeIntervalVec,...
                        [initDirectionsMat(:, iDirect).', supFun0], options);
                    %% checking equality                
                    isTestOk = isTestOk && (norm(...
                        expResultVec(size(T, 1), 1 : nElem).' -...
                        approxDirMat(:,...
                        self.N_TIME_GRID_POINTS * iDirect)) <=...
                        self.rel_tol) &&...
                        (norm(rho(externalApproxMat(iDirect,...
                        self.N_TIME_GRID_POINTS), approxDirMat(:,...
                        self.N_TIME_GRID_POINTS * iDirect)) -...
                        expResultVec(size(T, 1), nElem + 1)) <=...
                        self.rel_tol) &&...
                        (norm(rho(internalApproxMat(iDirect,...
                        self.N_TIME_GRID_POINTS), approxDirMat(:,...
                        self.N_TIME_GRID_POINTS * iDirect)) -...
                        expResultVec(size(T, 1), nElem + 1)) <= self.rel_tol);
                end
                isAllTestsOk = isAllTestsOk && isTestOk;
            end;
            mlunit.assert_equals(true, isAllTestsOk);
        end
    end
end