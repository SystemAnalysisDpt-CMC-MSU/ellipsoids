.. role:: math(raw)
   :format: html latex
..

Introduction
============

Research on dynamical and hybrid systems has produced several methods
for verification and controller synthesis. A common step in these
methods is the reachability analysis of the system. Reachability
analysis is concerned with the computation of the reach set in a way
that can effectively meet requests like the following:

#. For a given target set and time, determine whether the reach set and
   the target set have nonempty intersection.

#. For specified reachable state and time, find a feasible initial
   condition and control that steers the system from this initial
   condition to the given reachable state in given time.

#. Graphically display the projection of the reach set onto any
   specified two- or three-dimensional subspace.

Except for very specific classes of systems, exact computation of reach
sets is not possible, and approximation techniques are needed. For
controlled linear systems with convex bounds on the control and initial
conditions, the efficiency and accuracy of these techniques depend on
how they represent convex sets and how well they perform the operations
of unions, intersections, geometric (Minkowski) sums and differences of
convex sets. Two basic objects are used as convex approximations:
polytopes of various types, including general polytopes, zonotopes,
parallelotopes, rectangular polytopes; and ellipsoids.

Reachability analysis for general polytopes is implemented in the Multi
Parametric Toolbox (MPT) for Matlab Kvasnica et al. (2004;
“Multi-Parametric Toolbox Homepage”). The reach set at every time step
is computed as the geometric sum of two polytopes. The procedure
consists in finding the vertices of the resulting polytope and
calculating their convex hull. MPT’s convex hull algorithm is based on
the Double Description method Motzkin et al. (1953) and implemented in
the CDD/CDD+ package (“CDD/CDD+ Homepage”). Its complexity is
:math:`V^n`, where :math:`V` is the number of vertices and :math:`n` is
the state space dimension. Hence the use of MPT is practicable for low
dimensional systems. But even in low dimensional systems the number of
vertices in the reach set polytope can grow very large with the number
of time steps. For example, consider the system,

.. math:: x_{k+1} = Ax_k + u_k ,

 with :math:`A=\left[\begin{array}{cc}
\cos 1 & -\sin 1\\
\sin 1 & \cos 1\end{array}\right]`,
:math:`u_k \in \{u\in {\bf R}^2 ~|~ \|u\|_{\infty}\leqslant1\}`, and
:math:`x_0 \in \{x\in {\bf R}^2 ~|~ \|x\|_{\infty}\leqslant1\}`.
Starting with a rectangular initial set, the number of vertices of the
reach set polytope is :math:`4k + 4` at the :math:`k`\ th step.

In :math:`d/dt` (“$d/dt$ Homepage”), the reach set is approximated by
unions of rectangular polytopes E.Asarin et al. (2000).

|image|

[ddtfig]

The algorithm works as follows. First, given the set of initial
conditions defined as a polytope, the evolution in time of the
polytope’s extreme points is computed (figure [ddtfig](a)).
:math:`R(t_1)` in figure [ddtfig](a) is the reach set of the system at
time :math:`t_1`, and :math:`R[t_0, t_1]` is the set of all points that
can be reached during :math:`[t_0, t_1]`. Second, the algorithm computes
the convex hull of vertices of both, the initial polytope and
:math:`R(t_1)` (figure [ddtfig](b)). The resulting polytope is then
bloated to include all the reachable states in :math:`[t_0,t_1]` (figure
[ddtfig](c)). Finally, this overapproximating polytope is in its turn
overapproximated by the union of rectangles (figure [ddtfig](d)). The
same procedure is repeated for the next time interval :math:`[t_1,t_2]`,
and the union of both rectangular approximations is taken (figure
[ddtfig](e,f)), and so on. Rectangular polytopes are easy to represent
and the number of facets grows linearly with dimension, but a large
number of rectangles must be used to assure the approximation is not
overly conservative. Besides, the important part of this method is again
the convex hull calculation whose implementation relies on the same
CDD/CDD+ library. This limits the dimension of the system and time
interval for which it is feasible to calculate the reach set.

Polytopes can give arbitrarily close approximations to any convex set,
but the number of vertices can grow prohibitively large and, as shown in
Avis, Bremner, and Seidel (1997), the computation of a polytope by its
convex hull becomes intractable for large number of vertices in high
dimensions.

The method of zonotopes for approximation of reach sets Girard (2005;
A.Girard, Guernic, and O.Maler 2006; “MATISSE Homepage”) uses a special
class of polytopes (see (“Zonotope Methods on Wolfgang Kühn Homepage”))
of the form,

.. math::

   Z=\{x \in {\bf R}^n ~|~
   x=c+\sum_{i=1}^p\alpha_ig_i,~ -1\leqslant\alpha_i\leqslant1\},

 wherein :math:`c` and :math:`g_1, ..., g_p` are vectors in
:math:`{\bf R}^n`. Thus, a zonotope :math:`Z` is represented by its
center :math:`c` and ‘generator’ vectors :math:`g_1, ..., g_p`. The
value :math:`p/n` is called the order of the zonotope. The main benefit
of zonotopes over general polytopes is that a symmetric polytope can be
represented more compactly than a general polytope. The geometric sum of
two zonotopes is a zonotope:

.. math:: Z(c_1, G_1)\oplus Z(c_2, G_2) = Z(c_1+c_2, [G_1 ~ G_2]),

 wherein :math:`G_1` and :math:`G_2` are matrices whose columns are
generator vectors, and :math:`[G_1 ~ G_2]` is their concatenation. Thus,
in the reach set computation, the order of the zonotope increases by
:math:`p/n` with every time step. This difficulty can be averted by
limiting the number of generator vectors, and overapproximating
zonotopes whose number of generator vectors exceeds the limit by lower
order zonotopes. The benefits of the compact zonotype representation,
however, appear to diminish because in order to plot them or check if
they intersect with given objects and compute those intersections, these
operations are performed after converting zonotopes to polytopes.

CheckMate (“CheckMate Homepage”) is a Matlab toolbox that can evaluate
specifications for trajectories starting from the set of initial
(continuous) states corresponding to the parameter values at the
vertices of the parameter set. This provides preliminary insight into
whether the specifications will be true for all parameter values. The
method of oriented rectangluar polytopes for external approximation of
reach sets is introduced in Stursberg and Krogh (2003). The basic idea
is to construct an oriented rectangular hull of the reach set for every
time step, whose orientation is determined by the singular value
decomposition of the sample covariance matrix for the states reachable
from the vertices of the initial polytope. The limitation of CheckMate
and the method of oriented rectangles is that only autonomous (i.e.
uncontrolled) systems, or systems with fixed input are allowed, and only
an external approximation of the reach set is provided.

All the methods described so far employ the notion of time step, and
calculate the reach set or its approximation at each time step. This
approach can be used only with discrete-time systems. By contrast, the
analytic methods which we are about to discuss, provide a formula or
differential equation describing the (continuous) time evolution of the
reach set or its approximation.

The level set method Mitchell and Tomlin (2000; “Level Set Toolbox
Homepage”) deals with general nonlinear controlled systems and gives
exact representation of their reach sets, but requires solving the HJB
equation and finding the set of states that belong to sub-zero level set
of the value function. The method (“Level Set Toolbox Homepage”) is
impractical for systems of dimension higher than three.

Requiem (“Requiem Homepage”) is a Mathematica notebook which, given a
linear system, the set of initial conditions and control bounds,
symbolically computes the exact reach set, using the experimental
quantifier elimination package. Quantifier elimination is the removal of
all quantifiers (the universal quantifier :math:`\forall` and the
existential quantifier :math:`\exists`) from a quantified system. Each
quantified formula is substituted with quantifier-free expression with
operations :math:`+`, :math:`\times`, :math:`=` and :math:`<`. For
example, consider the discrete-time system

.. math:: x_{k+1} = Ax_k + Bu_k

 with :math:`A=\left[\begin{array}{cc}
0 & 1\\
0 & 0\end{array}\right]` and :math:`B=\left[\begin{array}{c}
0\\
1\end{array}\right]`. For initial conditions
:math:`x_0\in\{x\in {\bf R}^2 ~|~ \|x\|_{\infty} \leqslant1\}` and
controls :math:`u_k\in\{u\in {\bf R} ~|~ -1\leqslantu\leqslant1\}`, the
reach set for :math:`k\geqslant0` is given by the quantified formula

.. math::

   \{ x\in{\bf R}^2 ~|~ \exists x_0, ~~ \exists k\geqslant0, ~~
   \exists u_i, ~ 0\leqslanti\leqslantk: ~~
   x = A^kx_0+\sum_{i=0}^{k-1}A^{k-i-1}Bu_i \},

 which is equivalent to the quantifier-free expression

.. math:: -1\leqslant[1 ~~ 0]x\leqslant1 ~ \wedge ~ -1\leqslant[0 ~~ 1]x\leqslant1.

 It is proved in Lafferriere, Pappas, and Yovine (2001) that for
continuous-time systems, :math:`\dot{x}(t) = Ax(t) + Bu(t)`, if
:math:`A` is constant and nilpotent or is diagonalizable with rational
real or purely imaginary eigenvalues, and with suitable restrictions on
the control and initial conditions, the quantifier elimination package
returns a quantifier free formula describing the reach set. Quantifier
elimination has limited applicability.

The reach set approximation via parallelotopes Kostousova (2001) employs
the idea of parametrization described in Kurzhanski and Varaiya (2000)
for ellipsoids. The reach set is represented as the intersection of
tight external, and the union of tight internal, parallelotopes. The
evolution equations for the centers and orientation matrices of both
external and internal parallelotopes are provided. This method also
finds controls that can drive the system to the boundary points of the
reach set, similarly to Varaiya (1998) and Kurzhanski and Varaiya
(2000). It works for general linear systems. The computation to solve
the evolution equation for tight approximating parallelotopes, however,
is more involved than that for ellipsoids, and for discrete-time systems
this method does not deal with singular state transition matrices.

*Ellipsoidal Toolbox* (ET) implements in MATLAB the ellipsoidal calculus
Kurzhanski and Vályi (1997) and its application to the reachability
analysis of continuous-time Kurzhanski and Varaiya (2000), discrete-time
A. A. Kurzhanskiy (2007), possibly time-varying linear systems, and
linear systems with disturbances A.B.Kurzhanski and P.Varaiya (2001),
for which ET calculates both open-loop and close-loop reach sets. The
ellipsoidal calculus provides the following benefits:

-  The complexity of the ellipsoidal representation is quadratic in the
   dimension of the state space, and linear in the number of time steps.

-  It is possible to exactly represent the reach set of linear system
   through both external and internal ellipsoids.

-  It is possible to single out individual external and internal
   approximating ellipsoids that are optimal to some given criterion
   (e.g. trace, volume, diameter), or combination of such criteria.

-  We obtain simple analytical expressions for the control that steers
   the state to a desired target.

The report is organized as follows. Chapter 2 describes the operations
of the ellipsoidal calculus: affine transformation, geometric sum,
geometric difference, intersections with hyperplane, ellipsoid,
halfspace and polytope, calculation of maximum ellipsoid, calculation of
minimum ellipsoid. Chapter 3 presents the reachability problem and
ellipsoidal methods for the reach set approximation. Chapter 4 contains
*Ellipsoidal Toolbox* installation and quick start instructions, and
lists the software packages used by the toolbox. Chapter 5 describes
structures and objects implemented and used in toolbox. Also it
describes the implementation of methods from chapters 2 and 3 and
visualization routines. Chapter 6 describes structures and objects
implemented and used in the toolbox. Chapter 6 gives examples of how to
use the toolbox. Chapter 7 collects some conclusions and plans for
future toolbox development. The functions provided by the toolbox
together with their descriptions are listed in appendix A.

Ellipsoidal Calculus
====================

Basic Notions
-------------

We start with basic definitions. Ellipsoid :math:`{\mathcal E}(q,Q)` in
:math:`{\bf R}^n` with center :math:`q` and shape matrix :math:`Q` is
the set

.. math::

   {\mathcal E}(q,Q) = \{ x \in {\bf R}^n ~|~ \langle (x-q), Q^{-1}(x-q)\rangle\leqslant1 \},
   \label{ellipsoid}

wherein :math:`Q` is positive definite (:math:`Q=Q^T` and
:math:`\langle x, Qx\rangle>0` for all nonzero :math:`x\in{\bf R}^n`).
[ellipsoiddef0] Here :math:`\langle\cdot,\cdot\rangle` denotes inner
product. The support function of a set
:math:`{\mathcal X}\subseteq{\bf R}^n` is

.. math:: \rho(l~|~{\mathcal X}) = \sup_{x\in{\mathcal X}} \langle l,x\rangle.

 In particular, the support function of the ellipsoid ([ellipsoid]) is

.. math::

   \rho(l~|~{\mathcal E}(q,Q)) = \langle l, q\rangle + \langle l, Ql\rangle^{1/2}.
   \label{ellsupp}

Although in ([ellipsoid]) :math:`Q` is assumed to be positive definite,
in practice we may deal with situations when :math:`Q` is singular, that
is, with degenerate ellipsoids flat in those directions for which the
corresponding eigenvalues are zero. Therefore, it is useful to give an
alternative definition of an ellipsoid using the expression ([ellsupp]).
Ellipsoid :math:`{\mathcal E}(q,Q)` in :math:`{\bf R}^n` with center
:math:`q` and shape matrix :math:`Q` is the set

.. math::

   {\mathcal E}(q,Q) = \{ x \in {\bf R}^n ~|~
   \langle l,x\rangle\leqslant\langle l,q\rangle + \langle l,Ql\rangle^{1/2}
   \mbox{ for all } l\in{\bf R}^n \},
   \label{ellipsoid2}

wherein matrix :math:`Q` is positive semidefinite (:math:`Q=Q^T` and
:math:`\langle x, Qx\rangle\geqslant0` for all :math:`x\in{\bf R}^n`).
[ellipsoiddef] The volume of ellipsoid :math:`{\mathcal E}(q,Q)` is

.. math::

   {\bf Vol}(E(q,Q)) = {\bf Vol}_{\langle x,x\rangle\leqslant1}\sqrt{\det Q},
   \label{ellvolume}

where :math:`{\bf Vol}_{\langle x,x\rangle\leqslant1}` is the volume of
the unit ball in :math:`{\bf R}^n`:

.. math::

   {\bf Vol}_{\langle x,x\rangle\leqslant1} = \left\{\begin{array}{ll}
   \frac{\pi^{n/2}}{(n/2)!}, &
   \mbox{ for even } n,\\
   \frac{2^n\pi^{(n-1)/2}\left((n-1)/2\right)!}{n!}, &
   \mbox{ for odd } n. \end{array}\right.
   \label{ellunitball}

The distance from :math:`{\mathcal E}(q,Q)` to the fixed point :math:`a`
is

.. math::

   {\bf dist}({\mathcal E}(q,Q),a) = \max_{\langle l,l\rangle=1}\left(\langle l,a\rangle -
   \rho(l ~|~ {\mathcal E}(q,Q)) \right) =
   \max_{\langle l,l\rangle=1}\left(\langle l,a\rangle - \langle l,q\rangle -
   \langle l,Ql\rangle^{1/2}\right). \label{dist_point}

If :math:`{\bf dist}({\mathcal E}(q,Q),a) > 0`, :math:`a` lies outside
:math:`{\mathcal E}(q,Q)`; if
:math:`{\bf dist}({\mathcal E}(q,Q),a) = 0`, :math:`a` is a boundary
point of :math:`{\mathcal E}(q,Q)`; if
:math:`{\bf dist}({\mathcal E}(q,Q),a) < 0`, :math:`a` is an internal
point of :math:`{\mathcal E}(q,Q)`.

Given two ellipsoids, :math:`{\mathcal E}(q_1,Q_1)` and
:math:`{\mathcal E}(q_2,Q_2)`, the distance between them is

.. math::

   \begin{aligned}
   {\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) & = & \max_{\langle l,l\rangle=1}
   \left(-\rho(-l ~|~ {\mathcal E}(q_1,Q_1)) - \rho(l ~|~ {\mathcal E}(q_2,Q_2))\right) \\
   & = & \max_{\langle l,l\rangle=1}\left(\langle l,q_1\rangle -
   \langle l,Q_1l\rangle^{1/2} - \langle l,q_2\rangle -
   \langle l,Q_2l\rangle^{1/2}\right). \label{dist_ell}\end{aligned}

If :math:`{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) > 0`,
the ellipsoids have no common points; if
:math:`{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) = 0`, the
ellipsoids have one common point - they touch; if
:math:`{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) < 0`, the
ellipsoids intersect.

Finding :math:`{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))`
using QCQP is

.. math:: d({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) = \min \langle (x-y), (x-y)\rangle

 subject to:

.. math::

   \begin{aligned}
   \langle (q_1-x), Q_1^{-1}(q_1-x)\rangle & \leqslant& 1,\\
   \langle (q_2-x), Q_2^{-1}(q_2-y)\rangle & \leqslant& 1,\end{aligned}

where

.. math::

   d({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))=\left\{\begin{array}{ll}
   {\bf dist}^2({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) &
   \mbox{ if } {\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))>0, \\
   0 & \mbox{ otherwise}. \end{array}\right.

Checking if :math:`k` nondegenerate ellipsoids
:math:`{\mathcal E}(q_1,Q_1),\cdots,{\mathcal E}(q_k,Q_k)` have nonempty
intersection, can be cast as a quadratically constrained quadratic
programming (QCQP) problem:

.. math:: \min 0

 subject to:

.. math:: \langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leqslant0, ~~~ i=1,\cdots,k.

 If this problem is feasible, the intersection is nonempty. Given
compact convex set :math:`{\mathcal X}\subseteq{\bf R}^n`, its polar
set, denoted :math:`{\mathcal X}^\circ`, is

.. math:: {\mathcal X}^\circ = \{x\in{\bf R}^n ~|~ \langle x,y\rangle\leqslant1, ~ y\in{\mathcal X}\},

 or, equivalently,

.. math:: {\mathcal X}^\circ = \{l\in{\bf R}^n ~|~ \rho(l ~|~ {\mathcal X})\leqslant1\}.

 The properties of the polar set are

-  If :math:`{\mathcal X}` contains the origin,
   :math:`({\mathcal X}^\circ)^\circ = {\mathcal X}`;

-  If :math:`{\mathcal X}_1\subseteq{\mathcal X}_2`,
   :math:`{\mathcal X}_2^\circ\subseteq{\mathcal X}_1^\circ`;

-  For any nonsingular matrix :math:`A\in{\bf R}^{n\times n}`,
   :math:`(A{\mathcal X})^\circ = (A^T)^{-1}{\mathcal X}^\circ`.

If a nondegenerate ellipsoid :math:`{\mathcal E}(q,Q)` contains the
origin, its polar set is also an ellipsoid:

.. math::

   \begin{aligned}
   {\mathcal E}^\circ(q,Q) & = & \{l\in{\bf R}^n ~|~ \langle l,q\rangle +
   \langle l,Ql\rangle^{1/2}\leqslant1 \}\\
   & = & \{l\in{\bf R}^n ~|~ \langle l,(Q-qq^T)^{-1}l\rangle +
   2\langle l,q\rangle\leqslant1 \}\\
   & = & \{l\in{\bf R}^n ~|~ \langle(l+(Q-qq^T)^{-1}q),
   (Q-qq^T)(l+(Q-qq^T)^{-1}q)\rangle\leqslant1+\langle q,(Q-qq^T)^{-1}q\rangle \}.\end{aligned}

The special case is

.. math:: {\mathcal E}^\circ(0,Q) = {\mathcal E}(0,Q^{-1}).

 Given :math:`k` compact sets
:math:`{\mathcal X}_1, \cdots, {\mathcal X}_k\subseteq{\bf R}^n`, their
geometric (Minkowski) sum is

.. math::

   {\mathcal X}_1\oplus\cdots\oplus{\mathcal X}_k=\bigcup_{x_1\in{\mathcal X}_1}\cdots\bigcup_{x_k\in{\mathcal X}_k}
   \{x_1 + \cdots + x_k\} .  \label{minksum}

Given two compact sets
:math:`{\mathcal X}_1, {\mathcal X}_2 \subseteq{\bf R}^n`, their
geometric (Minkowski) difference is

.. math::

   {\mathcal X}_1\dot{-}{\mathcal X}_2 = \{x\in{\bf R}^n ~|~ x + {\mathcal X}_2 \subseteq {\mathcal X}_1 \}.
   \label{minkdiff}

Ellipsoidal calculus concerns the following set of operations:

-  affine transformation of ellipsoid;

-  geometric sum of finite number of ellipsoids;

-  geometric difference of two ellipsoids;

-  intersection of finite number of ellipsoids.

These operations occur in reachability calculation and verification of
piecewise affine dynamical systems. The result of all of these
operations, except for the affine transformation, is *not* generally an
ellipsoid but some convex set, for which we can compute external and
internal ellipsoidal approximations.

Additional operations implemented in the *Ellipsoidal Toolbox* include
external and internal approximations of intersections of ellipsoids with
hyperplanes, halfspaces and polytopes. Hyperplane :math:`H(c,\gamma)` in
:math:`{\bf R}^n` is the set

.. math::

   H = \{x\in{\bf R}^n ~|~ \langle c, x\rangle = \gamma\}
   \label{hyperplane}

with :math:`c\in{\bf R}^n` and :math:`\gamma\in{\bf R}` fixed.
[hyperplanedef] The distance from ellipsoid :math:`{\mathcal E}(q,Q)` to
hyperplane :math:`H(c,\gamma)` is

.. math::

   {\bf dist}({\mathcal E}(q,Q),H(c,\gamma)) =
   \frac{\left|\gamma-\langle c,q\rangle\right| -
   \langle c,Qc\rangle^{1/2}}{\langle c,c\rangle^{1/2}}. \label{dist_hp}

If :math:`{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))>0`, the ellipsoid
and the hyperplane do not intersect; if
:math:`{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))=0`, the hyperplane is a
supporting hyperplane for the ellipsoid; if
:math:`{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))<0`, the ellipsoid
intersects the hyperplane. The intersection of an ellipsoid with a
hyperplane is always an ellipsoid and can be computed directly.

Checking if the intersection of :math:`k` nondegenerate ellipsoids
:math:`E(q_1,Q_1),\cdots,{\mathcal E}(q_k,Q_k)` intersects hyperplane
:math:`H(c,\gamma)`, is equivalent to the feasibility check of the QCQP
problem:

.. math:: \min 0

 subject to:

.. math::

   \begin{aligned}
   \langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leqslant0, & & i=1,\cdots,k,\\
   \langle c, x\rangle - \gamma = 0. & &\end{aligned}

A hyperplane defines two (closed) *halfspaces*:

.. math::

   {\bf S}_1 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \leqslant\gamma\}
   \label{halfspace1}

and

.. math::

   {\bf S}_2 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \geqslant\gamma\}.
   \label{halfspace2}

To avoid confusion, however, we shall further assume that a hyperplane
:math:`H(c,\gamma)` specifies the halfspace in the sense ([halfspace1]).
In order to refer to the other halfspace, the same hyperplane should be
defined as :math:`H(-c,-\gamma)`.

The idea behind the calculation of intersection of an ellipsoid with a
halfspace is to treat the halfspace as an unbounded ellipsoid, that is,
as the ellipsoid with the shape matrix all but one of whose eigenvalues
are :math:`\infty`. [polytope] Polytope :math:`P(C,g)` is the
intersection of a finite number of closed halfspaces:

.. math:: P = \{x\in{\bf R}^n ~|~ Cx\leqslantg\},

 wherein :math:`C=[c_1 ~ \cdots ~ c_m]^T\in{\bf R}^{m\times n}` and
:math:`g=[\gamma_1 ~ \cdots ~ \gamma_m]^T\in{\bf R}^m`. The distance
from ellipsoid :math:`{\mathcal E}(q,Q)` to the polytope :math:`P(C,g)`
is

.. math::

   {\bf dist}({\mathcal E}(q,Q),P(C,g))=\min_{y\in P(C,g)}{\bf dist}({\mathcal E}(q,Q),y),
   \label{dist_poly}

where :math:`{\bf dist}({\mathcal E}(q,Q),y)` comes from
([dist:sub:`p`\ oint]). If
:math:`{\bf dist}({\mathcal E}(q,Q),P(C,g))>0`, the ellipsoid and the
polytope do not intersect; if
:math:`{\bf dist}({\mathcal E}(q,Q),P(C,g))=0`, the ellipsoid touches
the polytope; if :math:`{\bf dist}({\mathcal E}(q,Q),P(C,g))<0`, the
ellipsoid intersects the polytope.

Checking if the intersection of :math:`k` nondegenerate ellipsoids
:math:`E(q_1,Q_1),\cdots,{\mathcal E}(q_k,Q_k)` intersects polytope
:math:`P(C,g)` is equivalent to the feasibility check of the QCQP
problem:

.. math:: \min 0

 subject to:

.. math::

   \begin{aligned}
   \langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leqslant0, & & i=1,\cdots,k,\\
   \langle c_j, x\rangle - \gamma_j \leqslant0, & & j=1,\cdots,m.\end{aligned}

Operations with Ellipsoids
--------------------------

Affine Transformation
~~~~~~~~~~~~~~~~~~~~~

The simplest operation with ellipsoids is an affine transformation. Let
ellipsoid :math:`{\mathcal E}(q,Q)\subseteq{\bf R}^n`, matrix
:math:`A\in{\bf R}^{m\times n}` and vector :math:`b\in{\bf R}^m`. Then

.. math:: A{\mathcal E}(q,Q) + b = {\mathcal E}(Aq+b, AQA^T) .\label{affinetrans}

Thus, ellipsoids are preserved under affine transformation. If the rows
of :math:`A` are linearly independent (which implies
:math:`m\leqslantn`), and :math:`b=0`, the affine transformation is
called *projection*.

Geometric Sum
~~~~~~~~~~~~~

Consider the geometric sum ([minksum]) in which
:math:`{\mathcal X}_1,\cdots`,\ :math:`{\mathcal X}_k` are nondegenerate
ellipsoids :math:`{\mathcal E}(q_1,Q_1),\cdots`,
:math:`{\mathcal E}(q_k,Q_k)\subseteq{\bf R}^n`. The resulting set is
not generally an ellipsoid. However, it can be tightly approximated by
the parametrized families of external and internal ellipsoids.

Let parameter :math:`l` be some nonzero vector in :math:`{\bf R}^n`.
Then the external approximation :math:`{\mathcal E}(q,Q_l^+)` and the
internal approximation :math:`{\mathcal E}(q,Q_l^-)` of the sum
:math:`{\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k)` are
*tight* along direction :math:`l`, i.e.,

.. math::

   {\mathcal E}(q,Q_l^-)\subseteq{\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k)
   \subseteq{\mathcal E}(q,Q_l^+)

 and

.. math::

   \rho(\pm l ~|~ {\mathcal E}(q,Q_l^-)) =
   \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k)) =
   \rho(\pm l ~|~ {\mathcal E}(q,Q_l^+)).

 Here the center :math:`q` is

.. math:: q = q_1 + \cdots + q_k , \label{minksum_c}

the shape matrix of the external ellipsoid :math:`Q_l^+` is

.. math::

   Q_l^+ = \left(\langle l,Q_1l\rangle^{1/2} + \cdots
   + \langle l,Q_kl\rangle^{1/2}\right)
   \left(\frac{1}{\langle l,Q_1l\rangle^{1/2}}Q_1 + \cdots +
   \frac{1}{\langle l,Q_kl\rangle^{1/2}}Q_k\right), \label{minksum_ea}

and the shape matrix of the internal ellipsoid :math:`Q_l^-` is

.. math::

   Q_l^- = \left(Q_1^{1/2} + S_2Q_2^{1/2} + \cdots + S_kQ_k^{1/2}\right)^T
   \left(Q_1^{1/2} + S_2Q_2^{1/2} + \cdots + S_kQ_k^{1/2}\right),\label{minksum_ia}

with matrices :math:`S_i`, :math:`i=2,\cdots,k`, being orthogonal
(:math:`S_iS_i^T=I`) and such that vectors
:math:`Q_1^{1/2}l, S_2Q_2^{1/2}l, \cdots, S_kQ_k^{1/2}l` are parallel.

Varying vector :math:`l` we get exact external and internal
approximations,

.. math::

   \bigcup_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^-) =
   {\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k) =
   \bigcap_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^+) .

 For proofs of formulas given in this section, see Kurzhanski and Vályi
(1997), Kurzhanski and Varaiya (2000).

One last comment is about how to find orthogonal matrices
:math:`S_2,\cdots,S_k` that align vectors
:math:`Q_2^{1/2}l, \cdots, Q_k^{1/2}l` with :math:`Q_1^{1/2}l`. Let
:math:`v_1` and :math:`v_2` be some unit vectors in :math:`{\bf R}^n`.
We have to find matrix :math:`S` such that
:math:`Sv_2\uparrow\uparrow v_1`. We suggest explicit formulas for the
calculation of this matrix ( Dariyn and Kurzhanski (2012)):

.. math::

   \begin{aligned}
   &&T = I + Q_1(S - I)Q_1^T,\\ \label{valign1}
   && S = \begin{pmatrix}
        c & s\\
        -s & c
       \end{pmatrix},\quad c = \langle\hat{v_1}, \hat{v_2}\rangle,\quad s = \sqrt{1 - c^2},\quad \hat{v_i} = \dfrac{v_i}{\|v_i\|}\\ \label{valign2}
   &&  Q_1 = [q_1 \,q_2]\in \mathbb{R}^{n\times2},\quad q_1 = \hat{v_1}, \quad
   q_2 = \begin{cases}
   s^{-1}(\hat{v_2} - c\hat{v_1}),& s\ne 0\\
   0,& s = 0.
   \end{cases} \label{valign3}\end{aligned}

Geometric Difference
~~~~~~~~~~~~~~~~~~~~

Consider the geometric difference ([minkdiff]) in which the sets
:math:`{\mathcal X}_1` and :math:`{\mathcal X}_2` are nondegenerate
ellipsoids :math:`{\mathcal E}(q_1,Q_1)` and
:math:`{\mathcal E}(q_2,Q_2)`. We say that ellipsoid
:math:`{\mathcal E}(q_1,Q_1)` is *bigger* than ellipsoid
:math:`{\mathcal E}(q_2,Q_2)` if

.. math:: {\mathcal E}(0,Q_2) \subseteq {\mathcal E}(0,Q_1).

 If this condition is not fulfilled, the geometric difference
:math:`{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)` is an empty
set:

.. math::

   {\mathcal E}(0,Q_2) \not\subseteq {\mathcal E}(0,Q_1) ~~~ \Rightarrow ~~~
   {\mathcal E}(q_1,Q_1) \dot{-}{\mathcal E}(q_2,Q_2) = \emptyset.

 If :math:`{\mathcal E}(q_1,Q_1)` is bigger than
:math:`{\mathcal E}(q_2,Q_2)` and :math:`{\mathcal E}(q_2,Q_2)` is
bigger than :math:`{\mathcal E}(q_1,Q_1)`, in other words, if
:math:`Q_1=Q_2`,

.. math::

   {\mathcal E}(q_1,Q_1) \dot{-}{\mathcal E}(q_2,Q_2) = \{q_1-q_2\} ~~~ \mbox{and} ~~~
   {\mathcal E}(q_2,Q_2) \dot{-}{\mathcal E}(q_1,Q_1) = \{q_2-q_1\}.

 To check if ellipsoid :math:`{\mathcal E}(q_1,Q_1)` is bigger than
ellipsoid :math:`{\mathcal E}(q_2,Q_2)`, we perform simultaneous
diagonalization of matrices :math:`Q_1` and :math:`Q_2`, that is, we
find matrix :math:`T` such that

.. math:: TQ_1T^T = I ~~~ \mbox{and} ~~~ TQ_2T^T=D,

 where :math:`D` is some diagonal matrix. Simultaneous diagonalization
of :math:`Q_1` and :math:`Q_2` is possible because both are symmetric
positive definite (see Gantmacher (1960)). To find such matrix
:math:`T`, we first do the SVD of :math:`Q_1`:

.. math:: Q_1 = U_1\Sigma_1V_1^T . \label{simdiag1}

Then the SVD of matrix
:math:`\Sigma_1^{-1/2}U_1^TQ_2U_1\Sigma_1^{-1/2}`:

.. math:: \Sigma_1^{-1/2}U_1^TQ_2U_1\Sigma_1^{-1/2} = U_2\Sigma_2V_2^T. \label{simdiag2}

Now, :math:`T` is defined as

.. math:: T = U_2^T \Sigma_1^{-1/2}U_1^T.  \label{simdiag3}

If the biggest diagonal element (eigenvalue) of matrix :math:`D=TQ_2T^T`
is less than or equal to :math:`1`,
:math:`{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)`.

Once it is established that ellipsoid :math:`{\mathcal E}(q_1,Q_1)` is
bigger than ellipsoid :math:`{\mathcal E}(q_2,Q_2)`, we know that their
geometric difference
:math:`{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)` is a nonempty
convex compact set. Although it is not generally an ellipsoid, we can
find tight external and internal approximations of this set parametrized
by vector :math:`l\in{\bf R}^n`. Unlike geometric sum, however,
ellipsoidal approximations for the geometric difference do not exist for
every direction :math:`l`. Vectors for which the approximations do not
exist are called *bad directions*.

Given two ellipsoids :math:`{\mathcal E}(q_1,Q_1)` and
:math:`{\mathcal E}(q_2,Q_2)` with
:math:`{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)`, :math:`l` is a
bad direction if

.. math:: \frac{\langle l,Q_1l\rangle^{1/2}}{\langle l,Q_2l\rangle^{1/2}}>r,

 in which :math:`r` is a minimal root of the equation

.. math:: {\bf det}(Q_1-rQ_2) = 0.

 To find :math:`r`, compute matrix :math:`T` by ([simdiag1]-[simdiag3])
and define

.. math:: r = \frac{1}{\max({\bf diag}(TQ_2T^T))}.

 If :math:`l` is *not* a bad direction, we can find tight external and
internal ellipsoidal approximations :math:`{\mathcal E}(q,Q^+_l)` and
:math:`{\mathcal E}(q,Q^-_l)` such that

.. math:: {\mathcal E}(q,Q^-_l)\subseteq{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q,Q^+_l)

 and

.. math::

   \rho(\pm l ~|~ {\mathcal E}(q,Q_l^-)) =
   \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)) =
   \rho(\pm l ~|~ {\mathcal E}(q,Q_l^+)).

 The center :math:`q` is

.. math:: q = q_1 - q_2;  \label{minkdiff_c}

the shape matrix of the internal ellipsoid :math:`Q^-_l` is

.. math::

   \begin{aligned}
   && P = \frac{\sqrt{\langle l, Q_1 l\rangle}}{\sqrt{\langle l, Q_2 \rangle}};\nonumber\\
   && Q^-_l = \left(1 - \dfrac{1}{P}\right)Q_1 + \left(1 - P\right)Q_2.
   \label{minkdiff_ia}\end{aligned}

and the shape matrix of the external ellipsoid :math:`Q^+_l` is

.. math::

   Q^+_l = \left(Q_1^{1/2} - SQ_2^{1/2}\right)^T
   \left(Q_1^{1/2} - SQ_2^{1/2}\right).  \label{minkdiff_ea}

Here :math:`S` is an orthogonal matrix such that vectors
:math:`Q_1^{1/2}l` and :math:`SQ_2^{1/2}l` are parallel. :math:`S` is
found from ([valign1]-[valign3]), with :math:`v_1=Q_2^{1/2}l` and
:math:`v_2=Q_1^{1/2}l`.

Running :math:`l` over all unit directions that are not bad, we get

.. math::

   \bigcup_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^-) =
   {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2) =
   \bigcap_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^+) .

 For proofs of formulas given in this section, see Kurzhanski and Vályi
(1997).

Geometric Difference-Sum
~~~~~~~~~~~~~~~~~~~~~~~~

Given ellipsoids :math:`{\mathcal E}(q_1,Q_1)`,
:math:`{\mathcal E}(q_2,Q_2)` and :math:`{\mathcal E}(q_3,Q_3)`, it is
possible to compute families of external and internal approximating
ellipsoids for

.. math:: {\mathcal E}(q_1,Q_1) \dot{-} {\mathcal E}(q_2,Q_2) \oplus {\mathcal E}(q_3,Q_3) \label{minkmp}

parametrized by direction :math:`l`, if this set is nonempty
(:math:`{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)`).

First, using the result of the previous section, for any direction
:math:`l` that is not bad, we obtain tight external
:math:`{\mathcal E}(q_1-q_2, Q_l^{0+})` and internal
:math:`{\mathcal E}(q_1-q_2, Q_l^{0-})` approximations of the set
:math:`{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)`.

The second and last step is, using the result of section 2.2.2, to find
tight external ellipsoidal approximation
:math:`{\mathcal E}(q_1-q_2+q_3,Q_l^+)` of the sum
:math:`{\mathcal E}(q_1-q_2,Q_l^{0+})\oplus{\mathcal E}(q_3,Q_3)`, and
tight internal ellipsoidal approximation
:math:`{\mathcal E}(q_1-q_2+q_3,Q_l^-)` for the sum
:math:`{\mathcal E}(q_1-q_2,Q_l^{0-})\oplus{\mathcal E}(q_3,Q_3)`.

As a result, we get

.. math::

   {\mathcal E}(q_1-q_2+q_3,Q_l^-) \subseteq
   {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\oplus{\mathcal E}(q_3,Q_3) \subseteq
   {\mathcal E}(q_1-q_2+q_3,Q_l^+)

 and

.. math::

   \rho(\pm l ~|~{\mathcal E}(q_1-q_2+q_3,Q_l^-)) =
   \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\oplus{\mathcal E}(q_3,Q_3)) =
   \rho(\pm l ~|~ {\mathcal E}(q_1-q_2+q_3,Q_l^+)).

 Running :math:`l` over all unit vectors that are not bad, this
translates to

.. math::

   \bigcup_{\langle l,l\rangle=1} {\mathcal E}(q_1-q_2+q_3,Q_l^-) =
   {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\oplus{\mathcal E}(q_3,Q_3) =
   \bigcap_{\langle l,l\rangle=1} {\mathcal E}(q_1-q_2+q_3,Q_l^+) .

Geometric Sum-Difference
~~~~~~~~~~~~~~~~~~~~~~~~

Given ellipsoids :math:`{\mathcal E}(q_1,Q1)`,
:math:`{\mathcal E}(q_2,Q_2)` and :math:`{\mathcal E}(q_3,Q_3)`, it is
possible to compute families of external and internal approximating
ellipsoids for

.. math:: {\mathcal E}(q_1,Q_1) \oplus {\mathcal E}(q_2,Q_2) \dot{-} {\mathcal E}(q_3,Q_3) \label{minkpm}

parametrized by direction :math:`l`, if this set is nonempty
(:math:`{\mathcal E}(0,Q_3)\subseteq{\mathcal E}(0,Q_1)\oplus{\mathcal E}(0,Q_2)`).

First, using the result of section 2.2.2, we obtain tight external
:math:`{\mathcal E}(q_1+q_2,Q_l^{0+})` and internal
:math:`{\mathcal E}(q_1+q_2,Q_l^{0-})` ellipsoidal approximations of the
set :math:`{\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)`. In order
for the set ([minkpm]) to be nonempty, inclusion
:math:`{\mathcal E}(0,Q_3)\subseteq{\mathcal E}(0,Q_l^{0+})` must be
true for any :math:`l`. Note, however, that even if ([minkpm]) is
nonempty, it may be that
:math:`{\mathcal E}(0,Q_3)\not\subseteq{\mathcal E}(0,Q_l^{0-})`, then
internal approximation for this direction does not exist.

Assuming that ([minkpm]) is nonempty and
:math:`{\mathcal E}(0,Q_3)\subseteq{\mathcal E}(0,Q_l^{0-})`, the second
step would be, using the results of section 2.2.3, to compute tight
external ellipsoidal approximation
:math:`{\mathcal E}(q_1+q_2-q_3,Q_l^+)` of the difference
:math:`{\mathcal E}(q_1+q_2,Q_l^{0+})\dot{-}{\mathcal E}(q_3,Q_3)`,
which exists only if :math:`l` is not bad, and tight internal
ellipsoidal approximation :math:`{\mathcal E}(q_1+q_2-q_3,Q_l^-)` of the
difference
:math:`{\mathcal E}(q_1+q_2,Q_l^{0-})\dot{-}{\mathcal E}(q_3,Q_3)`,
which exists only if :math:`l` is not bad for this difference.

If approximation :math:`{\mathcal E}(q_1+q_2-q_3,Q_l^+)` exists, then

.. math::

   {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3) \subseteq
   {\mathcal E}(q_1+q_2-q_3,Q_l^+)

 and

.. math::

   \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3)) =
   \rho(\pm l ~|~ {\mathcal E}(q_1+q_2-q_3,Q_l^+)).

 If approximation :math:`{\mathcal E}(q_1+q_2-q_3,Q_l^-)` exists, then

.. math::

   {\mathcal E}(q_1+q_2-q_3,Q_l^-) \subseteq
   {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3)

 and

.. math::

   \rho(\pm l ~|~{\mathcal E}(q_1+q_2-q_3,Q_l^-)) =
   \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3)) .

 For any fixed direction :math:`l` it may be the case that neither
external nor internal tight ellipsoidal approximations exist.

Intersection of Ellipsoid and Hyperplane
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let nondegenerate ellipsoid :math:`{\mathcal E}(q,Q)` and hyperplane
:math:`H(c,\gamma)` be such that
:math:`{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))<0`. In other words,

.. math:: {\mathcal E}_H(w,W) = {\mathcal E}(q,Q)\cap H(c,\gamma) \neq \emptyset .

 The intersection of ellipsoid with hyperplane, if nonempty, is always
an ellipsoid. Here we show how to find it.

First of all, we transform the hyperplane :math:`H(c,\gamma)` into
:math:`H([1~0~\cdots~0]^T, 0)` by the affine transformation

.. math:: y = Sx - \frac{\gamma}{\langle c,c\rangle^{1/2}}Sc,

 where :math:`S` is an orthogonal matrix found by ([valign1]-[valign3])
with :math:`v_1=c` and :math:`v_2=[1~0~\cdots~0]^T`. The ellipsoid in
the new coordinates becomes :math:`{\mathcal E}(q',Q')` with

.. math::

   \begin{aligned}
   q' & = & q-\frac{\gamma}{\langle c,c\rangle^{1/2}}Sc, \\
   Q' & = & SQS^T.\end{aligned}

Define matrix :math:`M=Q'^{-1}`; :math:`m_{11}` is its element in
position :math:`(1,1)`, :math:`\bar{m}` is the first column of :math:`M`
without the first element, and :math:`\bar{M}` is the submatrix of
:math:`M` obtained by stripping :math:`M` of its first row and first
column:

.. math::

   M = \left[\begin{array}{c|cl}
   m_{11} & & \bar{m}^T\\
    & \\
   \hline
    & \\
   \bar{m} & & \bar{M}\end{array}\right].

 The ellipsoid resulting from the intersection is
:math:`{\mathcal E}_H(w',W')` with

.. math::

   \begin{aligned}
   w' & = & q' + q_1'\left[\begin{array}{c}
   -1\\
   \bar{M}^{-1}\bar{m}\end{array}\right],\\
   W' & = & \left(1-q_1'^2(m_{11}-
   \langle\bar{m},\bar{M}^{-1}\bar{m}\rangle)\right)\left[\begin{array}{c|cl}
   0 & & {\bf 0}\\
    & \\
   \hline
    & \\
   {\bf 0} & & \bar{M}^{-1}\end{array}\right],\end{aligned}

in which :math:`q_1'` represents the first element of vector :math:`q'`.

Finally, it remains to do the inverse transform of the coordinates to
obtain ellipsoid :math:`{\mathcal E}_H(w,W)`:

.. math::

   \begin{aligned}
   w & = & S^Tw' + \frac{\gamma}{\langle c,c\rangle^{1/2}}c, \\
   W & = & S^TW'S.\end{aligned}

Intersection of Ellipsoid and Ellipsoid
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Given two nondegenerate ellipsoids :math:`{\mathcal E}(q_1,Q_1)` and
:math:`{\mathcal E}(q_2,Q_2)`,
:math:`{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))<0`
implies that

.. math:: {\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)\neq\emptyset .

 This intersection can be approximated by ellipsoids from the outside
and from the inside. Trivially, both :math:`{\mathcal E}(q_1,Q_1)` and
:math:`{\mathcal E}(q_2,Q_2)` are external approximations of this
intersection. Here, however, we show how to find the external
ellipsoidal approximation of minimal volume.

Define matrices

.. math:: W_1 = Q_1^{-1}, ~~~~ W_2 = Q_2^{-1} .\label{wmatrices}

Minimal volume external ellipsoidal approximation
:math:`{\mathcal E}(q+,Q^+)` of the intersection
:math:`{\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)` is determined
from the set of equations:

.. math::

   \begin{aligned}
   Q^+ & = & \alpha X^{-1} \label{fusion1} \\
   X & = & \pi W_1 + (1-\pi)W_2 \label{fusion2} \\
   \alpha & = & 1-\pi(1-\pi)\langle(q_2-q_1), W_2X^{-1}W_1(q_2-q_1)\rangle
   \label{fusion3} \\
   q^+ & = & X^{-1}(\pi W_1q_1 + (1-\pi)W_2q_2) \label{fusion4} \\
   0 & = & \alpha({\bf det}(X))^2{\bf trace}(X^{-1}(W_1-W_2)) \nonumber \\
   & - & n({\bf det}(X))^2
   \big{(}2\langle q^+,W_1q_1-W_2q_2\rangle +
   \langle q^+,(W_2-W_1)q^+\rangle \nonumber\\
   &  & - \langle q_1,W_1q_1\rangle +
   \langle q_2,W_2q_2\rangle\big{)}, \label{fusion5}\end{aligned}

with :math:`0\leqslant\pi\leqslant1`. We substitute :math:`X`,
:math:`\alpha`, :math:`q^+` defined in ([fusion2]-[fusion4]) into
([fusion5]) and get a polynomial of degree :math:`2n-1` with respect to
:math:`\pi`, which has only one root in the interval :math:`[0,1]`,
:math:`\pi_0`. Then, substituting :math:`\pi=\pi_0` into
([fusion1]-[fusion4]), we obtain :math:`q^+` and :math:`Q^+`. Special
cases are :math:`\pi_0=1`, whence
:math:`{\mathcal E}(q^+,Q^+)={\mathcal E}(q_1,Q_1)`, and
:math:`\pi_0=0`, whence
:math:`{\mathcal E}(q^+,Q^+)={\mathcal E}(q_2,Q_2)`. These situations
may occur if, for example, one ellipsoid is contained in the other:

.. math::

   \begin{aligned}
   {\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2) & \Rightarrow & \pi_0 = 1,\\
   {\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q_1,Q_1) & \Rightarrow & \pi_0 = 0.\\\end{aligned}

The proof that the system of equations ([fusion1]-[fusion5]) correctly
defines the minimal volume external ellipsoidal approximationi of the
intersection :math:`{\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)` is
given in L. Ros (2002).

To find the internal approximating ellipsoid
:math:`{\mathcal E}(q^-,Q^-)\subseteq{\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)`,
define

.. math::

   \begin{aligned}
   \beta_1 & = &
   \min_{\langle x,W_2x\rangle=1}\langle x,W_1x\rangle, \label{beta1}\\
   \beta_2 & = & \min_{\langle x,W_1x\rangle=1}\langle x,W_2x\rangle, \label{beta2}\end{aligned}

Notice that ([beta1]) and ([beta2]) are QCQP problems. Parameters
:math:`\beta_1` and :math:`\beta_2` are invariant with respect to affine
coordinate transformation and describe the position of ellipsoids
:math:`{\mathcal E}(q_1,Q_1)`, :math:`{\mathcal E}(q_2,Q_2)` with
respect to each other:

.. math::

   \begin{aligned}
   \beta_1\geqslant1,~\beta_2\geqslant1 & \Rightarrow &
   {\bf int}({\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2))=\emptyset, \\
   \beta_1\geqslant1,~\beta_2\leqslant1 & \Rightarrow & {\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2), \\
   \beta_1\leqslant1,~\beta_2\geqslant1 & \Rightarrow & {\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q_1,Q_1), \\
   \beta_1<1,~\beta_2<1 & \Rightarrow &
   {\bf int}({\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2))\neq\emptyset \\
   & & \mbox{and} ~ {\mathcal E}(q_1,Q_1)\not\subseteq{\mathcal E}(q_2,Q_2) \\
   & & \mbox{and} ~ {\mathcal E}(q_2,Q_2)\not\subseteq{\mathcal E}(q_1,Q_1).\end{aligned}

Define parametrized family of internal ellipsoids
:math:`{\mathcal E}(q^-_{\theta_1\theta_2},Q^-_{\theta_1\theta_2})` with

.. math::

   \begin{aligned}
   q^-_{\theta_1\theta_2} & = & (\theta_1W_1 +
   \theta_2W_2)^{-1}(\theta_1W_1q_1 + \theta_2W_2q_2), \label{paramell1} \\
   Q^-_{\theta_1\theta_2} & = & (1 - \theta_1\langle q_1,W_1q_1\rangle -
   \theta_2\langle q_2,W_2q_2\rangle +
   \langle q^-_{\theta_1\theta_2},(Q^-)^{-1}q^-_{\theta_1\theta_2}\rangle)
   (\theta_1W_1 + \theta_2W_2)^{-1} .\label{paramell2}\end{aligned}

The best internal ellipsoid
:math:`{\mathcal E}(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})`
in the class ([paramell1]-[paramell2]), namely, such that

.. math::

   {\mathcal E}(q^-_{{\theta}_1{\theta}_2},Q^-_{{\theta}_1{\theta}_2})\subseteq
   {\mathcal E}(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})
   \subseteq {\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)

 for all :math:`0\leqslant\theta_1,\theta_2\leqslant1`, is specified by
the parameters

.. math::

   \hat{\theta}_1 = \frac{1-\hat{\beta}_2}{1-\hat{\beta}_1\hat{\beta}_2}, ~~~~
   \hat{\theta}_2 = \frac{1-\hat{\beta}_1}{1-\hat{\beta}_1\hat{\beta}_2},
   \label{thetapar}

with

.. math:: \hat{\beta}_1=\min(1,\beta_1), ~~~~ \hat{\beta}_2=\min(1,\beta_2).

 It is the ellipsoid that we look for:
:math:`{\mathcal E}(q^-,Q^-)={\mathcal E}(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})`.
Two special cases are

.. math::

   \hat{\theta}_1=1, ~ \hat{\theta}_2=0 ~~~ \Rightarrow ~~~
   {\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2) ~~~ \Rightarrow ~~~
   {\mathcal E}(q^-,Q^-)={\mathcal E}(q_1,Q_1),

 and

.. math::

   \hat{\theta}_1=0, ~ \hat{\theta}_2=1 ~~~ \Rightarrow ~~~
   {\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q_1,Q_1) ~~~ \Rightarrow ~~~
   {\mathcal E}(q^-,Q^-)={\mathcal E}(q_2,Q_2).

 The method of finding the internal ellipsoidal approximation of the
intersection of two ellipsoids is described in Vazhentsev (1999).

Intersection of Ellipsoid and Halfspace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finding the intersection of ellipsoid and halfspace can be reduced to
finding the intersection of two ellipsoids, one of which is unbounded.
Let :math:`{\mathcal E}(q_1,Q_1)` be a nondegenerate ellipsoid and let
:math:`H(c,\gamma)` define the halfspace

.. math:: {\bf S}(c,\gamma) = \{x\in{\bf R}^n ~|~ \langle c,x\rangle\leqslant\gamma\}.

 We have to determine if the intersection
:math:`{\mathcal E}(q_1,Q_1)\cap{\bf S}(c,\gamma)` is empty, and if not,
find its external and internal ellipsoidal approximations,
:math:`{\mathcal E}(q^+,Q^+)` and :math:`{\mathcal E}(q^-,Q^-)`. Two
trivial situations are:

-  :math:`{\bf dist}({\mathcal E}(q_1,Q_1),H(c,\gamma))>0` and
   :math:`\langle c, q_1\rangle>0`, which implies that
   :math:`{\mathcal E}(q_1,Q_1)\cap{\bf S}(c,\gamma)=\emptyset`;

-  :math:`{\bf dist}({\mathcal E}(q_1,Q_1),H(c,\gamma))>0` and
   :math:`\langle c, q_1\rangle<0`, so that
   :math:`{\mathcal E}(q_1,Q_1)\subseteq{\bf S}(c,\gamma)`, and then
   :math:`{\mathcal E}(q^+,Q^+)={\mathcal E}(q^-,Q^-)={\mathcal E}(q_1,Q_1)`.

In case :math:`{\bf dist}({\mathcal E}(q_1,Q_1),H(c,\gamma)<0`, i.e. the
ellipsoid intersects the hyperplane,

.. math::

   {\mathcal E}(q_1,Q_1)\cap{\bf S}(c,\gamma) =
   {\mathcal E}(q_1,Q_1)\cap\{x ~|~ \langle (x-q_2),W_2(x-q_2)\rangle\leqslant1\},

 with

.. math::

   \begin{aligned}
   q_2 & = & (\gamma + 2\sqrt{\overline{\lambda}})c,\label{hsell1} \\
   W_2 & = & \frac{1}{4\overline{\lambda}}cc^T,\label{hsell2}\end{aligned}

:math:`\overline{\lambda}` being the biggest eigenvalue of matrix
:math:`Q_1`. After defining :math:`W_1=Q_1^{-1}`, we obtain
:math:`{\mathcal E}(q^+,Q^+)` from equations ([fusion1]-[fusion5]), and
:math:`{\mathcal E}(q^-,Q^-)` from ([paramell1]-[paramell2]),
([thetapar]).

**Remark.** Notice that matrix :math:`W_2` has rank :math:`1`, which
makes it singular for :math:`n>1`. Nevertheless, expressions
([fusion1]-[fusion2]), ([paramell1]-[paramell2]) make sense because
:math:`W_1` is nonsingular, :math:`\pi_0\neq0` and
:math:`\hat{\theta}_1\neq0`.

To find the ellipsoidal approximations :math:`{\mathcal E}(q^+,Q^+)` and
:math:`{\mathcal E}(q^-,Q^-)` of the intersection of ellipsoid
:math:`{\mathcal E}(q,Q)` and polytope :math:`P(C,g)`,
:math:`C\in{\bf R}^{m\times n}`, :math:`b\in{\bf R}^m`, such that

.. math:: {\mathcal E}(q^-,Q^-)\subseteq{\mathcal E}(q,Q)\cap P(C,g)\subseteq{\mathcal E}(q^+,Q^+),

 we first compute

.. math::

   {\mathcal E}(q^-_1,Q^-_1)\subseteq{\mathcal E}(q,Q)\cap{\bf S}(c_1,\gamma_1)\subseteq
   {\mathcal E}(q^+_1,Q^+_1),

 wherein :math:`{\bf S}(c_1,\gamma_1)` is the halfspace defined by the
first row of matrix :math:`C`, :math:`c_1`, and the first element of
vector :math:`g`, :math:`\gamma_1`. Then, one by one, we get

.. math::

   \begin{aligned}
   & & {\mathcal E}(q^-_2,Q^-_2)\subseteq{\mathcal E}(q^-_1,Q^-_1)\cap{\bf S}(c_2,\gamma_2), ~~~
   {\mathcal E}(q^+_1,Q^+_1)\cap{\bf S}(c_2,\gamma_2)\subseteq{\mathcal E}(q^+_2,Q^+_2), \\
   & & {\mathcal E}(q^-_3,Q^-_3)\subseteq{\mathcal E}(q^-_2,Q^-_2)\cap{\bf S}(c_3,\gamma_3), ~~~
   {\mathcal E}(q^+_2,Q^+_2)\cap{\bf S}(c_3,\gamma_3)\subseteq{\mathcal E}(q^+_3,Q^+_3), \\
   & & \cdots \\
   & & {\mathcal E}(q^-_m,Q^-_m)\subseteq{\mathcal E}(q^-_{m-1},Q^-_{m-1})\cap{\bf S}(c_m,\gamma_m), ~~~
   {\mathcal E}(q^+_{m-1},Q^+_{m-1})\cap{\bf S}(c_m,\gamma_m)\subseteq{\mathcal E}(q^+_m,Q^+_m), \\\end{aligned}

The resulting ellipsoidal approximations are

.. math:: {\mathcal E}(q^+,Q^+)={\mathcal E}(q^+_m,Q^+_m), ~~~~ {\mathcal E}(q^-,Q^-)={\mathcal E}(q^-_m,Q^-_m) .

Checking if 
~~~~~~~~~~~~

Theorem of alternatives, also known as *:math:`S`-procedure* Boyd and
Vandenberghe (2004), states that the implication

.. math::

   \langle x, A_1x\rangle + 2\langle b_1,x\rangle + c_1 \leqslant0
   ~~ \Rightarrow ~~
   \langle x, A_2x\rangle + 2\langle b_2,x\rangle + c_2 \leqslant0,

 where :math:`A_i\in{\bf R}^{n\times n}` are symmetric matrices,
:math:`b_i\in{\bf R}^n`, :math:`c_i\in{\bf R}`, :math:`i=1,2`, holds if
and only if there exists :math:`\lambda>0` such that

.. math::

   \left[\begin{array}{cc}
   A_2 & b_2\\
   b_2^T & c_2\end{array}\right]
   \preceq
   \lambda\left[\begin{array}{cc}
   A_1 & b_1\\
   b_1^T & c_1\end{array}\right].

By :math:`S`-procedure,
:math:`{\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2)` (both
ellipsoids are assumed to be nondegenerate) if and only if the following
SDP problem is feasible:

.. math:: \min 0

 subject to:

.. math::

   \begin{aligned}
   \lambda & > & 0, \\
   \left[\begin{array}{cc}
   Q_2^{-1} & -Q_2^{-1}q_2\\
   (-Q_2^{-1}q_2)^T & q_2^TQ_2^{-1}q_2-1\end{array}\right]
   & \preceq &
   \lambda \left[\begin{array}{cc}
   Q_1^{-1} & -Q_1^{-1}q_1\\
   (-Q_1^{-1}q_1)^T & q_1^TQ_1^{-1}q_1-1\end{array}\right]\end{aligned}

where :math:`\lambda\in{\bf R}` is the variable.

Minimum Volume Ellipsoids
~~~~~~~~~~~~~~~~~~~~~~~~~

The minimum volume ellipsoid that contains set :math:`S` is called
*Löwner-John ellipsoid* of the set :math:`S`. To characterize it we
rewrite general ellipsoid :math:`{\mathcal E}(q,Q)` as

.. math:: {\mathcal E}(q,Q) = \{x ~|~ \langle (Ax + b), (Ax + b)\rangle \},

 where

.. math:: A = Q^{-1/2} ~~~ \mbox{ and } ~~~ b = -Aq .

 For positive definite matrix :math:`A`, the volume of
:math:`{\mathcal E}(q,Q)` is proportional to :math:`\det A^{-1}`. So,
finding the minimum volume ellipsoid containing :math:`S` can be
expressed as semidefinite programming (SDP) problem

.. math:: \min \log \det A^{-1}

 subject to:

.. math:: \sup_{v\in S} \langle (Av + b), (Av + b)\rangle \leqslant1,

 where the variables are :math:`A\in{\bf R}^{n\times n}` and
:math:`b\in{\bf R}^n`, and there is an implicit constraint
:math:`A\succ 0` (:math:`A` is positive definite). The objective and
constraint functions are both convex in :math:`A` and :math:`b`, so this
problem is convex. Evaluating the constraint function, however, requires
solving a convex maximization problem, and is tractable only in certain
special cases.

For a finite set :math:`S=\{x_1,\cdots,x_m\}\subset{\bf R}^n`, an
ellipsoid covers :math:`S` if and only if it covers its convex hull. So,
finding the minimum volume ellipsoid covering :math:`S` is the same as
finding the minimum volume ellipsoid containing the polytope
:math:`{\bf conv}\{x_1,\cdots,x_m\}`. The SDP problem is

.. math:: \min \log \det A^{-1}

 subject to:

.. math::

   \begin{aligned}
   A & \succ & 0, \\
   \langle (Ax_i + b), (Ax_i + b)\rangle & \leqslant& 1, ~~~ i=1..m.\end{aligned}

We can find the minimum volume ellipsoid containing the union of
ellipsoids :math:`\bigcup_{i=1}^m{\mathcal E}(q_i,Q_i)`. Using the fact
that for :math:`i=1..m`
:math:`{\mathcal E}(q_i,Q_i)\subseteq{\mathcal E}(q,Q)` if and only if
there exists :math:`\lambda_i>0` such that

.. math::

   \left[\begin{array}{cc}
   A^2 - \lambda_i Q_i^{-1} & Ab + \lambda_i Q_i^{-1}q_i\\
   (Ab + \lambda_i Q_i^{-1}q_i)^T & b^Tb-1 - \lambda_i (q_i^TQ_i^{-1}q_i-1) \end{array}
   \right] \preceq 0 .

 Changing variable :math:`\tilde{b}=Ab`, we get convex SDP in the
variables :math:`A`, :math:`\tilde{b}`, and
:math:`\lambda_1,\cdots,\lambda_m`:

.. math:: \min \log \det A^{-1}

 subject to:

.. math::

   \begin{aligned}
   \lambda_i & > & 0,\\
   \left[\begin{array}{ccc}
   A^2-\lambda_iQ_i^{-1} & \tilde{b}+\lambda_iQ_i^{-1}q_i & 0 \\
   (\tilde{b}+\lambda_iQ_i^{-1}q_i)^T & -1-\lambda_i(q_i^TQ_i^{-1}q_i-1) & \tilde{b}^T \\
   0 & \tilde{b} & -A^2\end{array}\right] & \preceq & 0, ~~~ i=1..m.\end{aligned}

After :math:`A` and :math:`b` are found,

.. math:: q=-A^{-1}b ~~~ \mbox{ and } ~~~ Q=(A^TA)^{-1}.

The results on the minimum volume ellipsoids are explained and proven in
Boyd and Vandenberghe (2004).

Maximum Volume Ellipsoids
~~~~~~~~~~~~~~~~~~~~~~~~~

Consider a problem of finding the maximum volume ellipsoid that lies
inside a bounded convex set :math:`S` with nonempty interior. To
formulate this problem we rewrite general ellipsoid
:math:`{\mathcal E}(q,Q)` as

.. math:: {\mathcal E}(q,Q) = \{Bx + q ~|~ \langle x,x\rangle\leqslant1\},

 where :math:`B=Q^{1/2}`, so the volume of :math:`{\mathcal E}(q,Q)` is
proportional to :math:`\det B`.

The maximum volume ellipsoid that lies inside :math:`S` can be found by
solving the following SDP problem:

.. math:: \max \log \det B

 subject to:

.. math:: \sup_{\langle v,v\rangle\leqslant1} I_S(Bv+q)\leqslant0 ,

 in the variables :math:`B\in{\bf R}^{n\times n}` - symmetric matrix,
and :math:`q\in{\bf R}^n`, with implicit constraint :math:`B\succ 0`,
where :math:`I_S` is the indicator function:

.. math::

   I_S(x) = \left\{\begin{array}{ll}
   0, & \mbox{ if } x\in S,\\
   \infty, & \mbox{ otherwise.}\end{array}\right.

In case of polytope, :math:`S=P(C,g)` with :math:`P(C,g)` defined in
([polytope]), the SDP has the form

.. math:: \min \log \det B^{-1}

 subject to:

.. math::

   \begin{aligned}
   B & \succ & 0,\\
   \langle c_i, Bc_i\rangle + \langle c_i, q\rangle & \leqslant& \gamma_i,
   ~~~ i=1..m.\end{aligned}

We can find the maximum volume ellipsoid that lies inside the
intersection of given ellipsoids
:math:`\bigcap_{i=1}^m{\mathcal E}(q_i,Q_i)`. Using the fact that for
:math:`i=1..m` :math:`{\mathcal E}(q,Q)\subseteq{\mathcal E}(q_i,Q_i)`
if and only if there exists :math:`\lambda_i>0` such that

.. math::

   \left[\begin{array}{cc}
   -\lambda_i - q^TQ_i^{-1}q + 2q_i^TQ_i^{-1}q - q_i^TQ_i^{-1}q_i + 1 & (Q_i^{-1}q-Q_i^{-1}q_i)^TB\\
   B(Q_i^{-1}q-Q_i^{-1}q_i) & \lambda_iI-BQ_i^{-1}B\end{array}\right] \succeq 0.

To find the maximum volume ellipsoid, we solve convex SDP in variables
:math:`B`, :math:`q`, and :math:`\lambda_1,\cdots,\lambda_m`:

.. math:: \min \log \det B^{-1}

 subject to:

.. math::

   \begin{aligned}
   \lambda_i & > & 0, \\
   \left[\begin{array}{ccc}
   1-\lambda_i & 0 & (q - q_i)^T\\
   0 & \lambda_iI & B\\
   q - q_i & B & Q_i\end{array}\right] & \succeq & 0, ~~~ i=1..m.\end{aligned}

After :math:`B` and :math:`q` are found,

.. math:: Q = B^TB.

The results on the maximum volume ellipsoids are explained and proven in
Boyd and Vandenberghe (2004).

Reachability
============

Basics of Reachability Analysis
-------------------------------

Systems without disturbances
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider a general continuous-time

.. math::

   \dot{x}(t) = f(t, x, u),
   \label{ctds1}

or discrete-time dynamical system

.. math::

   x(t+1) = f(t, x, u),
   \tag*{(\ref{ctds1}d)}
   \label{dtds1}

wherein :math:`t` is time [1]_, :math:`x\in{\bf R}^n` is the state,
:math:`u\in{\bf R}^m` is the control, and :math:`f` is a measurable
vector function taking values in :math:`{\bf R}^n`. [2]_ The control
values :math:`u(t, x(t))` are restricted to a closed compact control set
:math:`{\mathcal U}(t)\subset{\bf R}^m`. An *open-loop* control does not
depend on the state, :math:`u=u(t)`; for a *closed-loop* control,
:math:`u=u(t, x(t))`.

The (forward) reach set :math:`{\mathcal X}(t, t_0, x_0)` at time
:math:`t>t_0` from the initial position :math:`(t_0, x_0)` is the set of
all states :math:`x(t)` reachable at time :math:`t` by system ([ctds1]),
or [dtds1], with :math:`x(t_0)=x_0` through all possible controls
:math:`u(\tau, x(\tau))\in{\mathcal U}(\tau)`,
:math:`t_0\leqslant\tau< t`. For a given set of initial states
:math:`{\mathcal X}_0`, the reach set
:math:`{\mathcal X}(t, t_0, {\mathcal X}_0)` is

.. math:: {\mathcal X}(t, t_0, {\mathcal X}_0) = \bigcup_{x_0\in{\mathcal X}_0}{\mathcal X}(t, t_0, x_0).

 [def:sub:`o`\ lrs] Here are two facts about forward reach sets.

#. :math:`{\mathcal X}(t, t_0, {\mathcal X}_0)` is the same for
   open-loop and closed-loop control.

#. :math:`{\mathcal X}(t, t_0, {\mathcal X}_0)` satisfies the semigroup
   property,

   .. math::

      {\mathcal X}(t, t_0, {\mathcal X}_0) = {\mathcal X}(t, \tau, {\mathcal X}(\tau, t_0, {\mathcal X}_0)), \;\;\;
      t_0\leqslant\tau< t.
      \label{semigroup}

For linear systems

.. math::

   f(t, x, u) = A(t)x(t) + B(t)u,
   \label{linearrhs}

with matrices :math:`A(t)` in :math:`{\bf R}^{n\times n}` and
:math:`B(t)` in :math:`{\bf R}^{m\times n}`. For continuous-time linear
system the state transition matrix is

.. math:: \dot{\Phi}(t, t_0) = A(t)\Phi(t, t_0), \;\;\; \Phi(t, t) = I,

 which for constant :math:`A(t)\equiv A` simplifies as

.. math:: \Phi(t, t_0) = e^{A(t-t_0)} .

 For discrete-time linear system the state transition matrix is

.. math:: \Phi(t+1, t_0) = A(t)\Phi(t, t_0), \;\;\; \Phi(t, t) = I,

 which for constant :math:`A(t)\equiv A` simplifies as

.. math:: \Phi(t, t_0) = A^{t-t_0} .

If the state transition matrix is invertible,
:math:`\Phi^{-1}(t, t_0) = \Phi(t_0, t)`. The transition matrix is
always invertible for continuous-time and for sampled discrete-time
systems. However, if for some :math:`\tau`, :math:`t_0\leqslant\tau<t`,
:math:`A(\tau)` is degenerate (singular),
:math:`\Phi(t, t_0)=\prod_{\tau=t_0}^{t-1}A(\tau)`, is also degenerate
and cannot be inverted.

Following Cauchy’s formula, the reach set
:math:`{\mathcal X}(t, t_0, {\mathcal X}_0)` for a linear system can be
expressed as

.. math::

   {\mathcal X}(t, t_0, {\mathcal X}_0) =
   \Phi(t, t_0){\mathcal X}_0 \oplus \int_{t_0}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau
   \label{ctlsrs}

in continuous-time, and as

.. math::

   {\mathcal X}(t, t_0, {\mathcal X}_0) =
   \Phi(t, t_0){\mathcal X}_0 \oplus \sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)
   \tag*{(\ref{ctlsrs}d)}
   \label{dtlsrs}

in discrete-time case.

The operation ‘:math:`\oplus`’ is the *geometric sum*, also known as
*Minkowski sum*. [3]_ The geometric sum and linear (or affine)
transformations preserve compactness and convexity. Hence, if the
initial set :math:`{\mathcal X}_0` and the control sets
:math:`{\mathcal U}(\tau)`, :math:`t_0\leqslant\tau<t`, are compact and
convex, so is the reach set
:math:`{\mathcal X}(t, t_0, {\mathcal X}_0)`.

The backward reach set :math:`{\mathcal Y}(t_1, t, y_1)` for the target
position :math:`(t_1, y_1)` is the set of all states :math:`y(t)` for
which there exists some control
:math:`u(\tau, x(\tau))\in{\mathcal U}(\tau)`,
:math:`t\leqslant\tau<t_1`, that steers system ([ctds1]), or [dtds1] to
the state :math:`y_1` at time :math:`t_1`. For the target set
:math:`{\mathcal Y}_1` at time :math:`t_1`, the backward reach set
:math:`{\mathcal Y}(t_1, t, {\mathcal Y}_1)` is

.. math:: {\mathcal Y}(t_1, t, {\mathcal Y}_1) = \bigcup_{y_1\in{\mathcal Y}_1}{\mathcal Y}(t_1, t, y_1).

 [def:sub:`o`\ lbrs] The backward reach set
:math:`{\mathcal Y}(t_1, t, {\mathcal Y}_1)` is the largest *weakly
invariant* set with respect to the target set :math:`{\mathcal Y}_1` and
time values :math:`t` and :math:`t_1`. [4]_

**Remark.** Backward reach set can be computed for continuous-time
system only if the solution of ([ctds1]) exists for :math:`t<t_1`; and
for discrete-time system only if the right hand side of [dtds1] is
invertible [5]_.

These two facts about the backward reach set :math:`{\mathcal Y}` are
similar to those for forward reach sets.

#. :math:`{\mathcal Y}(t_1, t, {\mathcal Y}_1)` is the same for
   open-loop and closed-loop control.

#. :math:`{\mathcal Y}(t_1, t, {\mathcal Y}_1)` satisfies the semigroup
   property,

   .. math::

      {\mathcal Y}(t_1, t, {\mathcal Y}_1) = {\mathcal Y}(\tau, t, {\mathcal Y}(t_1, \tau, {\mathcal Y}_1)), \;\;\;
      t\leqslant\tau< t_1.
      \label{semigroup_b}

For the linear system ([linearrhs]) the backward reach set can be
expressed as

.. math::

   {\mathcal Y}(t_1, t, {\mathcal Y}_1) =
   \Phi(t, t_1){\mathcal Y}_1 \oplus \int_{t_1}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau
   \label{ctlsbrs}

in the continuous-time case, and as

.. math::

   {\mathcal Y}(t_1, t, {\mathcal Y}_1) =
   \Phi(t, t_1){\mathcal Y}_1 \oplus \sum_{\tau =t}^{t_1-1}-\Phi(t, \tau)B(\tau){\mathcal U}(\tau)
   \tag*{(\ref{ctlsbrs}d)}
   \label{dtlsbrs}

in discrete-time case. The last formula makes sense only for
discrete-time linear systems with invertible state transition matrix.
Degenerate discrete-time linear systems have unbounded backward reach
sets and such sets cannot be computed with available software tools.

Just as in the case of forward reach set, the backward reach set of a
linear system :math:`{\mathcal Y}(t_1, t, {\mathcal Y}_1)` is compact
and convex if the target set :math:`{\mathcal Y}_1` and the control sets
:math:`{\mathcal U}(\tau)`, :math:`t\leqslant\tau<t_1`, are compact and
convex.

**Remark.** In the computer science literature the reach set is said to
be the result of operator *post*, and the backward reach set is the
result of operator *pre*. In the control literature the backward reach
set is also called the *solvability set*.

Systems with disturbances
~~~~~~~~~~~~~~~~~~~~~~~~~

Consider the continuous-time dynamical system with disturbance

.. math::

   \dot{x}(t) = f(t, x, u, v),
   \label{ctds2}

or the discrete-time dynamical system with disturbance

.. math::

   x(t+1) = f(t, x, u, v),
   \tag*{(\ref{ctds2}d)}
   \label{dtds2}

in which we also have the disturbance input :math:`v\in{\bf R}^d` with
values :math:`v(t)` restricted to a closed compact set
:math:`{\mathcal V}(t)\subset{\bf R}^d`.

In the presence of disturbances the open-loop reach set (OLRS) is
different from the closed-loop reach set (CLRS).

Given the initial time :math:`t_0`, the set of initial states
:math:`{\mathcal X}_0`, and terminal time :math:`t`, there are two types
of OLRS.

The maxmin open-loop reach set
:math:`\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)` is the set
of all states :math:`x`, such that for any disturbance
:math:`v(\tau)\in{\mathcal V}(\tau)`, there exist an initial state
:math:`x_0\in{\mathcal X}_0` and a control
:math:`u(\tau)\in{\mathcal U}(\tau)`, :math:`t_0\leqslant\tau<t`, that
steers system ([ctds2]) or [dtds2] from :math:`x(t_0)=x_0` to
:math:`x(t)=x`. [def:sub:`m`\ axminolrs] The minmax open-loop reach set
:math:`\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)` is the set
of all states :math:`x`, such that there exists a control
:math:`u(\tau)\in{\mathcal U}(\tau)` that for all disturbances
:math:`v(\tau)\in{\mathcal V}(\tau)`, :math:`t_0\leqslant\tau<t`,
assigns an initial state :math:`x_0\in{\mathcal X}_0` and steers system
([ctds2]), or [dtds2], from :math:`x(t_0)=x_0` to :math:`x(t)=x`.
[def:sub:`m`\ inmaxolrs] In the maxmin case the control is chosen
*after* knowing the disturbance over the entire time interval
:math:`[t_0, t]`, whereas in the minmax case the control is chosen
*before* any knowledge of the disturbance. Consequently, the OLRS do not
satisfy the semigroup property.

The terms ‘maxmin’ and ‘minmax’ come from the fact that
:math:`\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)` is the
subzero level set of the value function

.. math::

   \underline{V}(t, x) =
   \max_v\min_u\{{\bf dist}(x(t_0), {\mathcal X}_0) ~|~ x(t)=x, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t_0\leqslant\tau<t\},
   \label{maxminvf}

i.e.,
:math:`\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \{ x~|~\underline{V}(t, x) \leqslant0\}`,
and :math:`\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)` is the
subzero level set of the value function

.. math::

   \overline{V}(t, x) =
   \min_u\max_v\{{\bf dist}(x(t_0), {\mathcal X}_0) ~|~ x(t)=x, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t_0\leqslant\tau<t\},
   \label{minmaxvf}

in which :math:`{\bf dist}(\cdot, \cdot)` denotes Hausdorff
semidistance. [6]_ Since
:math:`\underline{V}(t, x)\leqslant\overline{V}(t, x)`,
:math:`\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)\subseteq\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)`.

Note that maxmin and minmax OLRS imply *guarantees*: these are states
that can be reached no matter what the disturbance is, whether it is
known in advance (maxmin case) or not (minmax case). The OLRS may be
empty.

Fixing time instant :math:`\tau_1`, :math:`t_0<\tau_1<t`, define the
*piecewise maxmin open-loop reach set with one correction*,

.. math::

   \overline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) = \overline{{\mathcal X}}_{OL}(t, \tau_1, \overline{{\mathcal X}}_{OL}(\tau_1, t_0, {\mathcal X}_0)),
   \label{maxmin1}

and the *piecewise minmax open-loop reach set with one correction*,

.. math::

   \underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) = \underline{{\mathcal X}}_{OL}(t, \tau_1, \underline{{\mathcal X}}_{OL}(\tau_1, t_0, {\mathcal X}_0)).
   \label{minmax1}

The piecewise maxmin OLRS
:math:`\overline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0)` is the
subzero level set of the value function

.. math::

   \underline{V}^1(t, x) =
   \max_v\min_u\{\underline{V}(\tau_1, x(\tau_1)) ~|~ x(t)=x, \;
   u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_1\leqslant\tau<t\},
   \label{maxminvf1}

with :math:`V(\tau_1, x(\tau_1))` given by ([maxminvf]), which yields

.. math:: \underline{V}^1(t, x) \geqslant\underline{V}(t, x),

 and thus,

.. math:: \overline{{\mathcal X}}_{OL}^1(t, t_0 {\mathcal X}_0) \subseteq \overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) .

 On the other hand, the piecewise minmax OLRS
:math:`\underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0)` is the
subzero level set of the value function

.. math::

   \overline{V}^1(t, x) =
   \min_u\max_v\{\overline{V}(\tau_1, x(\tau_1)) ~|~ x(t)=x, \;
   u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_1\leqslant\tau<t\},
   \label{minmaxvf1}

with :math:`V(\tau_1, x(\tau_1))` given by ([minmaxvf]), which yields

.. math:: \overline{V}(t, x) \geqslant\overline{V}^1(t, x),

 and thus,

.. math:: \underline{{\mathcal X}}_{OL}(t, t_0 {\mathcal X}_0) \subseteq \underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) .

 We can now recursively define piecewise maxmin and minmax OLRS with
:math:`k` corrections for :math:`t_0<\tau_1<\cdots<\tau_k<t`. The maxmin
piecewise OLRS with :math:`k` corrections is

.. math::

   \overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) =
   \overline{{\mathcal X}}_{OL}(t, \tau_k, \overline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0)),
   \label{maxmink}

which is the subzero level set of the corresponding value function

.. math::

   \begin{aligned}
   &&\underline{V}^k(t, x) = \nonumber \\
   &&\max_v\min_u\{\underline{V}^{k-1}(\tau_k, x(\tau_k)) ~|~ x(t)=x, \;
   u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_k\leqslant\tau<t\}.
   \label{maxminvfk}\end{aligned}

The minmax piecewise OLRS with :math:`k` corrections is

.. math::

   \underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) =
   \underline{{\mathcal X}}_{OL}(t, \tau_k, \underline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0)),
   \label{minmaxk}

which is the subzero level set of the corresponding value function

.. math::

   \begin{aligned}
   &&\overline{V}^k(t, x) = \nonumber \\
   &&\min_u\max_v\{\overline{V}^{k-1}(\tau_k, x(\tau_k)) ~|~ x(t)=x, \;
   u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_k\leqslant\tau<t\}.
   \label{minmaxvfk}\end{aligned}

From ([maxminvf1]), ([minmaxvf1]), ([maxminvfk]) and ([minmaxvfk]) it
follows that

.. math::

   \underline{V}(t, x) \leqslant\underline{V}^1(t, x)\leqslant\cdots
   \leqslant\underline{V}^k(t, x) \leqslant\overline{V}^k(t, x) \leqslant\cdots
   \leqslant\overline{V}^1(t, x) \leqslant\overline{V}(t, x) .

 Hence,

.. math::

   \begin{aligned}
   &&\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) \subseteq \underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) \subseteq \cdots
   \subseteq \underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) \subseteq \nonumber \\
   &&\overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) \subseteq \cdots \subseteq \overline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0)
   \subseteq \overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) .
   \label{olrsinclusion}\end{aligned}

We call

.. math::

   \overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = \overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0), \;\;
   k = \left\{\begin{array}{ll}
   \infty & \mbox{ for continuous-time system}\\
   t-t_0-1 & \mbox{ for discrete-time system}\end{array}\right.
   \label{maxminclrs}

the *maxmin closed-loop reach set* of system ([ctds2]) or [dtds2] at
time :math:`t`, and we call

.. math::

   \underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = \underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0), \;\;
   k = \left\{\begin{array}{ll}
   \infty & \mbox{ for continuous-time system}\\
   t-t_0-1 & \mbox{ for discrete-time system}\end{array}\right.
   \label{minmaxclrs}

the *minmax closed-loop reach set* of system ([ctds2]) or [dtds2] at
time :math:`t`. Given initial time :math:`t_0` and the set of initial
states :math:`{\mathcal X}_0`, the maxmin CLRS
:math:`\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)` of system
([ctds2]) or [dtds2] at time :math:`t>t_0`, is the set of all states
:math:`x`, for each of which and for every disturbance
:math:`v(\tau)\in{\mathcal V}(\tau)`, there exist an initial state
:math:`x_0\in{\mathcal X}_0` and a control
:math:`u(\tau, x(\tau))\in{\mathcal U}(\tau)`, such that the trajectory
:math:`x(\tau | v(\tau), u(\tau, x(\tau)))` satisfying
:math:`x(t_0) = x_0` and

.. math::

   \dot{x}(\tau | v(\tau), u(\tau, x(\tau))) \in
   f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))

 in the continuous-time case, or

.. math::

   x(\tau+1 | v(\tau), u(\tau, x(\tau))) \in
   f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))

 in the discrete-time case, with :math:`t_0\leqslant\tau<t`, is such
that :math:`x(t)=x`. [def:sub:`m`\ axminclrs] Given initial time
:math:`t_0` and the set of initial states :math:`{\mathcal X}_0`, the
maxmin CLRS
:math:`\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)` of system
([ctds2]) or [dtds2], at time :math:`t>t_0`, is the set of all states
:math:`x`, for each of which there exists a control
:math:`u(\tau, x(\tau))\in{\mathcal U}(\tau)`, and for every disturbance
:math:`v(\tau)\in{\mathcal V}(\tau)` there exists an initial state
:math:`x_0\in{\mathcal X}_0`, such that the trajectory
:math:`x(\tau, v(\tau) | u(\tau, x(\tau)))` satisfying
:math:`x(t_0) = x_0` and

.. math::

   \dot{x}(\tau, v(\tau) | u(\tau, x(\tau))) \in
   f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))

 in the continuous-time case, or

.. math::

   x(\tau+1, v(\tau) | u(\tau, x(\tau))) \in
   f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))

 in the discrete-time case, with :math:`t_0\leqslant\tau<t`, is such
that :math:`x(t)=x`. [def:sub:`m`\ inmaxclrs] By construction, both
maxmin and minmax CLRS satisfy the semigroup property ([semigroup]).

For some classes of dynamical systems and some types of constraints on
initial conditions, controls and disturbances, the maxmin and minmax
CLRS may coincide. This is the case for continuous-time linear systems
with convex compact bounds on the initial set, controls and disturbances
under the condition that the initial set :math:`{\mathcal X}_0` is large
enough to ensure that
:math:`{\mathcal X}(t_0+\epsilon, t_0, {\mathcal X}_0)` is nonempty for
some small :math:`\epsilon>0`.

Consider the linear system case,

.. math::

   f(t, x, u) = A(t)x(t) + B(t)u + G(t)v,
   \label{linearrhsdist}

where :math:`A(t)` and :math:`B(t)` are as in ([linearrhs]), and
:math:`G(t)` takes its values in :math:`{\bf R}^d`.

The maxmin OLRS for the continuous-time linear system can be expressed
through set valued integrals,

.. math::

   \begin{array}{l}
   \overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, t_0){\mathcal X}_0 \oplus
   \int_{t_0}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
   \int_{t_0}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau,
   \end{array}
   \label{ctlsmaxmin}

and for discrete-time linear system through set-valued sums,

.. math::

   \begin{array}{l}
   \overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, t_0){\mathcal X}_0 \oplus
   \sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
   \sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau).
   \end{array}
   \tag*{(\ref{ctlsmaxmin}d)}
   \label{dtlsmaxmin}

Similarly, the minmax OLRS for the continuous-time linear system is

.. math::

   \begin{array}{l}
   \underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, t_0){\mathcal X}_0 \dot{-}
   \int_{t_0}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau\right)
   \oplus \\
   \int_{t_0}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
   \end{array}
   \label{ctlsminmax}

and for the discrete-time linear system it is

.. math::

   \begin{array}{l}
   \underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, t_0){\mathcal X}_0 \dot{-}
   \sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau)\right)
   \oplus \\
   \sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
   \end{array}
   \tag*{(\ref{ctlsminmax}d)}
   \label{dtlsminmax}

The operation ‘:math:`\dot{-}`’ is *geometric difference*, also known as
*Minkowski difference*. [7]_

Now consider the piecewise OLRS with :math:`k` corrections. Expression
([maxmink]) translates into

.. math::

   \begin{array}{l}
   \overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, \tau_k)\overline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0) \oplus
   \int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
   \int_{\tau_k}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau,
   \end{array}
   \label{ctlsmaxmink}

in the continuous-time case, and for the discrete-time case into

.. math::

   \begin{array}{l}
   \overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, \tau_k)\overline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0) \oplus
   \sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
   \sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau).
   \end{array}
   \tag*{(\ref{ctlsmaxmink}d)}
   \label{dtlsmaxmink}

Expression ([minmaxk]) translates into

.. math::

   \begin{array}{l}
   \underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, \tau_k)\underline{{\mathcal X}}_{OL}^{k-1}(t, t_0, {\mathcal X}_0) \dot{-}
   \int_{\tau_k}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau\right)
   \oplus \\
   \int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
   \end{array}
   \label{ctlsminmaxk}

in the continuous-time case, and for the discrete-time case into

.. math::

   \begin{array}{l}
   \underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
   \left(\Phi(t, \tau_k)\underline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0) \dot{-}
   \sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau)\right)
   \oplus \\
   \sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
   \end{array}
   \tag*{(\ref{ctlsminmaxk}d)}
   \label{dtlsminmaxk}

Since for any
:math:`{\mathcal W}_1, {\mathcal W}_2, {\mathcal W}_3 \subseteq {\bf R}^n`
it is true that

.. math::

   ({\mathcal W}_1 \dot{-} {\mathcal W}_2) \oplus {\mathcal W}_3 =
   ({\mathcal W}_1 \oplus {\mathcal W}_3) \dot{-} ({\mathcal W}_2 \oplus {\mathcal W}_3) \subseteq
   ({\mathcal W}_1 \oplus {\mathcal W}_3) \dot{-} {\mathcal W}_2,

 from ([ctlsmaxmink]), ([ctlsminmaxk]) and from [dtlsmaxmink],
[dtlsminmaxk], it is clear that ([olrsinclusion]) is true.

For linear systems, if the initial set :math:`{\mathcal X}_0`, control
bounds :math:`{\mathcal U}(\tau)` and disturbance bounds
:math:`{\mathcal V}(\tau)`, :math:`t_0\leqslant\tau<t`, are compact and
convex, the CLRS
:math:`\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)` and
:math:`\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)` are
compact and convex, provided they are nonempty. For continuous-time
linear systems,
:math:`\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = \underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = {\mathcal X}_{CL}(t, t_0, {\mathcal X}_0)`.

Just as for forward reach sets, the backward reach sets can be open-loop
(OLBRS) or closed-loop (CLBRS).

Given the terminal time :math:`t_1` and target set
:math:`{\mathcal Y}_1`, the maxmin open-loop backward reach set
:math:`\overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)` of system
([ctds2]) or [dtds2] at time :math:`t<t_1`, is the set of all :math:`y`,
such that for any disturbance :math:`v(\tau)\in{\mathcal V}(\tau)` there
exists a terminal state :math:`y_1\in{\mathcal Y}_1` and control
:math:`u(\tau)\in{\mathcal U}(\tau)`, :math:`t\leqslant\tau<t_1`, which
steers the system from :math:`y(t)=y` to :math:`y(t_1)=y_1`.
[def:sub:`m`\ axminolbrs]
:math:`\overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)` is the
subzero level set of the value function

.. math::

   \begin{aligned}
   &&\underline{V}_b(t, y) = \nonumber \\
   &&\max_v\min_u\{{\bf dist}(y(t_1), {\mathcal Y}_1) ~|~ y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau<t_1\},
   \label{maxminvfb}\end{aligned}

Given the terminal time :math:`t_1` and target set
:math:`{\mathcal Y}_1`, the minmax open-loop backward reach set
:math:`\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)` of system
([ctds2]) or [dtds2] at time :math:`t<t_1`, is the set of all :math:`y`,
such that there exists a control :math:`u(\tau)\in{\mathcal U}(\tau)`
that for all disturbances :math:`v(\tau\in{\mathcal V}(\tau)`,
:math:`t\leqslant\tau<t_1`, assigns a terminal state
:math:`y_1\in{\mathcal Y}_1` and steers the system from :math:`y(t)=y`
to :math:`y(t_1)=y_1`. [def:sub:`m`\ inmaxolbrs]
:math:`\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)` is the
subzero level set of the value function

.. math::

   \begin{aligned}
   &&\overline{V}_b(t, y) = \nonumber \\
   &&\min_u\max_v\{{\bf dist}(y(t_1), {\mathcal Y}_1) ~|~ y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau<t_1\},
   \label{minmaxvfb}\end{aligned}

**Remark.** The backward reach set can be computed for a continuous-time
system only if the solution of ([ctds2]) exists for :math:`t<t_1`, and
for a discrete-time system only if the right hand side of [dtds2] is
invertible.

Similarly to the forward reachability case, we construct piecewise OLBRS
with one correction at time :math:`\tau_1`, :math:`t<\tau_1<t_1`. The
piecewise maxmin OLBRS with one correction is

.. math::

   \overline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1) = \overline{{\mathcal Y}}_{OL}(\tau_1, t, \overline{{\mathcal Y}}_{OL}(t_1, \tau_1, {\mathcal Y}_1)),
   \label{maxminb1}

and it is the subzero level set of the function

.. math::

   \begin{aligned}
   &&\underline{V}^1_b(t, y) = \nonumber \\
   &&\max_v\min_u\{\underline{V}_b(\tau_1, y(\tau_1)) ~|~
   y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau<\tau_1\}.
   \label{maxminvfb1}\end{aligned}

The piecewise minmax OLBRS with one correction is

.. math::

   \underline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{OL}(\tau_1, t, \underline{{\mathcal Y}}_{OL}(t_1, \tau_1, {\mathcal Y}_1)),
   \label{minmaxb1}

and it is the subzero level set of the function

.. math::

   \begin{aligned}
   &&\overline{V}^1_b(t, y) = \nonumber \\
   &&\min_u\max_v\{\overline{V}_b(\tau_1, y(\tau_1)) ~|~
   y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau<\tau_1\},
   \label{minmaxvfb1}\end{aligned}

Recursively define maxmin and minmax OLBRS with :math:`k` corrections
for :math:`t<\tau_k<\cdots<\tau_1<t_1`. The maxmin OLBRS with :math:`k`
corrections is

.. math::

   \overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \overline{{\mathcal Y}}_{OL}(\tau_k, t, \overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1)),
   \label{maxminbk}

which is the subzero level set of function

.. math::

   \begin{aligned}
   &&\underline{V}^k_b(t, y) = \nonumber \\
   &&\max_v\min_u\{\underline{V}^{k-1}_b(\tau_k, y(\tau_k)) ~|~
   y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau<\tau_k\}.
   \label{maxminvfbk}\end{aligned}

The minmax OLBRS with :math:`k` corrections is

.. math::

   \underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{OL}(\tau_k, t, \underline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1)),
   \label{minmaxbk}

which is the subzero level set of the function

.. math::

   \begin{aligned}
   &&\overline{V}^k_b(t, y) = \nonumber \\
   &&\min_u\max_v\{\overline{V}^{k-1}_b(\tau_k, y(\tau_k)) ~|~
   y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
   v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau<\tau_k\},
   \label{minmaxvfbk}\end{aligned}

From ([maxminvfb1]), ([minmaxvfb1]), ([maxminvfbk]) and ([minmaxvfbk])
it follows that

.. math::

   \underline{V}_b(t, y) \leqslant\underline{V}^1_b(t, y)\leqslant\cdots
   \leqslant\underline{V}^k_b(t, y) \leqslant\overline{V}^k_b(t, y) \leqslant\cdots
   \leqslant\overline{V}^1_b(t, y) \leqslant\overline{V}_b(t, y) .

 Hence,

.. math::

   \begin{aligned}
   &&\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) \subseteq \underline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1) \subseteq \cdots
   \subseteq \underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) \subseteq \nonumber \\
   &&\overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) \subseteq \cdots \subseteq \overline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1)
   \subseteq \overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) .
   \label{olbrsinclusion}\end{aligned}

We say that

.. math::

   \overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = \overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1), \;\;
   k = \left\{\begin{array}{ll}
   \infty & \mbox{ for continuous-time system}\\
   t_1-t-1 & \mbox{ for discrete-time system}\end{array}\right.
   \label{maxminclbrs}

is the *maxmin closed-loop backward reach set* of system ([ctds2]) or
[dtds2] at time :math:`t`.

We say that

.. math::

   \underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1), \;\;
   k = \left\{\begin{array}{ll}
   \infty & \mbox{ for continuous-time system}\\
   t_1-t-1 & \mbox{ for discrete-time system}\end{array}\right.
   \label{minmaxclbrs}

is the *minmax closed-loop backward reach set* of system ([ctds2]) or
[dtds2] at time :math:`t`. Given the terminal time :math:`t_1` and
target set :math:`{\mathcal Y}_1`, the maxmin CLBRS
:math:`\overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)` of system
([ctds2]) or [dtds2] at time :math:`t<t_1`, is the set of all states
:math:`y`, for each of which for every disturbance
:math:`v(\tau)\in{\mathcal V}(\tau)` there exists terminal state
:math:`y_1\in{\mathcal Y}_1` and control
:math:`u(\tau, y(\tau))\in{\mathcal U}(\tau)` that assigns trajectory
:math:`y(\tau, | v(\tau), u(\tau, y(\tau)))` satisfying

.. math::

   \dot{y}(\tau | v(\tau), u(\tau, y(\tau))) \in
   f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))

 in continuous-time case, or

.. math::

   y(\tau+1 | v(\tau), u(\tau, y(\tau))) \in
   f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))

 in discrete-time case, with :math:`t\leqslant\tau<t_1`, such that
:math:`y(t) = y` and :math:`y(t_1)=y_1`. [def:sub:`m`\ axminclbrs] Given
the terminal time :math:`t_1` and target set :math:`{\mathcal Y}_1`, the
minmax CLBRS
:math:`\underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)` of system
([ctds2]) or [dtds2] at time :math:`t<t_1`, is the set of all states
:math:`y`, for each of which there exists control
:math:`u(\tau, y(\tau))\in{\mathcal U}(\tau)` that for every disturbance
:math:`v(\tau)\in{\mathcal V}(\tau)` assigns terminal state
:math:`y_1\in{\mathcal Y}_1` and trajectory
:math:`y(\tau, v(\tau) | u(\tau, y(\tau)))` satisfying

.. math::

   \dot{y}(\tau, v(\tau) | u(\tau, y(\tau))) \in
   f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))

 in the continuous-time case, or

.. math::

   y(\tau+1, v(\tau) | u(\tau, y(\tau))) \in
   f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))

 in the discrete-time case, with :math:`t\leqslant\tau<t_1`, such that
:math:`y(t) = y` and :math:`y(t_1)=y_1`. [def:sub:`m`\ inmaxclbrs] Both
maxmin and minmax CLBRS satisfy the semigroup property
([semigroup:sub:`b`]).

The maxmin OLBRS for the continuous-time linear system can be expressed
through set valued integrals,

.. math::

   \begin{array}{l}
   \overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, t_1){\mathcal Y}_1 \oplus
   \int_{t_1}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
   \int_{t}^{t_1}\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau,
   \end{array}
   \label{ctlsmaxminb}

and for the discrete-time linear system through set-valued sums,

.. math::

   \begin{array}{l}
   \overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, t_1){\mathcal Y}_1 \oplus
   \sum_{\tau=t}^{t_1-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
   \sum_{\tau=t}^{t_1-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau).
   \end{array}
   \tag*{(\ref{ctlsmaxminb}d)}
   \label{dtlsmaxminb}

Similarly, the minmax OLBRS for the continuous-time linear system is

.. math::

   \begin{array}{l}
   \underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, t_1){\mathcal Y}_1 \dot{-}
   \int_{t}^{t_1}\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau\right)
   \oplus \\
   \int_{t_1}^{t}\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
   \end{array}
   \label{ctlsminmaxb}

and for the discrete-time linear system it is

.. math::

   \begin{array}{l}
   \underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, t_1){\mathcal Y}_1 \dot{-}
   \sum_{\tau=t}^{t_1-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau)\right)
   \oplus \\
   \sum_{\tau=t}^{t_1-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
   \end{array}
   \tag*{(\ref{ctlsminmaxb}d)}
   \label{dtlsminmaxb}

Now consider piecewise OLBRS with :math:`k` corrections. Expression
([maxminbk]) translates into

.. math::

   \begin{array}{l}
   \overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \oplus
   \int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
   \int^{\tau_k}_t\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau,
   \end{array}
   \label{ctlsmaxminbk}

in the continuous-time case, and for the discrete-time case into

.. math::

   \begin{array}{l}
   \overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \oplus
   \sum_{\tau=t}^{\tau_k-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
   \sum_{\tau=t}^{\tau_k-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau).
   \end{array}
   \tag*{(\ref{ctlsmaxminbk}d)}
   \label{dtlsmaxminbk}

Expression ([minmaxbk]) translates into

.. math::

   \begin{array}{l}
   \underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \dot{-}
   \int^{\tau_k}_t\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau\right)
   \oplus \\
   \int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
   \end{array}
   \label{ctlsminmaxbk}

in the continuous-time case, and for the discrete-time case into

.. math::

   \begin{array}{l}
   \underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
   \left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \dot{-}
   \sum_{\tau=t}^{\tau_k-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau)\right)
   \oplus \\
   \sum_{\tau=t}^{\tau_k-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
   \end{array}
   \tag*{(\ref{ctlsminmaxk}d)}
   \label{dtlsminmaxbk}

For continuous-time linear systems
:math:`\overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = {\mathcal Y}_{CL}(t_1, t, {\mathcal Y}_1)`
under the condition that the target set :math:`{\mathcal Y}_1` is large
enough to ensure that
:math:`\underline{{\mathcal Y}}_{CL}(t_1, t_1-\epsilon, {\mathcal Y}_1)`
is nonempty for some small :math:`\epsilon>0`.

Computation of backward reach sets for discrete-time linear systems
makes sense only if the state transition matrix :math:`\Phi(t_1, t)` is
invertible.

If the target set :math:`{\mathcal Y}_1`, control sets
:math:`{\mathcal U}(\tau)` and disturbance sets
:math:`{\mathcal V}(\tau)`, :math:`t\leqslant\tau<t_1`, are compact and
convex, then CLBRS
:math:`\overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)` and
:math:`\underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)` are
compact and convex, if they are nonempty.

Reachability problem
~~~~~~~~~~~~~~~~~~~~

Reachability analysis is concerned with the computation of the forward
:math:`{\mathcal X}(t, t_0, {\mathcal X}_0)` and backward
:math:`{\mathcal Y}(t_1, t, {\mathcal Y}_1)` reach sets (the reach sets
may be maxmin or minmax) in a way that can effectively meet requests
like the following:

#. For the given time interval :math:`[t_0, t]`, determine whether the
   system can be steered into the given target set
   :math:`{\mathcal Y}_1`. In other words, is the set
   :math:`{\mathcal Y}_1\cap\bigcup_{t_0 \leqslant\tau\leqslantt}{\mathcal X}(\tau, t_0, {\mathcal X}_0)`
   nonempty? And if the answer is ‘yes’, find a control that steers the
   system to the target set (or avoids the target set). [8]_

#. If the target set :math:`{\mathcal Y}_1` is reachable from the given
   initial condition :math:`\{t_0, {\mathcal X}_0\}` in the time
   interval :math:`[t_0, t]`, find the shortest time to reach
   :math:`{\mathcal Y}_1`,

   .. math::

      \arg\min_{\tau}
      \{{\mathcal X}(\tau,t_0,{\mathcal X}_0)\cap{\mathcal Y}_1\neq\emptyset ~|~ t_0\leqslant\tau\leqslantt\}.

#. Given the terminal time :math:`t_1`, target set
   :math:`{\mathcal Y}_1` and time :math:`t<t_1` find the set of states
   starting at time :math:`t` from which the system can reach
   :math:`{\mathcal Y}_1` within time interval :math:`[t, t_1]`. In
   other words, find
   :math:`\bigcup_{t\leqslant\tau<t_1}{\mathcal Y}(t_1, \tau, {\mathcal Y}_1)`.

#. Find a closed-loop control that steers a system with disturbances to
   the given target set in given time.

#. Graphically display the projection of the reach set along any
   specified two- or three-dimensional subspace.

For linear systems, if the initial set :math:`{\mathcal X}_0`, target
set :math:`{\mathcal Y}_1`, control bounds :math:`{\mathcal U}(\cdot)`
and disturbance bounds :math:`{\mathcal V}(\cdot)` are compact and
convex, so are the forward :math:`{\mathcal X}(t, t_0, {\mathcal X}_0)`
and backward :math:`{\mathcal Y}(t_1, t, {\mathcal Y}_1)` reach sets.
Hence reachability analysis requires the computationally effective
manipulation of convex sets, and performing the set-valued operations of
unions, intersections, geometric sums and differences.

Existing reach set computation tools can deal reliably only with linear
systems with convex constraints. A claim that certain tool or method can
be used *effectively* for nonlinear systems must be treated with
caution, and the first question to ask is for what class of nonlinear
systems and with what limit on the state space dimension does this tool
work? Some “reachability methods for nonlinear systems” reduce to the
local linearization of a system followed by the use of well-tested
techniques for linear system reach set computation. Thus these
approaches in fact use reachability methods for linear systems.

Ellipsoidal Method
------------------

Continuous-time systems
~~~~~~~~~~~~~~~~~~~~~~~

Consider the system

.. math:: \dot{x}(t) = A(t)x(t) + B(t)u + G(t)v, \label{ctsystem}

in which :math:`x\in{\bf R}^n` is the state, :math:`u\in{\bf R}^m` is
the control and :math:`v\in{\bf R}^d` is the disturbance. :math:`A(t)`,
:math:`B(t)` and :math:`G(t)` are continuous and take their values in
:math:`{\bf R}^{n\times n}`, :math:`{\bf R}^{n\times m}` and
:math:`{\bf R}^{n\times d}` respectively. Control :math:`u(t,x(t))` and
disturbance :math:`v(t)` are measurable functions restricted by
ellipsoidal constraints: :math:`u(t,x(t)) \in {\mathcal E}(p(t), P(t))`
and :math:`v(t) \in {\mathcal E}(q(t), Q(t))`. The set of initial states
at initial time :math:`t_0` is assumed to be the ellipsoid
:math:`{\mathcal E}(x_0,X_0)`.

The reach sets for systems with disturbances computed by the Ellipsoidal
Toolbox are CLRS. Henceforth, when describing backward reachability,
reach sets refer to CLRS or CLBRS. Recall that for continuous-time
linear systems maxmin and minmax CLRS coincide, and the same is true for
maxmin and minmax CLBRS.

If the matrix :math:`Q(\cdot)=0`, the system ([ctsystem]) becomes an
ordinary affine system with known :math:`v(\cdot)=q(\cdot)`. If
:math:`G(\cdot) = 0`, the system becomes linear. For these two cases
(:math:`Q(\cdot)=0` or :math:`G(\cdot)=0`) the reach set is as given in
Definition [def:sub:`o`\ lrs], and so the reach set will be denoted as
:math:`{\mathcal X}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)) = {\mathcal X}(t, t_0, {\mathcal E}(x_0,X_0))`.

The reach set :math:`{\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0))` is a
symmetric compact convex set, whose center evolves in time according to

.. math::

   \dot{x}_c(t) = A(t)x_c(t) + B(t)p(t) + G(t)q(t), \;\;\;
   x_c(t_0)=x_0. \label{fwdcenter}

Fix a vector :math:`l_0\in{\bf R}^n`, and consider the solution
:math:`l(t)` of the adjoint equation

.. math::

   \dot{l}(t) = -A^T(t)l(t), \;\;\; l(t_0) = l_0,
   \label{adjointct}

which is equivalent to

.. math:: l(t) = \Phi^T(t_0, t)l_0.

 If the reach set :math:`{\mathcal X}(t, t_0, {\mathcal E}(x_0,X_0))` is
nonempty, there exist tight external and tight internal approximating
ellipsoids :math:`{\mathcal E}(x_c(t), X^+_l(t))` and
:math:`{\mathcal E}(x_c(t), X^-_l(t))`, respectively, such that

.. math::

   {\mathcal E}(x_c(t), X^-_l(t))\subseteq{\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0))
   \subseteq {\mathcal E}(x_c(t), X^+_l(t)),
   \label{fwdinclusion}

and

.. math::

   \rho(l(t) ~|~ {\mathcal E}(x_c(t), X^-_l(t))) =
   \rho(l(t) ~|~ {\mathcal X}(t, t_0, {\mathcal E}(x_0,X_0))) =
   \rho(l(t) ~|~ {\mathcal E}(x_c(t), X^+_l(t))) .
   \label{fwdtightness}

The equation for the shape matrix of the external ellipsoid is

.. math::

   \begin{aligned}
   \dot{X}^+_l(t) & = & A(t)X^+_l(t) + X^+_l(t)A^T(t) +\nonumber \\
   & & \pi_l(t)X^+_l(t) + \frac{1}{\pi_l(t)}B(t)P(t)B^T(t) -\nonumber \\
   & & (X_l^{+}(t))^{1/2}S_l(t)(G(t)Q(t)G^T(t))^{1/2} \nonumber -\\
   & & (G(t)Q(t)G^T(t))^{1/2}S_l^T(t)(X_l^{+}(t))^{1/2}, \label{fwdext1} \\
   X^+_l(t_0) & = & X_0, \label{fwdext2}\end{aligned}

in which

.. math::

   \pi_l(t) = \frac{\langle l(t),
   B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t), X^+_l(t)l(t)\rangle^{1/2}},

 and the orthogonal matrix :math:`S_l(t)` (:math:`S_l(t)S_l^T(t) = I`)
is determined by the equation

.. math::

   S_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t) = \frac{\langle l(t),
   G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t),
   X_l^+(t)l(t)\rangle^{1/2}}(X_l^{+}(t))^{1/2}l(t).

 In the presence of disturbance, if the reach set is empty, the matrix
:math:`X^+_l(t)` becomes sign indefinite. For a system without
disturbance, the terms containing :math:`G(t)` and :math:`Q(t)` vanish
from the equation ([fwdext1]).

The equation for the shape matrix of the internal ellipsoid is

.. math::

   \begin{aligned}
   \dot{X}^-_l(t) & = & A(t)X^-_l(t) + X^-_l(t)A^T(t) +\nonumber \\
   & & (X_l^{-}(t))^{1/2}T_l(t)(B(t)P(t)B^T(t))^{1/2} +\nonumber \\
   & & (B(t)P(t)B^T(t))^{1/2}T_l^T(t)(X_l^{-}(t))^{1/2} -\nonumber \\
   & & \eta_l(t)X^-_l(t) - \frac{1}{\eta_l(t)}G(t)Q(t)G^T(t), \label{fwdint1} \\
   X^-_l(t_0) & = & X_0, \label{fwdint2}\end{aligned}

in which

.. math::

   \eta_l(t) = \frac{\langle l(t),
   G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t), X^+_l(t)l(t)\rangle^{1/2}},

 and the orthogonal matrix :math:`T_l(t)` is determined by the equation

.. math::

   T_l(t)(B(t)P(t)B^T(t))^{1/2}l(t) = \frac{\langle l(t),
   B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t),
   X_l^-(t)l(t)\rangle^{1/2}}(X_l^{-}(t))^{1/2}l(t).

 Similarly to the external case, the terms containing :math:`G(t)` and
:math:`Q(t)` vanish from the equation ([fwdint1]) for a system without
disturbance.

The point where the external and internal ellipsoids touch the boundary
of the reach set is given by

.. math::

   x_l^*(t) = x_c(t) +
   \frac{X^+_l(t)l(t)}{\langle l(t), X^+_l(t)l(t)\rangle^{1/2}} .

 The boundary points :math:`x^*_l(t)` form trajectories, which we call
*extremal trajectories*. Due to the nonsingular nature of the state
transition matrix :math:`\Phi(t,t_0)`, every boundary point of the reach
set belongs to an extremal trajectory. To follow an extremal trajectory
specified by parameter :math:`l_0`, the system has to start at time
:math:`t_0` at initial state

.. math:: x^0_l = x_0 + \frac{X_0l_0}{\langle l_0,X_0l_0\rangle^{1/2}}. \label{x0lct}

In the absence of disturbances, the open-loop control

.. math::

   u_l(t) = p(t) + \frac{P(t)B^T(t)l(t)}{\langle l(t),
   B(t)P(t)B^T(t)l(t)\rangle^{1/2}}. \label{uct}

steers the system along the extremal trajectory defined by the vector
:math:`l_0`. When a disturbance is present, this control keeps the
system on an extremal trajectory if and only if the disturbance plays
against the control always taking its extreme values.

Expressions ([fwdinclusion]) and ([fwdtightness]) lead to the following
fact,

.. math::

   \bigcup_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),X^-_l(t)) =
   {\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0)) =
   \bigcap_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),X^+_l(t)).

 In practice this means that the more values of :math:`l_0` we use to
compute :math:`X^+_l(t)` and :math:`X^-_l(t)`, the better will be our
approximation.

Analogous results hold for the backward reach set.

Given the terminal time :math:`t_1` and ellipsoidal target set
:math:`{\mathcal E}_(y_1,Y_1)`, the CLBRS
:math:`{\mathcal Y}_{CL}(t_1, t, {\mathcal Y}_1)={\mathcal Y}(t_1, t, {\mathcal Y}_1)`,
:math:`t<t_1`, if it is nonempty, is a symmetric compact convex set
whose center is governed by

.. math:: y_c(t) = Ay_c(t) + B(t)p(t) + G(t)q(t), \;\;\; y_c(t_1) = y_1.\label{bckcenter}

Fix a vector :math:`l_1\in{\bf R}^n`, and consider

.. math::

   l(t) = \Phi(t_1, t)^Tl_1 .
   \label{bckadjoint}

If the backward reach set
:math:`{\mathcal Y}(t_1, t, {\mathcal E}(y_1,Y_1))` is nonempty, there
exist tight external and tight internal approximating ellipsoids
:math:`{\mathcal E}(y_c(t), Y^+_l(t))` and
:math:`{\mathcal E}(y_c(t), Y^-_l(t))` respectively, such that

.. math::

   {\mathcal E}(y_c(t), Y^-_l(t))\subseteq{\mathcal Y}(t_1,t,{\mathcal E}(y_1,Y_1))
   \subseteq {\mathcal E}(y_c(t), Y^+_l(t)),
   \label{bckinclusion}

and

.. math::

   \rho(l(t) ~|~ {\mathcal E}(y_c(t), Y^-_l(t))) =
   \rho(l(t) ~|~ {\mathcal Y}(t_1, t, {\mathcal E}(y_0,Y_0))) =
   \rho(l(t) ~|~ {\mathcal E}(y_c(t), Y^+_l(t))) .
   \label{bcktightness}

The equation for the shape matrix of the external ellipsoid is

.. math::

   \begin{aligned}
   \dot{Y}^+_l(t) & = & A(t)Y^+_l(t) + Y^+_l(t)A^T(t) -\nonumber \\
   & & \pi_l(t)Y^+_l(t) - \frac{1}{\pi_l(t)}B(t)P(t)B^T(t) +\nonumber \\
   & & (Y_l^{+}(t))^{1/2}S_l(t)(G(t)Q(t)G^T(t))^{1/2} +\nonumber \\
   & & (G(t)Q(t)G^T(t))^{1/2}S_l^T(t)(Y_l^{+}(t))^{1/2}, \label{bckext1} \\
   Y^+_l(t_1) & = & Y_1, \label{bckext2}\end{aligned}

in which

.. math::

   \pi_l(t) = \frac{\langle l(t),
   B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t),
   Y^+_l(t)l(t)\rangle^{1/2}},

 and the orthogonal matrix :math:`S_l(t)` satisfies the equation

.. math::

   S_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t) = \frac{\langle l(t),
   G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t),
   Y_l^+(t)l(t)\rangle^{1/2}}(Y_l^{+}(t))^{1/2}l(t).

 The equation for the shape matrix of the internal ellipsoid is

.. math::

   \begin{aligned}
   \dot{Y}^-_l(t) & = & A(t)Y^-_l(t) + Y^-_l(t)A^T(t) -\nonumber \\
   & & (Y_l^{-}(t))^{1/2}T_l(t)(B(t)P(t)B^T(t))^{1/2} -\nonumber \\
   & & (B(t)P(t)B^T(t))^{1/2}T_l^T(t)(Y_l^{-}(t))^{1/2} +\nonumber \\
   & & \eta_l(t)Y^-_l(t) + \frac{1}{\eta_l(t)}G(t)Q(t)G^T(t), \label{bckint1} \\
   Y^-_l(t_1) & = & Y_1, \label{bckint2}\end{aligned}

in which

.. math::

   \eta_l(t) = \frac{\langle l(t),
   G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t),
   Y^+_l(t)l(t)\rangle^{1/2}},

 and the orthogonal matrix :math:`T_l(t)` is determined by the equation

.. math::

   T_l(t)(B(t)P(t)B^T(t))^{1/2}l(t) = \frac{\langle l(t),
   B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t),
   Y_l^-(t)l(t)\rangle^{1/2}}(Y_l^{-}(t))^{1/2}l(t).

 Just as in the forward reachability case, the terms containing
:math:`G(t)` and :math:`Q(t)` vanish from equations ([bckext1]) and
([bckint1]) in the absence of disturbances. The boundary value problems
([bckcenter]), ([bckext1]) and ([bckint1]) are converted to the initial
value problems by the change of variables :math:`s = -t`.

Due to ([bckinclusion]) and ([bcktightness]),

.. math::

   \bigcup_{\langle l_1,l_1\rangle=1}{\mathcal E}(y_c(t),Y^-_l(t)) =
   {\mathcal Y}(t_1,t,{\mathcal E}(y_1,Y_1)) =
   \bigcap_{\langle l_1,l_1\rangle=1}{\mathcal E}(y_c(t),Y^+_l(t)).

**Remark.** In expressions ([fwdext1]), ([fwdint1]), ([bckext1]) and
([bckint1]) the terms :math:`\frac{1}{\pi_l(t)}` and
:math:`\frac{1}{\eta_l(t)}` may not be well defined for some vectors
:math:`l`, because matrices :math:`B(t)P(t)B^T(t)` and
:math:`G(t)Q(t)G^T(t)` may be singular. In such cases, we set these
entire expressions to zero.

Discrete-time systems
~~~~~~~~~~~~~~~~~~~~~

Consider the discrete-time linear system,

.. math::

   x(t+1) = A(t)x(t) + B(t)u(t,x(t)) + G(t)v(t),
   \tag*{(\ref{ctsystem})}
   \label{dtsystem}

in which :math:`x(t)\in{\bf R}^n` is the state,
:math:`u(t, x(t))\in{\bf R}^m` is the control bounded by the ellipsoid
:math:`{\mathcal E}(p(t),P(t))`, :math:`v(t)\in{\bf R}^d` is disturbance
bounded by ellipsoid :math:`{\mathcal E}(q(t),Q(t))`, and matrices
:math:`A(t)`, :math:`B(t)`, :math:`G(t)` are in
:math:`{\bf R}^{n\times n}`, :math:`{\bf R}^{n\times m}`,
:math:`{\bf R}^{n\times d}` respectively. Here we shall assume
:math:`A(t)` to be nonsingular. [9]_ The set of initial conditions at
initial time :math:`t_0` is ellipsoid :math:`{\mathcal E}(x_0,X_0)`.

Ellipsoidal Toolbox computes maxmin and minmax CLRS
:math:`\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)` and
:math:`\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)` for
discrete-time systems.

If matrix :math:`Q(\cdot)=0`, the system ([dtsystem]) becomes an
ordinary affine system with known :math:`v(\cdot)=q(\cdot)`. If matrix
:math:`G(\cdot)=0`, the system reduces to a linear controlled system. In
the absence of disturbance (:math:`Q(\cdot)=0` or :math:`G(\cdot)=0`),
:math:`\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))=\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))={\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0))`,
the reach set is as in Definition [def:sub:`o`\ lrs].

Maxmin and minmax CLRS
:math:`\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)` and
:math:`\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)`, if
nonempty, are symmetric convex and compact, with the center evolving in
time according to

.. math::

   x_c(t+1) = A(t)x_c(t) + B(t)p(t) + G(t)v(t), \;\;\; x_c(t_0)=x_0.
   \label{fwdcenterd}

Fix some vector :math:`l_0\in{\bf R}^n` and consider :math:`l(t)` that
satisfies the discrete-time adjoint equation, [10]_

.. math::

   l(t+1) = \left(A^T\right)^{-1}(t)l(t), \;\;\; l(t_0) = l_0,
   \label{adjointdt}

or, equivalently

.. math:: l(t) = \Phi^T(t_0, t)l_0 .

 There exist tight external ellipsoids
:math:`{\mathcal E}(x_c(t), \overline{X}^+_l(t))`,
:math:`{\mathcal E}(x_c(t), \underline{X}^+_l(t))` and tight internal
ellipsoids :math:`{\mathcal E}(x_c(t), \overline{X}^-_l(t))`,
:math:`{\mathcal E}(x_c(t), \underline{X}^-_l(t))` such that

.. math::

   {\mathcal E}(x_c(t), \overline{X}^-_l(t))\subseteq\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))
   \subseteq {\mathcal E}(x_c(t), \overline{X}^+_l(t)),
   \label{maxmininclusion}

.. math::

   \rho(l(t) ~|~ {\mathcal E}(x_c(t), \overline{X}^-_l(t))) =
   \rho(l(t) ~|~ \overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0,X_0))) =
   \rho(l(t) ~|~ {\mathcal E}(x_c(t), \overline{X}^+_l(t))) .
   \label{maxmintightness}

and

.. math::

   {\mathcal E}(x_c(t), \underline{X}^-_l(t))\subseteq\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))
   \subseteq {\mathcal E}(x_c(t), \underline{X}^+_l(t)),
   \label{minmaxinclusion}

.. math::

   \rho(l(t) ~|~ {\mathcal E}(x_c(t), \underline{X}^-_l(t))) =
   \rho(l(t) ~|~ \underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0,X_0))) =
   \rho(l(t) ~|~ {\mathcal E}(x_c(t), \underline{X}^+_l(t))) .
   \label{minmaxtightness}

The shape matrix of the external ellipsoid for maxmin reach set is
determined from

.. math::

   \begin{aligned}
   \hat{X}^+_l(t) & = & (1+\overline{\pi}_l(t))A(t)\overline{X}^+_l(t)A^T(t) +
   \left(1+\frac{1}{\overline{\pi}_l(t)}\right)
   B(t)P(t)B^T(t), \label{fwdextmaxmin1} \\
   \overline{X}^+_l(t+1) & = & \left((\hat{X}^+_l(t))^{1/2} +
   \overline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right)^T
   \times \nonumber \\
   & &\left((\hat{X}^+_l(t))^{1/2} + \overline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right),
   \label{fwdextmaxmin2}\\
   \overline{X}^+_l(t_0) & = & X_0, \label{fwdextmaxmin3}\end{aligned}

wherein

.. math::

   \overline{\pi}_l(t) = \frac{\langle l(t+1),
   B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
   \overline{X}^+_l(t)l(t)\rangle^{1/2}},

 and the orthogonal matrix :math:`\overline{S}_l(t)` is determined by
the equation

.. math::

   \begin{aligned}
   & & \overline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t+1) = \\
   & & \frac{\langle l(t+1),
   G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
   \hat{X}^+_l(t)l(t+1)\rangle^{1/2}}(\hat{X}^+_l(t))^{1/2}l(t+1).\end{aligned}

Equation ([fwdextmaxmin2]) is valid only if
:math:`{\mathcal E}(0,G(t)Q(t)G^T(t))\subseteq{\mathcal E}(0,\hat{X}^+_l(t))`,
otherwise the maxmin CLRS
:math:`\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))` is
empty.

The shape matrix of the external ellipsoid for minmax reach set is
determined from

.. math::

   \begin{aligned}
   \breve{X}^+_l(t) & = &
   \left((A(t)\underline{X}^+_l(t)A^T(t))^{1/2} +
   \underline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right)^T
   \times \nonumber \\
   & &\left((A(t)\underline{X}^+_l(t)A^T(t))^{1/2} +
   \underline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right)
   \label{fwdextminmax1}\\
   \underline{X}^+_l(t+1) & = &
   (1+\underline{\pi}_l(t))\breve{X}^+_l(t) +
   \left(1+\frac{1}{\underline{\pi}_l(t)}\right)
   B(t)P(t)B^T(t), \label{fwdextminmax2} \\
   \underline{X}^+_l(t_0) & = & X_0, \label{fwdextminmax3}\end{aligned}

where

.. math::

   \underline{\pi}_l(t) = \frac{\langle l(t+1),
   B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
   \breve{X}^+_l(t)l(t+1)\rangle^{1/2}},

 and :math:`\underline{S}_l(t)` is orthogonal matrix determined from the
equation

.. math::

   \begin{aligned}
   & & \underline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t+1) = \\
   & & \frac{\langle l(t+1),
   G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
   \underline{X}^+_l(t)l(t)\rangle^{1/2}}(A(t)\underline{X}^+_l(t)A^T(t))^{1/2}l(t+1).\end{aligned}

Equations ([fwdextminmax1]), ([fwdextminmax2]) are valid only if
:math:`{\mathcal E}(0,G(t)Q(t)G^T(t)\subseteq{\mathcal E}(0,A(t)\underline{X}^+_l(t)A^T(t))`,
otherwise minmax CLRS
:math:`\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))` is
empty.

The shape matrix of the internal ellipsoid for maxmin reach set is
determined from

.. math::

   \begin{aligned}
   \hat{X}^-_l(t) & = &
   \left((A(t)\overline{X}^-_l(t)A^T(t))^{1/2} +
   \overline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right)^T
   \times \nonumber \\
   & &\left((A(t)\overline{X}^-_l(t)A^T(t))^{1/2} +
   \overline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right)
   \label{fwdintmaxmin1}\\
   \overline{X}^-_l(t+1) & = &
   (1+\overline{\eta}_l(t))\hat{X}^-_l(t) +
   \left(1+\frac{1}{\underline{\eta}_l(t)}\right)
   G(t)Q(t)G^T(t), \label{fwdintmaxmin2} \\
   \overline{X}^-_l(t_0) & = & X_0, \label{fwdintmaxmin3}\end{aligned}

where

.. math::

   \overline{\eta}_l(t) = \frac{\langle l(t+1),
   G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
   \hat{X}^-_l(t)l(t+1)\rangle^{1/2}},

 and :math:`\overline{T}_l(t)` is orthogonal matrix determined from the
equation

.. math::

   \begin{aligned}
   & & \overline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}l(t+1) = \\
   & & \frac{\langle l(t+1),
   B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
   \overline{X}^-_l(t)l(t)\rangle^{1/2}}(A(t)\overline{X}^-_l(t)A^T(t))^{1/2}l(t+1).\end{aligned}

Equation ([fwdintmaxmin2]) is valid only if
:math:`{\mathcal E}(0,G(t)Q(t)G^T(t)\subseteq{\mathcal E}(0,\hat{X}^-_l(t))`.

The shape matrix of the internal ellipsoid for the minmax reach set is
determined by

.. math::

   \begin{aligned}
   \breve{X}^-_l(t) & = & (1+\underline{\eta}_l(t))A(t)\underline{X}^-_l(t)A^T(t) +
   \left(1+\frac{1}{\underline{\eta}_l(t)}\right)
   G(t)Q(t)G^T(t), \label{fwdintminmax1} \\
   \underline{X}^-_l(t+1) & = & \left((\breve{X}^-_l(t))^{1/2} +
   \underline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right)^T
   \times \nonumber \\
   & &\left((\breve{X}^-_l(t))^{1/2} + \underline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right),
   \label{fwdintminmax2}\\
   \underline{X}^-_l(t_0) & = & X_0, \label{fwdintminmax3}\end{aligned}

wherein

.. math::

   \underline{\eta}_l(t) = \frac{\langle l(t+1),
   G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
   \underline{X}^-_l(t)l(t)\rangle^{1/2}},

 and the orthogonal matrix :math:`\underline{T}_l(t)` is determined by
the equation

.. math::

   \begin{aligned}
   & & \underline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}l(t+1) = \\
   & & \frac{\langle l(t+1),
   B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
   \breve{X}^-_l(t)l(t+1)\rangle^{1/2}}(\breve{X}^-_l(t))^{1/2}l(t+1).\end{aligned}

Equations ([fwdintminmax1]), ([fwdintminmax2]) are valid only if
:math:`{\mathcal E}(0,G(t)Q(t)G^T(t)\subseteq{\mathcal E}(0,A(t)\underline{X}^-_l(t)A^T(t))`.

The point where the external and the internal ellipsoids both touch the
boundary of the maxmin CLRS is

.. math::

   x_l^+(t) = x_c(t) + \frac{\overline{X}^+_l(t)l(t)}{\langle l(t),
   \overline{X}^+_l(t)l(t)\rangle^{1/2}} ,

 and the bounday point of minmax CLRS is

.. math::

   x_l^-(t) = x_c(t) + \frac{\overline{X}^-_l(t)l(t)}{\langle l(t),
   \overline{X}^-_l(t)l(t)\rangle^{1/2}} .

 Points :math:`x^{\pm}_l(t)`, :math:`t\geqslantt_0`, form extremal
trajectories. In order for the system to follow the extremal trajectory
specified by some vector :math:`l_0`, the initial state must be

.. math:: x_l^0 = x_0 + \frac{X_0l_0}{\langle l_0, X_0l_0\rangle^{1/2}}. \label{dx0l}

When there is no disturbance (:math:`G(t)=0` or :math:`Q(t)=0`),
:math:`\overline{X}^+_l(t)=\underline{X}^+_l(t)` and
:math:`\overline{X}^-_l(t)=\underline{X}^-_l(t)`, and the open-loop
control that steers the system along the extremal trajectory defined by
:math:`l_0` is

.. math::

   u_l(t) = p(t) + \frac{P(t)B^T(t)l(t+1)}{\langle l(t+1),
   B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}. \label{udt}

Each choice of :math:`l_0` defines an external and internal
approximation. If
:math:`\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))` is
nonempty,

.. math::

   \bigcup_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\overline{X}^-_l(t)) =
   \overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0)) =
   \bigcap_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\overline{X}^+_l(t)).

 Similarly for
:math:`\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))`,

.. math::

   \bigcup_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\underline{X}^-_l(t)) =
   \underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0)) =
   \bigcap_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\underline{X}^+_l(t)).

Similarly, tight ellipsoidal approximations of maxmin and minmax CLBRS
with terminating conditions :math:`(t_1, {\mathcal E}(y_1,Y_1))` can be
obtained for those directions :math:`l(t)` satisfying

.. math::

   l(t) = \Phi^T(t_1,t)l_1,
   \tag*{(\ref{bckadjoint})}
   \label{bckadjointd}

with some fixed :math:`l_1`, for which they exist.

With boundary conditions

.. math::

   y_c(t_1)=y_1, ~~~ \overline{Y}^+_l(t_1)=\overline{Y}^-_l(t_1)=\underline{Y}^+_l(t_1)=\underline{Y}^-_l(t_1)=Y_1,
   \label{bndconds}

external and internal ellipsoids for maxmin CLBRS
:math:`\overline{{\mathcal Y}}_{CL}(t_1,t,{\mathcal E}(y_1,Y_1))` at
time :math:`t`, :math:`{\mathcal E}(y_c(t),\overline{Y}^+_l(t))` and
:math:`{\mathcal E}(y_c(t),\overline{Y}^-_l(t))`, are computed as
external and internal ellipsoidal approximations of the geometric
sum-difference

.. math::

   A^{-1}(t)\left(
   {\mathcal E}(y_c(t+1),\overline{Y}^+_l(t+1)) \oplus B(t){\mathcal E}(-p(t),P(t))
   \dot{-}G(t){\mathcal E}(-q(t),Q(t))
   \right)

 and

.. math::

   A^{-1}(t)\left(
   {\mathcal E}(y_c(t+1),\overline{Y}^-_l(t+1)) \oplus B(t){\mathcal E}(-p(t),P(t))
   \dot{-}G(t){\mathcal E}(-q(t),Q(t))
   \right)

 in direction :math:`l(t)` from [bckadjointd]. Section
[subsec:sub:`s`\ umdiff] describes the operation of geometric
sum-difference for ellipsoids.

External and internal ellipsoids for minmax CLBRS
:math:`\underline{{\mathcal Y}}_{CL}(t_1,t,{\mathcal E}(y_1,Y_1))` at
time :math:`t`, :math:`{\mathcal E}(y_c(t),\underline{Y}^+_l(t))` and
:math:`{\mathcal E}(y_c(t),\underline{Y}^-_l(t))`, are computed as
external and internal ellipsoidal approximations of the geometric
difference-sum

.. math::

   A^{-1}(t)\left(
   {\mathcal E}(y_c(t+1),\underline{Y}^+_l(t+1))
   \dot{-}G(t){\mathcal E}(-q(t),Q(t))
   \oplus B(t){\mathcal E}(-p(t),P(t))
   \right)

 and

.. math::

   A^{-1}(t)\left(
   {\mathcal E}(y_c(t+1),\underline{Y}^-_l(t+1))
   \dot{-}G(t){\mathcal E}(-q(t),Q(t))
   \oplus B(t){\mathcal E}(-p(t),P(t))
   \right)

 in direction :math:`l(t)` from [bckadjointd]. Section
[subsec:sub:`d`\ iffsum] describes the operation of geometric
difference-sum for ellipsoids.

Installation
============

Additional Software
-------------------

These packages aren’t included in the ET distribution. So, you need to
download them separately.

CVX
~~~

Some methods of the *Ellipsoidal Toolbox*, namely,

-  distance

-  intersect

-  isInside

-  doesContain

-  ellintersection\_ia

-  ellunion\_ea

require solving semidefinite programming (SDP) problems. We use CVX (
(“CVX Homepage”)) as an interface to an external SDP solver. CVX is a
reliable toolbox for solving SDP problems of high dimensionality. CVX is
implemented in Matlab, effectively turning Matlab into an optimization
modeling language. Model specifications are constructed using common
Matlab operations and functions, and standard Matlab code can be freely
mixed with these specifications. This combination makes it simple to
perform the calculations needed to form optimization problems, or to
process the results obtained from their solution. CVX distribution
includes two freeware solvers: SeDuMi(Sturm (1999), (“SeDuMi Homepage”))
and SDPT3( (“SDPT3 Homepage”)). The default solver used in the toolbox
is SeDuMi.

MPT
~~~

Multi-Parametric Toolbox( (“Multi-Parametric Toolbox Homepage”)) - a
Matlab toolbox for multi-parametric optimization and computational
geometry. MPT is a toolbox that defines polytope class used in *ET*. We
need MPT for the following methods operating with polytopes.

-  distance

-  intersect

-  intersection\_ia

-  intersection\_ea

-  isInside

-  hyperplane2polytope

-  polytope2hyperplane

Installation and Quick Start
----------------------------

#. Go to and download the *Ellipsoidal Toolbox*.

#. Unzip the distribution file into the directory where you would like
   the toolbox to be.

#. Unzip CVX into cvx folder next to products folder.

#. Unzip MPT into mpt folder next to products folder.

#. Read the copyright notice.

#. In MATLAB command window change the working directory to the one
   where you unzipped the toolbox and type

#. At this point, the directory tree of the *Ellipsoidal Toolbox* is
   added to the MATLAB path list. In order to save the updated path
   list, in your MATLAB window menu go to File :math:`\rightarrow` Set
   Path... and click Save.

#. To get an idea of what the toolbox is about, type

   This will produce a demo of basic *ET* functionality: how to create
   and manipulate ellipsoids.

   Type

   to learn how to plot ellipsoids and hyperplanes in 2 and 3D. For a
   quick tutorial on how to use the toolbox for reachability analysis
   and verification, type

Implementation
==============

Operations with ellipsoids
--------------------------

In the *Ellipsoidal Toolbox* we define a new class ellipsoid inside the
MATLAB programming environment. The following three commands define the
same ellipsoid :math:`{\mathcal E}(q,Q)`, with :math:`q\in{\bf R}^n` and
:math:`Q\in{\bf R}^{n\times n}` being symmetric positive semidefinite:
For the ellipsoid class we overload the following functions and
operators:

-  isEmpty(ellObj) - checks if :math:`{\mathcal E}(q,Q)` is an empty
   ellipsoid.

-  display(ellObj) - displays the details of ellipsoid
   :math:`{\mathcal E}(q,Q)`, namely, its center :math:`q` and the shape
   matrix :math:`Q`.

-  plot(ellObj) - plots ellipsoid :math:`{\mathcal E}(q,Q)` if its
   dimension is not greater than 3.

-  firstEllObj == secEllObj - checks if ellipsoids
   :math:`{\mathcal E}(q_1,Q_1)` and :math:`{\mathcal E}(q_2,Q_2)` are
   equal.

-  firstEllObj = secEllObj - checks if ellipsoids
   :math:`{\mathcal E}(q_1,Q_1)` and :math:`{\mathcal E}(q_2,Q_2)` are
   not equal.

-  - concatenates the ellipsoids into the horizontal array, e.g. ellVec
   = [firstEllObj secEllObj thirdEllObj].

-  - concatenates the ellipsoids into the vertical array, e.g. ellMat =
   [firstEllObj secEllObj; thirdEllObj fourthEllObj] defines
   :math:`2\times 2` array of ellipsoids.

-  firstEllObj >= secEllObj - checks if the ellipsoid firstEllObj is
   bigger than the ellipsoid secEllObj, or equivalently
   :math:`{\mathcal E}(0,Q_1)\subseteq{\mathcal E}(0,Q_2)`.

-  firstEllObj <= secEllObj - checks if
   :math:`{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)`.

-  -ellObj - defines ellipsoid :math:`{\mathcal E}(-q,Q)`.

-  ellObj + bScal - defines ellipsoid :math:`{\mathcal E}(q+b,Q)`.

-  ellObj - bScal - defines ellipsoid :math:`{\mathcal E}(q-b,Q)`.

-  aMat \* ellObj - defines ellipsoid :math:`{\mathcal E}(q,AQA^T)`.

-  ellObj.inv() - inverts the shape matrix of the ellipsoid:
   :math:`{\mathcal E}(q,Q^{-1})`.

All the listed operations can be applied to a single ellipsoid as well
as to a two-dimensional array of ellipsoids. For example, To access
individual elements of the array, the usual MATLAB subindexing is used:
Sometimes it may be useful to modify the shape of the ellipsoid without
affecting its center. Say, we would like to bloat or squeeze the
ellipsoid: Since function shape does not change the center of the
ellipsoid, it only accepts scalars or square matrices as its second
input parameter. Several functions access the internal data of the
ellipsoid object: One way to check if two ellipsoids intersect, is to
compute the distance between them ( (“Stanley Chan Article Homepage”),
Lin and Han (2002)): This result indicates that the ellipsoid
thirdEllObj does not intersect with the ellipsoid ellMat(2, 2), with all
the other ellipsoids in ellMat it has nonempty intersection. If the
intersection of the two ellipsoids is nonempty, it can be approximated
by ellipsoids from the outside as well as from the inside. See
:math:`\mbox{\!\!\@OldCite{ROS_SABATER_THOMAS_EN_ELLIPSOIDAL_CALCULUS_BASED_ON_PROPAGATION_AND_FUSION}}`
for more information about these methods. It can be checked that
resulting ellipsoid externalEllObj contains the given intersection,
whereas internalEllObj is contained in this intersection: Function
isInside in general checks if the intersection of ellipsoids in the
given array contains the union or intersection of ellipsoids or
polytopes.

It is also possible to solve the feasibility problem, that is, to check
if the intersection of more than two ellipsoids is empty: In this
particular example the result :math:`-1` indicates that the intersection
of ellipsoids in ellMat is empty. Function intersect in general checks
if an ellipsoid, hyperplane or polytope intersects the union or the
intersection of ellipsoids in the given array: For the ellipsoids in
:math:`{\bf R}`, :math:`{\bf R}^2` and :math:`{\bf R}^3` the geometric
sum can be computed explicitely and plotted: Figure
:math:`\ref{minksumPic}` displays the geometric sum of ellipsoids. If
the dimension of the space in which the ellipsoids are defined exceeds
:math:`3`, an error is returned. The result of the geometric sum
operation is not generally an ellipsoid, but it can be approximated by
families of external and internal ellipsoids parametrized by the
direction vector: Functions minksum\_ea and minksum\_ia work for
ellipsoids of arbitrary dimension. They should be used for general
computations whereas minksum is there merely for visualization purposes.

If the geometric difference of two ellipsoids is not an empty set, it
can be computed explicitely and plotted for ellipsoids in
:math:`{\bf R}`, :math:`{\bf R}^2` and :math:`{\bf R}^3`: Figure
:math:`\ref{minkdiffPic}` shows the geometric difference of ellipsoids.
Similar to minksum, minkdiff is there for visualization purpose. It
works only for dimensions :math:`1`, :math:`2` and :math:`3`, and for
higher dimensions it returns an error. For arbitrary dimensions, the
geometric difference can be approximated by families of external and
internal ellipsoids parametrized by the direction vector, provided this
direction is not bad: Operation ’difference-sum’ described in section
2.2.4 is implemented in functions minkmp, minkmp\_ea, minkmp\_ia, the
first one of which is used for visualization and works for dimensions
not higher than :math:`3`, whereas the last two can deal with ellipsoids
of arbitrary dimension. Figure :math:`\ref{minkPic}` displays results of
the implementation of minkpm and minkmp operations. Similarly, operation
’sum-difference’ described in section 2.2.5 is implemented in functions
minkpm, minkpm\_ea, minkpm\_ia, the first one of which is used for
visualization and works for dimensions not higher than :math:`3`,
whereas the last two can deal with ellipsoids of arbitrary dimension.

Operations with hyperplanes
---------------------------

The class hyperplane of the *Ellipsoidal Toolbox* is used to describe
hyperplanes and halfspaces. The following two commands define one and
the same hyperplane but two different halfspaces:

The following functions and operators are overloaded for the hyperplane
class:

-  isempty(hypObj) - checks if hypObj is an empty hyperplane.

-  display(hypObj) - displays the details of hyperplane
   :math:`H(c,\gamma)`, namely, its normal :math:`c` and the scalar
   :math:`\gamma`.

-  plot(hypObj) - plots hyperplane :math:`H(c,\gamma)` if the dimension
   of the space in which it is defined is not greater than 3.

-  firstHypObj == secHypObj - checks if hyperplanes
   :math:`H(c_1,\gamma_1)` and :math:`H(c_2,\gamma_2)` are equal.

-  firstHypObj = secHypObj - checks if hyperplanes
   :math:`H(c_1,\gamma_1)` and :math:`H(c_2,\gamma_2)` are not equal.

-  - concatenates the hyperplanes into the horizontal array, e.g. hypVec
   = [firstHypObj secHypObj thirdHypObj].

-  - concatenates the hyperplanes into the vertical array, e.g. hypMat =
   [firstHypObj secHypObj; thirdHypObj fourthHypObj] - defines
   :math:`2\times 2` array of hyperplanes.

-  -hypObj - defines hyperplane :math:`H(-c,-\gamma)`, which is the same
   as :math:`H(c,\gamma)` but specifies different halfspace.

There are several ways to access the internal data of the hyperplane
object: All the functions of *Ellipsoidal Toolbox* that accept
hyperplane object as parameter, work with single hyperplanes as well as
with hyperplane arrays. One exception is the function parameters that
allows only single hyperplane object.

An array of hyperplanes can be converted to the polytope object of the
Multi-Parametric Toolbox (Kvasnica et al. (2004), (“Multi-Parametric
Toolbox Homepage”)), and back: Functions hyperplane2polytope and
polytope2hyperplane require the Multi-Parametric Toolbox to be
installed.

We can compute distance from ellipsoids to hyperplanes and polytopes: A
negative distance value in the case of ellipsoid and hyperplane means
that the ellipsoid intersects the hyperplane. As we see in this example,
ellipsoid firstEllObj intersects hyperplanes hypVec(1) and hypVec(3) and
has no common points with hypVec(2) and hypVec(4). When distance
function has a polytope as a parameter, it always returns nonnegative
values to be consistent with distance function of the Multi-Parametric
Toolbox. Here, the zero distance values mean that each ellipsoid in
ellMat has nonempty intersection with polytope firstPolObj.

It can be checked if the union or intersection of given ellipsoids
intersects given hyperplanes or polytopes:

The intersection of ellipsoid and hyperplane can be computed exactly:
Functions intersection\_ea and intersection\_ia can be used with
hyperplane objects, which in this case define halfspaces and polytope
objects:

Function isInside can be used to check if a polytope or union of
polytopes is contained in the intersection of given ellipsoids:

Functions distance, intersect, intersection\_ia and isInside use the CVX
interface ( (“CVX Homepage”)) to the external optimization package. The
default optimization package included in the distribution of the
*Ellipsoidal Toolbox* is SeDuMi (Sturm (1999), (“SeDuMi Homepage”)).

Operations with ellipsoidal tubes
---------------------------------

There are several classes in *Ellipsoidal Toolbox* for operations with
ellipsoidal tubes. The class gras.ellapx.smartdb.rels.EllTube is used to
describe ellipsoidal tubes. The class
gras.ellapx.smartdb.rels.EllUnionTube is used to store tubes by the
instant of time:

.. math:: {\mathcal X}_{U}[t]=\bigcup \limits_{\tau\leqslantt}{\mathcal X}[\tau],

 where :math:`{\mathcal X}[\tau]` is single ellipsoidal tube. The class
gras.ellapx.smartdb.rels.EllTubeProj is used to describe the projection
of the ellipsoidal tubes onto time dependent subspaces.There are two
types of projection: static and dynamic. Also there is class
gras.ellapx.smartdb.rels.EllUnionTubeStaticProj for description of the
projection on static plane tubes by the instant of time. Next we provide
some examples of the operations with ellipsoidal tubes. We may be
interested in the data about ellipsoidal tube in some particular time
interval, smaller than the one for which the ellipsoidal tube was
computed, say :math:`2\leqslantt\leqslant4`. This data can be extracted
by the cut function: We can compute the projection of the ellipsoidal
tube onto time-dependent subspace.

Figure :math:`\ref{project}` displays static and dynamic projections.
Also we can see projections of good directions for ellipsoidal tubes.

We can compute tubes by the instant of time using methodfromEllTubes:
Figure :math:`\ref{unionTubeStatProj}` shows projection of ellipsoidal
tubes by the instant of time. ellipsoidal tutbes.

Also we can get initial data from the resulting tube: There is a method
to display a content of ellipsoidal tubes. Figure :math:`\ref{dispPic}`
displays all fields of the ellipsoidal tube.

There are several methods to find the tubes with necessary parameters.
Also you can use the method display to see the result of the method’s
work. We can sort our tubes by certain fields:

Reachability
------------

To compute the reach sets of the systems described in chapter 3, we
define few new classes in the *Ellipsoidal Toolbox*: class
LinSysContinuous for the continuous-time system description, class
LinSysDiscrete for the discrete-time system description and classes
ReachContinuous\ :math:`\backslash`\ ReachDiscrete for the reach set
data. We start by explaining how to define a system using
LinSysContinuous object. Also we can use LinSysFactory class for the
description of this system. Through it’s method create user can get
LinSysContinuous or LinSysDiscrete object. For example, description of
the system

.. math::

   \left[\begin{array}{cc}
   \dot{x}_1\\
   \dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
   0 & 1\\
   0 & 0\end{array}\right]\left[\begin{array}{c}
   x_1\\
   x_2\end{array}\right] + \left[\begin{array}{c}
   u_1(t)\\
   u_2(t)\end{array}\right], ~~~ u(t)\in{\mathcal E}(p(t), P)

 with

.. math::

   p(t) = \left[\begin{array}{c}
   \sin(t)\\
   \cos(t)\end{array}\right], ~~~ P = \left[\begin{array}{cc}
   9 & 0\\
   0 & 2\end{array}\right],

 is done by the following sequence of commands: If matrices :math:`A` or
:math:`B` depend on time, say :math:`A(t)=\left[\begin{array}{cc}
0 & 1-\cos(2t)\\
-\frac{1}{t} & 0\end{array}\right]`, then matrix aMat should be
symbolic: To describe the system with disturbance

.. math::

   \left[\begin{array}{cc}
   \dot{x}_1\\
   \dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
   0 & 1\\
   0 & 0\end{array}\right]\left[\begin{array}{c}
   x_1\\
   x_2\end{array}\right] + \left[\begin{array}{c}
   u_1(t)\\
   u_2(t)\end{array}\right] + \left[\begin{array}{c}
   0\\
   1\end{array}\right]v(t),

 with bounds on control as before, and disturbance being
:math:`-1\leqslantv(t)\leqslant1`, we type: Control and disturbance
bounds SUBounds and vEllObj can have different types. If the bound is
constant, it should be described by ellipsoid object. If the bound
depends on time, then it is represented by a structure with fields
center and shape, one or both of which are symbolic. In system sys, the
control bound SUBounds is defined as such a structure. Finally, if the
control or disturbance is known and fixed, it should be defined as a
vector, of type double if constant, or symbolic, if it depends on time.

To declare a discrete-time system

.. math::

   \left[\begin{array}{c}
   x_1[k+1]\\
   x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
   0 & 1\\
   -1 & -0.5\end{array}\right]\left[\begin{array}{c}
   x_1[k]\\
   x_2[k]\end{array}\right] + \left[\begin{array}{c}
   0\\
   1\end{array}\right]u[k], ~~~ -1\leqslantu[k]\leqslant1,

 we use LinSysDiscrete constructor: Once the LinSysDiscrete object is
created, we need to specify the set of initial conditions, the time
interval and values of the direction vector, for which the reach set
approximations must be computed: The reach set approximation is computed
by calling the constructor of the ReachContinuous object: At this point,
variable firstRsObj contains the reach set approximations for the
specified continuous-time system, time interval and set of initial
conditions computed for given directions. Both external and internal
approximations are computed. The reach set approximation data can be
extracted in the form of arrays of ellipsoids:

Ellipsoidal arrays externallEllMat and internalEllMat have :math:`4`
rows because we computed the reach set approximations for :math:`4`
directions. Each row of ellipsoids corresponds to one direction. The
number of columns in externallEllMat and internalEllMat is defined by
the nTimeGridPoints parameter, which is available from
elltool.conf.Properties static class (see chapter 6 for details). It
represents the number of time values in our time interval, at which the
approximations are evaluated. These time values are returned in the
optinal output parameter, array timeVec, whose length is the same as the
number of columns in externallEllMat and internalEllMat. Intersection of
ellipsoids in a particular column of externallEllMat gives external
ellipsoidal approximation of the reach set at corresponding time.
Internal ellipsoidal approximation of this set at this time is given by
the union of ellipsoids in the same column of internalEllMat.

We may be interested in the reachability data of our system in some
particular time interval, smaller than the one for which the reach set
was computed, say :math:`3\leqslantt\leqslant5`. This data can be
extracted and returned in the form of ReachContinuous object by the cut
function:

To obtain a snap shot of the reach set at given time, the same function
cut is used: It can be checked if the external or internal reach set
approximation intersects with given ellipsoids, hyperplanes or
polytopes:

If a given set intersects with the internal approximation of the reach
set, then this set intersects with the actual reach set. If the given
set does not intersect with external approximation, this set does not
intersect the actual reach set. There are situations, however, when the
given set intersects with the external approximation but does not
intersect with the internal one. In our example above, ellipsoid ellObj
is such a case: the quality of the approximation does not allow us to
determine whether or not ellObj intersects with the actual reach set. To
improve the quality of approximation, refine function should be used:

Now we are sure that ellipsoid ellObj intersects with the actual reach
set. However, to use the refine function, the reach set object must
contain all calculated data, otherwise, an error is returned.

Having a reach set object resulting from the ReachContinuous, cut or
refine operations, we can obtain the trajectory of the center of the
reach set and the good curves along which the actual reach set is
touched by its ellipsoidal approximations:

Variable ctrMat here is a matrix whose columns are the points ofthe
reach set center trajectory evaluated at time values returned in the
array ttVec. Variable gcCMat contains :math:`4` matrices each of which
corresponds to a good curve (columns of such matrix are points of the
good curve evaluated at time values in ttVec). The analytic expression
for the control driving the system along a good curve is given by
formula ([uct]).

We computed the reach set up to time :math:`10`. It is possible to
continue the reach set computation for a longer time horizon using the
reach set data at time :math:`10` as initial condition. It is also
possible that the dynamics and inputs of the system change at certain
time, and from that point on the system evolves according to the new
system of differential equations. For example, starting at time
:math:`10`, our reach set may evolve in time according to the
time-variant system sys\_t defined above. Switched systems are a special
case of this situation. To compute the further evolution in time of the
existing reach set, function evolve should be used: Function evolve can
be viewed as an implementation of the semigroup property.

To compute the backward reach set for some specified target set, we
declare the time interval so that the terminating time comes first:

Reach set and backward reach set computation for discrete-time systems
and manipulations with the resulting reach set object are performed
using the same functions as for continuous-time systems:

Number of columns in the ellipsoidal arrays externalEllMat and
internalEllMat is :math:`51` because the backward reach set is computed
for :math:`50` time steps, and the first column of these arrays contains
:math:`3` ellipsoids yEllObj - the terminating condition.

When dealing with discrete-time systems, all functions that accept time
or time interval as an input parameter, round the time values and treat
them as integers.

Properties
----------

Functions of the *Ellipsoidal Toolbox* can be called with user-specified
values of certain global parameters. System of the parameters are
configured using xml files, which available from a set of command-line
utilities: Here we list system parameters available from the ’default’
configuration:

#. version = ’1.4dev’ - current version of *ET*.

#. isVerbose = false - makes all the calls to *ET* routines silent, and
   no information except errors is displayed.

#. absTol = 1e-7 - absolute tolerance.

#. relTol = 1e-5 - relative tolerance.

#. nTimeGridPoints = 200 - density of the time grid for the continuous
   time reach set computation. This parameter directly affects the
   number of ellipsoids to be stored in the
   ReachContinuous\ :math:`\backslash`\ ReachDiscrete object.

#. ODESolverName = ode45 - specifies the ODE solver for continuous time
   reach set computation.

#. isODENormControl = ’on’ - switches on and off the norm control in the
   ODE solver. When turned on, it slows down the computation, but
   improves the accuracy.

#. isEnabledOdeSolverOptions = false - when set to false, calls the ODE
   solver without any additional options like norm control. It makes the
   computation faster but less accurate. Otherwise, it is assumed to be
   true, and only in this case the previous option makes a difference.

#. nPlot2dPoints = 200 - the number of points used to plot a 2D
   ellipsoid. This parameter also affects the quality of 2D reach tube
   and reach set plots.

#. nPlot3dPoints = 200 - the number of points used to plot a 3D
   ellipsoid. This parameter also affects the quality of 3D reach set
   plots.

Once the configuration is loaded, the system parameters are available
through elltool.conf.Properties. elltool.conf.Properties is a static
class, providing emulation of static properties for toolbox. It has two
function types: setters and getters. Using getters we obtain system
parameters. Some of the parameters can be changed in run-time via
setters.

Visualization
-------------

*Ellipsoidal Toolbox* has several plotting routines:

-  ellipsoid/plot - plots one or more ellipsoids, or arrays of
   ellipsoids, defined in :math:`{\bf R}`, :math:`{\bf R}^2` or
   :math:`{\bf R}^3`.

-  ellipsoid/minksum - plots geometric sum of finite number of
   ellipsoids defined in :math:`{\bf R}`, :math:`{\bf R}^2` or
   :math:`{\bf R}^3`.

-  ellipsoid/minkdiff - plots geometric difference (if it is not an
   empty set) of two ellipsoids defined in :math:`{\bf R}`,
   :math:`{\bf R}^2` or :math:`{\bf R}^3`.

-  ellipsoid/minkmp - plots geometric (Minkowski) sum of the geometric
   difference of two ellipsoids and the geometric sum of :math:`n`
   ellipsoids defined in :math:`{\bf R}`, :math:`{\bf R}^2` or
   :math:`{\bf R}^3`.

-  ellipsoid/minkpm - plots geometric (Minkowski) difference of the
   geometric sum of ellipsoids and a single ellipsoid defined in
   :math:`{\bf R}`, :math:`{\bf R}^2` or :math:`{\bf R}^3`.

-  hyperplane/plot - plots one or more hyperplanes, or arrays of
   hyperplanes, defined in :math:`{\bf R}^2` or :math:`{\bf R}^3`.

-  reach/plot\_ea - plots external approximation of the reach set whose
   dimension is :math:`2` or :math:`3`.

-  reach/plot\_ia - plots internal approximation of the reach set whose
   dimension is :math:`2` or :math:`3`.

All these functions allow the user to specify the color of the plotted
objects, line width for 1D and 2D plots, and transparency level of the
3D objects. Hyperplanes are displayed as line segments in 2D and square
facets in 3D. In the hyperplane/plot method it is possible to specify
the center of the line segment or facet and its size.

Ellipsoids of dimensions higher than three must be projected onto a two-
or three-dimensional subspace before being plotted. This is done by
means of projection function:

Since the operation of projection is linear, the projection of the
geometric sum of ellipsoids equals the geometric sum of the projected
ellipsoids. The same is true for the geometric difference of two
ellipsoids.

Function projection exists also for the
ReachContinuous\ :math:`\backslash`\ ReachDiscrete objects:

The quality of the ellipsoid and reach set plots is controlled by the
parameters nPlot2dPoints and nPlot3dPoints, which are available from
getters of ellipsoid class.

Examples
========

Ellipsoids vs. Polytopes
------------------------

Depending on the particular dynamical system, certain methods of reach
set computation may be more suitable than others. Even for a simple
2-dimensional discrete-time linear time-invariant system, application of
ellipsoidal methods may be more effective than using polytopes.

Consider the system from chapter 1:

.. math::

   \left[\begin{array}{c}
   x_1[k+1]\\
   x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
   \cos(1) & \sin(1)\\
   -\sin(1) & \cos(1)\end{array}\right]\left[\begin{array}{c}
   x_1[k]\\
   x_2[k]\end{array}\right] + \left[\begin{array}{c}\
   u_1[k]\\
   u_2[k]\end{array}\right], ~~~ x[0]\in{\mathcal X}_0, ~~~ u[k]\in U, ~~~ k\geqslant0,

 where :math:`{\mathcal X}_0` is the set of initial conditions, and
:math:`U` is the control set.

Let :math:`{\mathcal X}_0` and :math:`U` be unit boxes in
:math:`{\bf R}^2`, and compute the reach set using the polytope method
implemented in MPT ( (“Multi-Parametric Toolbox Homepage”)). With every
time step the number of vertices of the reach set polytope increases by
:math:`4`. The complexity of the convex hull computation increases
exponentially with number of vertices. In figure [ellpolyfig], the time
required to compute the reach set for different time steps using
polytopes is shown in red.

To compute the reach set of the system using *Ellipsoidal Toolbox*, we
assume :math:`{\mathcal X}_0` and :math:`U` to be unit balls in
:math:`{\bf R}^2`, fix any number of initial direction values that
corresponds to the number of ellipsoidal approximations, and obtain
external and internal ellipsoidal approximations of the reach set:

In figure [ellpolyfig], the time required to compute both external and
internal ellipsoidal approximations, with :math:`32` ellipsoids each,
for different number of time steps is shown in blue.

Figure [ellpolyfig] illustrates the fact that the complexity of polytope
method grows exponentially with number of time steps, whereas the
complexity of ellipsoidal method grows linearly.

System with Disturbance
-----------------------

The mechanical system presented in figure [springmassfig], is described
by the following system of equations:

.. math::

   \begin{aligned}
   m_1\ddot{x}_1+(k_1+k_2)x_1-k_2x_2 & = & u_1, \label{spmass1}\\
   m_2\ddot{x}_2-k_2x_1+(k_1+k_2)x_2 & = & u_2 . \label{spmass2}\end{aligned}

Here :math:`u_1` and :math:`u_2` are the forces applied to masses
:math:`m_1` and :math:`m_2`, and we shall assume
:math:`[u_1 ~~ u_2]^T\in{\mathcal E}(0,I)`. The initial conditions can
be taken as :math:`x_1(0)=0`, :math:`x_2(0)=2`. Defining
:math:`x_3=\dot{x}_1` and :math:`x_4=\dot{x}_2`, we can rewrite
([spmass1]-[spmass2]) as a linear system in standard form:

.. math::

   \left[\begin{array}{c}
   \dot{x}_1 \\
   \dot{x}_2 \\
   \dot{x}_3 \\
   \dot{x}_4 \end{array}\right] = \left[\begin{array}{cccc}
   0 & 0 & 1 & 0\\
   0 & 0 & 0 & 1\\
   -\frac{k_1+k_2}{m_1} & \frac{k_2}{m_1} & 0 & 0\\
   \frac{k_2}{m_2} & -\frac{k_1+k_2}{m_2} & 0 & 0\end{array}\right]
   \left[\begin{array}{c}
   x_1 \\
   x_2 \\
   x_3 \\
   x_4 \end{array}\right] + \left[\begin{array}{cc}
   0 & 0\\
   0 & 0\\
   \frac{1}{m_1} & 0\\
   0 & \frac{1}{m_2}\end{array}\right]\left[\begin{array}{c}
   u_1\\
   u_2\end{array}\right]. \label{spmassls}

Now we can compute the reach set of system ([spmass1]-[spmass2]) for
given time by computing the reach set of the linear system ([spmassls])
and taking its projection onto :math:`(x_1, x_2)` subspace. Figure
[mechreachfig](a) shows the reach set of the system
([spmass1]-[spmass2]) evolving in time from :math:`t=0` to :math:`t=4`.
Figure [mechreachfig](b) presents a snapshot of this reach set at time
:math:`t=4`.

So far we considered an ideal system without any disturbance, such as
friction. We introduce disturbance to ([spmass1]-[spmass2]) by adding
extra terms, :math:`v_1` and :math:`v_2`,

.. math::

   \begin{aligned}
   m_1\ddot{x}_1+(k_1+k_2)x_1-k_2x_2 & = & u_1 + v_1, \label{smdist1}\\
   m_2\ddot{x}_2-k_2x_1+(k_1+k_2)x_2 & = & u_2 + v_2, \label{smdist2}\end{aligned}

which results in equation ([spmassls]) getting an extra term

.. math::

   \left[\begin{array}{cc}
   0 & 0\\
   0 & 0\\
   1 & 0\\
   0 & 1\end{array}\right]\left[\begin{array}{c}
   v_1\\
   v_2\end{array}\right].

 Assuming that :math:`[v_1 ~~ v_2]^T` is unknown but bounded by
ellipsoid :math:`{\mathcal E}(0, \frac{1}{4}I)`, we can compute the
closed-loop reach set of the system with disturbance.

Figure [mechreachfig](c) shows the reach set of the system
([smdist1]-[smdist2]) evolving in time from :math:`t=0` to :math:`t=4`.
Figure [mechreachfig](d) presents a snapshot of this reach set at time
:math:`t=4`.

Switched System
---------------

By *switched systems* we mean systems whose dynamics changes at known
times. Consider the RLC circuit shown in figure [rlcfig]. It has two
inputs - the voltage (:math:`v`) and current (:math:`i`) sources. Define

-  :math:`x_1` - voltage across capacitor :math:`C_1`, so
   :math:`C_1\dot{x}_1` is the corresponding current;

-  :math:`x_2` - voltage across capacitor :math:`C_2`, so the
   corresponding current is :math:`C_2\dot{x}_2`.

-  :math:`x_3` - current through the inductor :math:`L`, so the voltage
   across the inductor is :math:`L\dot{x}_3`.

Applying Kirchoff current and voltage laws we arrive at the linear
system,

.. math::

   \left[\begin{array}{c}
   \dot{x}_1\\
   \dot{x}_2\\
   \dot{x}_3\end{array}\right] = \left[\begin{array}{ccc}
   -\frac{1}{R_1C_1} & 0 & -\frac{1}{C_1}\\
   0 & 0 & \frac{1}{C_2}\\
   \frac{1}{L} & -\frac{1}{L} & -\frac{R_2}{L}\end{array}\right]
   \left[\begin{array}{c}
   x_1\\
   x_2\\
   x_3\end{array}\right] + \left[\begin{array}{cc}
   \frac{1}{R_1C_1} & \frac{1}{C_1}\\
   0 & 0\\
   0 & 0\end{array}\right]\left[\begin{array}{c}
   v\\
   i\end{array}\right]. \label{rlceq}

The parameters :math:`R_1`, :math:`R_2`, :math:`C_1`, :math:`C_2` and
:math:`L`, as well as the inputs, may depend on time. Suppose, for time
:math:`0\leqslantt<2`, :math:`R_1=2` Ohm, :math:`R_2=1` Ohm,
:math:`C_1=3` F, :math:`C_2=7` F, :math:`L=2` H, both inputs, :math:`v`
and :math:`i` are present and bounded by ellipsoid
:math:`{\mathcal E}(0,I)`; and for time :math:`t\geqslant2`,
:math:`R_1=R_2=2` Ohm, :math:`C_1=C_2=3` F, :math:`L=6` H, the current
source is turned off, and :math:`|v|\leqslant1`. Then, system ([rlceq])
can be rewritten as

.. math::

   \left[\begin{array}{c}
   \dot{x}_1\\
   \dot{x}_2\\
   \dot{x}_3\end{array}\right] = \left\{\begin{array}{ll}
   \left[\begin{array}{ccc}
   -\frac{1}{6} & 0 & -\frac{1}{3}\\
   0 & 0 & \frac{1}{7}\\
   \frac{1}{2} & -\frac{1}{2} & -\frac{1}{2}\end{array}\right]
   \left[\begin{array}{c}
   x_1\\
   x_2\\
   x_3\end{array}\right] + \left[\begin{array}{cc}
   \frac{1}{6} & \frac{1}{3}\\
   0 & 0\\
   0 & 0\end{array}\right]\left[\begin{array}{c}
   v\\
   i\end{array}\right], & 0\leqslantt< 2, \\
   \left[\begin{array}{ccc}
   -\frac{1}{6} & 0 & -\frac{1}{3}\\
   0 & 0 & \frac{1}{3}\\
   \frac{1}{6} & -\frac{1}{6} & -\frac{1}{3}\end{array}\right]
   \left[\begin{array}{c}
   x_1\\
   x_2\\
   x_3\end{array}\right] + \left[\begin{array}{c}
   \frac{1}{6} \\
   0 \\
   0 \end{array}\right]v, & 2\leqslantt. \end{array}\right.
   \label{rlceq2}

We can compute the reach set of ([rlceq2]) for some time :math:`t>2`,
say, :math:`t=3`.

Figure [rlcreachfig](a) shows how the reach set projection onto
:math:`(x_1, x_2)` of system ([rlceq2]) evolves in time from :math:`t=0`
to :math:`t=3`. The external reach set approximation for the first
dynamics is in red, the internal approximation is in green. The dynamics
switches at :math:`t=2`. The external reach set approximation for the
second dynamics is in yellow, its internal approximation is in blue. The
full three-dimensional external (yellow) and internal (blue)
approximations of the reach set are shown in figure [rlcreachfig](b).

To find out where the system should start at time :math:`t=0` in order
to reach a neighborhood M of the origin at time :math:`t=3`, we compute
the backward reach set from :math:`t=3` to :math:`t=0`. Figure
[rlcreachfig](c) presents the evolution of the reach set projection onto
:math:`(x_1, x_2)` in backward time. Again, external and internal
approximations corresponding to the first dynamics are shown in red and
green, and to the second dynamics in yellow and blue. The full
dimensional backward reach set external and internal approximations of
system ([rlceq2]) at time :math:`t=0` is shown in figure
[rlcreachfig](d).

Hybrid System
-------------

There is no explicit implementation of the reachability analysis for
hybrid systems in the *Ellipsoidal Toolbox*. Nonetheless, the operations
of intersection available in the toolbox allow us to work with certain
class of hybrid systems, namely, hybrid systems with affine continuous
dynamics whose guards are ellipsoids, hyperplanes, halfspaces or
polytopes.

We consider the *switching-mode model* of highway traffic presented in
L.Muñoz et al. (2003). The highway segment is divided into :math:`N`
cells as shown in figure [hwfig]. In this particular case, :math:`N=4`.
The traffic density in cell :math:`i` is :math:`x_i` vehicles per mile,
:math:`i=1,2,3,4`.

Define

-  :math:`v_i` - average speed in mph, in the :math:`i`-th cell,
   :math:`i=1,2,3,4`;

-  :math:`w_i` - backward congestion wave propagation speed in mph, in
   the :math:`i`-th highway cell, :math:`i=1,2,3,4`;

-  :math:`x_{Mi}` - maximum allowed density in the :math:`i`-th cell;
   when this velue is reached, there is a traffic jam,
   :math:`i=1,2,3,4`;

-  :math:`d_i` - length of :math:`i`-th cell in miles,
   :math:`i=1,2,3,4`;

-  :math:`T_s` - sampling time in hours;

-  :math:`b` - split ratio for the off-ramp;

-  :math:`u_1` - traffic flow coming into the highway segment, in
   vehicles per hour (vph);

-  :math:`u_2` - traffic flow coming out of the highway segment (vph);

-  :math:`u_3` - on-ramp traffic flow (vph).

Highway traffic operates in two modes: *free-flow* in normal operation;
and *congested* mode, when there is a jam. Traffic flow in free-flow
mode is described by

.. math::

   \begin{aligned}
   \left[\begin{array}{c}
   x_1[t+1]\\
   x_2[t+1]\\
   x_3[t+1]\\
   x_4[t+1]\end{array}\right] & = & \left[\begin{array}{cccc}
   1-\frac{v_1T_s}{d_1} & 0 & 0 & 0\\
   \frac{v_1T_s}{d_2} & 1-\frac{v_2T_s}{d_2} & 0 & 0\\
   0 & \frac{v_2T_s}{d_3} & 1-\frac{v_3T_s}{d_3} & 0\\
   0 & 0 & (1-b)\frac{v_3T_s}{d_4} & 1-\frac{v_4T_s}{d_4}\end{array}\right]
   \left[\begin{array}{c}
   x_1[t]\\
   x_2[t]\\
   x_3[t]\\
   x_4[t]\end{array}\right] \nonumber\\
   & + & \left[\begin{array}{ccc}
   \frac{v_1T_s}{d_1} & 0 & 0\\
   0 & 0 & \frac{v_2T_s}{d_2}\\
   0 & 0 & 0\\
   0 & 0 & 0\end{array}\right]\left[\begin{array}{c}
   u_1\\
   u_2\\
   u_3\end{array}\right]. \label{fflow}\end{aligned}

The equation for the congested mode is

.. math::

   \begin{aligned}
   \left[\begin{array}{c}
   x_1[t+1]\\
   x_2[t+1]\\
   x_3[t+1]\\
   x_4[t+1]\end{array}\right] & = & \left[\begin{array}{cccc}
   1-\frac{w_1T_s}{d_1} & \frac{w_2T_s}{d_1} & 0 & 0\\
   0 & 1-\frac{w_2T_s}{d_2} & \frac{w_3T_s}{d_2} & 0\\
   0 & 0 & 1-\frac{w_3T_s}{d_3} & \frac{1}{1-b}\frac{w_4T_s}{d_3}\\
   0 & 0 & 0 & 1-\frac{w_4T_s}{d_4}\end{array}\right]
   \left[\begin{array}{c}
   x_1[t]\\
   x_2[t]\\
   x_3[t]\\
   x_4[t]\end{array}\right] \nonumber\\
   & + & \left[\begin{array}{ccc}
   0 & 0 & \frac{w_1T_s}{d_1}\\
   0 & 0 & 0\\
   0 & 0 & 0\\
   0 & -\frac{w_4T_s}{d_4} & 0\end{array}\right]\left[\begin{array}{c}
   u_1\\
   u_2\\
   u_3\end{array}\right] \nonumber\\
   & + & \left[\begin{array}{cccc}
   \frac{w_1T_s}{d_1} & -\frac{w_2T_s}{d_1} & 0 & 0\\
   0 & \frac{w_2T_s}{d_2} & -\frac{w_3T_s}{d_2} & 0\\
   0 & 0 & \frac{w_3T_s}{d_3} & -\frac{1}{1-b}\frac{w_4T_s}{d_3}\\
   0 & 0 & 0 & \frac{w_4T_s}{d_4}\end{array}\right]
   \left[\begin{array}{c}
   x_{M1}\\
   x_{M2}\\
   x_{M3}\\
   x_{M4}\end{array}\right]. \label{cflow}\end{aligned}

The switch from the free-flow to the congested mode occurs when the
density :math:`x_2` reaches :math:`x_{M2}`. In other words, the
hyperplane :math:`H([0 ~ 1 ~ 0 ~ 0]^T, x_{M2})` is the guard.

We indicate how to implement the reach set computation of this hybrid
system. We first define the two linear systems and the guard.

We assume that initially the system is in free-flow mode. Given a set of
initial conditions, we compute the reach set according to dynamics
([fflow]) for certain number of time steps. We will consider the
external approximation of the reach set by a single ellipsoid.

Having obtained the ellipsoidal array externalEllMat representing the
reach set evolving in time, we determine the ellipsoids in the array
that intersect the guard.

Analyzing the values in array dVec, we conclude that the free-flow reach
set has nonempty intersection with hyperplane grdHyp at :math:`t=18` for
the first time, and at :math:`t=68` for the last time. Between
:math:`t=18` and :math:`t=68` it crosses the guard. Figure
[hwreachfig](a) shows the free-flow reach set projection onto
:math:`(x_1,x_2,x_3)` subspace for :math:`t=10`, before the guard
crossing; figure [hwreachfig](b) for :math:`t=50`, during the guard
crossing; and figure [hwreachfig](c) for :math:`t=80`, after the guard
was crossed.

For each time step that the intersection of the free-flow reach set and
the guard is nonempty, we establish a new initial time and a set of
initial conditions for the reach set computation according to dynamics
([cflow]). The initial time is the array index minus one, and the set of
initial conditions is the intersection of the free-flow reach set with
the guard.

The union of reach sets in array crs forms the reach set for the
congested dynamics.

A summary of the reach set computation of the linear hybrid system
([fflow]-[cflow]) for :math:`N=100` time steps with one guard crossing
is given in figure [hwreachfig](d), which shows the projection of the
reach set trace onto :math:`(x_1,x_2)` subspace. The system starts
evolving in time in free-flow mode from a set of initial conditions at
:math:`t=0`, whose boundary is shown in magenta. The free-flow reach set
evolving from :math:`t=0` to :math:`t=100` is shown in blue. Between
:math:`t=18` and :math:`t=68` the free-flow reach set crosses the guard.
The guard is shown in red. For each nonempty intersection of the
free-flow reach set and the guard, the congested mode reach set starts
evolving in time until :math:`t=100`. All the congested mode reach sets
are shown in green. Observe that in the congested mode, the density
:math:`x_2` in the congested part decreases slightly, while the density
:math:`x_1` upstream of the congested part increases. The blue set above
the guard is not actually reached, because the state evolves according
to the green region.

Summary and Outlook
===================

Although some of the operations with ellipsoids are present in the
commercial Geometric Bounding Toolbox Veres et al. (2001; “Geometric
Bounding Toolbox Homepage”), the ellipsoid-related functionality of that
toolbox is rather limited.

*Ellipsoidal Toolbox* is the first free MATLAB package that implements
ellipsoidal calculus and uses ellipsoidal methods for reachability
analysis of continuous- and discrete-time affine systems,
continuous-time linear systems with disturbances and switched systems,
whose dynamics changes at known times. The reach set computation for
hybrid systems whose guards are hyperplanes or polyhedra is not
implemented explicitly, but the tool for such computation exists,
namely, the operations of intersection of ellipsoid with hyperplane and
ellipsoid with halfspace.

Acknowledgement
===============

The authors would like to thank Alexander B. Kurzhanski, Manfred Morari,
Johan Löfberg, Michal Kvasnica and Goran Frehse for their support of
this work by useful advice and encouragement.

Function Reference
==================

ellipsoid
---------

::

    CALCGRID - computes grid of 2d or 3d sphere and vertices for each face
               in the grid with number of points taken from ellObj
               nPlot2dPoints or nPlot3dPoints parameters

::

    CHECKISME - determine whether input object is ellipsoid. And display
                message and abort function if input object
                is not ellipsoid

    Input:
      regular:
          someObjArr: any[] - any type array of objects.

    Example:
      ellObj = ellipsoid([1; 2], eye(2));
      ellipsoid.checkIsMe(ellObj)

::

    Ellipsoid library of the Ellipsoidal Toolbox.


    Constructor and data accessing functions:
    -----------------------------------------
     ellipsoid    - Constructor of ellipsoid object.
     double       - Returns parameters of ellipsoid, i.e. center and shape
                    matrix.
     parameters   - Same function as 'double'(legacy matter).
     dimension    - Returns dimension of ellipsoid and its rank.
     isdegenerate - Checks if ellipsoid is degenerate.
     isempty      - Checks if ellipsoid is empty.
     maxeig       - Returns the biggest eigenvalue of the ellipsoid.
     mineig       - Returns the smallest eigenvalue of the ellipsoid.
     trace        - Returns the trace of the ellipsoid.
     volume       - Returns the volume of the ellipsoid.


    Overloaded operators and functions:
    -----------------------------------
     eq      - Checks if two ellipsoids are equal.
     ne      - The opposite of 'eq'.
     gt, ge  - E1 > E2 (E1 >= E2) checks if, given the same center ellipsoid
               E1 contains E2.
     lt, le  - E1 < E2 (E1 <= E2) checks if, given the same center ellipsoid
               E2 contains E1.
     mtimes  - Given matrix A in R^(mxn) and ellipsoid E in R^n, returns
               (A * E).
     plus    - Given vector b in R^n and ellipsoid E in R^n, returns (E + b).
     minus   - Given vector b in R^n and ellipsoid E in R^n, returns (E - b).
     uminus  - Changes the sign of the center of ellipsoid.
     display - Displays the details about given ellipsoid object.
     inv     - inverts the shape matrix of the ellipsoid.
     plot    - Plots ellipsoid in 1D, 2D and 3D.


    Geometry functions:
    -------------------
     move2origin        - Moves the center of ellipsoid to the origin.
     shape              - Same as 'mtimes', but modifies only shape matrix of
                          the ellipsoid leaving its center as is.
     rho                - Computes the value of support function and
                          corresponding boundary point of the ellipsoid in
                          the given direction.
     polar              - Computes the polar ellipsoid to an ellipsoid that
                          contains the origin.
     projection         - Projects the ellipsoid onto a subspace specified
                          by  orthogonal basis vectors.
     minksum            - Computes and plots the geometric (Minkowski) sum of
                          given ellipsoids in 1D, 2D and 3D.
     minksum_ea         - Computes the external ellipsoidal approximation of
                          geometric sum of given ellipsoids in given
                          direction.
     minksum_ia         - Computes the internal ellipsoidal approximation of
                          geometric sum of given ellipsoids in given
                          direction.
     minkdiff           - Computes and plots the geometric (Minkowski)
                          difference of given ellipsoids in 1D, 2D and 3D.
     minkdiff_ea        - Computes the external ellipsoidal approximation of
                          geometric difference of two ellipsoids in given
                          direction.
     minkdiff_ia        - Computes the internal ellipsoidal approximation of
                          geometric difference of two ellipsoids in given
                          direction
     minkpm             - Computes and plots the geometric (Minkowski)
                          difference of a geometric sum of ellipsoids and a
                          single ellipsoid in 1D, 2D and 3D.
     minkpm_ea          - Computes the external ellipsoidal approximation of
                          the geometric difference of a geometric sum of
                          ellipsoids and a single ellipsoid in given
                          direction.
     minkpm_ia          - Computes the internal ellipsoidal approximation of
                          the geometric difference of a geometric sum of
                          ellipsoids and a single ellipsoid in given
                          direction.
     minkmp             - Computes and plots the geometric (Minkowski) sum of
                          a geometric difference of two single ellipsoids and
                          a geometric sum of ellipsoids in 1D, 2D and 3D.
     minkmp_ea          - Computes the external ellipsoidal approximation of
                          the geometric sum of a geometric difference of two
                          single ellipsoids and a geometric sum of ellipsoids
                          in given direction.
     minkmp_ia          -  Computes the internal ellipsoidal approximation of
                          the geometric sum of a geometric difference of
                          two single ellipsoids and a geometric sum of ellipsoids
                          in given direction.
     isbaddirection     - Checks if ellipsoidal approximation of geometric difference
                          of two ellipsoids in the given direction can be computed.
     doesIntersectionContain           - Checks if the union or intersection of
                          ellipsoids or polytopes lies inside the intersection
                          of given ellipsoids.
     isinternal         - Checks if given vector belongs to the union or intersection
                          of given ellipsoids.
     distance           - Computes the distance from ellipsoid to given point,
                          ellipsoid, hyperplane or polytope.
     intersect          - Checks if the union or intersection of ellipsoids intersects
                          with given ellipsoid, hyperplane, or polytope.
     intersection_ea    - Computes the minimal volume ellipsoid containing intersection
                          of two ellipsoids, ellipsoid and halfspace, or ellipsoid
                          and polytope.
     intersection_ia    - Computes the maximal ellipsoid contained inside the
                          intersection of two ellipsoids, ellipsoid and halfspace
                          or ellipsoid and polytope.
     ellintersection_ia - Computes maximum volume ellipsoid that is contained
                          in the intersection of given ellipsoids (can be more than 2).
     ellunion_ea        - Computes minimum volume ellipsoid that contains
                          the union of given ellipsoids.
     hpintersection     - Computes the intersection of ellipsoid with hyperplane.

::

    DIMENSION - returns the dimension of the space in which the ellipsoid is
                defined and the actual dimension of the ellipsoid.

    Input:
      regular:
        myEllArr: ellipsoid[nDims1,nDims2,...,nDimsN] - array of ellipsoids.

    Output:
      regular:
        dimArr: double[nDims1,nDims2,...,nDimsN] - space dimensions.

      optional:
        rankArr: double[nDims1,nDims2,...,nDimsN] - dimensions of the
               ellipsoids in myEllArr.

    Example:
      firstEllObj = ellipsoid();
      tempMatObj = [3 1; 0 1; -2 1];
      secEllObj = ellipsoid([1; -1; 1], tempMatObj*tempMatObj');
      thirdEllObj = ellipsoid(eye(2));
      fourthEllObj = ellipsoid(0);
      ellMat = [firstEllObj secEllObj; thirdEllObj fourthEllObj];
      [dimMat, rankMat] = ellMat.dimension()

      dimMat =

         0     3
         2     1

      rankMat =

         0     2
         2     0

::

    DISP - Displays ellipsoid object.

    Input:
      regular:
        myEllMat: ellipsoid [mRows, nCols] - matrix of ellipsoids.

    Example:
      ellObj = ellipsoid([-2; -1], [2 -1; -1 1]);
      disp(ellObj)

      Ellipsoid with parameters
      Center:
          -2
          -1

      Shape Matrix:
           2    -1
          -1     1

::

    DISPLAY - Displays the details of the ellipsoid object.

    Input:
      regular:
          myEllMat: ellipsoid [mRows, nCols] - matrix of ellipsoids.

    Example:
      ellObj = ellipsoid([-2; -1], [2 -1; -1 1]);
      display(ellObj)

      ellObj =

      Center:
          -2
          -1

      Shape Matrix:
           2    -1
          -1     1

      Nondegenerate ellipsoid in R^2.

::

    DISTANCE - computes distance between the given ellipsoid (or array of
               ellipsoids) to the specified object (or arrays of objects):
               vector, ellipsoid, hyperplane or polytope.

    Input:
      regular:
          ellObjArr: ellipsoid [nDims1, nDims2,..., nDimsN] -  array of
             ellipsoids of the same dimension.
          objArray: double / ellipsoid / hyperplane / polytope [nDims1,
              nDims2,..., nDimsN] - array of vectors or ellipsoids or
              hyperplanes or polytopes. If number of elements in objArray
              is more than 1, then it must be equal to the number of elements
              in ellObjArr.

      optional:
          isFlagOn: logical[1,1] - if true then distance is  computed in
              ellipsoidal metric, if false - in Euclidean metric (by default
              isFlagOn=false).

    Output:
      regular:
        distValArray: double [nDims1, nDims2,..., nDimsN] - array of pairwise
              calculated distances.
              Negative distance value means
                  for ellipsoid and vector: vector belongs to the ellipsoid,
                  for ellipsoid and hyperplane: ellipsoid intersects the
                      hyperplane.
                  Zero distance value means for ellipsoid and vector: vector
                      is aboundary point of the ellipsoid,
                  for ellipsoid and hyperplane: ellipsoid  touches the
                      hyperplane.
      optional:
          statusArray: double [nDims1, nDims2,..., nDimsN] - array of time of
              computation of ellipsoids-vectors or ellipsoids-ellipsoids
              distances, or status of cvx solver for ellipsoids-polytopes
              distances.

    Literature:
     1. Lin, A. and Han, S. On the Distance between Two Ellipsoids.
        SIAM Journal on Optimization, 2002, Vol. 13, No. 1 : pp. 298-308
     2. Stanley Chan, "Numerical method for Finding Minimum Distance to an
        Ellipsoid".
        http://videoprocessing.ucsd.edu/~stanleychan/publication/...
        unpublished/Ellipse.pdf

    Example:
      ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      tempMat = [1 1; 1 -1; -1 1; -1 -1]';
      distVec = ellObj.distance(tempMat)

      distVec =

           2.3428    1.0855    1.3799    -1.0000

::

    DOESCONTAIN - checks if one ellipsoid contains the other ellipsoid or
                  polytope. The condition for E1 = firstEllArr to contain
                  E2 = secondEllArr is
                  min(rho(l | E1) - rho(l | E2)) > 0, subject to <l, l> = 1.
                  How checked if ellipsoid contains polytope is explained in
                  doesContainPoly.
    Input:
      regular:
          firstEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - first
              array of ellipsoids.
          secondObjArr: ellipsoid [nDims1,nDims2,...,nDimsN]/
              polytope[nDims1,nDims2,...,nDimsN]/[1,1] - array of the same
              size as firstEllArr or single ellipsoid or polytope.

       properties:
          mode: char[1, 1] - 'u' or 'i', go to description.
          computeMode: char[1,] - 'highDimFast' or 'lowDimFast'. Determines,
              which way function is computed, when secObjArr is polytope. If
              secObjArr is ellipsoid computeMode is ignored. 'highDimFast'
              works  faster for  high dimensions, 'lowDimFast' for low. If
              this property is omitted if dimension of ellipsoids is greater
              then 10, then 'hightDimFast' is choosen, otherwise -
              'lowDimFast'

    Output:
      isPosArr: logical[nDims1,nDims2,...,nDimsN],
          resArr(iCount) = true - firstEllArr(iCount)
          contains secondObjArr(iCount), false - otherwise.

    Example:
      firstEllObj = ellipsoid([-2; -1], [2 -1; -1 1]);
      secEllObj = ellipsoid([-1;0], eye(2));
      doesContain(firstEllObj,secEllObj)

      ans =

           0

::

    DOESINTERSECTIONCONTAIN - checks if the intersection of ellipsoids
                              contains the union or intersection of given
                              ellipsoids or polytopes.

      res = DOESINTERSECTIONCONTAIN(fstEllArr, secEllArr, mode)
          Checks if the union
          (mode = 'u') or intersection (mode = 'i') of ellipsoids in
          secEllArr lies inside the intersection of ellipsoids in
          fstEllArr. Ellipsoids in fstEllArr and secEllArr must be
          of the same dimension. mode = 'u' (default) - union of
          ellipsoids in secEllArr. mode = 'i' - intersection.
      res = DOESINTERSECTIONCONTAIN(fstEllArr, secPolyArr, mode)
           Checks if the union
          (mode = 'u') or intersection (mode = 'i')  of polytopes in
          secPolyArr lies inside the intersection of ellipsoids in
          fstEllArr. Ellipsoids in fstEllArr and polytopes in secPolyArr
          must be of the same dimension. mode = 'u' (default) - union of
          polytopes in secPolyMat. mode = 'i' - intersection.

      To check if the union of ellipsoids secEllArr belongs to the
      intersection of ellipsoids fstEllArr, it is enough to check that
      every ellipsoid of secEllMat is contained in every
      ellipsoid of fstEllArr.
      Checking if the intersection of ellipsoids in secEllMat is inside
      intersection fstEllMat can be formulated as quadratically
      constrained quadratic programming (QCQP) problem.

      Let fstEllArr(iEll) = E(q, Q) be an ellipsoid with center q and shape
      matrix Q. To check if this ellipsoid contains the intersection of
      ellipsoids in secObjArr:
      E(q1, Q1), E(q2, Q2), ..., E(qn, Qn), we define the QCQP problem:
                        J(x) = <(x - q), Q^(-1)(x - q)> --> max
      with constraints:
                        <(x - q1), Q1^(-1)(x - q1)> <= 1   (1)
                        <(x - q2), Q2^(-1)(x - q2)> <= 1   (2)
                        ................................
                        <(x - qn), Qn^(-1)(x - qn)> <= 1   (n)

      If this problem is feasible, i.e. inequalities (1)-(n) do not
      contradict, or, in other words, intersection of ellipsoids
      E(q1, Q1), E(q2, Q2), ..., E(qn, Qn) is nonempty, then we can find
      vector y such that it satisfies inequalities (1)-(n)
      and maximizes function J. If J(y) <= 1, then ellipsoid E(q, Q)
      contains the given intersection, otherwise, it does not.

      The intersection of polytopes is a polytope, which is computed
      by the standard routine of MPT. How checked if intersection of
      ellipsoids contains polytope is explained in doesContainPoly.

      Checking if the union of polytopes belongs to the intersection
      of ellipsoids is the same as checking if its convex hull belongs
      to this intersection.

    Input:
      regular:
          fstEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
              of the same size.
          secEllArr: ellipsoid /
              polytope [nDims1,nDims2,...,nDimsN] - array of ellipsoids or
              polytopes of the same sizes.

              note: if mode == 'i', then fstEllArr, secEllVec should be
                  array.

      properties:
          mode: char[1, 1] - 'u' or 'i', go to description.
          computeMode: char[1,] - 'highDimFast' or 'lowDimFast'. Determines,
              which way function is computed, when secObjArr is polytope. If
              secObjArr is ellipsoid computeMode is ignored. 'highDimFast'
              works  faster for  high dimensions, 'lowDimFast' for low. If
              this property is omitted if dimension of ellipsoids is greater
              then 10, then 'hightDimFast' is choosen, otherwise -
              'lowDimFast'


    Output:
      res: double[1, 1] - result:
          -1 - problem is infeasible, for example, if s = 'i',
              but the intersection of ellipsoids in E2 is an empty set;
          0 - intersection is empty;
          1 - if intersection is nonempty.
      status: double[0, 0]/double[1, 1] - status variable. status is empty
          if mode == 'u' or mSecRows == nSecCols == 1.

    Example:
      firstEllObj = [0 ; 0] + ellipsoid(eye(2, 2));
      secEllObj = [0 ; 0] + ellipsoid(2*eye(2, 2));
      thirdEllObj = [1; 0] + ellipsoid(0.5 * eye(2, 2));
      secEllObj.doesIntersectionContain([firstEllObj secEllObj], 'i')

      ans =

           1

::

    DOUBLE - returns parameters of the ellipsoid.

    Input:
      regular:
          myEll: ellipsoid [1, 1] - single ellipsoid of dimention nDims.


    Output:
      myEllCentVec: double[nDims, 1] - center of the ellipsoid myEll.

      myEllShMat: double[nDims, nDims] - shape matrix of the ellipsoid myEll.

    Example:
      ellObj = ellipsoid([-2; -1], [2 -1; -1 1]);
      [centVec, shapeMat] = double(ellObj)
      centVec =

          -2
          -1


      shapeMat =

           2    -1
          -1     1

::

    ELLBNDR_2D - compute the boundary of 2D ellipsoid. Private method.

    Input:
      regular:
          myEll: ellipsoid [1, 1]- ellipsoid of the dimention 2.
      optional:
          nPoints: number of boundary points

    Output:
      regular:
          bpMat: double[nPoints,2] - boundary points of ellipsoid
      optional:
          fVec: double[1,nFaces] - indices of points in each face of
              bpMat graph

::

    ELLBNDR_3D - compute the boundary of 3D ellipsoid.

    Input:
      regular:
          myEll: ellipsoid [1, 1]- ellipsoid of the dimention 3.

      optional:
          nPoints: number of boundary points

    Output:
      regular:
          bpMat: double[nPoints,3] - boundary points of ellipsoid
      optional:
          fMat: double[nFaces,3] - indices of face verties in bpMat

::

    ELLINTERSECTION_IA - computes maximum volume ellipsoid that is contained
                         in the intersection of given ellipsoids.


    Input:
      regular:
          inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
              ellipsoids of the same dimentions.

    Output:
      outEll: ellipsoid [1, 1] - resulting maximum volume ellipsoid.

    Example:
      firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
      secEllObj = ellipsoid([1 2], eye(2);
      ellVec = [firstEllObj secEllObj];
      resEllObj = ellintersection_ia(ellVec)

      resEllObj =

      Center:
          0.1847
          1.6914

      Shape Matrix:
          0.0340   -0.0607
         -0.0607    0.1713

      Nondegenerate ellipsoid in R^2.

::

    ELLIPSOID - constructor of the ellipsoid object.

      Ellipsoid E = { x in R^n : <(x - q), Q^(-1)(x - q)> <= 1 }, with current
          "Properties". Here q is a vector in R^n, and Q in R^(nxn) is positive
          semi-definite matrix

      ell = ELLIPSOID - Creates an empty ellipsoid

      ell = ELLIPSOID(shMat) - creates an ellipsoid with shape matrix shMat,
          centered at 0

       ell = ELLIPSOID(centVec, shMat) - creates an ellipsoid with shape matrix
          shMat and center centVec

      ell = ELLIPSOID(centVec, shMat, 'propName1', propVal1,...,
          'propNameN',propValN) - creates an ellipsoid with shape
          matrix shMat, center centVec and propName1 = propVal1,...,
          propNameN = propValN. In other cases "Properties"
          are taken from current values stored in
          elltool.conf.Properties.
      ellMat = Ellipsoid(centVecArray, shMatArray,
          ['propName1', propVal1,...,'propNameN',propValN]) -
          creates an array (possibly multidimensional) of
          ellipsoids with centers centVecArray(:,dim1,...,dimn)
          and matrices shMatArray(:,:,dim1,...dimn) with
          properties if given.

      These parameters can be accessed by DOUBLE(E) function call.
      Also, DIMENSION(E) function call returns the dimension of
      the space in which ellipsoid E is defined and the actual
      dimension of the ellipsoid; function ISEMPTY(E) checks if
      ellipsoid E is empty; function ISDEGENERATE(E) checks if
      ellipsoid E is degenerate.

    Input:
      Case1:
        regular:
          shMatArray: double [nDim, nDim] /
              double [nDim, nDim, nDim1,...,nDimn] -
              shape matrices array

      Case2:
        regular:
          centVecArray: double [nDim,1] /
              double [nDim, 1, nDim1,...,nDimn] -
              centers array
          shMatArray: double [nDim, nDim] /
              double [nDim, nDim, nDim1,...,nDimn] -
              shape matrices array


      properties:
          absTol: double [1,1] - absolute tolerance with default value 10^(-7)
          relTol: double [1,1] - relative tolerance with default value 10^(-5)
          nPlot2dPoints: double [1,1] - number of points for 2D plot with
              default value 200
          nPlot3dPoints: double [1,1] - number of points for 3D plot with
               default value 200.

    Output:
      ellMat: ellipsoid [1,1] / ellipsoid [nDim1,...nDimn] -
          ellipsoid with specified properties
          or multidimensional array of ellipsoids.

    Example:
      ellObj = ellipsoid([1 0 -1 6]', 9*eye(4));

::

    ELLUNION_EA - computes minimum volume ellipsoid that contains union
                  of given ellipsoids.

    Input:
      regular:
          inpEllMat: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
              ellipsoids of the same dimentions.

    Output:
      outEll: ellipsoid [1, 1] - resulting minimum volume ellipsoid.

    Example:
      firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
      secEllObj = ellipsoid([1 2], eye(2));
      ellVec = [firstEllObj secEllObj];
      resEllObj = ellunion_ea(ellVec)
      resEllObj =

      Center:
         -0.3188
          1.2936

      Shape Matrix:
          5.4573    1.3386
          1.3386    4.1037

      Nondegenerate ellipsoid in R^2.

::

    FROMREPMAT - returns array of equal ellipsoids the same
                 size as stated in sizeVec argument

      ellArr = fromRepMat(sizeVec) - creates an array  size
               sizeVec of empty ellipsoids.

      ellArr = fromRepMat(shMat,sizeVec) - creates an array
               size sizeVec of ellipsoids with shape matrix
               shMat.

      ellArr = fromRepMat(cVec,shMat,sizeVec) - creates an
               array size sizeVec of ellipsoids with shape
               matrix shMat and center cVec.

    Input:
      Case1:
          regular:
              sizeVec: double[1,n] - vector of size, have
              integer values.

      Case2:
          regular:
              shMat: double[nDim, nDim] - shape matrix of
              ellipsoids.
              sizeVec: double[1,n] - vector of size, have
              integer values.

      Case3:
          regular:
              cVec: double[nDim,1] - center vector of
              ellipsoids
              shMat: double[nDim, nDim] - shape matrix of
              ellipsoids.
              sizeVec: double[1,n] - vector of size, have
              integer values.

      properties:
          absTol: double [1,1] - absolute tolerance with default
              value 10^(-7)
          relTol: double [1,1] - relative tolerance with default
              value 10^(-5)
          nPlot2dPoints: double [1,1] - number of points for 2D plot
              with default value 200
          nPlot3dPoints: double [1,1] - number of points for 3D plot
              with default value 200.

::

    fromStruct -- converts structure array into ellipsoid array.

    Input:
      regular:
          SEllArr: struct [nDim1, nDim2, ...] - array
              of structures with the following fields:

          q: double[1, nEllDim] - the center of ellipsoid
          Q: double[nEllDim, nEllDim] - the shape matrix of ellipsoid
    Output:
          ellArr: ellipsoid [nDim1, nDim2, ...] - ellipsoid array with size of
              SEllArr.

    Example:
    s = struct('Q', eye(2), 'q', [0 0]);
    ellipsoid.fromStruct(s)

    -------ellipsoid object-------
    Properties:
       |
       |-- actualClass : 'ellipsoid'
       |--------- size : [1, 1]

    Fields (name, type, description):
        'Q'    'double'    'Configuration matrix'
        'q'    'double'    'Center'

    Data:
       |
       |-- q : [0 0]
       |       -----
       |-- Q : |1|0|
       |       |0|1|
       |       -----

::

    GETABSTOL - gives the array of absTol for all elements in ellArr

    Input:
      regular:
          ellArr: ellipsoid[nDim1, nDim2, ...] - multidimension array
              of ellipsoids
      optional
          fAbsTolFun: function_handle[1,1] - function that apply
              to the absTolArr. The default is @min.

    Output:
      regular:
          absTolArr: double [absTol1, absTol2, ...] - return absTol for
              each element in ellArr
      optional:
          absTol: double[1,1] - return result of work fAbsTolFun with
              the absTolArr

    Usage:
      use [~,absTol] = ellArr.getAbsTol() if you want get only
          absTol,
      use [absTolArr,absTol] = ellArr.getAbsTol() if you want get
          absTolArr and absTol,
      use absTolArr = ellArr.getAbsTol() if you want get only absTolArr

    Example:
      firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
      secEllObj = ellipsoid([1 2], eye(2));
      ellVec = [firstEllObj secEllObj];
      absTolVec = ellVec.getAbsTol()

      absTolVec =

         1.0e-07 *

          1.0000    1.0000

::

    GETBOUNDARY - computes the boundary of an ellipsoid.

    Input:
      regular:
          myEll: ellipsoid [1, 1]- ellipsoid of the dimention 2 or 3.
      optional:
          nPoints: number of boundary points

    Output:
      regular:
          bpMat: double[nPoints,nDim] - boundary points of ellipsoid
      optional:
          fVec: double[1,nFaces]/double[nFacex,nDim] - indices of points in
              each face of bpMat graph

::

      GETBOUNDARYBYFACTOR - computes grid of 2d or 3d ellipsoid and vertices
                            for each face in the grid

::

    GETCENTERVEC - returns centerVec vector of given ellipsoid

    Input:
      regular:
         self: ellipsoid[1,1]

    Output:
      centerVecVec: double[nDims,1] - centerVec of ellipsoid

    Example:
      ellObj = ellipsoid([1; 2], eye(2));
      getCenterVec(ellObj)

      ans =

           1
           2

::

    GETCOPY - gives array the same size as ellArr with copies of elements of
              ellArr.

    Input:
      regular:
          ellArr: ellipsoid[nDim1, nDim2,...] - multidimensional array of
              ellipsoids.

    Output:
      copyEllArr: ellipsoid[nDim1, nDim2,...] - multidimension array of
          copies of elements of ellArr.

    Example:
      firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
      secEllObj = ellipsoid([1; 2], eye(2));
      ellVec = [firstEllObj secEllObj];
      copyEllVec = getCopy(ellVec)

      copyEllVec =
      1x2 array of ellipsoids.

::

    GETINV - do the same as INV method: inverts shape matrices of ellipsoids
          in the given array, with only difference, that it doesn't modify
          input array of ellipsoids.

    Input:
      regular:
        myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids.

    Output:
       invEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          with inverted shape matrices.

    Example:
      ellObj = ellipsoid([1; 1], [4 -1; -1 5]);
      invEllObj = ellObj.getInv()

      invEllObj =

      Center:
           1
           1

      Shape Matrix:
          0.2632    0.0526
          0.0526    0.2105

      Nondegenerate ellipsoid in R^2.

::

    GETMOVE2ORIGIN - do the same as MOVE2ORIGIN method: moves ellipsoids in
          the given array to the origin, with only difference, that it doesn't
          modify input array of ellipsoids.

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
              ellipsoids.

    Output:
      outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          with the same shapes as in inpEllArr centered at the origin.

    Example:
      ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      outEllObj = ellObj.getMove2Origin()

      outEllObj =

      Center:
           0
           0

      Shape:
           4    -1
          -1     1

      Nondegenerate ellipsoid in R^2.

::

    GETNPLOT2DPOINTS - gives value of nPlot2dPoints property of ellipsoids
                       in ellArr

    Input:
      regular:
          ellArr: ellipsoid[nDim1, nDim2,...] - mltidimensional array of
              ellipsoids

    Output:
          nPlot2dPointsArr: double[nDim1, nDim2,...] - multidimension array
              of nPlot2dPoints property for ellipsoids in ellArr
    Example:
      firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
      secEllObj = ellipsoid([1 ;2], eye(2));
      ellVec = [firstEllObj secEllObj];
      ellVec.getNPlot2dPoints()

      ans =

         200   200

::

    GETNPLOT3DPOINTS - gives value of nPlot3dPoints property of ellipsoids
                       in ellArr

    Input:
      regular:
          ellArr: ellipsoid[nDim1, nDim2,...] - mltidimensional array  of
             ellipsoids

    Output:
          nPlot2dPointsArr: double[nDim1, nDim2,...] - multidimension array
              of nPlot3dPoints property for ellipsoids in ellArr

    Example:
      firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
      secEllObj = ellipsoid([1 ;2], eye(2));
      ellVec = [firstEllObj secEllObj];
      ellVec.getNPlot3dPoints()

      ans =

         200   200

::

    GETPROJECTION - do the same as PROJECTION method: computes projection of
          the ellipsoid onto the given subspace, with only difference, that
          it doesn't modify input array of ellipsoids.

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.
          basisMat: double[nDim, nSubSpDim] - matrix of orthogonal basis
              vectors

    Output:
      projEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
          projected ellipsoids, generally, of lower dimension.

    Example:
      ellObj = ellipsoid([-2; -1; 4], [4 -1 0; -1 1 0; 0 0 9]);
      basisMat = [0 1 0; 0 0 1]';
      outEllObj = ellObj.getProjection(basisMat)

      outEllObj =

      Center:
          -1
           4

      Shape:
          1     0
          0     9

      Nondegenerate ellipsoid in R^2.

::

    GETRELTOL - gives the array of relTol for all elements in ellArr

    Input:
      regular:
          ellArr: ellipsoid[nDim1, nDim2, ...] - multidimension array
              of ellipsoids
      optional:
          fRelTolFun: function_handle[1,1] - function that apply
              to the relTolArr. The default is @min.
    Output:
      regular:
          relTolArr: double [relTol1, relTol2, ...] - return relTol for
              each element in ellArr
      optional:
          relTol: double[1,1] - return result of work fRelTolFun with
              the relTolArr

    Usage:
      use [~,relTol] = ellArr.getRelTol() if you want get only
          relTol,
      use [relTolArr,relTol] = ellArr.getRelTol() if you want get
          relTolArr and relTol,
      use relTolArr = ellArr.getRelTol() if you want get only relTolArr

    Example:
      firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
      secEllObj = ellipsoid([1 ;2], eye(2));
      ellVec = [firstEllObj secEllObj];
      ellVec.getRelTol()

      ans =

         1.0e-05 *

          1.0000    1.0000

::

    GETSHAPE -  do the same as SHAPE method: modifies the shape matrix of the
       ellipsoid without changing its center, with only difference, that
       it doesn't modify input array of ellipsoids.

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.
          modMat: double[nDim, nDim]/[1,1] - square matrix or scalar

    Output:
       outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of modified
          ellipsoids.

    Example:
      ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      tempMat = [0 1; -1 0];
      outEllObj = ellObj.getShape(tempMat)

      outEllObj =

      Center:
          -2
          -1

      Shape:
          1     1
          1     4

      Nondegenerate ellipsoid in R^2.

::

    GETSHAPEMAT - returns shapeMat matrix of given ellipsoid

    Input:
      regular:
         self: ellipsoid[1,1]

    Output:
      shMat: double[nDims,nDims] - shapeMat matrix of ellipsoid

    Example:
      ellObj = ellipsoid([1; 2], eye(2));
      getShapeMat(ellObj)

      ans =

           1     0
           0     1

::

    HPINTERSECTION - computes the intersection of ellipsoid with hyperplane.

    Input:
      regular:
          myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
              of ellipsoids.
          myHypArr: hyperplane [nDims1,nDims2,...,nDimsN]/[1,1] - array
              of hyperplanes of the same size.

    Output:
      intEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          resulting from intersections.

      isnIntersectedArr: logical [nDims1,nDims2,...,nDimsN].
          isnIntersectedArr(iCount) = true, if myEllArr(iCount)
          doesn't intersect myHipArr(iCount),
          isnIntersectedArr(iCount) = false, otherwise.

    Example:
      ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      hypMat = [hyperplane([0 -1; -1 0]', 1); hyperplane([0 -2; -1 0]', 1)];
      ellMat = ellObj.hpintersection(hypMat)

      ellMat =
      2x2 array of ellipsoids.

::

    INTERSECT - checks if the union or intersection of ellipsoids intersects
                given ellipsoid, hyperplane or polytope.

      resArr = INTERSECT(myEllArr, objArr, mode) - Checks if the union
          (mode = 'u') or intersection (mode = 'i') of ellipsoids
          in myEllArr intersects with objects in objArr.
          objArr can be array of ellipsoids, array of hyperplanes,
          or array of polytopes.
          Ellipsoids, hyperplanes or polytopes in objMat must have
          the same dimension as ellipsoids in myEllArr.
          mode = 'u' (default) - union of ellipsoids in myEllArr.
          mode = 'i' - intersection.

      If we need to check the intersection of union of ellipsoids in
      myEllArr (mode = 'u'), or if myEllMat is a single ellipsoid,
      it can be done by calling distance function for each of the
      ellipsoids in myEllArr and objMat, and if it returns negative value,
      the intersection is nonempty. Checking if the intersection of
      ellipsoids in myEllArr (with size of myEllMat greater than 1)
      intersects with ellipsoids or hyperplanes in objArr is more
      difficult. This problem can be formulated as quadratically
      constrained quadratic programming (QCQP) problem.

      Let objArr(iObj) = E(q, Q) be an ellipsoid with center q and shape
      matrix Q. To check if this ellipsoid intersects (or touches) the
      intersection of ellipsoids in meEllArr: E(q1, Q1), E(q2, Q2), ...,
      E(qn, Qn), we define the QCQP problem:
                        J(x) = <(x - q), Q^(-1)(x - q)> --> min
      with constraints:
                         <(x - q1), Q1^(-1)(x - q1)> <= 1   (1)
                         <(x - q2), Q2^(-1)(x - q2)> <= 1   (2)
                         ................................
                         <(x - qn), Qn^(-1)(x - qn)> <= 1   (n)

      If this problem is feasible, i.e. inequalities (1)-(n) do not
      contradict, or, in other words, intersection of ellipsoids
      E(q1, Q1), E(q2, Q2), ..., E(qn, Qn) is nonempty, then we can find
      vector y such that it satisfies inequalities (1)-(n) and minimizes
      function J. If J(y) <= 1, then ellipsoid E(q, Q) intersects or touches
      the given intersection, otherwise, it does not. To check if E(q, Q)
      intersects the union of E(q1, Q1), E(q2, Q2), ..., E(qn, Qn),
      we compute the distances from this ellipsoids to those in the union.
      If at least one such distance is negative,
      then E(q, Q) does intersect the union.

      If we check the intersection of ellipsoids with hyperplane
      objArr = H(v, c), it is enough to check the feasibility
      of the problem
                          1'x --> min
      with constraints (1)-(n), plus
                        <v, x> - c = 0.

      Checking the intersection of ellipsoids with polytope
      objArr = P(A, b) reduces to checking if there any x, satisfying
      constraints (1)-(n) and
                           Ax <= b.

    Input:
      regular:
          myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
               ellipsoids.
          objArr: ellipsoid / hyperplane /
              / polytope [nDims1,nDims2,...,nDimsN] - array of ellipsoids or
              hyperplanes or polytopes of the same sizes.

      optional:
          mode: char[1, 1] - 'u' or 'i', go to description.

              note: If mode == 'u', then mRows, nCols should be equal to 1.

    Output:
      resArr: double[nDims1,nDims2,...,nDimsN] - return:
          resArr(iCount) = -1 in case parameter mode is set
              to 'i' and the intersection of ellipsoids in myEllArr
              is empty.
          resArr(iCount) = 0 if the union or intersection of
              ellipsoids in myEllArr does not intersect the object
              in objArr(iCount).
          resArr(iCount) = 1 if the union or intersection of
              ellipsoids in myEllArr and the object in objArr(iCount)
              have nonempty intersection.
      statusArr: double[0, 0]/double[nDims1,nDims2,...,nDimsN] - status
          variable. statusArr is empty if mode = 'u'.

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = firstEllObj + [5; 5];
      hypObj  = hyperplane([1; -1]);
      ellVec = [firstEllObj secEllObj];
      ellVec.intersect(hypObj)

      ans =

           1

      ellVec.intersect(hypObj, 'i')

      ans =

          -1

::

    INTERSECTION_EA - external ellipsoidal approximation of the
                      intersection of two ellipsoids, or ellipsoid and
                      halfspace, or ellipsoid and polytope.

      outEllArr = INTERSECTION_EA(myEllArr, objArr) Given two ellipsoidal
          matrixes of equal sizes, myEllArr and objArr = ellArr, or,
          alternatively, myEllArr or ellMat must be a single ellipsoid,
          computes the ellipsoid that contains the intersection of two
          corresponding ellipsoids from myEllArr and from ellArr.
      outEllArr = INTERSECTION_EA(myEllArr, objArr) Given matrix of
          ellipsoids myEllArr and matrix of hyperplanes objArr = hypArr
          whose sizes match, computes the external ellipsoidal
          approximations of intersections of ellipsoids
          and halfspaces defined by hyperplanes in hypArr.
          If v is normal vector of hyperplane and c - shift,
          then this hyperplane defines halfspace
                  <v, x> <= c.
      outEllArr = INTERSECTION_EA(myEllArr, objArr) Given matrix of
          ellipsoids myEllArr and matrix of polytopes objArr = polyArr
          whose sizes match, computes the external ellipsoidal
          approximations of intersections of ellipsoids myEllMat and
          polytopes polyArr.

      The method used to compute the minimal volume overapproximating
      ellipsoid is described in "Ellipsoidal Calculus Based on
      Propagation and Fusion" by Lluis Ros, Assumpta Sabater and
      Federico Thomas; IEEE Transactions on Systems, Man and Cybernetics,
      Vol.32, No.4, pp.430-442, 2002. For more information, visit
      http://www-iri.upc.es/people/ros/ellipsoids.html

      For polytopes this method won't give the minimal volume
      overapproximating ellipsoid, but just some overapproximating ellipsoid.

    Input:
      regular:
          myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
              of ellipsoids.
          objArr: ellipsoid / hyperplane /
              / polytope [nDims1,nDims2,...,nDimsN]/[1,1]  - array of
              ellipsoids or hyperplanes or polytopes of the same sizes.

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = firstEllObj + [5; 5];
      ellVec = [firstEllObj secEllObj];
      thirdEllObj  = ell_unitball(2);
      externalEllVec = ellVec.intersection_ea(thirdEllObj)

      externalEllVec =
      1x2 array of ellipsoids.

::

    INTERSECTION_IA - internal ellipsoidal approximation of the
                      intersection of ellipsoid and ellipsoid,
                      or ellipsoid and halfspace, or ellipsoid
                      and polytope.

      outEllArr = INTERSECTION_IA(myEllArr, objArr) - Given two
          ellipsoidal matrixes of equal sizes, myEllArr and
          objArr = ellArr, or, alternatively, myEllMat or ellMat must be
          a single ellipsoid, comuptes the internal ellipsoidal
          approximations of intersections of two corresponding ellipsoids
          from myEllMat and from ellMat.
      outEllArr = INTERSECTION_IA(myEllArr, objArr) - Given matrix of
          ellipsoids myEllArr and matrix of hyperplanes objArr = hypArr
          whose sizes match, computes the internal ellipsoidal
          approximations of intersections of ellipsoids and halfspaces
          defined by hyperplanes in hypMat.
          If v is normal vector of hyperplane and c - shift,
          then this hyperplane defines halfspace
                     <v, x> <= c.
      outEllArr = INTERSECTION_IA(myEllArr, objArr) - Given matrix of
          ellipsoids  myEllArr and matrix of polytopes objArr = polyArr
          whose sizes match, computes the internal ellipsoidal
          approximations of intersections of ellipsoids myEllArr
          and polytopes polyArr.

      The method used to compute the minimal volume overapproximating
      ellipsoid is described in "Ellipsoidal Calculus Based on
      Propagation and Fusion" by Lluis Ros, Assumpta Sabater and
      Federico Thomas; IEEE Transactions on Systems, Man and Cybernetics,
      Vol.32, No.4, pp.430-442, 2002. For more information, visit
      http://www-iri.upc.es/people/ros/ellipsoids.html

      The method used to compute maximum volume ellipsoid inscribed in
      intersection of ellipsoid and polytope, is modified version of
      algorithm of finding maximum volume ellipsoid inscribed in intersection
      of ellipsoids discribed in Stephen Boyd and Lieven Vandenberghe "Convex
      Optimization". It works properly for nondegenerate ellipsoid, but for
      degenerate ellipsoid result would not lie in this ellipsoid. The result
      considered as empty ellipsoid, when maximum absolute velue of element
      in its matrix is less than myEllipsoid.getAbsTol().

    Input:
      regular:
          myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
              of ellipsoids.
          objArr: ellipsoid / hyperplane /
              / polytope [nDims1,nDims2,...,nDimsN]/[1,1]  - array of
              ellipsoids or hyperplanes or polytopes of the same sizes.

    Output:
       outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of internal
          approximating ellipsoids; entries can be empty ellipsoids
          if the corresponding intersection is empty.

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = firstEllObj + [5; 5];
      ellVec = [firstEllObj secEllObj];
      thirdEllObj  = ell_unitball(2);
      internalEllVec = ellVec.intersection_ia(thirdEllObj)

      internalEllVec =
      1x2 array of ellipsoids.

::

    INV - inverts shape matrices of ellipsoids in the given array,
          modified given array is on output (not its copy).


      invEllArr = INV(myEllArr)  Inverts shape matrices of ellipsoids
          in the array myEllMat. In case shape matrix is sigular, it is
          regularized before inversion.

    Input:
      regular:
        myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids.

    Output:
       myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          with inverted shape matrices.

    Example:
      ellObj = ellipsoid([1; 1], [4 -1; -1 5]);
      ellObj.inv()

      ans =

      Center:
           1
           1

      Shape Matrix:
          0.2632    0.0526
          0.0526    0.2105

      Nondegenerate ellipsoid in R^2.

::

    ISEMPTY - checks if the ellipsoid object is empty.

    Input:
      regular:
          myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
               ellipsoids.

    Output:
      isPositiveArr: logical[nDims1,nDims2,...,nDimsN],
          isPositiveArr(iCount) = true - if ellipsoid
          myEllMat(iCount) is empty, false - otherwise.

    Example:
      ellObj = ellipsoid();
      isempty(ellObj)

      ans =

           1

::

    ISEQUAL - produces logical array the same size as
              ellFirstArr/ellFirstArr (if they have the same).
              isEqualArr[iDim1, iDim2,...] is true if corresponding
              ellipsoids are equal and false otherwise.

    Input:
      regular:
          ellFirstArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
              of ellipsoids.
          ellSecArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
              of ellipsoids.
      properties:
          'isPropIncluded': makes to compare second value properties, such as
          absTol etc.
    Output:
      isEqualArr: logical[nDim1, nDim2,...] - multidimension array of
          logical values. isEqualArr[iDim1, iDim2,...] is true if
          corresponding ellipsoids are equal and false otherwise.

      reportStr: char[1,] - comparison report.

::

    ISINSIDE - checks if given ellipsoid(or array of
               ellipsoids) lies inside given object(or array
               of objects): ellipsoid or polytope.

    Input:
      regular:
          ellArr: ellipsoid[nDims1,nDims2,...,nDimsN] - array
                  of ellipsoids of the same dimension.
          objArr: ellipsoid/
                  polytope[nDims1,nDims2,...,nDimsN] of
                  objects of the same dimension. If
                  ellArr and objArr both non-scalar, than
                  size of ellArr must be the same as size of
                  objArr. Note that polytopes could be
                  combined only in vector of size [1,N].
    Output:
      regular:
          resArr: logical[nDims1,nDims2,...,nDimsN] array of
                  results. resArr[iDim1,...,iDimN] = true, if
                  ellArr[iDim1,...,iDimN] lies inside
                  objArr[iDim1,...,iDimN].

    Example:
      firstEllObj = [0 ; 0] + ellipsoid(eye(2, 2));
      secEllObj = [0 ; 0] + ellipsoid(2*eye(2, 2));
      firstEllObj.isInside(secEllObj)

      ans =

           1

::

    ISBADDIRECTION - checks if ellipsoidal approximations of geometric
                     difference of two ellipsoids can be computed for
                     given directions.
      isBadDirVec = ISBADDIRECTION(fstEll, secEll, dirsMat) - Checks if
          it is possible to build ellipsoidal approximation of the
          geometric difference of two ellipsoids fstEll - secEll in
          directions specified by matrix dirsMat (columns of dirsMat
          are direction vectors). Type 'help minkdiff_ea' or
          'help minkdiff_ia' for more information.

    Input:
      regular:
          fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose nDim - space
              dimension.
          secEll: ellipsoid [1, 1] - second ellipsoid of the same dimention.
          dirsMat: numeric[nDims, nCols] - matrix whose columns are
              direction vectors that need to be checked.
          absTol: double [1,1] - absolute tolerance

    Output:
       isBadDirVec: logical[1, nCols] - array of true or false with length
          being equal to the number of columns in matrix dirsMat.
          ture marks direction vector as bad - ellipsoidal approximation
          true marks direction vector as bad - ellipsoidal approximation
          cannot be computed for this direction. false means the opposite.

::

    ISBIGGER - checks if one ellipsoid would contain the other if their
               centers would coincide.

      isPositive = ISBIGGER(fstEll, secEll) - Given two single ellipsoids
          of the same dimension, fstEll and secEll, check if fstEll
          would contain secEll inside if they were both
          centered at origin.

    Input:
      regular:
          fstEll: ellipsoid [1, 1] - first ellipsoid.
          secEll: ellipsoid [1, 1] - second ellipsoid
              of the same dimention.

    Output:
      isPositive: logical[1, 1], true - if ellipsoid fstEll
          would contain secEll inside, false - otherwise.

    Example:
      firstEllObj = ellipsoid([1; 1], eye(2));
      secEllObj = ellipsoid([1; 1], [4 -1; -1 5]);
      isbigger(firstEllObj, secEllObj)

      ans =

           0

::

    ISDEGENERATE - checks if the ellipsoid is degenerate.

    Input:
      regular:
          myEllArr: ellipsoid[nDims1,nDims2,...,nDimsN] - array of ellipsoids.

    Output:
      isPositiveArr: logical[nDims1,nDims2,...,nDimsN],
          isPositiveArr(iCount) = true if ellipsoid myEllMat(iCount)
          is degenerate, false - otherwise.

    Example:
      ellObj = ellipsoid([1; 1], eye(2));
      isdegenerate(ellObj)

      ans =

           0

::

    ISINTERNAL - checks if given points belong to the union or intersection
                 of ellipsoids in the given array.

      isPositiveVec = ISINTERNAL(myEllArr,  matrixOfVecMat, mode) - Checks
          if vectors specified as columns of matrix matrixOfVecMat
          belong to the union (mode = 'u'), or intersection (mode = 'i')
          of the ellipsoids in myEllArr. If myEllArr is a single
          ellipsoid, then this function checks if points in matrixOfVecMat
          belong to myEllArr or not. Ellipsoids in myEllArr must be
          of the same dimension. Column size of matrix  matrixOfVecMat
          should match the dimension of ellipsoids.

       Let myEllArr(iEll) = E(q, Q) be an ellipsoid with center q and shape
       matrix Q. Checking if given vector matrixOfVecMat = x belongs
       to E(q, Q) is equivalent to checking if inequality
                       <(x - q), Q^(-1)(x - q)> <= 1
       holds.
       If x belongs to at least one of the ellipsoids in the array, then it
       belongs to the union of these ellipsoids. If x belongs to all
       ellipsoids in the array,
       then it belongs to the intersection of these ellipsoids.
       The default value of the specifier s = 'u'.

       WARNING: be careful with degenerate ellipsoids.

    Input:
      regular:
          myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.
          matrixOfVecMat: double [mRows, nColsOfVec] - matrix which
              specifiy points.

      optional:
          mode: char[1, 1] - 'u' or 'i', go to description.

    Output:
       isPositiveVec: logical[1, nColsOfVec] -
          true - if vector belongs to the union or intersection
          of ellipsoids, false - otherwise.

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = firstEllObj + [5; 5];
      ellVec = [firstEllObj secEllObj];
      ellVec.isinternal([-2 3; -1 4], 'i')

      ans =

           0     0

      ellVec.isinternal([-2 3; -1 4])

      ans =

           1     1

::

    MAXEIG - return the maximal eigenvalue of the ellipsoid.

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
               ellipsoids.

    Output:
      maxEigArr: double[nDims1,nDims2,...,nDimsN] - array of maximal
          eigenvalues of ellipsoids in the input matrix inpEllMat.

    Example:
      ellObj = ellipsoid([-2; 4], [4 -1; -1 5]);
      maxEig = maxeig(ellObj)

      maxEig =

          5.6180

::

    MINEIG - return the minimal eigenvalue of the ellipsoid.

    Input:
       regular:
          inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
            ellipsoids.

    Output:
       minEigArr: double[nDims1,nDims2,...,nDimsN] - array of minimal
          eigenvalues of ellipsoids in the input array inpEllMat.

    Example:
      ellObj = ellipsoid([-2; 4], [4 -1; -1 5]);
      minEig = mineig(ellObj)

      minEig =

          3.3820

::

    MINKCOMMONACTION - plot Minkowski operation  of ellipsoids in 2D or 3D.
    Usage:
    minkCommonAction(getEllArr,fCalcBodyTriArr,...
       fCalcCenterTriArr,varargin) -  plot Minkowski operation  of
               ellipsoids in 2D or 3D, using triangulation  of output object

    Input:
      regular:
          getEllArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
                   array of 2D or 3D Ellipsoids objects. All ellipsoids in
                   ellArr must be either 2D or 3D simutaneously.
    fCalcBodyTriArr - function, calculeted triangulation of output object
       fCalcCenterTriArr - function, calculeted center  of output object
               properties:
          'shawAll': logical[1,1] - if 1, plot all ellArr.
                       Default value is 0.
          'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
                  if 1, ellipsoids in 2D will be filled with color.
                  Default value is 0.
          'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                       line width for 1D and 2D plots. Default value is 1.
          'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
                   sets default colors in the form [x y z].
                  Default value is [1 0 0].
          'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   level of transparency between 0 and 1
                      (0 - transparent, 1 - opaque).
                   Default value is 0.4.
          'relDataPlotter' - relation data plotter object.

    Output:
      centVec: double[nDim, 1] - center of the resulting set.
      boundPointMat: double[nDim, nBoundPoints] - set of boundary
          points (vertices) of resulting set.

::

    MINKDIFF - computes geometric (Minkowski) difference of two
                ellipsoids in 2D or 3D.
     Usage:
    MINKDIFF(inpEllMat,'Property',PropValue,...) - Computes
    geometric difference of two ellipsoids in the array inpEllMat, if
    1 <= min(dimension(inpEllMat)) = max(dimension(inpEllMat)) <= 3,
           and plots it if no output arguments are specified.

       [centVec, boundPointMat] = MINKDIFF(inpEllMat) - Computes
           geometric difference of two ellipsoids in inpEllMat.
           Here centVec is
           the center, and boundPointMat - array of boundary points.
       MINKDIFF(inpEllMat) - Plots geometric differencr of two
       ellipsoids in inpEllMat in default (red) color.
       MINKDIFF(inpEllMat, 'Property',PropValue,...) -
        Plots geometric sum of inpEllMat
           with setting properties.

       In order for the geometric difference to be nonempty set,
       ellipsoid fstEll must be bigger than secEll in the sense that
       if fstEll and secEll had the same centerVec, secEll would be
       contained inside fstEll.
     Input:
       regular:
           ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
                    array of 2D or 3D Ellipsoids objects. All ellipsoids in ellArr
                    must be either 2D or 3D simutaneously.

       properties:
           'shawAll': logical[1,1] - if 1, plot all ellArr.
                        Default value is 0.
           'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
                   if 1, ellipsoids in 2D will be filled with color.
                   Default value is 0.
           'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                        line width for 1D and 2D plots. Default value is 1.
           'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
                    sets default colors in the form [x y z].
                   Default value is [1 0 0].
           'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                    level of transparency between 0 and 1
                       (0 - transparent, 1 - opaque).
                    Default value is 0.4.
           'relDataPlotter' - relation data plotter object.
           Notice that property vector could have different dimensions, only
           total number of elements must be the same.

     Output:
       centVec: double[nDim, 1] - center of the resulting set.
       boundPointMat: double[nDim, nBoundPoints] - set of boundary
           points (vertices) of resulting set.

     Example:
       firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
       secEllObj = ellipsoid([1 2], eye(2));
       [centVec, boundPointMat] = minkdiff(firstEllObj, secEllObj);

::

    MINKDIFF_EA - computation of external approximating ellipsoids
                  of the geometric difference of two ellipsoids along
                  given directions.

      extApprEllVec = MINKDIFF_EA(fstEll, secEll, directionsMat) -
          Computes external approximating ellipsoids of the
          geometric difference of two ellipsoids fstEll - secEll
          along directions specified by columns of matrix directionsMat

      First condition for the approximations to be computed, is that
      ellipsoid fstEll = E1 must be bigger than ellipsoid secEll = E2
      in the sense that if they had the same center, E2 would be contained
      inside E1. Otherwise, the geometric difference E1 - E2
      is an empty set.
      Second condition for the approximation in the given direction l
      to exist, is the following. Given
          P = sqrt(<l, Q1 l>)/sqrt(<l, Q2 l>)
      where Q1 is the shape matrix of ellipsoid E1, and
      Q2 - shape matrix of E2, and R being minimal root of the equation
          det(Q1 - R Q2) = 0,
      parameter P should be less than R.
      If both of these conditions are satisfied, then external
      approximating ellipsoid is defined by its shape matrix
          Q = (Q1^(1/2) + S Q2^(1/2))' (Q1^(1/2) + S Q2^(1/2)),
      where S is orthogonal matrix such that vectors
          Q1^(1/2)l and SQ2^(1/2)l
      are parallel, and its center
          q = q1 - q2,
      where q1 is center of ellipsoid E1 and q2 - center of E2.

    Input:
      regular:
          fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
              nDim - space dimension.
          secEll: ellipsoid [1, 1] - second ellipsoid
              of the same dimention.
          directionsMat: double[nDim, nCols] - matrix whose columns
              specify the directions for which the approximations
              should be computed.

    Output:
      extApprEllVec: ellipsoid [1, nCols] - array of external
          approximating ellipsoids (empty, if for all specified
          directions approximations cannot be computed).

    Example:
      firstEllObj= ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = 3*ell_unitball(2);
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      externalEllVec = secEllObj.minkdiff_ea(firstEllObj, dirsMat)

      externalEllVec =
      1x2 array of ellipsoids.

::

    MINKDIFF_IA - computation of internal approximating ellipsoids
                  of the geometric difference of two ellipsoids along
                  given directions.

      intApprEllVec = MINKDIFF_IA(fstEll, secEll, directionsMat) -
          Computes internal approximating ellipsoids of the geometric
          difference of two ellipsoids fstEll - secEll along directions
          specified by columns of matrix directionsMat.

      First condition for the approximations to be computed, is that
      ellipsoid fstEll = E1 must be bigger than ellipsoid secEll = E2
      in the sense that if they had the same center, E2 would be contained
      inside E1. Otherwise, the geometric difference E1 - E2 is an
      empty set. Second condition for the approximation in the given
      direction l to exist, is the following. Given
          P = sqrt(<l, Q1 l>)/sqrt(<l, Q2 l>)
      where Q1 is the shape matrix of ellipsoid E1,
      and Q2 - shape matrix of E2, and R being minimal root of the equation
          det(Q1 - R Q2) = 0,
      parameter P should be less than R.
      If these two conditions are satisfied, then internal approximating
      ellipsoid for the geometric difference E1 - E2 along the
      direction l is defined by its shape matrix
          Q = (1 - (1/P)) Q1 + (1 - P) Q2
      and its center
          q = q1 - q2,
      where q1 is center of E1 and q2 - center of E2.

    Input:
      regular:
          fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
              nDim - space dimension.
          secEll: ellipsoid [1, 1] - second ellipsoid
              of the same dimention.
          directionsMat: double[nDim, nCols] - matrix whose columns
              specify the directions for which the approximations
              should be computed.

    Output:
      intApprEllVec: ellipsoid [1, nCols] - array of internal
          approximating ellipsoids (empty, if for all specified directions
          approximations cannot be computed).

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = 3*ell_unitball(2);
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      internalEllVec = secEllObj.minkdiff_ia(firstEllObj, dirsMat)

      internalEllVec =
      1x2 array of ellipsoids.

::

    MINKMP - computes and plots geometric (Minkowski) sum of the
             geometric difference of two ellipsoids and the geometric
             sum of n ellipsoids in 2D or 3D:
             (E - Em) + (E1 + E2 + ... + En),
             where E = firstEll, Em = secondEll,
             E1, E2, ..., En - are ellipsoids in sumEllArr

    Usage:
      MINKMP(firEll,secEll,ellMat,'Property',PropValue,...) -
              Computes (E1 - E2) + (E3 + E4+ ... + En), if
          1 <= min(dimension(inpEllMat)) = max(dimension(inpEllMat)) <= 3,
          and plots it if no output arguments are specified.

      [centVec, boundPointMat] = MINKMP(firEll,secEll,ellMat) - Computes
         (E1 - E2) + (E3 + E4+ ... + En). Here centVec is
          the center, and boundPointMat - array of boundary points.
    Input:
      regular:
          ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
              array of 2D or 3D Ellipsoids objects. All ellipsoids in ellArr
                   must be either 2D or 3D simutaneously.

      properties:
          'showAll': logical[1,1] - if 1, plot all ellArr.
                       Default value is 0.
          'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
                  if 1, ellipsoids in 2D will be filled with color.
                  Default value is 0.
          'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]-
                       line width for 1D and 2D plots. Default value is 1.
          'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
                   sets default colors in the form [x y z].
                      Default value is [1 0 0].
          'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   level of transparency between 0 and 1
                  (0 - transparent, 1 - opaque).
                   Default value is 0.4.
          'relDataPlotter' - relation data plotter object.
          Notice that property vector could have different dimensions, only
          total number of elements must be the same.

    Output:
      centVec: double[nDim, 1] - center of the resulting set.
      boundPointMat: double[nDim, nBoundPoints] - set of boundary
          points (vertices) of resulting set.

    Example:
      firstEllObj = ellipsoid([-2; -1], [2 -1; -1 1]);
      secEllObj = ell_unitball(2);
      ellVec = [firstEllObj secEllObj ellipsoid([-3; 1], eye(2))];
      minkmp(firstEllObj, secEllObj, ellVec);

::

    MINKMP_EA - computation of external approximating ellipsoids
                of (E - Em) + (E1 + ... + En) along given directions.
                where E = fstEll, Em = secEll,
                E1, E2, ..., En - are ellipsoids in sumEllArr

      extApprEllVec = MINKMP_EA(fstEll, secEll, sumEllArr, dirMat) -
          Computes external approximating
          ellipsoids of (E - Em) + (E1 + E2 + ... + En),
          where E1, E2, ..., En are ellipsoids in array sumEllArr,
          E = fstEll, Em = secEll,
          along directions specified by columns of matrix dirMat.

    Input:
      regular:
          fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
              nDims - space dimension.
          secEll: ellipsoid [1, 1] - second ellipsoid
              of the same dimention.
          sumEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array of
              ellipsoids of the same dimentions nDims.
          dirMat: double[nDims, nCols] - matrix whose columns specify the
              directions for which the approximations should be computed.

    Output:
      extApprEllVec: ellipsoid [1, nCols] - array of external
          approximating ellipsoids (empty, if for all specified
          directions approximations cannot be computed).

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = 3*ell_unitball(2);
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      bufEllVec = [secEllObj firstEllObj];
      externalEllVec = secEllObj.minkmp_ea(firstEllObj, bufEllVec, dirsMat)

      externalEllVec =
      1x2 array of ellipsoids.

::

    MINKMP_IA - computation of internal approximating ellipsoids
                of (E - Em) + (E1 + ... + En) along given directions.
                where E = fstEll, Em = secEll,
                E1, E2, ..., En - are ellipsoids in sumEllArr

      intApprEllVec = MINKMP_IA(fstEll, secEll, sumEllArr, dirMat) -
          Computes internal approximating
          ellipsoids of (E - Em) + (E1 + E2 + ... + En),
          where E1, E2, ..., En are ellipsoids in array sumEllArr,
          E = fstEll, Em = secEll,
          along directions specified by columns of matrix dirMat.

    Input:
      regular:
          fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
              nDim - space dimension.
          secEll: ellipsoid [1, 1] - second ellipsoid
              of the same dimention.
          sumEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array of
              ellipsoids of the same dimentions.
          dirMat: double[nDim, nCols] - matrix whose columns specify the
              directions for which the approximations should be computed.

    Output:
      intApprEllVec: ellipsoid [1, nCols] - array of internal
          approximating ellipsoids (empty, if for all specified
          directions approximations cannot be computed).

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = 3*ell_unitball(2);
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      bufEllVec = [secEllObj firstEllObj];
      internalEllVec = secEllObj.minkmp_ia(firstEllObj, bufEllVec, dirsMat)

      internalEllVec =
      1x2 array of ellipsoids.

::

    MINKPM - computes and plots geometric (Minkowski) difference
             of the geometric sum of ellipsoids and a single ellipsoid
             in 2D or 3D: (E1 + E2 + ... + En) - E,
             where E = inpEll,
             E1, E2, ... En - are ellipsoids in inpEllArr.

      MINKPM(inpEllArr, inpEll, OPTIONS)  Computes geometric difference
          of the geometric sum of ellipsoids in inpEllMat and
          ellipsoid inpEll, if
          1 <= dimension(inpEllArr) = dimension(inpArr) <= 3,
          and plots it if no output arguments are specified.

      [centVec, boundPointMat] = MINKPM(inpEllArr, inpEll) - pomputes
          (geometric sum of ellipsoids in inpEllArr) - inpEll.
          Here centVec is the center, and boundPointMat - array
          of boundary points.
      MINKPM(inpEllArr, inpEll) - plots (geometric sum of ellipsoids
          in inpEllArr) - inpEll in default (red) color.
      MINKPM(inpEllArr, inpEll, Options) - plots
          (geometric sum of ellipsoids in inpEllArr) - inpEll using
          options given in the Options structure.

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array of
              ellipsoids of the same dimentions 2D or 3D.
          inpEll: ellipsoid [1, 1] - ellipsoid of the same
              dimention 2D or 3D.

      optional:
          Options: structure[1, 1] - fields:
              show_all: double[1, 1] - if 1, displays
                  also ellipsoids fstEll and secEll.
              newfigure: double[1, 1] - if 1, each plot
                  command will open a new figure window.
              fill: double[1, 1] - if 1, the resulting
                  set in 2D will be filled with color.
              color: double[1, 3] - sets default colors
                  in the form [x y z].
              shade: double[1, 1] = 0-1 - level of transparency
                  (0 - transparent, 1 - opaque).

    Output:
       centVec: double[nDim, 1]/double[0, 0] - center of the resulting set.
          centerVec may be empty.
       boundPointMat: double[nDim, ]/double[0, 0] - set of boundary
          points (vertices) of resulting set. boundPointMat may be empty.

::

    MINKPM_EA - computation of external approximating ellipsoids
                of (E1 + E2 + ... + En) - E along given directions.
                where E = inpEll,
                E1, E2, ... En - are ellipsoids in inpEllArr.

      ExtApprEllVec = MINKPM_EA(inpEllArr, inpEll, dirMat) - Computes
          external approximating ellipsoids of
          (E1 + E2 + ... + En) - E, where E1, E2, ..., En are ellipsoids
          in array inpEllArr, E = inpEll,
          along directions specified by columns of matrix dirMat.

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] -
              array of ellipsoids of the same dimentions.
          inpEll: ellipsoid [1, 1] - ellipsoid of the same dimention.
          dirMat: double[nDim, nCols] - matrix whose columns specify
              the directions for which the approximations
              should be computed.

    Output:
      extApprEllVec: ellipsoid [1, nCols]/[0, 0] - array of external
          approximating ellipsoids. Empty, if for all specified
          directions approximations cannot be computed.

    Example:
      firstEllObj = ellipsoid([2; -1], [9 -5; -5 4]);
      secEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      thirdEllObj = ell_unitball(2);
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      ellVec = [thirdEllObj firstEllObj];
      externalEllVec = ellVec.minkpm_ea(secEllObj, dirsMat)

      externalEllVec =
      1x4 array of ellipsoids.

::

    MINKPM_IA - computation of internal approximating ellipsoids
                of (E1 + E2 + ... + En) - E along given directions.
                where E = inpEll,
                E1, E2, ... En - are ellipsoids in inpEllArr.

      intApprEllVec = MINKPM_IA(inpEllArr, inpEll, dirMat) - Computes
          internal approximating ellipsoids of
          (E1 + E2 + ... + En) - E, where E1, E2, ..., En are ellipsoids
          in array inpEllArr, E = inpEll,
          along directions specified by columns of matrix dirArr.

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] -
              array of ellipsoids of the same dimentions.
          inpEll: ellipsoid [1, 1] - ellipsoid of the same dimention.
          dirMat: double[nDim, nCols] - matrix whose columns specify
              the directions for which the approximations
              should be computed.

    Output:
      intApprEllVec: ellipsoid [1, nCols]/[0, 0] - array of internal
          approximating ellipsoids. Empty, if for all specified
          directions approximations cannot be computed.

    Example:
      firstEllObj = ellipsoid([2; -1], [9 -5; -5 4]);
      secEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      thirdEllObj = ell_unitball(2);
      ellVec = [thirdEllObj firstEllObj];
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      internalEllVec = ellVec.minkpm_ia(secEllObj, dirsMat)

      internalEllVec =
      1x3 array of ellipsoids.

::

    MINKSUM - computes geometric (Minkowski) sum of ellipsoids in 2D or 3D.

    Usage:
      MINKSUM(inpEllMat,'Property',PropValue,...) - Computes geometric sum of
          ellipsoids in the array inpEllMat, if
          1 <= min(dimension(inpEllMat)) = max(dimension(inpEllMat)) <= 3,
          and plots it if no output arguments are specified.

      [centVec, boundPointMat] = MINKSUM(inpEllMat) - Computes
          geometric sum of ellipsoids in inpEllMat. Here centVec is
          the center, and boundPointMat - array of boundary points.
      MINKSUM(inpEllMat) - Plots geometric sum of ellipsoids in
          inpEllMat in default (red) color.
      MINKSUM(inpEllMat, 'Property',PropValue,...) - Plots geometric sum of
      inpEllMat with setting properties.

    Input:
      regular:
          ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
                   array of 2D or 3D Ellipsoids objects. All ellipsoids
                   in ellArr must be either 2D or 3D simutaneously.

      properties:
       'showAll': logical[1,1] - if 1, plot all ellArr.
                       Default value is 0.
       'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
                  if 1, ellipsoids in 2D will be filled with color. Default
                  value is 0.
       'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]-
                       line width for 1D and 2D plots. Default value is 1.
       'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
           sets default colors in the form [x y z]. Default value is [1 0 0].
       'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
         level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
                   Default value is 0.4.
          'relDataPlotter' - relation data plotter object.
          Notice that property vector could have different dimensions, only
          total number of elements must be the same.

    Output:
      centVec: double[nDim, 1] - center of the resulting set.
      boundPointMat: double[nDim, nBoundPoints] - set of boundary
          points (vertices) of resulting set.

    Example:
      firstEllObj = ellipsoid([-2; -1], [2 -1; -1 1]);
      secEllObj = ell_unitball(2);
      ellVec = [firstEllObj, secellObj]
      sumVec = minksum(ellVec);

::

    MINKSUM_EA - computation of external approximating ellipsoids
                 of the geometric sum of ellipsoids along given directions.

      extApprEllVec = MINKSUM_EA(inpEllArr, dirMat) - Computes
          tight external approximating ellipsoids for the geometric
          sum of the ellipsoids in the array inpEllArr along directions
          specified by columns of dirMat.
          If ellipsoids in inpEllArr are n-dimensional, matrix
          dirMat must have dimension (n x k) where k can be
          arbitrarily chosen.
          In this case, the output of the function will contain k
          ellipsoids computed for k directions specified in dirMat.

      Let inpEllArr consists of E(q1, Q1), E(q2, Q2), ..., E(qm, Qm) -
      ellipsoids in R^n, and dirMat(:, iCol) = l - some vector in R^n.
      Then tight external approximating ellipsoid E(q, Q) for the
      geometric sum E(q1, Q1) + E(q2, Q2) + ... + E(qm, Qm)
      along direction l, is such that
          rho(l | E(q, Q)) = rho(l | (E(q1, Q1) + ... + E(qm, Qm)))
      and is defined as follows:
          q = q1 + q2 + ... + qm,
          Q = (p1 + ... + pm)((1/p1)Q1 + ... + (1/pm)Qm),
      where
          p1 = sqrt(<l, Q1l>), ..., pm = sqrt(<l, Qml>).

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array
              of ellipsoids of the same dimentions.
          dirMat: double[nDims, nCols] - matrix whose columns specify
              the directions for which the approximations
              should be computed.

    Output:
      extApprEllVec: ellipsoid [1, nCols] - array of external
          approximating ellipsoids.

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = ell_unitball(2);
      ellVec = [firstEllObj secEllObj firstEllObj.inv()];
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      externalEllVec = ellVec.minksum_ea(dirsMat)

      externalEllVec =
      1x4 array of ellipsoids.

::

    MINKSUM_IA - computation of internal approximating ellipsoids
                 of the geometric sum of ellipsoids along given directions.

      intApprEllVec = MINKSUM_IA(inpEllArr, dirMat) - Computes
          tight internal approximating ellipsoids for the geometric
          sum of the ellipsoids in the array inpEllArr along directions
          specified by columns of dirMat. If ellipsoids in
          inpEllArr are n-dimensional, matrix dirMat must have
          dimension (n x k) where k can be arbitrarily chosen.
          In this case, the output of the function will contain k
          ellipsoids computed for k directions specified in dirMat.

      Let inpEllArr consist of E(q1, Q1), E(q2, Q2), ..., E(qm, Qm) -
      ellipsoids in R^n, and dirMat(:, iCol) = l - some vector in R^n.
      Then tight internal approximating ellipsoid E(q, Q) for the
      geometric sum E(q1, Q1) + E(q2, Q2) + ... + E(qm, Qm) along
      direction l, is such that
          rho(l | E(q, Q)) = rho(l | (E(q1, Q1) + ... + E(qm, Qm)))
      and is defined as follows:
          q = q1 + q2 + ... + qm,
          Q = (S1 Q1^(1/2) + ... + Sm Qm^(1/2))' *
              * (S1 Q1^(1/2) + ... + Sm Qm^(1/2)),
      where S1 = I (identity), and S2, ..., Sm are orthogonal
      matrices such that vectors
      (S1 Q1^(1/2) l), ..., (Sm Qm^(1/2) l) are parallel.

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array
              of ellipsoids of the same dimentions.
          dirMat: double[nDim, nCols] - matrix whose columns specify the
              directions for which the approximations should be computed.

    Output:
      intApprEllVec: ellipsoid [1, nCols] - array of internal
          approximating ellipsoids.

    Example:
      firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      secEllObj = ell_unitball(2);
      ellVec = [firstEllObj secEllObj firstEllObj.inv()];
      dirsMat = [1 0; 1 1; 0 1; -1 1]';
      internalEllVec = ellVec.minksum_ia(dirsMat)

      internalEllVec =
      1x4 array of ellipsoids.

::

    MINUS - overloaded operator '-'

      outEllArr = MINUS(inpEllArr, inpVec) implements E(q, Q) - b
          for each ellipsoid E(q, Q) in inpEllArr.
      outEllArr = MINUS(inpVec, inpEllArr) implements b - E(q, Q)
          for each ellipsoid E(q, Q) in inpEllArr.

      Operation E - b where E = inpEll is an ellipsoid in R^n,
      and b = inpVec - vector in R^n. If E(q, Q) is an ellipsoid
      with center q and shape matrix Q, then
      E(q, Q) - b = E(q - b, Q).

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
              ellipsoids of the same dimentions nDims.
          inpVec: double[nDims, 1] - vector.

    Output:
       outEllVec: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          with same shapes as inpEllVec, but with centers shifted by vectors
          in -inpVec.

    Example:
      ellVec  = [ellipsoid([-2; -1], [4 -1; -1 1]) ell_unitball(2)];
      outEllVec = ellVec - [1; 1];
      outEllVec(1)

      ans =

      Center:
          -3
          -2

      Shape:
           4    -1
          -1     1

      Nondegenerate ellipsoid in R^2.

      outEllVec(2)

      ans =

      Center:
          -1
          -1

      Shape:
           1     0
           0     1

      Nondegenerate ellipsoid in R^2.

::

    MOVE2ORIGIN - moves ellipsoids in the given array to the origin. Modified
                  given array is on output (not its copy).

      outEllArr = MOVE2ORIGIN(inpEll) - Replaces the centers of
          ellipsoids in inpEllArr with zero vectors.

    Input:
      regular:
          inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
              ellipsoids.

    Output:
      inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          with the same shapes as in inpEllArr centered at the origin.

    Example:
      ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      outEllObj = ellObj.move2origin()

      outEllObj =

      Center:
           0
           0

      Shape:
           4    -1
          -1     1

      Nondegenerate ellipsoid in R^2.

::

    MTIMES - overloaded operator '*'.

      Multiplication of the ellipsoid by a matrix or a scalar.
      If inpEllVec(iEll) = E(q, Q) is an ellipsoid, and
      multMat = A - matrix of suitable dimensions,
      then A E(q, Q) = E(Aq, AQA').

    Input:
      regular:
          multMat: double[mRows, nDims]/[1, 1] - scalar or
              matrix in R^{mRows x nDim}
          inpEllVec: ellipsoid [1, nCols] - array of ellipsoids.

    Output:
      outEllVec: ellipsoid [1, nCols] - resulting ellipsoids.

    Example:
      ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      tempMat = [0 1; -1 0];
      outEllObj = tempMat*ellObj

      outEllObj =

      Center:
          -1
           2

      Shape:
           1     1
           1     4

      Nondegenerate ellipsoid in R^2.

::

    PARAMETERS - returns parameters of the ellipsoid.

    Input:
      regular:
          myEll: ellipsoid [1, 1] - single ellipsoid of dimention nDims.

    Output:
      myEllCenterVec: double[nDims, 1] - center of the ellipsoid myEll.
      myEllShapeMat: double[nDims, nDims] - shape matrix
          of the ellipsoid myEll.

    Example:
      ellObj = ellipsoid([-2; 4], [4 -1; -1 5]);
      [centVec shapeMat] = parameters(ellObj)
      centVec =

          -2
           4

      shapeMat =

          4    -1
         -1     5

::

    PLOT - plots ellipsoids in 2D or 3D.


    Usage:
          plot(ell) - plots ellipsoid ell in default (red) color.
          plot(ellArr) - plots an array of ellipsoids.
          plot(ellArr, 'Property',PropValue,...) - plots ellArr with setting
                                                   properties.

    Input:
      regular:
          ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
                   array of 2D or 3D Ellipsoids objects. All ellipsoids in ellArr
                   must be either 2D or 3D simutaneously.
      optional:
          color1Spec: char[1,1] - color specification code, can be 'r','g',
                                  etc (any code supported by built-in Matlab function).
          ell2Arr: Ellipsoid: [dim21Size,dim22Size,...,dim2kSize] -
                                              second ellipsoid array...
          color2Spec: char[1,1] - same as color1Spec but for ell2Arr
          ....
          ellNArr: Ellipsoid: [dimN1Size,dim22Size,...,dimNkSize] -
                                               N-th ellipsoid array
          colorNSpec - same as color1Spec but for ellNArr.
      properties:
          'newFigure': logical[1,1] - if 1, each plot command will open a new figure window.
                       Default value is 0.
          'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
                  if 1, ellipsoids in 2D will be filled with color. Default value is 0.
          'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                       line width for 1D and 2D plots. Default value is 1.
          'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
                   sets default colors in the form [x y z]. Default value is [1 0 0].
          'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
                   Default value is 0.4.
          'relDataPlotter' - relation data plotter object.
          Notice that property vector could have different dimensions, only
          total number of elements must be the same.
    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

    Examples:
          plot([ell1, ell2, ell3], 'color', [1, 0, 1; 0, 0, 1; 1, 0, 0]);
          plot([ell1, ell2, ell3], 'color', [1; 0; 1; 0; 0; 1; 1; 0; 0]);
          plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1, 1, 1; 1, 1,
          1]);
          plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1; 1; 1; 1; 1;
          1]);
          plot([ell1, ell2, ell3], 'shade', 0.5);
          plot([ell1, ell2, ell3], 'lineWidth', 1.5);
          plot([ell1, ell2, ell3], 'lineWidth', [1.5, 0.5, 3]);

::

    PLUS - overloaded operator '+'

      outEllArr = PLUS(inpEllArr, inpVec) implements E(q, Q) + b
          for each ellipsoid E(q, Q) in inpEllArr.
      outEllArr = PLUS(inpVec, inpEllArr) implements b + E(q, Q)
          for each ellipsoid E(q, Q) in inpEllArr.

       Operation E + b (or b+E) where E = inpEll is an ellipsoid in R^n,
      and b=inpVec - vector in R^n. If E(q, Q) is an ellipsoid
      with center q and shape matrix Q, then
      E(q, Q) + b = b + E(q,Q) = E(q + b, Q).

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
              of the same dimentions nDims.
          bVec: double[nDims, 1] - vector.

    Output:
      outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          with same shapes as ellVec, but with centers shifted by vectors
          in inpVec.

    Example:
      ellVec  = [ellipsoid([-2; -1], [4 -1; -1 1]) ell_unitball(2)];
      outEllVec = ellVec + [1; 1];
      outEllVec(1)

      ans =

      Center:
          -1
           0

      Shape:
          4    -1
         -1     1

      Nondegenerate ellipsoid in R^2.

      outEllVec(2)

      ans =

      Center:
           1
           1

      Shape:
          1     0
          0     1

      Nondegenerate ellipsoid in R^2.

::

    POLAR - computes the polar ellipsoids.

      polEllArr = POLAR(ellArr)  Computes the polar ellipsoids for those
          ellipsoids in ellArr, for which the origin is an interior point.
          For those ellipsoids in E, for which this condition does not hold,
          an empty ellipsoid is returned.

      Given ellipsoid E(q, Q) where q is its center, and Q - its shape matrix,
      the polar set to E(q, Q) is defined as follows:
      P = { l in R^n  | <l, q> + sqrt(<l, Q l>) <= 1 }
      If the origin is an interior point of ellipsoid E(q, Q),
      then its polar set P is an ellipsoid.

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.

    Output:
      polEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
           polar ellipsoids.

    Example:
      ellObj = ellipsoid([4 -1; -1 1]);
      ellObj.polar() == ellObj.inv()

      ans =

          1

::

    PROJECTION - computes projection of the ellipsoid onto the given subspace.
                 modified given array is on output (not its copy).

      projEllArr = projection(ellArr, basisMat)  Computes projection of the
          ellipsoid ellArr onto a subspace, specified by orthogonal
          basis vectors basisMat. ellArr can be an array of ellipsoids of
          the same dimension. Columns of B must be orthogonal vectors.

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.
          basisMat: double[nDim, nSubSpDim] - matrix of orthogonal basis
              vectors

    Output:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
          projected ellipsoids, generally, of lower dimension.

    Example:
      ellObj = ellipsoid([-2; -1; 4], [4 -1 0; -1 1 0; 0 0 9]);
      basisMat = [0 1 0; 0 0 1]';
      outEllObj = ellObj.projection(basisMat)

      outEllObj =

      Center:
          -1
           4

      Shape:
          1     0
          0     9

      Nondegenerate ellipsoid in R^2.

::

    REPMAT - is analogous to built-in repmat function with one exception - it
             copies the objects, not just the handles

    Example:
      firstEllObj = ellipsoid([1; 2], eye(2));
      secEllObj = ellipsoid([1; 1], 2*eye(2));
      ellVec = [firstEllObj secEllObj];
      repMat(ellVec)

      ans =
      1x2 array of ellipsoids.

::

    RHO - computes the values of the support function for given ellipsoid
          and given direction.

          supArr = RHO(ellArr, dirsMat)  Computes the support function of the
          ellipsoid ellArr in directions specified by the columns of matrix
          dirsMat. Or, if ellArr is array of ellipsoids, dirsMat is expected
          to be a single vector.

          [supArr, bpArr] = RHO(ellArr, dirstMat)  Computes the support function
          of the ellipsoid ellArr in directions specified by the columns of
          matrix dirsMat, and boundary points bpArr of this ellipsoid that
          correspond to directions in dirsMat. Or, if ellArr is array of
          ellipsoids, and dirsMat - single vector, then support functions and
          corresponding boundary points are computed for all the given
          ellipsoids in the array in the specified direction dirsMat.

          The support function is defined as
      (1)  rho(l | E) = sup { <l, x> : x belongs to E }.
          For ellipsoid E(q,Q), where q is its center and Q - shape matrix,
      it is simplified to
      (2)  rho(l | E) = <q, l> + sqrt(<l, Ql>)
      Vector x, at which the maximum at (1) is achieved is defined by
      (3)  q + Ql/sqrt(<l, Ql>)

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
              of ellipsoids.
          dirsMat: double[nDim,nDims1,nDims2,...,nDimsN]/
              double[nDim,nDirs]/[nDim,1] - array or matrix of directions.

    Output:
          supArr: double [nDims1,nDims2,...,nDimsN]/[1,nDirs] - support function
          of the ellArr in directions specified by the columns of matrix
          dirsMat. Or, if ellArr is array of ellipsoids, support function of
          each ellipsoid in ellArr specified by dirsMat direction.

      bpArr: double[nDim,nDims1,nDims2,...,nDimsN]/
              double[nDim,nDirs]/[nDim,1] - array or matrix of boundary points

    Example:
      ellObj = ellipsoid([-2; 4], [4 -1; -1 1]);
      dirsMat = [-2 5; 5 1];
      suppFuncVec = rho(ellObj, dirsMat)

      suppFuncVec =

          31.8102    3.5394

::

    SHAPE - modifies the shape matrix of the ellipsoid without
      changing its center. Modified given array is on output (not its copy).

       modEllArr = SHAPE(ellArr, modMat)  Modifies the shape matrices of
          the ellipsoids in the ellipsoidal array ellArr. The centers
          remain untouched - that is the difference of the function SHAPE and
          linear transformation modMat*ellArr. modMat is expected to be a
          scalar or a square matrix of suitable dimension.

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.
          modMat: double[nDim, nDim]/[1,1] - square matrix or scalar

    Output:
       ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of modified
          ellipsoids.

    Example:
      ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
      tempMat = [0 1; -1 0];
      outEllObj = shape(ellObj, tempMat)

      outEllObj =

      Center:
          -2
          -1

      Shape:
          1     1
          1     4

      Nondegenerate ellipsoid in R^2.

::

    TOPOLYTOPE - for ellipsoid ell makes polytope object represanting the
                 boundary of ell

    Input:
      regular:
          ell: ellipsoid[1,1] - ellipsoid in 3D or 2D.
      optional:
          nPoints: double[1,1] - number of boundary points.
                   Actually number of points in resulting
                   polytope will be ecual to lowest
                   number of points of icosaeder, that greater
                   than nPoints.

    Output:
      regular:
          poly: polytope[1,1] - polytop in 3D or 2D.

::

    toStruct -- converts ellipsoid array into structural array.

    Input:
      regular:
          ellArr: ellipsoid [nDim1, nDim2, ...] - array
              of ellipsoids.
    Output:
      SDataArr: struct[nDims1,...,nDimsk] - structure array same size, as
          ellArr, contain all data.
      SFieldNiceNames: struct[1,1] - structure with the same fields as SDataArr. Field values
          contain the nice names.
      SFieldDescr: struct[1,1] - structure with same fields as SDataArr,
          values contain field descriptions.

          q: double[1, nEllDim] - the center of ellipsoid
          Q: double[nEllDim, nEllDim] - the shape matrix of ellipsoid

    Example:
      ellObj = ellipsoid([1 1]', eye(2));
      ellObj.toStruct()

      ans =

      Q: [2x2 double]
      q: [1 1]

::

    TRACE - returns the trace of the ellipsoid.

       trArr = TRACE(ellArr)  Computes the trace of ellipsoids in
          ellipsoidal array ellArr.

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.

    Output:
       trArr: double [nDims1,nDims2,...,nDimsN] - array of trace values,
          same size as ellArr.

    Example:
      firstEllObj = ellipsoid([4 -1; -1 1]);
      secEllObj = ell_unitball(2);
      ellVec = [firstEllObj secEllObj];
      trVec = ellVec.trace()

      trVec =

          5     2

::

    UMINUS - changes the sign of the centerVec of ellipsoid.

    Input:
       regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids.


    Output:
       outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids,
           same size as ellArr.

    Example:
      ellObj = -ellipsoid([-2; -1], [4 -1; -1 1])

      ellObj =

      Center:
           2
           1

      Shape:
           4    -1
          -1     1

      Nondegenerate ellipsoid in R^2.

::

    VOLUME - returns the volume of the ellipsoid.

       volArr = VOLUME(ellArr)  Computes the volume of ellipsoids in
          ellipsoidal array ellArr.

       The volume of ellipsoid E(q, Q) with center q and shape matrix Q
       is given by V = S sqrt(det(Q)) where S is the volume of unit ball.

    Input:
      regular:
          ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
              of ellipsoids.

    Output:
       volArr: double [nDims1,nDims2,...,nDimsN] - array of
          volume values, same size as ellArr.

    Example:
      firstEllObj = ellipsoid([4 -1; -1 1]);
      secEllObj = ell_unitball(2);
      ellVec = [firstEllObj secEllObj]
      volVec = ellVec.volume()

      volVec =

          5.4414     3.1416

hyperplane
----------

::

    CHECKISME - determine whether input object is hyperplane. And display
                message and abort function if input object
                is not hyperplane

    Input:
      regular:
          someObjArr: any[] - any type array of objects.

    Example:
      hypObj = hyperplane([-2, 0]);
      hyperplane.checkIsMe(hypObj)

::

    CONTAINS - checks if given vectors belong to the hyperplanes.

      isPosArr = CONTAINS(myHypArr, xArr) - Checks if vectors specified
          by columns xArr(:, hpDim1, hpDim2, ...) belong
          to hyperplanes in myHypArr.

    Input:
      regular:
          myHypArr: hyperplane [nCols, 1]/[1, nCols]/
              /[hpDim1, hpDim2, ...]/[1, 1] - array of hyperplanes
              of the same dimentions nDims.
          xArr: double[nDims, nCols]/[nDims, hpDim1, hpDim2, ...]/
              /[nDims, 1]/[nDims, nVecArrDim1, nVecArrDim2, ...] - array
              whose columns represent the vectors needed to be checked.

              note: if size of myHypArr is [hpDim1, hpDim2, ...], then
                  size of xArr is [nDims, hpDim1, hpDim2, ...]
                  or [nDims, 1], if size of myHypArr [1, 1], then xArr
                  can be any size [nDims, nVecArrDim1, nVecArrDim2, ...],
                  in this case output variable will has
                  size [1, nVecArrDim1, nVecArrDim2, ...]. If size of
                  xArr is [nDims, nCols], then size of myHypArr may be
                  [nCols, 1] or [1, nCols] or [1, 1], output variable
                  will has size respectively
                  [nCols, 1] or [1, nCols] or [nCols, 1].

    Output:
      isPosArr: logical[hpDim1, hpDim2,...] /
          / logical[1, nVecArrDim1, nVecArrDim2, ...],
          isPosArr(iDim1, iDim2, ...) = true - myHypArr(iDim1, iDim2, ...)
          contains xArr(:, iDim1, iDim2, ...), false - otherwise.

    Example:
      hypObj = hyperplane([-1; 1]);
      tempMat = [100 -1 2; 100 1 2];
      hypObj.contains(tempMat)

      ans =

           1
           0
           1

::

    Hyperplane object of the Ellipsoidal Toolbox.


    Functions:
    ----------
     hyperplane - Constructor of hyperplane object.
     double     - Returns parameters of hyperplane, i.e. normal vector and
                  shift.
     parameters - Same function as 'double' (legacy matter).
     dimension  - Returns dimension of hyperplane.
     isempty    - Checks if hyperplane is empty.
     isparallel - Checks if one hyperplane is parallel to the other one.
     contains   - Check if hyperplane contains given point.


    Overloaded operators and functions:
    -----------------------------------
     eq      - Checks if two hyperplanes are equal.
     ne      - The opposite of 'eq'.
     uminus  - Switches signs of normal and shift parameters to the opposite.
     display - Displays the details about given hyperplane object.
     plot    - Plots hyperplane in 2D and 3D.

::

    DIMENSION - returns dimensions of hyperplanes in the array.

      dimsArr = DIMENSION(hypArr) - returns dimensions of hyperplanes
          described by hyperplane structures in the array hypArr.

    Input:
      regular:
          hypArr: hyperplane [nDims1, nDims2, ...] - array
              of hyperplanes.

    Output:
          dimsArr: double[nDims1, nDims2, ...] - dimensions
              of hyperplanes.

    Example:
      firstHypObj = hyperplane([-1; 1]);
      secHypObj = hyperplane([-1; 1; 8; -2; 3], 7);
      thirdHypObj = hyperplane([1; 2; 0], -1);
      hypVec = [firstHypObj secHypObj thirdHypObj];
      dimsVec  = hypVec.dimension()

      dimsVec =

         2     5     3

::

    DISPLAY - Displays hyperplane object.

    Input:
      regular:
          myHypArr: hyperplane [hpDim1, hpDim2, ...] - array
              of hyperplanes.

    Example:
      hypObj = hyperplane([-1; 1]);
      display(hypObj)

      hypObj =
      size: [1 1]

      Element: [1 1]
      Normal:
          -1
           1

      Shift:
           0

      Hyperplane in R^2.

::

    DOUBLE - return parameters of hyperplane - normal vector and shift.

      [normVec, hypScal] = DOUBLE(myHyp) - returns normal vector
          and scalar value of the hyperplane.

    Input:
      regular:
          myHyp: hyperplane [1, 1] - single hyperplane of dimention nDims.

    Output:
      normVec: double[nDims, 1] - normal vector of the hyperplane myHyp.
      hypScal: double[1, 1] - scalar of the hyperplane myHyp.

    Example:
      hypObj = hyperplane([-1; 1]);
      [normVec, hypScal] = double(hypObj)

      normVec =

          -1
           1

      hypScal =

           0

::

    FROMREPMAT - returns array of equal hyperplanes the same
                 size as stated in sizeVec argument

      hpArr = fromRepMat(sizeVec) - creates an array  size
               sizeVec of empty hyperplanes.

      hpArr = fromRepMat(normalVec,sizeVec) - creates an array
               size sizeVec of hyperplanes with normal
               normalVec.

      hpArr = fromRepMat(normalVec,shift,sizeVec) - creates an
               array size sizeVec of hyperplanes with normal normalVec
               and hyperplane shift shift.

    Input:
      Case1:
          regular:
              sizeVec: double[1,n] - vector of size, have
              integer values.

      Case2:
          regular:
              normalVec: double[nDim, 1] - normal of
              hyperplanes.
              sizeVec: double[1, n] - vector of size, have
              integer values.

      Case3:
          regular:
              normalVec: double[nDim, 1] - normal of
              hyperplanes.
              shift: double[1, 1] - shift of hyperplane.
              sizeVec: double[1,n] - vector of size, have
              integer values.

      properties:
          absTol: double [1,1] - absolute tolerance with default
              value 10^(-7)

::

    fromStruct -- converts structural array into hyperplanes array.

    Input:
      regular:
      SHpArr: struct [hpDim1, hpDim2, ...] -  structural array with following fields:

           normal: double[nHpDim, 1] - the normal of hyperplane
           shift: double[1, 1] - the shift of hyperplane

    Output:
      hpArr : hyperplane [nDim1, nDim2, ...] - hyperplane array with size of
          SHpArr.


    Example:
      hpObj = hyperplane([1 1]', 1);
      hpObj.toStruct()

      ans =

      normal: [2x1 double]
      shift: 0.7071

::

    GETABSTOL - gives the array of absTol for all elements in hplaneArr

    Input:
      regular:
          ellArr: hyperplane[nDim1, nDim2, ...] - multidimension array
              of hyperplane
      optional
          fAbsTolFun: function_handle[1,1] - function that apply
              to the absTolArr. The default is @min.

    Output:
      regular:
          absTolArr: double [absTol1, absTol2, ...] - return absTol for
              each element in hplaneArr
      optional:
          absTol: double[1, 1] - return result of work fAbsTolFun with
              the absTolArr

    Usage:
      use [~,absTol] = hplaneArr.getAbsTol() if you want get only
          absTol,
      use [absTolArr,absTol] = hplaneArr.getAbsTol() if you want get
          absTolArr and absTol,
      use absTolArr = hplaneArr.getAbsTol() if you want get only absTolArr

    Example:
      firstHypObj = hyperplane([-1; 1]);
      secHypObj = hyperplane([-2; 5]);
      hypVec = [firstHypObj secHypObj];
      hypVec.getAbsTol()

      ans =

         1.0e-07 *

          1.0000    1.0000

::

    GETCOPY - gives array the same size as hpArr with copies of elements of
              hpArr.

    Input:
      regular:
          hpArr: hyperplane[nDim1, nDim2,...] - multidimensional array of
              hyperplanes.

    Output:
      copyHpArr: hyperplane[nDim1, nDim2,...] - multidimension array of
          copies of elements of hpArr.

    Example:
      firstHpObj = hyperplane([-1; 1], [2 0; 0 3]);
      secHpObj = hyperplane([1; 2], eye(2));
      hpVec = [firstHpObj secHpObj];
      copyHpVec = getCopy(hpVec)

      copyHpVec =
      1x2 array of hyperplanes.

::

    GETPROPERTY - gives array the same size as hpArr with values of
                  propName properties for each hyperplane in hpArr.
                  Private method, used in every public property getter.

    Input:
      regular:
          hpArr: hyperplane[nDim1, nDim2,...] - mltidimensional array
              of hyperplanes
          propName: char[1,N] - name property
      optional:
          fPropFun: function_handle[1,1] - function that apply
              to the propArr. The default is @min.

    Output:
      regular:
          propArr: double[nDim1, nDim2,...] - multidimension array of
              propName properties for hyperplanes in rsArr
      optional:
          propVal: double[1, 1] - return result of work fPropFun with
              the propArr

::

    GETRELTOL - gives the array of relTol for all elements in hpArr

    Input:
      regular:
          hpArr: hyperplane[nDim1, nDim2, ...] - multidimension array
              of hyperplanes
      optional:
          fRelTolFun: function_handle[1,1] - function that apply
              to the relTolArr. The default is @min.
    Output:
      regular:
          relTolArr: double [relTol1, relTol2, ...] - return relTol for
              each element in hpArr
      optional:
          relTol: double[1,1] - return result of work fRelTolFun with
              the relTolArr

    Usage:
      use [~,relTol] = hpArr.getRelTol() if you want get only
          relTol,
      use [relTolArr,relTol] = hpArr.getRelTol() if you want get
          relTolArr and relTol,
      use relTolArr = hpArr.getRelTol() if you want get only relTolArr

    Example:
      firsthpObj = hyperplane([-1; 1], 1);
      sechpObj = hyperplane([1 ;2], 2);
      hpVec = [firsthpObj sechpObj];
      hpVec.getRelTol()

      ans =

         1.0e-05 *

          1.0000    1.0000

::

    HYPERPLANE - creates hyperplane structure
                 (or array of hyperplane structures).

      Hyperplane H = { x in R^n : <v, x> = c },
      with current "Properties"..
      Here v must be vector in R^n, and c - scalar.

      hypH = HYPERPLANE - create empty hyperplane.

      hypH = HYPERPLANE(hypNormVec) - create
          hyperplane object hypH with properties:
              hypH.normal = hypNormVec,
              hypH.shift = 0.

      hypH = HYPERPLANE(hypNormVec, hypConst) - create
          hyperplane object hypH with properties:
              hypH.normal = hypNormVec,
              hypH.shift = hypConst.

      hypH = HYPERPLANE(hypNormVec, hypConst, ...
          'absTol', absTolVal) - create
          hyperplane object hypH with properties:
              hypH.normal = hypNormVec,
              hypH.shift = hypConst.
              hypH.absTol = absTolVal

      hypObjArr = HYPERPLANE(hypNormArr, hypConstArr) - create
          array of hyperplanes object just as
          hyperplane(hypNormVec, hypConst).

      hypObjArr = HYPERPLANE(hypNormArr, hypConstArr, ...
          'absTol', absTolValArr) - create
          array of hyperplanes object just as
          hyperplane(hypNormVec, hypConst, 'absTol', absTolVal).

    Input:
      Case1:
        regular:
          hypNormArr: double[hpDims, nDims1, nDims2,...] -
              array of vectors in R^hpDims. There hpDims -
              hyperplane dimension.

      Case2:
        regular:
          hypNormArr: double[hpDims, nCols] /
              / [hpDims, nDims1, nDims2,...] /
              / [hpDims, 1] - array of vectors
              in R^hpDims. There hpDims - hyperplane dimension.
          hypConstArr: double[1, nCols] / [nCols, 1] /
              / [nDims1, nDims2,...] /
              / [nVecArrDim1, nVecArrDim2,...] -
              array of scalar.

      Case3:
        regular:
          hypNormArr: double[hpDims, nCols] /
              / [hpDims, nDims1, nDims2,...] /
              / [hpDims, 1] - array of vectors
              in R^hpDims. There hpDims - hyperplane dimension.
          hypConstArr: double[1, nCols] / [nCols, 1] /
              / [nDims1, nDims2,...] /
              / [nVecArrDim1, nVecArrDim2,...] -
              array of scalar.
          absTolValArr: double[1, 1] - value of
              absTol propeties.

        properties:
          propMode: char[1,] - property mode, the following
              modes are supported:
              'absTol' - name of absTol properties.

              note: if size of hypNormArr is
                  [hpDims, nDims1, nDims2,...], then size of
                  hypConstArr is [nDims1, nDims2, ...] or
                  [1, 1], if size of hypNormArr [hpDims, 1],
                  then hypConstArr can be any size
                  [nVecArrDim1, nVecArrDim2, ...],
                  in this case output variable will has
                  size [nVecArrDim1, nVecArrDim2, ...].
                  If size of hypNormArr is [hpDims, nCols],
                  then size of hypConstArr may be
                  [1, nCols] or [nCols, 1],
                  output variable will has size
                  respectively [1, nCols] or [nCols, 1].

    Output:
      hypObjArr: hyperplane [nDims1, nDims2...] /
          / hyperplane [nVecArrDim1, nVecArrDim2, ...] -
          array of hyperplane structure hypH:
              hypH.normal - vector in R^hpDims,
              hypH.shift  - scalar.

    Example:
      hypNormMat = [1 1 1; 1 1 1];
      hypConstVec = [1 -5 0];
      hypObj = hyperplane(hypNormMat, hypConstVec);

::

    ISEMPTY - checks if hyperplanes in H are empty.

    Input:
      regular:
          myHypArr: hyperplane [nDims1, nDims2, ...] - array
              of hyperplanes.

    Output:
      isPositiveArr: logical[nDims1, nDims2, ...],
          isPositiveArr(iDim1, iDim2, ...) = true - if ellipsoid
          myHypArr(iDim1, iDim2, ...) is empty, false - otherwise.

    Example:
      hypObj = hyperplane();
      isempty(hypObj)

      ans =

           1

::

    ISEQUAL - produces logical array the same size as
              ellFirstArr/ellFirstArr (if they have the same).
              isEqualArr[iDim1, iDim2,...] is true if corresponding
              ellipsoids are equal and false otherwise.

    Input:
      regular:
          ellFirstArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
              of ellipsoids.
          ellSecArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
              of ellipsoids.
      properties:
          'isPropIncluded': makes to compare second value properties, such as
          absTol etc.
    Output:
      isEqualArr: logical[nDim1, nDim2,...] - multidimension array of
          logical values. isEqualArr[iDim1, iDim2,...] is true if
          corresponding ellipsoids are equal and false otherwise.

      reportStr: char[1,] - comparison report.

::

    ISPARALLEL - check if two hyperplanes are parallel.

      isResArr = ISPARALLEL(fstHypArr, secHypArr) - Checks if hyperplanes
          in fstHypArr are parallel to hyperplanes in secHypArr and
          returns array of true and false of the size corresponding
          to the sizes of fstHypArr and secHypArr.

    Input:
      regular:
          fstHypArr: hyperplane [nDims1, nDims2, ...] - first array
              of hyperplanes
          secHypArr: hyperplane [nDims1, nDims2, ...] - second array
              of hyperplanes

    Output:
      isPosArr: logical[nDims1, nDims2, ...] -
          isPosArr(iFstDim, iSecDim, ...) = true -
          if fstHypArr(iFstDim, iSecDim, ...) is parallel
          secHypArr(iFstDim, iSecDim, ...), false - otherwise.

    Example:
      hypObj = hyperplane([-1 1 1; 1 1 1; 1 1 1], [2 1 0]);
      hypObj.isparallel(hypObj(2))

      ans =

           0     1     1

::

    PARAMETERS - return parameters of hyperplane - normal vector and shift.

      [normVec, hypScal] = PARAMETERS(myHyp) - returns normal vector
          and scalar value of the hyperplane.

    Input:
      regular:
          myHyp: hyperplane [1, 1] - single hyperplane of dimention nDims.

    Output:
      normVec: double[nDims, 1] - normal vector of the hyperplane myHyp.
      hypScal: double[1, 1] - scalar of the hyperplane myHyp.

    Example:
      hypObj = hyperplane([-1; 1]);
      [normVec, hypScal] = parameters(hypObj)

      normVec =

          -1
           1


      hypScal =

           0

::

    PLOT - plots hyperplaces in 2D or 3D.


    Usage:
          plot(hyp) - plots hyperplace hyp in default (red) color.
          plot(hypArr) - plots an array of hyperplaces.
          plot(hypArr, 'Property',PropValue,...) - plots hypArr with setting
                                                   properties.

    Input:
      regular:
          hypArr:  Hyperplace: [dim11Size,dim12Size,...,dim1kSize] -
                   array of 2D or 3D hyperplace objects. All hyperplaces in hypArr
                   must be either 2D or 3D simutaneously.
      optional:
          color1Spec: char[1,1] - color specification code, can be 'r','g',
                                  etc (any code supported by built-in Matlab function).
          hyp2Arr: Hyperplane: [dim21Size,dim22Size,...,dim2kSize] -
                                              second Hyperplane array...
          color2Spec: char[1,1] - same as color1Spec but for hyp2Arr
          ....
          hypNArr: Hyperplane: [dimN1Size,dim22Size,...,dimNkSize] -
                                               N-th Hyperplane array
          colorNSpec - same as color1Spec but for hypNArr.
      properties:
          'newFigure': logical[1,1] - if 1, each plot command will open a new figure window.
                       Default value is 0.
          'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
                  if 1, ellipsoids in 2D will be filled with color. Default value is 0.
          'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                       line width for 1D and 2D plots. Default value is 1.
          'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
                   sets default colors in the form [x y z]. Default value is [1 0 0].
          'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
                   Default value is 0.4.
          'size': double[1,1] - length of the line segment in 2D, or square diagonal in 3D.
          'center': double[1,dimHyp] - center of the line segment in 2D, of the square in 3D
          'relDataPlotter' - relation data plotter object.
          Notice that property vector could have different dimensions, only
          total number of elements must be the same.
    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

::

    toStruct -- converts hyperplanes array into structural array.

    Input:
      regular:
          hpArr: hyperplane [hpDim1, hpDim2, ...] - array
              of hyperplanes.

    Output:
      ShpArr : struct[nDim1, nDim2, ...] - structural array with size of
          hpArr with the following fields:

          normal: double[nHpDim, 1] - the normal of hyperplane
          shift: double[1, 1] - the shift of hyperplane

::

    UMINUS - switch signs of normal vector and the shift scalar
             to the opposite.

    Input:
      regular:
          inpHypArr: hyperplane [nDims1, nDims2, ...] - array
              of hyperplanes.

    Output:
      outHypArr: hyperplane [nDims1, nDims2, ...] - array
          of the same hyperplanes as in inpHypArr whose
          normals and scalars are multiplied by -1.

    Example:
      hypObj = -hyperplane([-1; 1], 1)

      hypObj =
      size: [1 1]

      Element: [1 1]
      Normal:
           1
          -1

      Shift:
          -1

      Hyperplane in R^2.

elltool.conf.Properties
-----------------------

::

    PROPERTIES - a static class, providing emulation of static properties for
                 toolbox.

::

    Example:
      elltool.conf.Properties.checkSettings()

::

    Example:
      elltool.conf.Properties.getAbsTol();

::

    Example:
      elltool.conf.Properties.getConfRepoMgr()

      ans =

        elltool.conf.ConfRepoMgr handle
        Package: elltool.conf

        Properties:
          DEFAULT_STORAGE_BRANCH_KEY: '_default'

::

    Example:
      elltool.conf.Properties.getIsEnabledOdeSolverOptions();

::

    Example:
      elltool.conf.Properties.getIsODENormControl();

::

    Example:
      elltool.conf.Properties.getIsVerbose();

::

    Example:
      elltool.conf.Properties.getNPlot2dPoints();

::

    Example:
      elltool.conf.Properties.getNPlot3dPoints();

::

    Example:
      elltool.conf.Properties.getNTimeGridPoints();

::

    Example:
      elltool.conf.Properties.getODESolverName();

::

    Example:
      elltool.conf.Properties.getConfRepoMgr.getCurConf()

      ans =

                        version: '1.4dev'
                      isVerbose: 0
                         absTol: 1.0000e-07
                         relTol: 1.0000e-05
                nTimeGridPoints: 200
                  ODESolverName: 'ode45'
               isODENormControl: 'on'
      isEnabledOdeSolverOptions: 0
                  nPlot2dPoints: 200
                  nPlot3dPoints: 200
                        logging: [1x1 struct]

::

::

::

    Example:
      elltool.conf.Properties.getVersion();

::

    Example:
      elltool.conf.Properties.init()

::

    PARSEPROP - parses input into cell array with values of properties listed
               in neededPropNameList.
               Values are  taken from args or, if there no value for some
               property in args, in current Properties.


    Input:
      regular:
          args: cell[1,] of any[] - cell array of arguments that
              should be parsed.
      optional
          neededPropNameList: cell[1,nProp] of char[1,] - cell array of strings
              containing names of parameters, that output should consist of.
              The following properties are supported:
                  version
                  isVerbose
                  absTol
                  relTol
                  regTol
                  ODESolverName
                  isODENormControl
                  isEnabledOdeSolverOptions
                  nPlot2dPoints
                  nPlot3dPoints
                  nTimeGridPoints
              trying to specify other properties would be result in error
              If neededPropNameList is not specified, the list of all
              supported properties is assumed.

    Output:
      propVal1:  - value of the first property specified
                                 in neededPropNameList in the same order as
                                 they listed in neededPropNameList
          ....
      propValN:  - value of the last property from neededPropNameList
      restList: cell[1,nRest] - list of the input arguments that were not
          recognized as properties

    Example:
        testAbsTol = 1;
        testRelTol = 2;
        nPlot2dPoints = 3;
        someArg = 4;
        args = {'absTol',testAbsTol, 'relTol',testRelTol,'nPlot2dPoints',...
            nPlot2dPoints, 'someOtherArg', someArg};
        neededPropList = {'absTol','relTol'};
        [absTol, relTol,resList]=elltool.conf.Properties.parseProp(args,...
            neededPropList)

        absTol =

             1


        relTol =

             2


        resList =

            'nPlot2dPoints'    [3]    'someOtherArg'    [4]

::

    Example:
      prevConfRepo = Properties.getConfRepoMgr();
      prevAbsTol = prevConfRepo.getParam('absTol');
      elltool.conf.Properties.setConfRepoMgr(prevConfRepo);

::

    Example:
      elltool.conf.Properties.setIsVerbose(true);

::

    Example:
      elltool.conf.Properties.setNPlot2dPoints(300);

::

    Example:
      elltool.conf.Properties.setNTimeGridPoints(300);

::

    SETRELTOL - set global relative tolerance

    Input
    relTol: double[1,1]

elltool.core.GenEllipsoid
-------------------------

::

    GENELLIPSOID - class of generalized ellipsoids

    Input:
      Case1:
        regular:
          qVec: double[nDim,1] - ellipsoid center
          qMat: double[nDim,nDim] / qVec: double[nDim,1] - ellipsoid matrix
              or diagonal vector of eigenvalues, that may contain infinite
              or zero elements

      Case2:
        regular:
          qMat: double[nDim,nDim] / qVec: double[nDim,1] - diagonal matrix or
              vector, may contain infinite or zero elements

      Case3:
        regular:
          qVec: double[nDim,1] - ellipsoid center
          dMat: double[nDim,nDim] / dVec: double[nDim,1] - diagonal matrix or
              vector, may contain infinite or zero elements
          wMat: double[nDim,nDim] - any square matrix


    Output:
      self: GenEllipsoid[1,1] - created generalized ellipsoid

    Example:
      ellObj = elltool.core.GenEllipsoid([5;2], eye(2));
      ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);

::

    Example:
      firstEllObj = elltool.core.GenEllipsoid([1; 1], eye(2));
      secEllObj = elltool.core.GenEllipsoid([0; 5], 2*eye(2));
      ellVec = [firstEllObj secEllObj];
      ellVec.dimension()

      ans =

           2     2

::

    Example:
      ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
      ellObj.display()
         |
         |----- q : [5 2]
         |          -------
         |----- Q : |10|19|
         |          |19|41|
         |          -------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----

::

    Example:
      ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
      ellObj.getCenter()

      ans =

           5
           2

::

    Example:
      ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
      ellObj.getCheckTol()

      ans =

         1.0000e-09

::

    Example:
      ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
      ellObj.getDiagMat()

      ans =

          0.9796         0
               0   50.0204

::

    Example:
      ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
      ellObj.getEigvMat()

      ans =

          0.9034   -0.4289
         -0.4289   -0.9034

::

    Example:
      firstEllObj = elltool.core.GenEllipsoid([10;0], 2*eye(2));
      secEllObj = elltool.core.GenEllipsoid([0;0], [1 0; 0 0.1]);
      curDirMat = [1; 0];
      isOk=getIsGoodDir(firstEllObj,secEllObj,dirsMat)

      isOk =

           1

::

    INV - create generalized ellipsoid whose matrix in pseudoinverse
          to the matrix of input generalized ellipsoid

    Input:
      regular:
          ellObj: GenEllipsoid: [1,1] - generalized ellipsoid

    Output:
      ellInvObj: GenEllipsoid: [1,1] - inverse generalized ellipsoid

    Example:
      ellObj = elltool.core.GenEllipsoid([5;2], [1 0; 0 0.7]);
      ellObj.inv()
         |
         |----- q : [5 2]
         |          -----------------
         |----- Q : |1      |0      |
         |          |0      |1.42857|
         |          -----------------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----

::

    MINKDIFFEA - computes tight external ellipsoidal approximation for
                 Minkowsky difference of two generalized ellipsoids

    Input:
      regular:
          ellObj1: GenEllipsoid: [1,1] - first generalized ellipsoid
          ellObj2: GenEllipsoid: [1,1] - second generalized ellipsoid
          dirMat: double[nDim,nDir] - matrix whose columns specify
              directions for which approximations should be computed
    Output:
      resEllVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
          external approximation of the dirrence of first and second
          generalized ellipsoids (may contain empty ellipsoids if in specified
          directions approximation cannot be computed)

    Example:
      firstEllObj = elltool.core.GenEllipsoid([10;0], 2*eye(2));
      secEllObj = elltool.core.GenEllipsoid([0;0], [1 0; 0 0.1]);
      dirsMat = [1,0].';
      resEllVec  = minkDiffEa( firstEllObj, secEllObj, dirsMat)
         |
         |----- q : [10 0]
         |          -------------------
         |----- Q : |0.171573|0       |
         |          |0       |1.20557 |
         |          -------------------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----

::

    MINKDIFFIA - computes tight internal ellipsoidal approximation for
                 Minkowsky difference of two generalized ellipsoids

    Input:
      regular:
          ellObj1: GenEllipsoid: [1,1] - first generalized ellipsoid
          ellObj2: GenEllipsoid: [1,1] - second generalized ellipsoid
          dirMat: double[nDim,nDir] - matrix whose columns specify
              directions for which approximations should be computed
    Output:
      resEllVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
          internal approximation of the dirrence of first and second
          generalized ellipsoids

    Example:
      firstEllObj = elltool.core.GenEllipsoid([10;0], 2*eye(2));
      secEllObj = elltool.core.GenEllipsoid([0;0], [1 0; 0 0.1]);
      dirsMat = [1,0].';
      resEllVec  = minkDiffIa( firstEllObj, secEllObj, dirsMat)
         |
         |----- q : [10 0]
         |          -------------------
         |----- Q : |0.171573|0       |
         |          |0       |0.544365|
         |          -------------------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----

::

    MINKSUMEA - computes tight external ellipsoidal approximation for
                Minkowsky sum of the set of generalized ellipsoids

    Input:
      regular:
          ellObjVec: GenEllipsoid: [kSize,mSize] - vector of  generalized
                                              ellipsoid
          dirMat: double[nDim,nDir] - matrix whose columns specify
              directions for which approximations should be computed
    Output:
      ellResVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
          external approximation of the dirrence of first and second
          generalized ellipsoids

    Example:
      firstEllObj = elltool.core.GenEllipsoid([1;1],eye(2));
      secEllObj = elltool.core.GenEllipsoid([5;0],[3 0; 0 2]);
      ellVec = [firstEllObj secEllObj];
      dirsMat = [1 3; 2 4];
      ellResVec  = minkSumEa(ellVec, dirsMat )

      Structure(1)
         |
         |----- q : [6 1]
         |          -----------------
         |----- Q : |7.50584|0      |
         |          |0      |5.83164|
         |          -----------------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----
         O

      Structure(2)
         |
         |----- q : [6 1]
         |          -----------------
         |----- Q : |7.48906|0      |
         |          |0      |5.83812|
         |          -----------------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----
         O

::

    MINKSUMIA - computes tight internal ellipsoidal approximation for
                Minkowsky sum of the set of generalized ellipsoids

    Input:
      regular:
          ellObjVec: GenEllipsoid: [kSize,mSize] - vector of  generalized
                                              ellipsoid
          dirMat: double[nDim,nDir] - matrix whose columns specify
              directions for which approximations should be computed
    Output:
      ellResVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
          internal approximation of the dirrence of first and second
          generalized ellipsoids

    Example:
      firstEllObj = elltool.core.GenEllipsoid([1;1],eye(2));
      secEllObj = elltool.core.GenEllipsoid([5;0],[3 0; 0 2]);
      ellVec = [firstEllObj secEllObj];
      dirsMat = [1 3; 2 4];
      ellResVec  = minkSumIa(ellVec, dirsMat )

      Structure(1)
         |
         |----- q : [6 1]
         |          ---------------------
         |----- Q : |7.45135  |0.0272432|
         |          |0.0272432|5.81802  |
         |          ---------------------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----
         O

      Structure(2)
         |
         |----- q : [6 1]
         |          ---------------------
         |----- Q : |7.44698  |0.0315642|
         |          |0.0315642|5.81445  |
         |          ---------------------
         |          -----
         |-- QInf : |0|0|
         |          |0|0|
         |          -----
         O

::

    PLOT - plots ellipsoids in 2D or 3D.


    Usage:
          plot(ell) - plots generic ellipsoid ell in default (red) color.
          plot(ellArr) - plots an array of generic ellipsoids.
          plot(ellArr, 'Property',PropValue,...) - plots ellArr with setting
                                                   properties.

    Input:
      regular:
          ellArr:  elltool.core.GenEllipsoid: [dim11Size,dim12Size,...,
                   dim1kSize] - array of 2D or 3D GenEllipsoids objects.
                   All ellipsoids in ellArr  must be either 2D or 3D
                   simutaneously.
      optional:
          color1Spec: char[1,1] - color specification code, can be 'r','g',
                                  etc (any code supported by built-in Matlab
                                  function).
          ell2Arr: elltool.core.GenEllipsoid: [dim21Size,dim22Size,...,
                                  dim2kSize] - second ellipsoid array...
          color2Spec: char[1,1] - same as color1Spec but for ell2Arr
          ....
          ellNArr: elltool.core.GenEllipsoid: [dimN1Size,dim22Size,...,
                                   dimNkSize] - N-th ellipsoid array
          colorNSpec - same as color1Spec but for ellNArr.
      properties:
          'newFigure': logical[1,1] - if 1, each plot command will open a new .
                       figure window Default value is 0.
          'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
                  if 1, ellipsoids in 2D will be filled with color.
                  Default value is 0.
          'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   line width for 1D and 2D plots.
                   Default value is 1.
          'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
                   sets default colors in the form [x y z].
                   Default value is [1 0 0].
          'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   level of transparency between 0 and 1 (0 - transparent,
                   1 - opaque).
                   Default value is 0.4.
          'relDataPlotter' - relation data plotter object.
          Notice that property vector could have different dimensions, only
          total number of elements must be the same.
    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

    Examples:
      plot([ell1, ell2, ell3], 'color', [1, 0, 1; 0, 0, 1; 1, 0, 0]);
      plot([ell1, ell2, ell3], 'color', [1; 0; 1; 0; 0; 1; 1; 0; 0]);
      plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1, 1, 1; 1, 1,
        1]);
      plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1; 1; 1; 1; 1;
          1]);
      plot([ell1, ell2, ell3], 'shade', 0.5);
      plot([ell1, ell2, ell3], 'lineWidth', 1.5);
      plot([ell1, ell2, ell3], 'lineWidth', [1.5, 0.5, 3]);

::

    Example:
      ellObj = elltool.core.GenEllipsoid([1;1],eye(2));
      dirsVec = [1; 0];
      [resRho, bndPVec] = rho(ellObj, dirsVec)

      resRho =

           2

     bndPVec =

           2
           1

smartdb.relations.ATypifiedStaticRelation
-----------------------------------------

::

    ATYPIFIEDSTATICRELATION is a constructor of static relation class
    object

    Usage: self=AStaticRelation(obj) or
           self=AStaticRelation(varargin)

    Input:
      optional
        inpObj: ARelation[1,1]/SData: struct[1,1]
            structure with values of all fields
            for all tuples

        SIsNull: struct [1,1] - structure of fields with is-null
           information for the field content, it can be logical for
           plain real numbers of cell of logicals for cell strs or
           cell of cell of str for more complex types

        SIsValueNull: struct [1,1] - structure with logicals
            determining whether value corresponding to each field
            and each tuple is null or not

      properties:
          fillMissingFieldsWithNulls: logical[1,1] - if true,
              the relation fields absent in the input data
              structures are filled with null values

    Output:
      regular:
        self: ATYPIFIEDSTATICRELATION [1,1] - constructed class object

    Note: In the case the first interface is used, SData and
          SIsNull are taken from class object obj

::

    ADDDATA - adds a set of field values to existing data in a form of new
              tuples

    Input:
      regular:
         self:ARelation [1,1] - class object

::

    ADDDATAALONGDIM - adds a set of field values to existing data using
                      a concatenation along a specified dimension

    Input:
      regular:
          self: CubeStruct [1,1] - the object

::

    ADDTUPLES - adds a set of new tuples to the relation

    Usage: addTuplesInternal(self,varargin)

    input:
      regular:
          self: ARelation [1,1] - class object
          SData: struct [1,1] - structure with values of all fields  for all
           tuples
      optional:
          SIsNull: struct [1,1] - structure of fields with is-null
            information for the field content, it can be logical for plain
            real numbers of cell of logicals for cell strs or cell of cell of
            str for more complex types

          SIsValueNull: struct [1,1] - structure with logicals determining
            whether value corresponding to each field and each tuple is null
            or not

      properties:
          checkConsistency: logical[1,1], if true, a consistency between the
             input structures is not checked, true by default

::

    APPLYGETFUNC - applies a function to the specified fields as columns, i.e.
                   the function is applied to each field as whole, not to
                   each cell separately

    Input:
      regular:
          hFunc: function_handle[1,1] - function to apply to each of the
             field values
      optional:
          toFieldNameList: char/cell[1,] of char - a list of fields to which
             the function specified by hFunc is to be applied

        Note: hFunc can optionally be specified after toFieldNameList
              parameter

    Notes: this function currently has a lots of limitations:
      1) it assumes that the output is uniform
      2) the function is applies to SData part of field value
      3) no additional arguments can be passed
      All this limitations will eventually go away though so stay tuned...

::

    APPLYSETFUNC - applies some function to each cell of the specified fields
                   of a given CubeStruct object

    Usage: applySetFunc(self,toFieldNameList,hFunc)
           applySetFunc(self,hFunc,toFieldNameList)

    Input:
      regular:
          self: CubeStruct [1,1] - class object

          hFunc: function handle [1,1] - handle of function to be
            applied to fields, the function is assumed to
              1) have the same number of input/output arguments
              2) the number of input arguments should be
                 length(structNameList)*length(fieldNameList)
              3) the input arguments should be ordered according to the
              following rule
                  (x_struct_1_field_1,x_struct_1_field_2,...,struct_n_field1,
                  ...,struct_n_field_m)

      optional:

          toFieldNameList: char or char cell [1,nFields] - list of
            field names to which given function should be applied

            Note1: field lists of length>1 are not currently supported !
            Note2: it is possible to specify toFieldNameList before hFunc in
               which case the parameters will be recognized automatically

      properties:
          uniformOutput: logical[1,1] - specifies if the result
             of the function is uniform to be stored in non-cell
             field, by default it is false for cell fileds and
             true for non-cell fields

          structNameList: char[1,]/cell[1,], name of data structure/list of
            data structure names to which the function is to
                 be applied, can be composed from the following values

               SData - data itself

               SIsNull - contains is-null indicator information for data
                 values

               SIsValueNull - contains is-null indicators for CubeStruct
                  cells (not for cell values)

            structNameList={'SData'} by default

          inferIsNull: logical[1,2] - if the first(second) element is true,
              SIsNull(SIsValueNull) indicators are inferred from SData,
              i.e. with this indicator set to true it is sufficient to apply
              the function only to SData while the rest of the structures
              will be adjusted automatically.

          inputType: char[1,] - specifies a way in which the field value is
             partitioned into individual cells before being passed as an
             input parameter to hFunc. This parameter directly corresponds to
             outputType parameter of toArray method, see its documentation
             for a list of supported input types.

::

    APPLYTUPLEGETFUNC - applies a function to the specified fields
                        separately to each tuple

    Input:
      regular:
          hFunc: function_handle[1,1] - function to apply to the specified
             fields
      optional:
          toFieldNameList: char/cell[1,] of char - a list of fields to which
             the function specified by hFunc is to be applied

      properties:
          uniformOutput: logical[1,1] - if true, output is expected to be
              uniform as in cellfun with 'UniformOutput'=true, default
               value is true

    Output:
      funcOut1Arr: <type1>[] - array corresponding to the first output of the
          applied function
              ....
      funcOutNArr: <typeN>[] - array corresponding to the last output of the
          applied function


    Notes: this function currently has a lots of limitations:
      1) the function is applies to SData part of field value
      2) no additional arguments can be passed
      All this limitations will eventually go away though so stay tuned...

::

    CLEARDATA - deletes all the data from the object

    Usage: self.clearData(self)

    Input:
      regular:
        self: CubeStruct [1,1] - class object

::

    CLONE - creates a copy of a specified object via calling
            a copy constructor for the object class

    Input:
      regular:
        self: any [] - current object
      optional
        any parameters applicable for relation constructor

    Ouput:
      self: any [] - constructed object

::

    COPYFROM - reconstruct CubeStruct object within a current object using the
               input CubeStruct object as a prototype

    Input:
      regular:
        self: CubeStruct [n_1,...,n_k]
        obj: any [] - internal representation of the object

      optional:
        fieldNameList: cell[1,nFields] - list of fields to copy

::

    CREATEINSTANCE - returns an object of the same class by calling a default
                     constructor (with no parameters)

    Usage: resObj=getInstance(self)

    input:
      regular:
        self: any [] - current object
      optional
        any parameters applicable for relation constructor

    Ouput:
      self: any [] - constructed object

::

    DISPONUI - displays a content of the given relation as a data grid UI
               component.

    Input:
      regular:
          self:
      properties:
          tableType: char[1,] - type of table used for displaying the data,
              the following types are supported:
              'sciJavaGrid' - proprietary Java-based data grid component
                  is used
              'uitable'  - Matlab built-in uitable component is used.
                  if not specified, the method tries to use sciJavaGrid
                  if it is available, if not - uitable is used.

    Output:
      hFigure: double[1,1] - figure handle containing the component
      gridObj: smartdb.relations.disp.UIDataGrid[1,1] - data grid component
          instance used for displaying a content of the relation object

::

    DISPLAY - puts some textual information about CubeStruct object in screen

    Input:
     regular:
         self.

::

    FROMSTRUCTLIST - creates a dynamic relation from a list of structures
                     interpreting each structure as the data for
                     several tuples.

    Input:
      regular:
          className: name of object class which will be created,
              the class constructor should accept 2 properties:
              'fieldNameList' and 'fieldTypeSpecList'

          structList: cell[] of struct[1,1] - list of structures

    Output:
      relDataObj: smartdb.relations.DynamicRelation[1,1] -
         constructed relation

::

    GETCOPY - returns an object copy

    Usage: resObj=getCopy(self)

    Input:
      regular:
        self: CubeStruct [1,1] - current CubeStruct object
      optional:
        same as for getData

::

    GETDATA - returns an indexed projection of CubeStruct object's content

    Input:
      regular:
          self: CubeStruct [1,1] - the object

      optional:

          subIndCVec:
            Case#1: numeric[1,]/numeric[,1]

            Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
                  for i=1,...,nDims

              -array of indices of field value slices that are selected
              to be returned; if not given (default),
              no indexation is performed

            Note!: numeric components of subIndVec are allowed to contain
               zeros which are be treated as they were references to null
               data slices

          dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
              numbers corresponding to subIndCVec

      properties:

          fieldNameList: char[1,]/cell[1,nFields] of char[1,]
              list of field names to return

          structNameList: char[1,]/cell[1,nStructs] of char[1,]
              list of internal structures to return (by default it
              is {SData, SIsNull, SIsValueNull}

          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all the cells,
                  default value is false

          nullReplacements: cell[1,nReplacedFields]  - list of null
              replacements for each of the fields

          nullReplacementFields: cell[1,nReplacedFields] - list of fields in
             which the nulls are to be replaced with the specified values,
             if not specified it is assumed that all fields are to be
             replaced

             NOTE!: all fields not listed in this parameter are replaced with
             the default values

          checkInputs: logical[1,1] - true by default (input arguments are
             checked for correctness

    Output:
      regular:
        SData: struct [1,1] - structure containing values of
            fields at the selected slices, each field is an array
            containing values of the corresponding type

        SIsNull: struct [1,1] - structure containing a nested
            array with is-null indicators for each CubeStruct cell content

        SIsValueNull: struct [1,1] - structure containing a
           logical array [] for each of the fields (true
           means that a corresponding cell doesn't not contain
              any value

::

    GETFIELDDESCRLIST - returns the list of CubeStruct field descriptions

    Usage: value=getFieldDescrList(self)

    Input:
      regular:
          self: CubeStruct [1,1]
      optional:
          fieldNameList: cell[1,nSpecFields] of char[1,] - field names for
             which descriptions should be returned

    Output:
      regular:
        value: char cell [1,nFields] - list of CubeStruct object field
            descriptions

::

    GETFIELDISNULL - returns for given field a nested logical/cell array
                     containing is-null indicators for cell content

    Usage: fieldIsNullCVec=getFieldIsNull(self,fieldName)

    Input:
      regular:
        self: CubeStruct [1,1]
        fieldName: char - field name
    Output:
      regular:
        fieldIsCVec: logical/cell[] - nested cell/logical array containing
           is-null indicators for content of the field

::

    GETFIELDISVALUENULL - returns for given field logical vector determining
                          whether value of this field in each cell is null
                          or not.

    BEWARE OF confusing this with getFieldIsNull method which returns is-null
       indicators for a field content

    Usage: isNullVec=getFieldValueIsNull(self,fieldName)

    Input:
      regular:
        self: CubeStruct [1,1]
        fieldName: char - field name

    Output:
      regular:
        isValueNullVec: logical[] - array of isValueNull indicators for the
           specified field

::

    GETFIELDNAMELIST - returns the list of CubeStruct object field names

    Usage: value=getFieldNameList(self)

    Input:
      regular:
        self: CubeStruct [1,1]
    Iutput:
      regular:
        value: char cell [1,nFields] - list of CubeStruct object field
            names

::

    GETFIELDPROJECTION - project object with specified fields.

    Input:
      regular:
          self: ARelation[1,1] - original object
          fieldNameList: cell[1,nFields] of char[1,] - field name list

    Output:
      obj: DynamicRelation[1,1] - projected object

::

    GETFIELDTYPELIST - returns list of field types in given CubeStruct object

    Usage: fieldTypeList=getFieldTypeList(self)

    Input:
      regular:
          self: CubeStruct [1,1]

      optional:
          fieldNameList: cell[1,nFields] - list of field names

    Output:
     regular:
      fieldTypeList: cell [1,nFields] of smartdb.cubes.ACubeStructFieldType[1,1]
          - list of field types

::

    GETFIELDTYPESPECLIST - returns a list of field type specifications. Field
                           type specification is a sequence of type names
                           corresponding to field value types starting with
                           the top level and going down into the nested
                           content of a field (for a field having a complex
                           type).

    Input:
      regular:
          self:
      optional:
          fieldNameList: cell [1,nFields] of char[1,] - list of field names
      properties:
          uniformOutput: logical[1,1] - if true, the result is concatenated
             across all the specified fields

    Output:
      typeSpecList:
           Case#1: uniformOutput=false
              cell[1,nFields] of cell[1,nNestedLevels_i] of char[1,.]
           Case#2: uniformOutput=true
              cell[1,nFields*prod(nNestedLevelsVec)] of char[1,.]
           - list of field type specifications

::

    GETFIELDVALUESIZEMAT - returns a matrix composed from the size vectors
                           for the specified fields

    Input:
      regular:
          self:

      optional:
          fieldNameList: cell[1,nFields] - a list of fileds for which the size
             matrix is to be generated

      properties:
          skipMinDimensions: logical[1,1] - if true, the dimensions from 1 up
              to minDimensionality are skipped

          minDimension: numeric[1,1] - minimum dimension which definies a
             minimum number of columns in the resulting matrix

    Output:
      sizeMat: double[nFields,nMaxDims]

::

    GETISFIELDVALUENULL - returns a vector indicating whether a particular
                          field is composed of null values completely

    Usage: isValueNullVec=getIsFieldValueNull(self,fieldNameList)

    Input:
      regular:
        self: CubeStruct [1,1]

      optional:
        fieldNameList: cell[1,nFields] of char[1,] - list of field names

    Output:
      regular:
        isValueNullVec: logical[1,nFields]

::

    GETJOINWITH - returns a result of INNER join of given relation with
                  another relation by the specified key fields

    LIMITATION: key fields by which the join is peformed are required to form
    a unique key in the given relation

    Input:
      regular:
          self:
          otherRel: smartdb.relations.ARelation[1,1]
          keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

      properties:
          joinType: char[1,] - type of join, can be
              'inner' (DEFAULT)
              'leftOuter'

    Output:
      resRel: smartdb.relations.ARelation[1,1] - join result

::

    GETMINDIMENSIONSIZE - returns a size vector for the specified
                          dimensions. If no dimensions are specified, a size
                          vector for all dimensions up to minimum CubeStruct
                          dimension is returned

    Input:
      regular:
          self:
      optional:
          dimNumVec: numeric[1,nDims] - a vector of dimension
              numbers

    Output:
      minDimensionSizeVec: double [1,nDims] - a size vector for
         the requested dimensions

::

    GETMINDIMENSIONALITY - returns a minimum dimensionality for a given
                           object

    Input:
      regular:
          self

    Output:
      minDimensionality: double[1,1] - minimum dimensionality of
         self object

::

    GETNELEMS - returns a number of elements in a given object
    Input:
      regular:
         self:

    Output:
      nElems:double[1, 1] - number of elements in a given object

::

    GETNFIELDS - returns number of fields in given object

    Usage: nFields=getNFields(self)

    Input:
      regular:
        self: CubeStruct [1,1]
    Output:
      regular:
        nFields: double [1,1] - number of fields in given object

::

    GETNTUPLES - returns number of tuples in given relation

    Usage: nTuples=getNTuples(self)

    input:
      regular:
        self: ARelation [1,1] - class object
    output:
      regular:
        nTuples: double [1,1] - number of tuples in given  relation

::

    GETSORTINDEX - gets sort index for all tuples of given relation with
                   respect to some of its fields

    Usage: sortInd=getSortIndex(self,sortFieldNameList,varargin)

    input:
      regular:
        self: ARelation [1,1] - class object
        sortFieldNameList: char or char cell [1,nFields] - list of field
           names with respect to which tuples are sorted

      properties:
        Direction: char or char cell [1,nFields] - direction of sorting for
            all fields (if one value is given) or for each field separately;
            each value may be 'asc' or 'desc'
    output:
      regular:
       sortIndex: double [nTuples,1] - sort index for all tuples such that if
           fieldValueVec is a vector of values for some field of given
           relation, then fieldValueVec(sortIndex) is a vector of values for
           this field when tuples of the relation are sorted

::

    GETTUPLES - selects tuples with given indices from given relation and
                returns the result as new relation

    Usage: obj=getTuples(self,subIndVec)

    input:
      regular:
        self: ARelation [1,1] - class object
        subIndVec: double [nSubTuples,1]/logical[nTuples,1] - array of
            indices for tuples that are selected
    output:
      regular:
        obj: ARelation [1,1] - new class object containing only selected
            tuples

::

    GETTUPLESFILTEREDBY - selects tuples from given relation such that a
                          fixed index field contains values from a given set
                          of value and returns the result as new relation

    Input:
      regular:
        self: ARelation [1,1] - class object
        filterFieldName: char - name of index field
        filterValueVec: numeric/ cell of char [nValues,1] - vector of index
            values

      properties:
        keepNulls: logical[1,1] - if true, null values are not filteed out,
           and removed otherwise,
              default: false

    Output:
      regular:
        obj: ARelation [1,1] - new class object containing only selected
            tuples
        isThereVec: logical[nTuples,1] - contains true for the kept tuples

::

     GETTUPLESINDEXEDBY - selects tuples from given relation such that fixed
                          index field contains given in a specified order
                          values and returns the result as new relation.
                          It is required that the original relation
                          contains only one record for each field value

     input:
       regular:
         self: ARelation [1,1] - class object
         indexFieldName: char - name of index field
         indexValueVec: numeric or char cell [nValues,1] - vector of index
             values
     output:
       regular:
         obj: ARelation [1,1] - new class object containing only selected
             tuples

    TODO add type check

::

    GETTUPLESJOINEDWITH - returns the tuples of the given relation
                          INNER-joined with other relation by the specified
                          key fields

    Input:
      regular:
          self:
          otherRel: smartdb.relations.ARelation[1,1]
          keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

      properties:
          joinType: char[1,] - type of join, can be
              'inner' (DEFAULT) - inner join
              'leftOuter' - left outer join
              'rightOuter' - right outer join
              'fullOuter' - full outer join

          fieldDescrSource: char[1,] - defines where the field descriptions
             are taken from, can be
              'useOriginal' - field descriptions are taken from the left hand
                  side argument of the join operation
              'useOther' - field descriptions are taken from the right hand
                  side of the join operation

    Output:
      resRel: smartdb.relations.ARelation[1,1] - join result

::

    GETUNIQUEDATA - returns internal representation for a set of unique
                    tuples for given relation

    Usage: [SData,SIsNull,SIsValueNull]=getUniqueData(self,varargin)

    Input:
      regular:
        self: ARelation [1,1] - class object
      properties
          fieldNameList: list of field names used for finding the unique
              elements; only the specified fields are returned in SData,
              SIsNull,SIsValueNull structures
          structNameList: list of internal structures to return (by default it
              is {SData, SIsNull, SIsValueNull}
          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all the tuples
                  default value is false

    Output:
      regular:

        SData: struct [1,1] - structure containing values of fields in
            selected tuples, each field is an array containing values of the
            corresponding type

        SIsNull: struct [1,1] - structure containing info whether each value
            in selected tuples is null or not, each field is either logical
            array or cell array containing logical arrays

        SIsValueNull: struct [1,1] - structure containing a
           logical array [nTuples,1] for each of the fields (true
           means that a corresponding cell doesn't not contain
              any value

        indForward: double[1,nUniqueTuples] - indices of unique entries in
           the original tuple set

        indBackward: double[1,nTuples] - indices that map the unique tuple
           set back to the original tuple set

::

    GETUNIQUEDATAALONGDIM - returns internal representation of CubeStruct

    Input:
      regular:
        self:
        catDim: double[1,1] - dimension number along which uniqueness is
           checked

      properties
          fieldNameList: list of field names used for finding the unique
              elements; only the specified fields are returned in SData,
              SIsNull,SIsValueNull structures
          structNameList: list of internal structures to return (by default
              it is {SData, SIsNull, SIsValueNull}
          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all CubeStruct cells
                  default value is false
          checkInputs: logical[1,1] - if true, the input parameters are
             checked for consistency

    Output:
      regular:
        SData: struct [1,1] - structure containing values of fields

        SIsNull: struct [1,1] - structure containing info whether each value
            in selected cells is null or not, each field is either logical
            array or cell array containing logical arrays

        SIsValueNull: struct [1,1] - structure containing a
           logical array [nSlices,1] for each of the fields (true
           means that a corresponding cell doesn't not contain
              any value

        indForwardVec: double[nUniqueSlices,1] - indices of unique entries in
           the original CubeStruct data set

        indBackwardVec: double[nSlices,1] - indices that map the unique data
           set back to the original data setdata set unique along a specified
           dimension

::

    GETUNIQUETUPLES - returns a relation containing the unique tuples from
                      the original relation

    Usage: [resRel,indForwardVec,indBackwardVec]=getUniqueTuples(self,varargin)

    Input:
      regular:
        self: ARelation [1,1] - class object
      properties
          fieldNameList: list of field names used for finding the unique
             tuples
          structNameList: list of internal structures to return (by default it
              is {SData, SIsNull, SIsValueNull}
          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all the tuples
                  default value is false

    Output:
      regular:

        resRel: ARelation[1,1] - resulting relation

        indForward: double[1,nUniqueTuples] - indices of unique entries in
           the original tuple set

        indBackward: double[1,nTuples] - indices that map the unique tuple
           set back to the original tuple set

::

    INITBYEMPTYDATASET - initializes cube struct object with null value arrays
                         of specified size based on minDimVec specified.

    For instance, if minDimVec=[2,3,4,5,6] and minDimensionality of cube
    struct object cb is 2, then cb.initByEmptyDataSet(minDimVec) will create
    a cube struct object with element array of [2,3] size where each element
    has size of [4,5,6,0]

    Input:
      regular:
          self:
      optional
          minDimVec: double[1,nDims] - size vector of null value arrays

::

    INITBYDEFAULTDATASET - initializes cube struct object with null value
                           arrays of specified size based on minDimVec
                           specified.

    For instance, if minDimVec=[2,3,4,5,6] and minDimensionality of cube
    struct object cb is 2, then cb.initByEmptyDataSet(minDimVec) will create
    a cube struct object with element array of [2,3] size where each element
    has size of [4,5,6]

    Input:
      regular:
          self:
      optional
          minDimVec: double[1,nDims] - size vector of null value arrays

::

    ISEQUAL - compares current relation object with other relation object and
              returns true if they are equal, otherwise it returns false


    Usage: isEq=isEqual(self,otherObj)

    Input:
      regular:
        self: ARelation [1,1] - current relation object
        otherObj: ARelation [1,1] - other relation object

      properties:
        checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
            in compared relations must be in the same order, otherwise the
            order is not  important (false by default)
        checkTupleOrder: logical[1,1] -  if true, then the tuples in the
            compared relations are expected to be in the same order,
            otherwise the order is not important (false by default)

        maxTolerance: double [1,1] - maximum allowed tolerance

        compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
            referenced from the meta data objects are also compared

        maxRelativeTolerance: double [1,1] - maximum allowed
        relative tolerance

    Output:
      isEq: logical[1,1] - result of comparison
      reportStr: char[1,] - report of comparsion

::

     ISFIELDS - returns whether all fields whose names are given in the input
                list are in the field list of given object or not

     Usage: isPositive=isFields(self,fieldList)

     Input:
       regular:
         self: CubeStruct [1,1]
         fieldList: char or char cell [1,nFields]/[nFields,1] - input list of
             given field names
     Output:
       isPositive: logical [1,1] - true if all gields whose
           names are given in the input list are in the field
           list of given object, false otherwise

       isUniqueNames: logical[1,1] - true if the specified names contain
          unique field values

       isThereVec: logical[1,nFields] - each element indicate whether the
           corresponding field is present in the cube

    TODO allow for varargins

::

    ISMEMBERALONGDIM - performs ismember operation of CubeStruct data slices
                       along the specified dimension
    Input:
      regular:
        self: ARelation [1,1] - class object
        other: ARelation [1,1] - other class object
        dim: double[1,1] - dimension number for ismember operation

      properties:
        keyFieldNameList/fieldNameList: char or char cell [1,nKeyFields] -
            list  of fields to which ismember is applied; by default all
            fields of first (self) object are used


    Output:
      regular:
        isThere: logical [nSlices,1] - determines for each data slice of the
            first (self) object whether combination of values for key fields
            is in the second (other) object or not
        indTheres: double [nSlices,1] - zero if the corresponding coordinate
            of isThere is false, otherwise the highest index of the
            corresponding data slice in the second (other) object

::

    ISMEMBER - performs ismember operation for tuples of two relations by key
               fields given by special list

    Usage: isTuple=isMemberTuples(self,otherRel,keyFieldNameList) or
           [isTuple indTuples]=isMemberTuples(self,otherRel,keyFieldNameList)

    Input:
      regular:
        self: ARelation [1,1] - class object
        other: ARelation [1,1] - other class object
      optional:
        keyFieldNameList: char or char cell [1,nKeyFields] - list of fields
            to which ismember is applied; by default all fields of first
            (self) object are used
    Output:
      regular:
        isTuple: logical [nTuples,1] - determines for each tuple of first
            (self) object whether combination of values for key fields is in
            the second (other) relation or not
        indTuples: double [nTuples,1] - zero if the corresponding coordinate
            of isTuple is false, otherwise the highest index of the
            corresponding tuple in the second (other) relation

::

    ISUNIQUEKEY - checks if a specified set of fields forms a unique key

    Usage: isPositive=self.isUniqueKey(fieldNameList)

    Input:
      regular:
          self: ARelation [1,1] - class object
          fieldNameList: cell[1,nFields] - list of field names for a unique
              key candidate
    Output:
      isPositive: logical[1,1] - true means that a specified set of fields is
         a unique key

::

    ISEQUAL - compares current relation object with other relation object and
              returns true if they are equal, otherwise it returns false


    Usage: isEq=isEqual(self,otherObj)

    Input:
      regular:
        self: ARelation [1,1] - current relation object
        otherObj: ARelation [1,1] - other relation object

      properties:
        checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
            in compared relations must be in the same order, otherwise the
            order is not  important (false by default)
        checkTupleOrder: logical[1,1] -  if true, then the tuples in the
            compared relations are expected to be in the same order,
            otherwise the order is not important (false by default)

        maxTolerance: double [1,1] - maximum allowed tolerance

        compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
            referenced from the meta data objects are also compared

        maxRelativeTolerance: double [1,1] - maximum allowed
        relative tolerance

    Output:
      isEq: logical[1,1] - result of comparison
      reportStr: char[1,] - report of comparsion

::

    REMOVEDUPLICATETUPLES - removes all duplicate tuples from the relation

    Usage: [indForwardVec,indBackwardVec]=...
               removeDuplicateTuples(self,varargin)

    Input:
      regular:
        self: ARelation [1,1] - class object

      properties:
          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values for all fields uniformly across all
              relation tuples
                  default value is false

    Output:
      optional:
        indForwardVec: double[nUniqueSlices,1] - indices of unique tuples in
           the original relation

        indBackwardVec: double[nSlices,1] - indices that map the unique
           tuples back to the original tuples

::

    REMOVETUPLES - removes tuples with given indices from given relation

    Usage: self.removeTuples(subIndVec)

    Input:
      regular:
        self: ARelation [1,1] - class object
        subIndVec: double [nSubTuples,1]/logical[nTuples,1] - array of
           indices for tuples that are selected to be removed

::

    REORDERDATA - reorders cells of CubeStruct object along the specified
                  dimensions according to the specified index vectors

    Input:
      regular:
          self: CubeStruct [1,1] - the object
          subIndCVec: numeric[1,]/cell[1,nDims] of double [nSubElem_i,1]
              for i=1,...,nDims array of indices of field value slices that
              are selected to be returned;
              if not given (default), no indexation is performed

      optional:
          dimVec: numeric[1,nDims] - vector of dimension numbers
              corresponding to subIndCVec

::

    SAVEOBJ- transforms given CubeStruct object into structure containing
             internal representation of object properties

    Input:
      regular:
        self: CubeStruct [nDim1,...,nDim2]


    Output:
      regular:
        SObjectData: struct [n1,...,n_k] - structure containing an internal
           representation of the specified object

::

    SETDATA - sets values of all cells for all fields

    Input:
      regular:
        self: CubeStruct[1,1]

      optional:
        SData: struct [1,1] - structure with values of all cells for
            all fields

        SIsNull: struct [1,1] - structure of fields with is-null
           information for the field content, it can be logical for
           plain real numbers of cell of logicals for cell strs or
           cell of cell of str for more complex types

        SIsValueNull: struct [1,1] - structure with logicals
            determining whether value corresponding to each field
            and field cell is null or not

      properties:
          fieldNameList: cell[1,] of char[1,] - list of fields for which data
              should be generated, if not specified, all fields from the
              relation are taken

          isConsistencyCheckedVec: logical [1,1]/[1,2]/[1,3] -
              the first element defines if a consistency between the value
                  elements (data, isNull and isValueNull) is checked;
              the second element (if specified) defines if
                  value's type is checked.
              the third element defines if consistency between of sizes
                  between different fields is checked
                If isConsistencyCheckedVec
                  if scalar, it is automatically replicated to form a
                      3-element vector
                  if the third element is not specified it is assumed
                      to be true

          transactionSafe: logical[1,1], if true, the operation is performed
             in a transaction-safe manner

          checkStruct: logical[1,nStruct] - an array of indicators which when
             all true force checking of structure content (including presence
             of required fields). The first element correspod to SData, the
             second and the third (if specified) to SIsNull and SIsValueNull
             correspondingly

          structNameList: char[1,]/cell[1,], name of data structure/list of
            data structure names to which the function is to
                 be applied, can be composed from the following values

               SData - data itself

               SIsNull - contains is-null indicator information for data
                    values

               SIsValueNull - contains is-null indicators for CubeStruct cells
                   (not for cell values)
            structNameList={'SData'} by default

          fieldMetaData: smartdb.cubes.CubeStructFieldInfo[1,] - field meta
             data array which is used for data validity checking and for
             replacing the existing meta-data

          mdFieldNameList: cell[1,] of char - list of names of fields for
             which meta data is specified

          dataChangeIsComplete: logical[1,1] - indicates whether a change
              performed by the function is complete

    Note: call of setData with an empty list of arguments clears
       the data

::

    SETFIELDINTERNAL - sets values of all cells for given field

    Usage: setFieldInternal(self,fieldName,value)

    Input:
      regular:
        self: CubeStruct [1,1]
        fieldName: char - name of field
        value: array [] of some type - field values

      optional:
        isNull: logical/cell[]
        isValueNull: logical[]

      properties:
        structNameList: list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}

        inferIsNull: logical[1,2] - the first (second) element = false
          means that IsNull (IsValueNull) indicator for a field in question
              is kept intact (default = [true,true])

          Note: if structNameList contains 'SIsValueNull' entry,
           inferIsValueNull parameter is overwritten by false

::

    SORTBY - sorts all tuples of given relation with respect to some of its
             fields

    Usage: sortBy(self,sortFieldNameList,varargin)

    input:
      regular:
        self: ARelation [1,1] - class object
        sortFieldNameList: char or char cell [1,nFields] - list of field
            names with respect to which tuples are sorted
      properties:
        direction: char or char cell [1,nFields] - direction of sorting for
            all fields (if one value is given) or for each field separately;
            each value may be 'asc' or 'desc'

::

    SORTBYALONGDIM -  sorts data of given CubeStruct object along the
                      specified dimension using the specified fields

    Usage: sortByInternal(self,sortFieldNameList,varargin)

    input:
      regular:
        self: CubeStruct [1,1] - class object
        sortFieldNameList: char or char cell [1,nFields] - list of field
            names with respect to which field content is sorted
        sortDim: numeric[1,1] - dimension number along which the sorting is
           to be performed
        properties:
        direction: char or char cell [1,nFields] - direction of sorting for
            all fields (if one value is given) or for each field separately;
            each value may be 'asc' or 'desc'

::

    TOARRAY - transforms values of all CubeStruct cells into a multi-
              dimentional array

    Usage: resCArray=toArray(self,varargin)

    Input:
      regular:
        self: CubeStruct [1,1]

      properties:
        checkInputs: logical[1,1] - if false, the method skips checking the
           input parameters for consistency

        fieldNameList: cell[1,] - list of filed names to return

        structNameList: cell[1,]/char[1,], data structure list
           for which the data is to be taken from, can consist of the
           following values

          SData - data itself
          SIsNull - contains is-null indicator information for data values
          SIsValueNull - contains is-null indicators for CubeStruct cells
             (not for cell values)

        groupByColumns: logical[1,1], if true, each column is returned in a
           separate cell

        outputType: char[1,] - method of formign an output array, the
           following methods are supported:
               'uniformMat' - the field values are concatenated without any
                       type/size transformations. As a result, this method
                       will fail if the specified fields have different types
                       or/and sizes along any dimension apart from catDim

               'uniformCell' - not-cell fields are converted to cells
                       element-wise but no size-transformations is performed.
                       This method will fail if the specified fields have
                       different sizes along any dimension apart from catDim

               'notUniform' - this method doesn't make any assumptions about
                       size or type of the fields. Each field value is wrapped
                       into cell in a such way that a size of resulting cell
                       is minDimensionSizeVec for each field. Thus if for
                       instance is size of cube object is [2,3,4] and a field
                       size is [2,4,5,10,30] its value is splitted into 2*4*5
                       pieces with each piece of size [1,1,1,10,30] put it
                       its separate cell
               'adaptiveCell' - functions similarly to 'nonUniform' except for
                       the cases when a field value size equals
                       minDimensionSizeVec exactly i.e. the field takes only
                       scalar values. In such cases no wrapping into cell is
                       performed which allows to get a more transparent
                       output.

        catDim: double[1,1] - dimension number for
           concatenating outputs when groupByColumns is false


        replaceNull: logical[1,1], if true, null values from SData are
           replaced by null replacement, = true by default

        nullTopReplacement: - can be of any type and currently only applicable
          when  UniformOutput=false and of
          the corresponding column type if UniformOutput=true.

          Note!: this parameter is disregarded for any dataStructure different
             from 'SData'.

          Note!: the main difference between this parameter and the following
             parameters is that nullTopReplacement can violate field type
             constraints thus allowing to replace doubles with strings for
             instance (for non-uniform output types only of course)


        nullReplacements: cell[1,nReplacedFields]  - list of null
           replacements for each of the fields

        nullReplacementFields: cell[1,nReplacedFields] - list of fields in
           which the nulls are to be replaced with the specified values,
           if not specified it is assumed that all fields are to be replaced

           NOTE!: all fields not listed in this parameter are replaced with
           the default values


    Output:
      Case1 (one output is requested and length(structNameList)==1):

          resCMat: matrix/cell[]  with values of all fields (or
            fields selected by optional arguments) for all CubeStruct
            data cells

      Case2 (multiple outputs are requested and their number =
        length(structNameList) each output is assigned resCMat for the
        corresponding struct

      Case3 (2 outputs is requested or length(structNameList)+1 outputs is
      requested). In this case the last output argument is

           isConvertedToCell: logical[nFields,nStructs] -  matrix with true
              values on the positions which correspond to fields converted to
              cells

::

    TOCELL - transforms values of all fields for all tuples into two
             dimensional cell array

    Usage: resCMat=toCell(self,varargin)

    input:
      regular:
        self: ARelation [1,1] - class object
      optional:
        fieldName1: char - name of first field
        ...
        fieldNameN: char - name of N-th field
    output:
      resCMat: cell [nTuples,nFields(N)] - cell with values of all fields (or
          fields selected by optional arguments) for all tuples

    FIXME - order fields in setData method

::

    TOCELLISNULL - transforms is-null indicators of all fields for all tuples
                   into two dimensional cell array

    Usage: resCMat=toCell(self,varargin)

    input:
      regular:
        self: ARelation [1,1] - class object
      optional:
        fieldName1: char - name of first field
        ...
        fieldNameN: char - name of N-th field
    output:
      resCMat: cell [nTuples,nFields(N)] - cell with values of all fields (or
          fields selected by optional arguments) for all tuples

    FIXME - order fields in setData method

::

    TODISPCELL - transforms values of all fields into their character
                 representation

    Usage: resCMat=toDispCell(self)

    Input:
      regular:
        self: ARelation [1,1] - class object

      properties:
          nullTopReplacement: any[1,1] - value used to replace null values
          fieldNameList: cell[1,] of char[1,] - field name list

    Output:
      dataCell: cell[nRows,nCols] of char[1,] - cell array containing the
          character representation of field values

::

    TOMAT - transforms values of all fields for all tuples into two
            dimensional array

    Usage: resCMat=toMat(self,varargin)

    input:
      regular:
        self: ARelation [1,1] - class object

      optional:
        fieldNameList: cell[1,] - list of filed names to return

        uniformOutput: logical[1,1], true - cell is returned, false - the
           functions tries to return a result as a matrix

        groupByColumns: logical[1,1], if true, each column is returned in a
           separate cell

        structNameList/dataStructure: char[1,], data structure for which the
           data is to be taken from, can have one of the following values

          SData - data itself
          SIsNull - contains is-null indicator information for data values
          SIsValueNull - contains is-null indicators for relation cells (not
             for cell values

        replaceNull: logical[1,1], if true, null values from SData are
           replaced by null replacement, = true by default

        nullTopReplacement: - can be of any type and currently only applicable
          when  UniformOutput=false and of
          the corresponding column type if UniformOutput=true.

          Note!: this parameter is disregarded for any dataStructure different
             from 'SData'.

          Note!: the main difference between this parameter and the following
             parameters is that nullTopReplacement can violate field type
             constraints thus allowing to replace doubles with strings for
             instance (for non-uniform output types only of course)


        nullReplacements: cell[1,nReplacedFields]  - list of null
           replacements for each of the fields

        nullReplacementFields: cell[1,nReplacedFields] - list of fields in
           which the nulls are to be replaced with the specified values,
           if not specified it is assumed that all fields are to be replaced

           NOTE!: all fields not listed in this parameter are replaced with
           the default values

    output:
      resCMat:  [nTuples,nFields(N)] - matrix/cell with values of all fields
          (or fields selected by optional arguments) for all tuples

::

    TOSTRUCT - transforms given CubeStruct object into structure

    Input:
      regular:
        self: CubeStruct [nDim1,...,nDim2]


    Output:
      regular:
        SObjectData: struct [n1,...,n_k] - structure containing an internal
           representation of the specified object

::

    UNIONWITH - adds tuples of the input relation to the set of tuples of the
                original relation
    Usage: self.unionWith(inpRel)

    Input:
      regular:
        self: ARelation [1,1] - class object
        inpRel1: ARelation [1,1] - object to get the additional tuples from
          ...
        inpRelN: ARelation [1,1] - object to get the additional tuples from

      properties:
          checkType: logical[1,1] - if true, union is only performed when the
              types of relations is the same. Default value is false

          checkStruct: logical[1,nStruct] - an array of indicators which when
             true force checking of structure content (including presence
             of all required fields). The first element correspod to SData,
             the second and the third (if specified) to SIsNull and
             SIsValueNull correspondingly

          checkConsistency: logical [1,1]/[1,2] - the
              first element defines if a consistency between the value
              elements (data, isNull and isValueNull) is checked;
              the second element (if specified) defines if
              value's type is checked. If isConsistencyChecked
              is scalar, it is automatically replicated to form a
              two-element vector.
              Note: default value is true

::

    UNIONWITHALONGDIM - adds data from the input CubeStructs

    Usage: self.unionWithAlongDim(unionDim,inpCube)

    Input:
      regular:
      self:
          inpCube1: CubeStruct [1,1] - object to get the additional data from
              ...
          inpCubeN: CubeStruct [1,1] - object to get the additional data from

      properties:
          checkType: logical[1,1] - if true, union is only performed when the
              types of relations is the same. Default value is false

          checkStruct: logical[1,nStruct] - an array of indicators which when
             true force checking of structure content (including presence of
    all required fields). The first element correspod to SData, the
             second and the third (if specified) to SIsNull and SIsValueNull
             correspondingly

          checkConsistency: logical [1,1]/[1,2] - the
              first element defines if a consistency between the value
              elements (data, isNull and isValueNull) is checked;
              the second element (if specified) defines if
              value's type is checked. If isConsistencyChecked
              is scalar, it is automatically replicated to form a
              two-element vector.
              Note: default value is true

::

    WRITETOCSV - writes a content of relation into Excel spreadsheet file
    Input:
      regular:
          self:
          filePath: char[1,] - file path

    Output:
      none

::

    WRITETOXLS - writes a content of relation into Excel spreadsheet file
    Input:
      regular:
          self:
          filePath: char[1,] - file path

    Output:
      fileName: char[1,] - resulting file name, may not match with filePath
          when Excel is not available and csv format is used instead

gras.ellapx.smartdb.rels.EllTube
--------------------------------

::

    EllTube - class which keeps ellipsoidal tubes

    Fields:
      QArray:cell[1, nElem] - Array of ellipsoid matrices
      aMat:cell[1, nElem] - Array of ellipsoid centers
      scaleFactor:double[1, 1] - Tube scale factor
      MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
      dim :double[1, 1] - Dimensionality
      sTime:double[1, 1] - Time s
      approxSchemaName:cell[1,] - Name
      approxSchemaDescr:cell[1,] - Description
      approxType:gras.ellapx.enums.EApproxType - Type of approximation
                    (external, internal, not defined)
      timeVec:cell[1, m] - Time vector
      calcPrecision:double[1, 1] - Calculation precision
      indSTime:double[1, 1]  - index of sTime within timeVec
      ltGoodDirMat:cell[1, nElem] - Good direction curve
      lsGoodDirVec:cell[1, nElem] - Good direction at time s
      ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
      lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
      xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                      direction
      xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                        opposite to good direction
      xsTouchVec:cell[1, nElem]  - Touch point at time s
      xsTouchOpVec :cell[1, nElem] - Touch point at time s

      TODO: correct description of the fields in gras.ellapx.smartdb.rels.EllTube

See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:

::

    CAT  - concatenates data from relation objects.

    Input:
      regular:
          self.
          newEllTubeRel: smartdb.relation.StaticRelation[1, 1]/
              smartdb.relation.DynamicRelation[1, 1] - relation object
      properties:
          isReplacedByNew: logical[1,1] - if true, sTime and
              values of properties corresponding to sTime are taken
              from newEllTubeRel. Common times in self and
              newEllTubeRel are allowed, however the values for
              those times are taken either from self or from
              newEllTubeRel depending on value of isReplacedByNew
              property

          isCommonValuesChecked: logical[1,1] - if true, values
              at common times (if such are found) are checked for
              strong equality (with zero precision). If not equal
              - an exception is thrown. True by default.

          commonTimeAbsTol: double[1,1] - absolute tolerance used
              for comparing values at common times, =0 by default

          commonTimeRelTol: double[1,1] - absolute tolerance used
              for comparing values at common times, =0 by default

    Output:
      catEllTubeRel:smartdb.relation.StaticRelation[1, 1]/
          smartdb.relation.DynamicRelation[1, 1] - relation object
          resulting from CAT operation

::

::

    FROMELLARRAY  - creates a relation object using an array of ellipsoids

    Input:
      regular:
        qEllArray: ellipsoid[nDim1, nDim2, ..., nDimN] - array of ellipsoids

      optional:
       timeVec:cell[1, m] - time vector
       ltGoodDirArray:cell[1, nElem] - good direction at time s
       sTime:double[1, 1] - time s
       approxType:gras.ellapx.enums.EApproxType - type of approximation
                    (external, internal, not defined)
       approxSchemaName:cell[1,] - name of the schema
       approxSchemaDescr:cell[1,] - description of the schema
       calcPrecision:double[1, 1] - calculation precision

    Output:
       ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
           object

::

    FROMELLMARRAY  - creates a relation object using an array of ellipsoids.
                     This method uses regularizer in the form of a matrix
                     function.

    Input:
      regular:
        qEllArray: ellipsoid[nDim1, nDim2, ..., nDimN] - array of ellipsoids
        ellMArr: double[nDim1, nDim2, ..., nDimN] - regularization ellipsoid
            matrices

      optional:
       timeVec:cell[1, m] - time vector
       ltGoodDirArray:cell[1, nElem] - good direction at time s
       sTime:double[1, 1] - time s
       approxType:gras.ellapx.enums.EApproxType - type of approximation
                    (external, internal, not defined)
       approxSchemaName:cell[1,] - name of the schema
       approxSchemaDescr:cell[1,] - description of the schema
       calcPrecision:double[1, 1] - calculation precision

    Output:
       ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
             object

::

    FROMQARRAYS  - creates a relation object using an array of ellipsoids,
                   described by the array of ellipsoid matrices and
                   array of ellipsoid centers.This method used default
                   scale factor.

    Input:
      regular:
        QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
            matrices
        aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers

    Optional:
       MArrayList:cell[1, nElem] - array of regularization ellipsoid matrices
       timeVec:cell[1, m] - time vector
       ltGoodDirArray:cell[1, nElem] - good direction at time s
       sTime:double[1, 1] - time s
       approxType:gras.ellapx.enums.EApproxType - type of approximation
                    (external, internal, not defined)
       approxSchemaName:cell[1,] - name of the schema
       approxSchemaDescr:cell[1,] - description of the schema
       calcPrecision:double[1, 1] - calculation precision

    Output:
       ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
           object

::

    FROMQMARRAYS  - creates a relation object using an array of ellipsoids,
                    described by the array of ellipsoid matrices and
                    array of ellipsoid centers. Also this method uses
                    regularizer in the form of a matrix function. This method
                    used default scale factor.

    Input:
      regular:
      QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
            matrices
      aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers
      MArrayList: double[nDim1, nDim2, ..., nDimN] - ellipsoid  matrices of
            regularization

     optional:
       timeVec:cell[1, m] - time vector
       ltGoodDirArray:cell[1, nElem] - good direction at time s
       sTime:double[1, 1] - time s
       approxType:gras.ellapx.enums.EApproxType - type of approximation
                    (external, internal, not defined)
       approxSchemaName:cell[1,] - name of the schema
       approxSchemaDescr:cell[1,] - description of the schema
       calcPrecision:double[1, 1] - calculation precision

    Output:
       ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
             object

::

    FROMQMSCALEDARRAYS  - creates a relation object using an array of ellipsoids,
                          described by the array of ellipsoid matrices and
                          array of ellipsoid centers. Also this method uses
                          regularizer in the form of a matrix function.


    Input:
      regular:
        QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
            matrices
        aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers
        MArrayList: double[nDim1, nDim2, ..., nDimN] - ellipsoid matrices
                  of regularization
        scaleFactor:double[1, 1] - tube scale factor

     optional:
       timeVec:cell[1, m] - time vector
       ltGoodDirArray:cell[1, nElem] - good direction at time s
       sTime:double[1, 1] - time s
       approxType:gras.ellapx.enums.EApproxType - type of approximation
                    (external, internal, not defined)
       approxSchemaName:cell[1,] - name of the schema
       approxSchemaDescr:cell[1,] - description of the schema
       calcPrecision:double[1, 1] - calculation precision

    Output:
       ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
             object

::

    GETDATA - returns an indexed projection of CubeStruct object's content

    Input:
      regular:
          self: CubeStruct [1,1] - the object

      optional:

          subIndCVec:
            Case#1: numeric[1,]/numeric[,1]

            Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
                  for i=1,...,nDims

              -array of indices of field value slices that are selected
              to be returned; if not given (default),
              no indexation is performed

            Note!: numeric components of subIndVec are allowed to contain
               zeros which are be treated as they were references to null
               data slices

          dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
              numbers corresponding to subIndCVec

      properties:

          fieldNameList: char[1,]/cell[1,nFields] of char[1,]
              list of field names to return

          structNameList: char[1,]/cell[1,nStructs] of char[1,]
              list of internal structures to return (by default it
              is {SData, SIsNull, SIsValueNull}

          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all the cells,
                  default value is false

          nullReplacements: cell[1,nReplacedFields]  - list of null
              replacements for each of the fields

          nullReplacementFields: cell[1,nReplacedFields] - list of fields in
             which the nulls are to be replaced with the specified values,
             if not specified it is assumed that all fields are to be
             replaced

             NOTE!: all fields not listed in this parameter are replaced with
             the default values

          checkInputs: logical[1,1] - true by default (input arguments are
             checked for correctness

    Output:
      regular:
        SData: struct [1,1] - structure containing values of
            fields at the selected slices, each field is an array
            containing values of the corresponding type

        SIsNull: struct [1,1] - structure containing a nested
            array with is-null indicators for each CubeStruct cell content

        SIsValueNull: struct [1,1] - structure containing a
           logical array [] for each of the fields (true
           means that a corresponding cell doesn't not contain
              any value

::

    GETELLARRAY - returns array of matrix's ellipsoid according to
                  approxType

    Input:
     regular:
        self.
        approxType:char[1,] - type of approximation(internal/external)

    Output:
      apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
               matrices

::

    GETJOINWITH - returns a result of INNER join of given relation with
                  another relation by the specified key fields

    LIMITATION: key fields by which the join is peformed are required to form
    a unique key in the given relation

    Input:
      regular:
          self:
          otherRel: smartdb.relations.ARelation[1,1]
          keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

      properties:
          joinType: char[1,] - type of join, can be
              'inner' (DEFAULT)
              'leftOuter'

    Output:
      resRel: smartdb.relations.ARelation[1,1] - join result

::

::

::

    ISEQUAL - compares current relation object with other relation object and
              returns true if they are equal, otherwise it returns false


    Usage: isEq=isEqual(self,otherObj)

    Input:
      regular:
        self: ARelation [1,1] - current relation object
        otherObj: ARelation [1,1] - other relation object

      properties:
        checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
            in compared relations must be in the same order, otherwise the
            order is not  important (false by default)
        checkTupleOrder: logical[1,1] -  if true, then the tuples in the
            compared relations are expected to be in the same order,
            otherwise the order is not important (false by default)

        maxTolerance: double [1,1] - maximum allowed tolerance

        compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
            referenced from the meta data objects are also compared

        maxRelativeTolerance: double [1,1] - maximum allowed
        relative tolerance

    Output:
      isEq: logical[1,1] - result of comparison
      reportStr: char[1,] - report of comparsion

::

    PLOT - displays ellipsoidal tubes using the specified RelationDataPlotter


    Input:
      regular:
          self:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
              object used for displaying ellipsoidal tubes

::

    PROJECT - computes projection of the relation object onto given time
              dependent subspase
    Input:
      regular:
          self.
          projType: gras.ellapx.enums.EProjType[1,1] -
              type of the projection, can be
              'Static' and 'DynamicAlongGoodCurve'
          projMatList: cell[1,nProj] of double[nSpDim,nDim] - list of
              projection matrices, not necessarily orthogonal
       fGetProjMat: function_handle[1,1] - function which creates
          vector of the projection
                matrices
           Input:
            regular:
              projMat:double[nDim, mDim] - matrix of the projection at the
                instant of time
              timeVec:double[1, nDim] - time interval
            optional:
               sTime:double[1,1] - instant of time
           Output:
              projOrthMatArray:double[1, nSpDim] - vector of the projection
                matrices
              projOrthMatTransArray:double[nSpDim, 1] - transposed vector of
                the projection matrices
    Output:
       ellTubeProjRel: gras.ellapx.smartdb.rels.EllTubeProj[1, 1]/
           gras.ellapx.smartdb.rels.EllTubeUnionProj[1, 1] -
              projected ellipsoidal tube

       indProj2OrigVec:cell[nDim, 1] - index of the line number from
                which is obtained the projection

    Example:
      function example
       aMat = [0 1; 0 0]; bMat = eye(2);
       SUBounds = struct();
       SUBounds.center = {'sin(t)'; 'cos(t)'};
       SUBounds.shape = [9 0; 0 2];
       sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
       x0EllObj = ell_unitball(2);
       timeVec = [0 10];
       dirsMat = [1 0; 0 1]';
       rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
       ellTubeObj = rsObj.getEllTubeRel();
       unionEllTube = ...
        gras.ellapx.smartdb.rels.EllUnionTube.fromEllTubes(ellTubeObj);
       projMatList = {[1 0;0 1]};
       projType = gras.ellapx.enums.EProjType.Static;
       statEllTubeProj = unionEllTube.project(projType,projMatList,...
          @fGetProjMat);
       plObj=smartdb.disp.RelationDataPlotter();
       statEllTubeProj.plot(plObj);
    end

    function [projOrthMatArray,projOrthMatTransArray]=fGetProjMat(projMat,...
        timeVec,varargin)
      nTimePoints=length(timeVec);
      projOrthMatArray=repmat(projMat,[1,1,nTimePoints]);
      projOrthMatTransArray=repmat(projMat.',[1,1,nTimePoints]);
     end

::

::

    PROJECTTOORTHS - project elltube onto subspace defined by
    vectors of standart basis with indices specified in indVec

    Input:
      regular:
          self: gras.ellapx.smartdb.rels.EllTube[1, 1] - elltube
              object
          indVec: double[1, nProjDims] - indices specifying a subset of
              standart basis
      optional:
          projType: gras.ellapx.enums.EProjType[1, 1] -  type of
              projection

    Output:
      regular:
          ellTubeProjRel: gras.ellapx.smartdb.rels.EllTubeProj[1, 1] -
              elltube projection

    Example:
      ellTubeProjRel = ellTubeRel.projectToOrths([1,2])
      projType = gras.ellapx.enums.EProjType.DynamicAlongGoodCurve
      ellTubeProjRel = ellTubeRel.projectToOrths([3,4,5], projType)

::

    SCALE - scales relation object

     Input:
      regular:
         self.
         fCalcFactor - function which calculates factor for
                        fields in fieldNameList
           Input:
             regular:
               fieldNameList: char/cell[1,] of char - a list of fields
                      for which factor will be calculated
            Output:
                factor:double[1, 1] - calculated factor

          fieldNameList:cell[1,nElem]/char[1,] - names of the fields

     Output:
          none

    Example:
      nPoints=5;
      calcPrecision=0.001;
      approxSchemaDescr=char.empty(1,0);
      approxSchemaName=char.empty(1,0);
      nDims=3;
      nTubes=1;
      lsGoodDirVec=[1;0;1];
      aMat=zeros(nDims,nPoints);
      timeVec=1:nPoints;
      sTime=nPoints;
      approxType=gras.ellapx.enums.EApproxType.Internal;
      qArrayList=repmat({repmat(diag([1 2 3]),[1,1,nPoints])},1,nTubes);
      ltGoodDirArray=repmat(lsGoodDirVec,[1,nTubes,nPoints]);
      fromMatEllTube=...
            gras.ellapx.smartdb.rels.EllTube.fromQArrays(qArrayList,...
            aMat, timeVec,ltGoodDirArray, sTime, approxType,...
            approxSchemaName, approxSchemaDescr, calcPrecision);
      fromMatEllTube.scale(@(varargin)2,{});

::

::

gras.ellapx.smartdb.rels.EllTubeProj
------------------------------------

::

    EllTubeProj - class which keeps ellipsoidal tube's projection

    Fields:
      QArray:cell[1, nElem] - Array of ellipsoid matrices
      aMat:cell[1, nElem] - Array of ellipsoid centers
      scaleFactor:double[1, 1] - Tube scale factor
      MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
      dim :double[1, 1] - Dimensionality
      sTime:double[1, 1] - Time s
      approxSchemaName:cell[1,] - Name
      approxSchemaDescr:cell[1,] - Description
      approxType:gras.ellapx.enums.EApproxType - Type of approximation
                    (external, internal, not defined)
      timeVec:cell[1, m] - Time vector
      calcPrecision:double[1, 1] - Calculation precision
      indSTime:double[1, 1]  - index of sTime within timeVec
      ltGoodDirMat:cell[1, nElem] - Good direction curve
      lsGoodDirVec:cell[1, nElem] - Good direction at time s
      ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
      lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
      xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                      direction
      xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                        opposite to good direction
      xsTouchVec:cell[1, nElem]  - Touch point at time s
      xsTouchOpVec:cell[1, nElem] - Touch point at time s
      projSTimeMat: cell[1, 1] - Projection matrix at time s
      projType:gras.ellapx.enums.EProjType - Projection type
      ltGoodDirNormOrigVec:cell[1, 1] - Norm of the original (not
                                        projected) good direction curve
      lsGoodDirNormOrig:double[1, 1] - Norm of the original (not
                                       projected)good direction at time s
      lsGoodDirOrigVec:cell[1, 1] - Original (not projected) good
                                    direction at time s

    TODO: correct description of the fields in
        gras.ellapx.smartdb.rels.EllTubeProj

See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:

::

::

    GETDATA - returns an indexed projection of CubeStruct object's content

    Input:
      regular:
          self: CubeStruct [1,1] - the object

      optional:

          subIndCVec:
            Case#1: numeric[1,]/numeric[,1]

            Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
                  for i=1,...,nDims

              -array of indices of field value slices that are selected
              to be returned; if not given (default),
              no indexation is performed

            Note!: numeric components of subIndVec are allowed to contain
               zeros which are be treated as they were references to null
               data slices

          dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
              numbers corresponding to subIndCVec

      properties:

          fieldNameList: char[1,]/cell[1,nFields] of char[1,]
              list of field names to return

          structNameList: char[1,]/cell[1,nStructs] of char[1,]
              list of internal structures to return (by default it
              is {SData, SIsNull, SIsValueNull}

          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all the cells,
                  default value is false

          nullReplacements: cell[1,nReplacedFields]  - list of null
              replacements for each of the fields

          nullReplacementFields: cell[1,nReplacedFields] - list of fields in
             which the nulls are to be replaced with the specified values,
             if not specified it is assumed that all fields are to be
             replaced

             NOTE!: all fields not listed in this parameter are replaced with
             the default values

          checkInputs: logical[1,1] - true by default (input arguments are
             checked for correctness

    Output:
      regular:
        SData: struct [1,1] - structure containing values of
            fields at the selected slices, each field is an array
            containing values of the corresponding type

        SIsNull: struct [1,1] - structure containing a nested
            array with is-null indicators for each CubeStruct cell content

        SIsValueNull: struct [1,1] - structure containing a
           logical array [] for each of the fields (true
           means that a corresponding cell doesn't not contain
              any value

::

    GETELLARRAY - returns array of matrix's ellipsoid according to
                  approxType

    Input:
     regular:
        self.
        approxType:char[1,] - type of approximation(internal/external)

    Output:
      apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
               matrices

::

    GETJOINWITH - returns a result of INNER join of given relation with
                  another relation by the specified key fields

    LIMITATION: key fields by which the join is peformed are required to form
    a unique key in the given relation

    Input:
      regular:
          self:
          otherRel: smartdb.relations.ARelation[1,1]
          keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

      properties:
          joinType: char[1,] - type of join, can be
              'inner' (DEFAULT)
              'leftOuter'

    Output:
      resRel: smartdb.relations.ARelation[1,1] - join result

::

::

    GETREACHTUBEANEPREFIX - return prefix of the reach tube

    Input:
      regular:
         self.

::

    GETREGTUBEANEPREFIX - return prefix of the reg tube

    Input:
      regular:
         self.

::

::

    ISEQUAL - compares current relation object with other relation object and
              returns true if they are equal, otherwise it returns false


    Usage: isEq=isEqual(self,otherObj)

    Input:
      regular:
        self: ARelation [1,1] - current relation object
        otherObj: ARelation [1,1] - other relation object

      properties:
        checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
            in compared relations must be in the same order, otherwise the
            order is not  important (false by default)
        checkTupleOrder: logical[1,1] -  if true, then the tuples in the
            compared relations are expected to be in the same order,
            otherwise the order is not important (false by default)

        maxTolerance: double [1,1] - maximum allowed tolerance

        compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
            referenced from the meta data objects are also compared

        maxRelativeTolerance: double [1,1] - maximum allowed
        relative tolerance

    Output:
      isEq: logical[1,1] - result of comparison
      reportStr: char[1,] - report of comparsion

::

    PLOT - displays ellipsoidal tubes using the specified
      RelationDataPlotter

    Input:
      regular:
          self:
      optional:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
              object used for displaying ellipsoidal tubes
      properties:
          fGetColor: function_handle[1, 1] -
              function that specified colorVec for
              ellipsoidal tubes
          fGetAlpha: function_handle[1, 1] -
              function that specified transparency
              value for ellipsoidal tubes
          fGetLineWidth: function_handle[1, 1] -
              function that specified lineWidth for good curves
          fGetFill: function_handle[1, 1] - this
              property not used in this version
          colorFieldList: cell[nColorFields, ] of char[1, ] -
              list of parameters for color function
          alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
              list of parameters for transparency function
          lineWidthFieldList: cell[nLineWidthFields, ]
              of char[1, ] - list of parameters for lineWidth
              function
          fillFieldList: cell[nIsFillFields, ] of char[1, ] -
              list of parameters for fill function
          plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
              defaul list of parameters. If for any function in
              properties not specified list of parameters,
              this one will be used

    Output:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
              object used for displaying ellipsoidal tubes

::

    PLOTEXT - plots external approximation of ellTube.


    Usage:
          obj.plotExt() - plots external approximation of ellTube.
          obj.plotExt('Property',PropValue,...) - plots external approximation
                                                  of ellTube with setting
                                                  properties.

    Input:
      regular:
          obj:  EllTubeProj: EllTubeProj object
      optional:
          relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
          colorSpec: char[1,1] - color specification code, can be 'r','g',
                       etc (any code supported by built-in Matlab function).

      properties:

          fGetColor: function_handle[1, 1] -
              function that specified colorVec for
              ellipsoidal tubes
          fGetAlpha: function_handle[1, 1] -
              function that specified transparency
              value for ellipsoidal tubes
          fGetLineWidth: function_handle[1, 1] -
              function that specified lineWidth for good curves
          fGetFill: function_handle[1, 1] - this
              property not used in this version
          colorFieldList: cell[nColorFields, ] of char[1, ] -
              list of parameters for color function
          alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
              list of parameters for transparency function
          lineWidthFieldList: cell[nLineWidthFields, ]
              of char[1, ] - list of parameters for lineWidth
              function
          fillFieldList: cell[nIsFillFields, ] of char[1, ] -
              list of parameters for fill function
          plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
              defaul list of parameters. If for any function in
              properties not specified list of parameters,
              this one will be used
          'showDiscrete':logical[1,1]  -
              if true, approximation in 3D will be filled in every time slice
          'nSpacePartPoins': double[1,1] -
              number of points in every time slice.
    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

::

    PLOTINT - plots internal approximation of ellTube.


    Usage:
          obj.plotInt() - plots internal approximation of ellTube.
          obj.plotInt('Property',PropValue,...) - plots internal approximation
                                                  of ellTube with setting
                                                  properties.

    Input:
      regular:
          obj:  EllTubeProj: EllTubeProj object
      optional:
          relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
          colorSpec: char[1,1] - color specification code, can be 'r','g',
                       etc (any code supported by built-in Matlab function).

      properties:

          fGetColor: function_handle[1, 1] -
              function that specified colorVec for
              ellipsoidal tubes
          fGetAlpha: function_handle[1, 1] -
              function that specified transparency
              value for ellipsoidal tubes
          fGetLineWidth: function_handle[1, 1] -
              function that specified lineWidth for good curves
          fGetFill: function_handle[1, 1] - this
              property not used in this version
          colorFieldList: cell[nColorFields, ] of char[1, ] -
              list of parameters for color function
          alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
              list of parameters for transparency function
          lineWidthFieldList: cell[nLineWidthFields, ]
              of char[1, ] - list of parameters for lineWidth
              function
          fillFieldList: cell[nIsFillFields, ] of char[1, ] -
              list of parameters for fill function
          plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
              defaul list of parameters. If for any function in
              properties not specified list of parameters,
              this one will be used
          'showDiscrete':logical[1,1]  -
              if true, approximation in 3D will be filled in every time slice
          'nSpacePartPoins': double[1,1] -
              number of points in every time slice.
    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

::

::

::

::

gras.ellapx.smartdb.rels.EllUnionTube
-------------------------------------

::

    EllUionTube - class which keeps ellipsoidal tubes by the instant of
                  time

    Fields:
      QArray:cell[1, nElem] - Array of ellipsoid matrices
      aMat:cell[1, nElem] - Array of ellipsoid centers
      scaleFactor:double[1, 1] - Tube scale factor
      MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
      dim :double[1, 1] - Dimensionality
      sTime:double[1, 1] - Time s
      approxSchemaName:cell[1,] - Name
      approxSchemaDescr:cell[1,] - Description
      approxType:gras.ellapx.enums.EApproxType - Type of approximation
                    (external, internal, not defined
      timeVec:cell[1, m] - Time vector
      calcPrecision:double[1, 1] - Calculation precision
      indSTime:double[1, 1]  - index of sTime within timeVec
      ltGoodDirMat:cell[1, nElem] - Good direction curve
      lsGoodDirVec:cell[1, nElem] - Good direction at time s
      ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
      lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
      xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                      direction
      xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                        opposite to good direction
      xsTouchVec:cell[1, nElem]  - Touch point at time s
      xsTouchOpVec :cell[1, nElem] - Touch point at time s
      ellUnionTimeDirection:gras.ellapx.enums.EEllUnionTimeDirection -
                         Direction in time along which union is performed
      isLsTouch:logical[1, 1] - Indicates whether a touch takes place
                                along LS
      isLsTouchOp:logical[1, 1] - Indicates whether a touch takes place
                                  along LS opposite
      isLtTouchVec:cell[1, nElem] - Indicates whether a touch takes place
                                    along LT
      isLtTouchOpVec:cell[1, nElem] - Indicates whether a touch takes
                                      place along LT opposite
      timeTouchEndVec:cell[1, nElem] - Touch point curve for good
                                       direction
      timeTouchOpEndVec:cell[1, nElem] - Touch point curve for good
                                         direction

    TODO: correct description of the fields in
        gras.ellapx.smartdb.rels.EllUnionTube

See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:

::

::

    FROMELLTUBES - returns union of the ellipsoidal tubes on time

    Input:
       ellTubeRel: smartdb.relation.StaticRelation[1, 1]/
          smartdb.relation.DynamicRelation[1, 1] - relation
          object

    Output:
    ellUnionTubeRel: ellapx.smartdb.rel.EllUnionTube - union of the
                ellipsoidal tubes

::

    GETDATA - returns an indexed projection of CubeStruct object's content

    Input:
      regular:
          self: CubeStruct [1,1] - the object

      optional:

          subIndCVec:
            Case#1: numeric[1,]/numeric[,1]

            Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
                  for i=1,...,nDims

              -array of indices of field value slices that are selected
              to be returned; if not given (default),
              no indexation is performed

            Note!: numeric components of subIndVec are allowed to contain
               zeros which are be treated as they were references to null
               data slices

          dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
              numbers corresponding to subIndCVec

      properties:

          fieldNameList: char[1,]/cell[1,nFields] of char[1,]
              list of field names to return

          structNameList: char[1,]/cell[1,nStructs] of char[1,]
              list of internal structures to return (by default it
              is {SData, SIsNull, SIsValueNull}

          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all the cells,
                  default value is false

          nullReplacements: cell[1,nReplacedFields]  - list of null
              replacements for each of the fields

          nullReplacementFields: cell[1,nReplacedFields] - list of fields in
             which the nulls are to be replaced with the specified values,
             if not specified it is assumed that all fields are to be
             replaced

             NOTE!: all fields not listed in this parameter are replaced with
             the default values

          checkInputs: logical[1,1] - true by default (input arguments are
             checked for correctness

    Output:
      regular:
        SData: struct [1,1] - structure containing values of
            fields at the selected slices, each field is an array
            containing values of the corresponding type

        SIsNull: struct [1,1] - structure containing a nested
            array with is-null indicators for each CubeStruct cell content

        SIsValueNull: struct [1,1] - structure containing a
           logical array [] for each of the fields (true
           means that a corresponding cell doesn't not contain
              any value

::

    GETELLARRAY - returns array of matrix's ellipsoid according to
                  approxType

    Input:
     regular:
        self.
        approxType:char[1,] - type of approximation(internal/external)

    Output:
      apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
               matrices

::

    GETJOINWITH - returns a result of INNER join of given relation with
                  another relation by the specified key fields

    LIMITATION: key fields by which the join is peformed are required to form
    a unique key in the given relation

    Input:
      regular:
          self:
          otherRel: smartdb.relations.ARelation[1,1]
          keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

      properties:
          joinType: char[1,] - type of join, can be
              'inner' (DEFAULT)
              'leftOuter'

    Output:
      resRel: smartdb.relations.ARelation[1,1] - join result

::

::

::

    ISEQUAL - compares current relation object with other relation object and
              returns true if they are equal, otherwise it returns false


    Usage: isEq=isEqual(self,otherObj)

    Input:
      regular:
        self: ARelation [1,1] - current relation object
        otherObj: ARelation [1,1] - other relation object

      properties:
        checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
            in compared relations must be in the same order, otherwise the
            order is not  important (false by default)
        checkTupleOrder: logical[1,1] -  if true, then the tuples in the
            compared relations are expected to be in the same order,
            otherwise the order is not important (false by default)

        maxTolerance: double [1,1] - maximum allowed tolerance

        compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
            referenced from the meta data objects are also compared

        maxRelativeTolerance: double [1,1] - maximum allowed
        relative tolerance

    Output:
      isEq: logical[1,1] - result of comparison
      reportStr: char[1,] - report of comparsion

::

    PROJECT - computes projection of the relation object onto given time
              dependent subspase
    Input:
      regular:
          self.
          projType: gras.ellapx.enums.EProjType[1,1] -
              type of the projection, can be
              'Static' and 'DynamicAlongGoodCurve'
          projMatList: cell[1,nProj] of double[nSpDim,nDim] - list of
              projection matrices, not necessarily orthogonal
       fGetProjMat: function_handle[1,1] - function which creates
          vector of the projection
                matrices
           Input:
            regular:
              projMat:double[nDim, mDim] - matrix of the projection at the
                instant of time
              timeVec:double[1, nDim] - time interval
            optional:
               sTime:double[1,1] - instant of time
           Output:
              projOrthMatArray:double[1, nSpDim] - vector of the projection
                matrices
              projOrthMatTransArray:double[nSpDim, 1] - transposed vector of
                the projection matrices
    Output:
       ellTubeProjRel: gras.ellapx.smartdb.rels.EllTubeProj[1, 1]/
           gras.ellapx.smartdb.rels.EllTubeUnionProj[1, 1] -
              projected ellipsoidal tube

       indProj2OrigVec:cell[nDim, 1] - index of the line number from
                which is obtained the projection

    Example:
      function example
       aMat = [0 1; 0 0]; bMat = eye(2);
       SUBounds = struct();
       SUBounds.center = {'sin(t)'; 'cos(t)'};
       SUBounds.shape = [9 0; 0 2];
       sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
       x0EllObj = ell_unitball(2);
       timeVec = [0 10];
       dirsMat = [1 0; 0 1]';
       rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
       ellTubeObj = rsObj.getEllTubeRel();
       unionEllTube = ...
        gras.ellapx.smartdb.rels.EllUnionTube.fromEllTubes(ellTubeObj);
       projMatList = {[1 0;0 1]};
       projType = gras.ellapx.enums.EProjType.Static;
       statEllTubeProj = unionEllTube.project(projType,projMatList,...
          @fGetProjMat);
       plObj=smartdb.disp.RelationDataPlotter();
       statEllTubeProj.plot(plObj);
    end

    function [projOrthMatArray,projOrthMatTransArray]=fGetProjMat(projMat,...
        timeVec,varargin)
      nTimePoints=length(timeVec);
      projOrthMatArray=repmat(projMat,[1,1,nTimePoints]);
      projOrthMatTransArray=repmat(projMat.',[1,1,nTimePoints]);
     end

::

::

::

gras.ellapx.smartdb.rels.EllUnionTubeStaticProj
-----------------------------------------------

::

    EllUnionTubeStaticProj - class which keeps projection on static plane
                             union of ellipsoid tubes

    Fields:
      QArray:cell[1, nElem] - Array of ellipsoid matrices
      aMat:cell[1, nElem] - Array of ellipsoid centers
      scaleFactor:double[1, 1] - Tube scale factor
      MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
      dim :double[1, 1] - Dimensionality
      sTime:double[1, 1] - Time s
      approxSchemaName:cell[1,] - Name
      approxSchemaDescr:cell[1,] - Description
      approxType:gras.ellapx.enums.EApproxType - Type of approximation
                    (external, internal, not defined
      timeVec:cell[1, m] - Time vector
      calcPrecision:double[1, 1] - Calculation precision
      indSTime:double[1, 1]  - index of sTime within timeVec
      ltGoodDirMat:cell[1, nElem] - Good direction curve
      lsGoodDirVec:cell[1, nElem] - Good direction at time s
      ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
      lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
      xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                      direction
      xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                        opposite to good direction
      xsTouchVec:cell[1, nElem]  - Touch point at time s
      xsTouchOpVec :cell[1, nElem] - Touch point at time s
      projSTimeMat: cell[1, 1] - Projection matrix at time s
      projType:gras.ellapx.enums.EProjType - Projection type
      ltGoodDirNormOrigVec:cell[1, 1] - Norm of the original (not
                                        projected) good direction curve
      lsGoodDirNormOrig:double[1, 1] - Norm of the original (not
                                       projected)good direction at time s
      lsGoodDirOrigVec:cell[1, 1] - Original (not projected) good
                                    direction at time s
      ellUnionTimeDirection:gras.ellapx.enums.EEllUnionTimeDirection -
                         Direction in time along which union is performed
      isLsTouch:logical[1, 1] - Indicates whether a touch takes place
                                along LS
      isLsTouchOp:logical[1, 1] - Indicates whether a touch takes place
                                  along LS opposite
      isLtTouchVec:cell[1, nElem] - Indicates whether a touch takes place
                                    along LT
      isLtTouchOpVec:cell[1, nElem] - Indicates whether a touch takes
                                      place along LT opposite
      timeTouchEndVec:cell[1, nElem] - Touch point curve for good
                                       direction
      timeTouchOpEndVec:cell[1, nElem] - Touch point curve for good
                                         direction

      TODO: correct description of the fields in
        gras.ellapx.smartdb.rels.EllUnionTubeStaticProj

See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:

::

::

    FROMELLTUBES - returns union of the ellipsoidal tubes on time

    Input:
       ellTubeRel: smartdb.relation.StaticRelation[1, 1]/
          smartdb.relation.DynamicRelation[1, 1] - relation
          object

    Output:
    ellUnionTubeRel: ellapx.smartdb.rel.EllUnionTube - union of the
                ellipsoidal tubes

::

    GETDATA - returns an indexed projection of CubeStruct object's content

    Input:
      regular:
          self: CubeStruct [1,1] - the object

      optional:

          subIndCVec:
            Case#1: numeric[1,]/numeric[,1]

            Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
                  for i=1,...,nDims

              -array of indices of field value slices that are selected
              to be returned; if not given (default),
              no indexation is performed

            Note!: numeric components of subIndVec are allowed to contain
               zeros which are be treated as they were references to null
               data slices

          dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
              numbers corresponding to subIndCVec

      properties:

          fieldNameList: char[1,]/cell[1,nFields] of char[1,]
              list of field names to return

          structNameList: char[1,]/cell[1,nStructs] of char[1,]
              list of internal structures to return (by default it
              is {SData, SIsNull, SIsValueNull}

          replaceNull: logical[1,1] if true, null values are replaced with
              certain default values uniformly across all the cells,
                  default value is false

          nullReplacements: cell[1,nReplacedFields]  - list of null
              replacements for each of the fields

          nullReplacementFields: cell[1,nReplacedFields] - list of fields in
             which the nulls are to be replaced with the specified values,
             if not specified it is assumed that all fields are to be
             replaced

             NOTE!: all fields not listed in this parameter are replaced with
             the default values

          checkInputs: logical[1,1] - true by default (input arguments are
             checked for correctness

    Output:
      regular:
        SData: struct [1,1] - structure containing values of
            fields at the selected slices, each field is an array
            containing values of the corresponding type

        SIsNull: struct [1,1] - structure containing a nested
            array with is-null indicators for each CubeStruct cell content

        SIsValueNull: struct [1,1] - structure containing a
           logical array [] for each of the fields (true
           means that a corresponding cell doesn't not contain
              any value

::

    GETELLARRAY - returns array of matrix's ellipsoid according to
                  approxType

    Input:
     regular:
        self.
        approxType:char[1,] - type of approximation(internal/external)

    Output:
      apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
               matrices

::

    GETJOINWITH - returns a result of INNER join of given relation with
                  another relation by the specified key fields

    LIMITATION: key fields by which the join is peformed are required to form
    a unique key in the given relation

    Input:
      regular:
          self:
          otherRel: smartdb.relations.ARelation[1,1]
          keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

      properties:
          joinType: char[1,] - type of join, can be
              'inner' (DEFAULT)
              'leftOuter'

    Output:
      resRel: smartdb.relations.ARelation[1,1] - join result

::

::

    GETREACHTUBEANEPREFIX - return prefix of the reach tube

    Input:
      regular:
         self.

::

    GETREGTUBEANEPREFIX - return prefix of the reg tube

    Input:
      regular:
         self.

::

::

    ISEQUAL - compares current relation object with other relation object and
              returns true if they are equal, otherwise it returns false


    Usage: isEq=isEqual(self,otherObj)

    Input:
      regular:
        self: ARelation [1,1] - current relation object
        otherObj: ARelation [1,1] - other relation object

      properties:
        checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
            in compared relations must be in the same order, otherwise the
            order is not  important (false by default)
        checkTupleOrder: logical[1,1] -  if true, then the tuples in the
            compared relations are expected to be in the same order,
            otherwise the order is not important (false by default)

        maxTolerance: double [1,1] - maximum allowed tolerance

        compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
            referenced from the meta data objects are also compared

        maxRelativeTolerance: double [1,1] - maximum allowed
        relative tolerance

    Output:
      isEq: logical[1,1] - result of comparison
      reportStr: char[1,] - report of comparsion

::

    PLOT - displays ellipsoidal tubes using the specified
      RelationDataPlotter

    Input:
      regular:
          self:
      optional:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
              object used for displaying ellipsoidal tubes
      properties:
          fGetColor: function_handle[1, 1] -
              function that specified colorVec for
              ellipsoidal tubes
          fGetAlpha: function_handle[1, 1] -
              function that specified transparency
              value for ellipsoidal tubes
          fGetLineWidth: function_handle[1, 1] -
              function that specified lineWidth for good curves
          fGetFill: function_handle[1, 1] - this
              property not used in this version
          colorFieldList: cell[nColorFields, ] of char[1, ] -
              list of parameters for color function
          alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
              list of parameters for transparency function
          lineWidthFieldList: cell[nLineWidthFields, ]
              of char[1, ] - list of parameters for lineWidth
              function
          fillFieldList: cell[nIsFillFields, ] of char[1, ] -
              list of parameters for fill function
          plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
              defaul list of parameters. If for any function in
              properties not specified list of parameters,
              this one will be used

    Output:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
              object used for displaying ellipsoidal tubes

::

    PLOTEXT - plots external approximation of ellTube.


    Usage:
          obj.plotExt() - plots external approximation of ellTube.
          obj.plotExt('Property',PropValue,...) - plots external approximation
                                                  of ellTube with setting
                                                  properties.

    Input:
      regular:
          obj:  EllTubeProj: EllTubeProj object
      optional:
          relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
          colorSpec: char[1,1] - color specification code, can be 'r','g',
                       etc (any code supported by built-in Matlab function).

      properties:

          fGetColor: function_handle[1, 1] -
              function that specified colorVec for
              ellipsoidal tubes
          fGetAlpha: function_handle[1, 1] -
              function that specified transparency
              value for ellipsoidal tubes
          fGetLineWidth: function_handle[1, 1] -
              function that specified lineWidth for good curves
          fGetFill: function_handle[1, 1] - this
              property not used in this version
          colorFieldList: cell[nColorFields, ] of char[1, ] -
              list of parameters for color function
          alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
              list of parameters for transparency function
          lineWidthFieldList: cell[nLineWidthFields, ]
              of char[1, ] - list of parameters for lineWidth
              function
          fillFieldList: cell[nIsFillFields, ] of char[1, ] -
              list of parameters for fill function
          plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
              defaul list of parameters. If for any function in
              properties not specified list of parameters,
              this one will be used
          'showDiscrete':logical[1,1]  -
              if true, approximation in 3D will be filled in every time slice
          'nSpacePartPoins': double[1,1] -
              number of points in every time slice.
    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

::

    PLOTINT - plots internal approximation of ellTube.


    Usage:
          obj.plotInt() - plots internal approximation of ellTube.
          obj.plotInt('Property',PropValue,...) - plots internal approximation
                                                  of ellTube with setting
                                                  properties.

    Input:
      regular:
          obj:  EllTubeProj: EllTubeProj object
      optional:
          relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
          colorSpec: char[1,1] - color specification code, can be 'r','g',
                       etc (any code supported by built-in Matlab function).

      properties:

          fGetColor: function_handle[1, 1] -
              function that specified colorVec for
              ellipsoidal tubes
          fGetAlpha: function_handle[1, 1] -
              function that specified transparency
              value for ellipsoidal tubes
          fGetLineWidth: function_handle[1, 1] -
              function that specified lineWidth for good curves
          fGetFill: function_handle[1, 1] - this
              property not used in this version
          colorFieldList: cell[nColorFields, ] of char[1, ] -
              list of parameters for color function
          alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
              list of parameters for transparency function
          lineWidthFieldList: cell[nLineWidthFields, ]
              of char[1, ] - list of parameters for lineWidth
              function
          fillFieldList: cell[nIsFillFields, ] of char[1, ] -
              list of parameters for fill function
          plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
              defaul list of parameters. If for any function in
              properties not specified list of parameters,
              this one will be used
          'showDiscrete':logical[1,1]  -
              if true, approximation in 3D will be filled in every time slice
          'nSpacePartPoins': double[1,1] -
              number of points in every time slice.
    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

::

::

::

::

elltool.reach.AReach
--------------------

::

::

    CUT - extracts the piece of reach tube from given start time to given
          end time. Given reach set self, find states that are reachable
          within time interval specified by cutTimeVec. If cutTimeVec
          is a scalar, then reach set at given time is returned.

    Input:
      regular:
          self.

       cutTimeVec: double[1, 2]/double[1, 1] - time interval to cut.

    Output:
      cutObj: elltool.reach.IReach[1, 1] - reach set resulting from the CUT
            operation.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      cutObj = rsObj.cut([3 5]);
      dRsObj = elltool.reach.ReachDiscrete(dtsys, x0EllObj, dirsMat, timeVec);
      dCutObj = dRsObj.cut([3 5]);

::


    DIMENSION - returns array of dimensions of given reach set array.

    Input:
      regular:
          self - multidimensional array of
                 ReachContinuous/ReachDiscrete objects

    Output:
      rSdimArr: double[nDim1, nDim2,...] - array of reach set dimensions.
      sSdimArr: double[nDim1, nDim2,...] - array of state space dimensions.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObjArr = rsObj.repMat(1,2);
      [rSdim sSdim] = rsObj.dimension()

      rSdim =

               2


      sSdim =

               2

      [rSdim sSdim] = rsObjArr.dimension()

      rSdim =
              [ 2  2 ]

      sSdim =
              [ 2  2 ]

::


    DISPLAY - displays the reach set object.

    Input:
      regular:
          self.

    Output:
      None.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj.display()

      rsObj =
      Reach set of the continuous-time linear system in R^2 in the time...
           interval [0, 10].

      Initial set at time t0 = 0:
      Ellipsoid with parameters
      Center:
           0
           0

      Shape Matrix:
           1     0
           0     1

      Number of external approximations: 2
      Number of internal approximations: 2

::


    EVOLVE - computes further evolution in time of the
             already existing reach set.

    Input:
      regular:
          self.

          newEndTime: double[1, 1] - new end time.

      optional:
          linSys: elltool.linsys.LinSys[1, 1] - new linear system.

    Output:
      newReachObj: reach[1, 1] - reach set on time  interval
            [oldT0 newEndTime].

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      dRsObj = elltool.reach.ReachDiscrete(dsys, x0EllObj, dirsMat, timeVec);
      newRsObj = rsObj.evolve(12);
      newDRsObj = dRsObj.evolve(11);

::

    GETABSTOL - gives the array of absTol for all elements
      in rsArr

    Input:
      regular:
          rsArr: elltool.reach.AReach[nDim1, nDim2, ...] -
              multidimension array of reach sets
      optional:
          fAbsTolFun: function_handle[1,1] - function that is
              applied to the absTolArr. The default is @min.

    Output:
      regular:
          absTolArr: double [absTol1, absTol2, ...] - return
              absTol for each element in rsArr
      optional:
          absTol: double[1,1] - return result of work fAbsTolFun
              with the absTolArr

    Usage:
      use [~,absTol] = rsArr.getAbsTol() if you want get only
          absTol,
      use [absTolArr,absTol] = rsArr.getAbsTol() if you want
          get absTolArr and absTol,
      use absTolArr = rsArr.getAbsTol() if you want get only
          absTolArr

::

    Input:
      regular:
          self:
      properties:
          l0Mat: double[nDims,nDirs] - matrix of good
              directions at time s
          isIntExtApxVec: logical[1,2] - two element vector with the
             first element corresponding to internal approximations
            and second - to external ones. An element equal to
             false means that the corresponding approximation type
             is filtered out. Default value is [true,true]
    Example:
        aMat = [0 1; 0 0]; bMat = eye(2);
        SUBounds = struct();
        SUBounds.center = {'sin(t)'; 'cos(t)'};
        SUBounds.shape = [9 0; 0 2];
        sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
        x0EllObj = ell_unitball(2);
        timeVec = [0 10];
        dirsMat = [1 0; 0 1; 1 1;1 2]';
        rsObj = elltool.reach.ReachContinuous(sys, x0EllObj,...
          dirsMat, timeVec);

        copyRsObj = rsObj.getCopy()

        Reach set of the continuous-time linear system in R^2 in
          the time interval [0, 10].

        Initial set at time k0 = 0:
        Ellipsoid with parameters
        Center:
             0
             0

        Shape Matrix:
             1     0
             0     1

        Number of external approximations: 4
        Number of internal approximations: 4

        copyRsObj = rsObj.getCopy('l0Mat',[0;1],'approxType',...
          [true,false])

        Reach set of the continuous-time linear system in R^2 in
          the time interval [0, 10].

        Initial set at time k0 = 0:
        Ellipsoid with parameters
        Center:
             0
             0

        Shape Matrix:
             1     0
             0     1

        Number of external approximations: 1
        Number of internal approximations: 1

::

    GET_EASCALEFACTOR - return the scale factor for external approximation
                        of reach tube

    Input:
      regular:
          self.

    Output:
      regular:
          eaScaleFactor: double[1, 1] - scale factor.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [10 0];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj.getEaScaleFactor()

      ans =

          1.0200

::

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj.getEllTubeRel();

::

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      getEllTubeUnionRel(rsObj);

::

    GET_IASCALEFACTOR - return the scale factor for internal approximation
                        of reach tube

    Input:
      regular:
          self.

    Output:
      regular:
          iaScaleFactor: double[1, 1] - scale factor.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [10 0];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj.getIaScaleFactor()

      ans =

          1.0200

::

    GETINITIALSET - return the initial set for linear system, which is solved
                    for building reach tube.

    Input:
      regular:
          self.

    Output:
      regular:
          x0Ell: ellipsoid[1, 1] - ellipsoid x0, which was initial set for
              linear system.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [10 0];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      x0Ell = rsObj.getInitialSet()

      x0Ell =

      Center:
           0
           0

      Shape Matrix:
           1     0
           0     1

      Nondegenerate ellipsoid in R^2.

::

    GETNPLOT2DPOINTS - gives array  the same size as rsArr of
      value of nPlot2dPoints property for each element in rsArr -
      array of reach sets

    Input:
      regular:
        rsArr:elltool.reach.AReach[nDims1,nDims2,...] - reach
          set array

    Output:
      nPlot2dPointsArr:double[nDims1,nDims2,...] - array of
          values of nTimeGridPoints property for each reach set
          in rsArr

::

    GETNPLOT3DPOINTS - gives array  the same size as rsArr of
      value of nPlot3dPoints property for each element in rsArr
      array of reach sets

    Input:
      regular:
          rsArr:reach[nDims1,nDims2,...] - reach set array

    Output:
      nPlot3dPointsArr:double[nDims1,nDims2,...]- array of values
          of nPlot3dPoints property for each reach set in rsArr

::

    GETNTIMEGRIDPOINTS - gives array  the same size as rsArr of
      value of nTimeGridPoints property for each element in rsArr
      array of reach sets

    Input:
      regular:
          rsArr: elltool.reach.AReach [nDims1,nDims2,...] - reach
              set array

    Output:
      nTimeGridPointsArr: double[nDims1,nDims2,...]- array of
          values of nTimeGridPoints property for each reach set
          in rsArr

::

    GETRELTOL - gives the array of relTol for all elements in
    ellArr

    Input:
      regular:
          rsArr: elltool.reach.AReach[nDim1,nDim2, ...] -
              multidimension array of reach sets.
      optional
          fRelTolFun: function_handle[1,1] - function that is
              applied to the relTolArr. The default is @min.

    Output:
      regular:
          relTolArr: double [relTol1, relTol2, ...] - return
              relTol for each element in rsArr.
      optional:
          relTol: double[1,1] - return result of work fRelTolFun
              with the relTolArr

    Usage:
      use [~,relTol] = rsArr.getRelTol() if you want get only
          relTol,
      use [relTolArr,relTol] = rsArr.getRelTol() if you want get
          relTolArr and relTol,
      use relTolArr = rsArr.getRelTol() if you want get only
          relTolArr

::

::


    GET_CENTER - returns the trajectory of the center of the reach set.

    Input:
      regular:
          self.

    Output:
      trCenterMat: double[nDim, nPoints] - array of points that form the
          trajectory of the reach set center, where nDim is reach set
          dimentsion, nPoints - number of points in time grid.

      timeVec: double[1, nPoints] - array of time values.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      [trCenterMat timeVec] = rsObj.get_center();

::


    GET_DIRECTIONS - returns the values of direction vectors for time grid
                     values.

    Input:
      regular:
          self.

    Output:
      directionsCVec: cell[1, nPoints] of double [nDim, nDir] - array of
          cells, where each cell is a sequence of direction vector values
          that correspond to the time values of the grid, where nPoints is
          number of points in time grid.

      timeVec: double[1, nPoints] - array of time values.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      [directionsCVec timeVec] = rsObj.get_directions();

::


    GET_EA - returns array of ellipsoid objects representing external
             approximation of the reach  tube.

    Input:
      regular:
          self.

    Output:
      eaEllMat: ellipsoid[nAppr, nPoints] - array of ellipsoids, where nAppr
          is the number of approximations, nPoints is number of points in time
          grid.

       timeVec: double[1, nPoints] - array of time values.
       l0Mat: double[nDirs,nDims] - matrix of good directions at t0

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      [eaEllMat timeVec] = rsObj.get_ea();

      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
      [eaEllMat timeVec] = dRsObj.get_ea();

::

    GET_GOODCURVES - returns the 'good curve' trajectories of the reach set.

    Input:
      regular:
          self.

    Output:
      goodCurvesCVec: cell[1, nPoints] of double [x, y] - array of cells,
          where each cell is array of points that form a 'good curve'.

      timeVec: double[1, nPoints] - array of time values.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      [goodCurvesCVec timeVec] = rsObj.get_goodcurves();

      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
      [goodCurvesCVec timeVec] = dRsObj.get_goodcurves();

::


    GET_IA - returns array of ellipsoid objects representing internal
             approximation of the  reach tube.

    Input:
      regular:
          self.

    Output:
      iaEllMat: ellipsoid[nAppr, nPoints] - array of ellipsoids, where nAppr
          is the number of approximations, nPoints is number of points in time
          grid.

      timeVec: double[1, nPoints] - array of time values.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      [iaEllMat timeVec] = rsObj.get_ia();

::


    GET_SYSTEM - returns the linear system for which the reach set is
                 computed.

    Input:
      regular:
          self.

    Output:
      linSys: elltool.linsys.LinSys[1, 1] - linear system object.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      linSys = rsObj.get_system()

      self =
      A:
           0     1
           0     0


      B:
           1     0
           0     1


      Control bounds:
         2-dimensional ellipsoid with center
          'sin(t)'
          'cos(t)'

         and shape matrix
           9     0
           0     2


      C:
           1     0
           0     1

      2-input, 2-output continuous-time linear time-invariant system of
              dimension 2:
      dx/dt  =  A x(t)  +  B u(t)
       y(t)  =  C x(t)

      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
      dRsObj.get_system();

::

    INTERSECT - checks if its external (s = 'e'), or internal (s = 'i')
                approximation intersects with given ellipsoid, hyperplane
                or polytop.

    Input:
      regular:
          self.

          intersectObj: ellipsoid[1, 1]/hyperplane[1,1]/polytop[1, 1].

          approxTypeChar: char[1, 1] - 'e' (default) - external approximation,
                                       'i' - internal approximation.

    Output:
      isEmptyIntersect: logical[1, 1] -  true - if intersection is nonempty,
                                         false - otherwise.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      ellObj = ellipsoid([0; 0], 2*eye(2));
      isEmptyIntersect = intersect(rsObj, ellObj)

      isEmptyIntersect =

                      1

::


    ISEMPTY - checks if given reach set array is an array of empty objects.

    Input:
      regular:
          self - multidimensional array of
                 ReachContinuous/ReachDiscrete objects

    Output:
      isEmptyArr: logical[nDim1, nDim2, nDim3,...] -
                  isEmpty(iDim1, iDim2, iDim3,...) = true - if self(iDim1, iDim2, iDim3,...) is empty,
                                                   = false - otherwise.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      dRsObj = elltool.reach.ReachRiscrete(dsys, x0EllObj, dirsMat, timeVec);
      rsObjArr = rsObj.repMat(1,2);
      dRsObjArr = dRsObj.repMat(1,2);
      dRsObj.isEmpty();
      rsObj.isEmpty()

      ans =

           0

      dRsObjArr.isEmpty();
      rsObjArr.isEmpty()

      ans =
          [ 0  0 ]

::

    ISEQUAL - checks for equality given reach set objects

    Input:
      regular:
          self.
          reachObj:
              elltool.reach.AReach[1, 1] - each set object, which
               compare with self.
      optional:
          indTupleVec: double[1,] - tube numbers that are
              compared
          approxType: gras.ellapx.enums.EApproxType[1, 1] -  type of
              approximation, which will be compared.
      properties:
          notComparedFieldList: cell[1,k] - fields not to compare
              in tubes. Default: LT_GOOD_DIR_*, LS_GOOD_DIR_*,
              IND_S_TIME, S_TIME, TIME_VEC
          areTimeBoundsCompared: logical[1,1] - treat tubes with
              different timebounds as inequal if 'true'.
              Default: false

    Output:
      regular:
          ISEQUAL: logical[1, 1] - true - if reach set objects are equal.
              false - otherwise.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      copyRsObj = rsObj.getCopy();
      isEqual = isEqual(rsObj, copyRsObj)

      isEqual =

              1

::

    ISBACKWARD - checks if given reach set object was obtained by solving
                 the system in reverse time.

    Input:
      regular:
          self.

    Output:
      regular:
          isBackward: logical[1, 1] - true - if self was obtained by solving
              in reverse time, false - otherwise.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [10 0];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj.isbackward()

      ans =

           1

::

    ISCUT - checks if given array of reach set objects is a cut of
            another reach set object's array.

    Input:
      regular:
          self - multidimensional array of
                 ReachContinuous/ReachDiscrete objects

    Output:
      isCutArr: logical[nDim1, nDim2, nDim3 ...] -
                isCut(iDim1, iDim2, iDim3,..) = true - if self(iDim1, iDim2, iDim3,...) is a cut of the reach set,
                                              = false - otherwise.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      dRsObj = elltool.reach.ReachRiscrete(dsys, x0EllObj, dirsMat, timeVec);
      cutObj = rsObj.cut([3 5]);
      cutObjArr = cutObj.repMat(2,3,4);
      iscut(cutObj);
      iscut(cutObjArr);
      cutObj = dRsObj.cut([4 8]);
      cutObjArr = cutObj.repMat(1,2);
      iscut(cutObjArr);
      iscut(cutObj);

::


    ISPROJECTION - checks if given array of reach set objects is projections.

    Input:
      regular:
          self - multidimensional array of
                 ReachContinuous/ReachDiscrete objects

    Output:
      isProjArr: logical[nDim1, nDim2, nDim3, ...] -
                 isProj(iDim1, iDim2, iDim3,...) = true - if self(iDim1, iDim2, iDim3,...) is projection,
                                                 = false - otherwise.


    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      dRsObj = elltool.reach.ReachRiscrete(dsys, x0EllObj, dirsMat, timeVec);
      projMat = eye(2);
      projObj = rsObj.projection(projMat);
      projObjArr = projObj.repMat(3,2,2);
      isprojection(projObj);
      isprojection(projObjArr);
      projObj = dRsObj.projection(projMat);
      projObjArr = projObj.repMat(1,2);
      isprojection(projObj);
      isprojection(projObjArr);

::

    plotByEa - plots external approximation of reach tube.


    Usage:
          plotByEa(self,'Property',PropValue,...)
          - plots external approximation of reach tube
               with  setting properties

    Input:
      regular:
          self: - reach tube

      optional:
          relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
          charColor: char[1,1]  - color specification code, can be 'r','g',
                         etc (any code supported by built-in Matlab function).
      properties:

          'fill': logical[1,1]  -
                  if 1, tube in 2D will be filled with color.
                  Default value is true.
          'lineWidth': double[1,1]  -
                       line width for 2D plots. Default value is 2.
          'color': double[1,3] -
                   sets default colors in the form [x y z].
                      Default value is [0 0 1].
          'shade': double[1,1]  -
         level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
                   Default value is 0.3.

    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

::

    plotByIa - plots internal approximation of reach tube.


    Usage:
          plotByIa(self,'Property',PropValue,...)
          - plots internal approximation of reach tube
               with  setting properties

    Input:
      regular:
          self: - reach tube

      optional:
          relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
          charColor: char[1,1]  - color specification code, can be 'r','g',
                         etc (any code supported by built-in Matlab function).
      properties:

          'fill': logical[1,1]  -
                  if 1, tube in 2D will be filled with color.
                  Default value is true.
          'lineWidth': double[1,1]  -
                       line width for 2D plots. Default value is 2.
          'color': double[1,3] -
                   sets default colors in the form [x y z].
                      Default value is [0 1 0].
          'shade': double[1,1]  -
         level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
                   Default value is 0.1.

    Output:
      regular:
          plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
          data plotter object.

::


    PLOT_EA - plots external approximations of 2D and 3D reach sets.

    Input:
      regular:
          self.

      optional:
          colorSpec: char[1, 1] - set color to plot in following way:
                                 'r' - red color,
                                 'g' - green color,
                                 'b' - blue color,
                                 'y' - yellow color,
                                 'c' - cyan color,
                                 'm' - magenta color,
                                 'w' - white color.

          OptStruct: struct[1, 1] with fields:
              color: double[1, 3] - sets color of the picture in the form
                    [x y z].
              width: double[1, 1] - sets line width for 2D plots.
              shade: double[1, 1] in [0; 1] interval - sets transparency level
                    (0 - transparent, 1 - opaque).
               fill: double[1, 1] - if set to 1, reach set will be filled with
                     color.

    Output:
      None.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj.plotEa();
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);

      dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
      dRsObj.plotEa();

::


    PLOTIA - plots internal approximations of 2D and 3D reach sets.

    Input:
      regular:
          self.

      optional:
          colorSpec: char[1, 1] - set color to plot in following way:
                                 'r' - red color,
                                 'g' - green color,
                                 'b' - blue color,
                                 'y' - yellow color,
                                 'c' - cyan color,
                                 'm' - magenta color,
                                 'w' - white color.

          OptStruct: struct[1, 1] with fields:
              color: double[1, 3] - sets color of the picture in the form
                    [x y z].
              width: double[1, 1] - sets line width for 2D plots.
              shade: double[1, 1] in [0; 1] interval - sets transparency level
                    (0 - transparent, 1 - opaque).
               fill: double[1, 1] - if set to 1, reach set will be filled with
                    color.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj.plotIa();
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
      dRsObj.plotIa();

::

::


    REFINE - adds new approximations computed for the specified directions
             to the given reach set or to the projection of reach set.

    Input:
      regular:
          self.
          l0Mat: double[nDim, nDir] - matrix of directions for new
              approximation

    Output:
      regular:
          reachObj: reach[1,1] - refine reach set for the directions
              specified in l0Mat

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      newDirsMat = [1; -1];
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
      rsObj = rsObj.refine(newDirsMat);

::


    REPMAT - is analogous to built-in repmat function with one exception - it
             copies the objects, not just the handles

    Input:
      regular:
          self.

    Output:
      Array of given ReachContinuous/ReachDiscrete object's copies.

     Example:
       aMat = [0 1; 0 0]; bMat = eye(2);
       SUBounds = struct();
       SUBounds.center = {'sin(t)'; 'cos(t)'};
       SUBounds.shape = [9 0; 0 2];
       sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
       x0EllObj = ell_unitball(2);
       timeVec = [0 10];
       dirsMat = [1 0; 0 1]';
       reachObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
       reachObjArr = reachObj.repMat(1,2);

       reachObjArr = 1x2 array of ReachContinuous objects

elltool.reach.ReachContinuous
-----------------------------

::

    ReachContinuous - computes reach set approximation of the continuous
        linear system for the given time interval.
    Input:
        regular:
          linSys: elltool.linsys.LinSys object -
              given linear system .
          x0Ell: ellipsoid[1, 1] - ellipsoidal set of
              initial conditions.
          l0Mat: double[nRows, nColumns] - initial good directions
              matrix.
          timeVec: double[1, 2] - time interval.

        properties:
          isRegEnabled: logical[1, 1] - if it is 'true' constructor
              is allowed to use regularization.
          isJustCheck: logical[1, 1] - if it is 'true' constructor
              just check if square matrices are degenerate, if it is
              'false' all degenerate matrices will be regularized.
          regTol: double[1, 1] - regularization precision.

    Output:
      regular:
        self - reach set object.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);

See the description of the following methods in section
[secClassDescr:elltool.reach.AReach] for elltool.reach.AReach:

elltool.reach.ReachDiscrete
---------------------------

::

    ReachDiscrete - computes reach set approximation of the discrete linear
                    system for the given time interval.


    Input:
        linSys: elltool.linsys.LinSys object - given linear system
        x0Ell: ellipsoid[1, 1] - ellipsoidal set of initial conditions
        l0Mat: double[nRows, nColumns] - initial good directions
              matrix.
        timeVec: double[1, 2] - time interval
        properties:
          isRegEnabled: logical[1, 1] - if it is 'true' constructor
              is allowed to use regularization.
          isJustCheck: logical[1, 1] - if it is 'true' constructor
              just check if square matrices are degenerate, if it is
              'false' all degenerate matrices will be regularized.
          regTol: double[1, 1] - regularization precision.
          minmax: logical[1, 1] - field, which:
              = 1 compute minmax reach set,
              = 0 (default) compute maxmin reach set.

    Output:
      regular:
        self - reach set object.
    Example:
      adMat = [0 1; -1 -0.5];
      bdMat = [0; 1];
      udBoundsEllObj  = ellipsoid(1);
      dtsys = elltool.linsys.LinSysDiscrete(adMat, bdMat, udBoundsEllObj);
      x0EllObj = ell_unitball(2);
      timeVec = [0 10];
      dirsMat = [1 0; 0 1]';
      dRsObj = elltool.reach.ReachDiscrete(dtsys, x0EllObj, dirsMat, timeVec);

See the description of the following methods in section
[secClassDescr:elltool.reach.AReach] for elltool.reach.AReach:

elltool.reach.ReachFactory
--------------------------

::

    Example:
      import elltool.reach.ReachFactory;
      crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
      crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
      rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);

::

    Example:
      import elltool.reach.ReachFactory;
      crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
      crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
      rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
      reachObj = rsObj.createInstance();

::

::

    Example:
      import elltool.reach.ReachFactory;
      crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
      crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
      rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
      dim = rsObj.getDim();

::

    Example:
      import elltool.reach.ReachFactory;
      crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
      crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
      rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
      l0Mat = rsObj.getL0Mat()

      l0Mat =

           1     0
           0     1

::

    Example:
      import elltool.reach.ReachFactory;
      crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
      crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
      rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
      linSys = rsObj.getLinSys();

::

    Example:
      import elltool.reach.ReachFactory;
      crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
      crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
      rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
      tVec = rsObj.getTVec()

      tVec =

           0    10

::

    Example:
      import elltool.reach.ReachFactory;
      crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
      crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
      rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
      X0Ell = rsObj.getX0Ell()

      X0Ell =

      Center:
           0
           0

      Shape Matrix:
          0.0100         0
               0    0.0100

      Nondegenerate ellipsoid in R^2.

elltool.linsys.ALinSys
----------------------

::

    ALinSys - constructor abstract class of linear system.

    Continuous-time linear system:
              dx/dt  =  A(t) x(t)  +  B(t) u(t)  +  C(t) v(t)

    Discrete-time linear system:
              x[k+1]  =  A[k] x[k]  +  B[k] u[k]  +  C[k] v[k]

    Input:
      regular:
          atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

          btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.

          uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
              ellipsoid.

          ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

          vBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds
              ellipsoid.
          discrFlag: char[1, 1] - if discrFlag set:
              'd' - to discrete-time linSys
              not 'd' - to continuous-time linSys.

    Output:
      self: elltool.linsys.ALinSys[1, 1] -
          linear system.

::


    DIMENSION - returns dimensions of state, input, output and disturbance
                spaces.
    Input:
      regular:
          self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of
                linear systems.

    Output:
      stateDimArr: double[nDims1, nDims2,...] - array of state space
          dimensions.

      inpDimArr: double[nDims1, nDims2,...] - array of input dimensions.

      distDimArr: double[nDims1, nDims2,...] - array of disturbance
            dimensions.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      [stateDimArr, inpDimArr, outDimArr, distDimArr] = sys.dimension()

      stateDimArr =

           2


      inpDimArr =

           2



      distDimArr =

           0

      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dsys.dimension();

::

    DISPLAY - displays the details of linear system object.

    Input:
      regular:
          self: elltool.linsys.ALinSys[1, 1] - linear system.

    Output:
      None.

::


    GETABSTOL - gives array the same size as linsysArr with values of absTol
                properties for each hyperplane in hplaneArr.


    Input:
      regular:
          self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of linear
                systems.

    Output:
      absTolArr: double[nDims1, nDims2,...] - array of absTol properties for
          linear systems in self.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      sys.getAbsTol();
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dsys.getAbsTol();

::


    Input:
      regular:
          self: elltool.linsys.ILinSys[1, 1] - linear system.

    Output:
      aMat: double[aMatDim, aMatDim]/cell[nDim, nDim] - matrix A.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      aMat = dsys.getAtMat();

::


    Input:
      regular:
          self: elltool.linsys.ILinSys[1, 1] - linear system.

    Output:
      bMat: double[bMatDim, bMatDim]/cell[bMatDim, bMatDim] - matrix B.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      bMat = dsys.getBtMat();

::


    GETCOPY - gives array the same size as linsysArr with with copies of
              elements of self.

    Input:
      regular:
          self: elltool.linsys.ALinSys[nDims1, nDims2,...] - an array of
                linear systems.

    Output:
      copyLinSysArr: elltool.linsys.LinSys[nDims1, nDims2,...] -  an array of
         copies of elements of self.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      newSys = sys.getCopy();
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      newDSys = dsys.getCopy();

::


    Input:
      regular:
          self: elltool.linsys.ILinSys[1, 1] - linear system.

    Output:
      cMat: double[cMatDim, cMatDim]/cell[cMatDim, cMatDim] - matrix C.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      gMat = sys.getCtMat();

::


    Input:
      regular:
          self: elltool.linsys.ILinSys[1, 1] - linear system.

    Output:
      distEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds ellipsoid.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      distEll = sys.getDistBoundsEll();

::


    Input:
      regular:
          self: elltool.linsys.ILinSys[1, 1] - linear system.

    Output:
      uEll: ellipsoid[1, 1]/struct[1, 1] - control bounds ellipsoid.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      uEll = dsys.getUBoundsEll();

::

    HASDISTURBANCE - returns true if system has disturbance

    Input:
      regular:
          self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of
                linear systems.
      optional:
          isMeaningful: logical[1,1] - if true(default), treat constant
                        disturbance vector as absence of disturbance

    Output:
      isDisturbanceArr: logical[nDims1, nDims2,...] - array such that it's
          element at each position is true if corresponding linear system
          has disturbance, and false otherwise.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      sys.hasDisturbance()

      ans =

           0
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dsys.hasDisturbance();

::



    ISEMPTY - checks if linear system is empty.

    Input:
      regular:
          self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of linear
                systems.

    Output:
      isEmptyMat: logical[nDims1, nDims2,...] - array such that it's element at
          each position is true if corresponding linear system is empty, and
          false otherwise.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      sys.isEmpty()

      ans =

           0
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      dsys.isEmpty();

::


    ISEQUAL - produces produces logical array the same size as
              self/compLinSysArr (if they have the same).
              isEqualArr[iDim1, iDim2,...] is true if corresponding
              linear systems are equal and false otherwise.

    Input:
      regular:
          self: elltool.linsys.ILinSys[nDims1, nDims2,...] -  an array of
               linear systems.
          compLinSysArr: elltool.linsys.ILinSys[nDims1,...nDims2,...] - an
               array of linear systems.

    Output:
      isEqualArr: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of
          logical values.
          isEqualArr[iDim1, iDim2,...] is true if corresponding linear systems
          are equal and false otherwise.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      newSys = sys.getCopy();
      isEqual = sys.isEqual(newSys)

      isEqual =

           1
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      newDSys = sys.getCopy();
      isEqual = dsys.isEqual(newDSys)

      isEqual =

           1

::


    ISLTI - checks if linear system is time-invariant.

    Input:
      regular:
          self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of linear
                systems.

    Output:
      isLtiMat: logical[nDims1, nDims2,...] -array such that it's element at
          each position is true if corresponding linear system is
          time-invariant, and false otherwise.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
      isLtiArr = sys.isLti();
      dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
      isLtiArr = dsys.isLti();

elltool.linsys.LinSysContinuous
-------------------------------

::

    LINSYSCONTINUOUS - Constructor of continuous linear system object.

    Continuous-time linear system:
              dx/dt  =  A(t) x(t)  +  B(t) u(t)  +  C(t) v(t)

    Input:
      regular:
          atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

          btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.

      optional:
          uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
                ellipsoid.

          ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

          distBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance
                bounds ellipsoid.

          discrFlag: char[1, 1] - if discrFlag set:
                 'd' - to discrete-time linSys,
                 not 'd' - to continuous-time linSys.


    Output:
      self: elltool.linsys.LinSysContinuous[1, 1] - continuous linear
                system.

    Example:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);

See the description of the following methods in section
[secClassDescr:elltool.linsys.ALinSys] for elltool.linsys.ALinSys:

elltool.linsys.LinSysDiscrete
-----------------------------

::

    LINSYSDISCRETE - constructor of discrete linear system object.

    Discrete-time linear system:
              x[k+1]  =  A[k] x[k]  +  B[k] u[k]  +  C[k] v[k]

    Input:
      regular:
          atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

          btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.
      optional:
          uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
              ellipsoid.

          ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

          distBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds
              ellipsoid.

          discrFlag: char[1, 1] - if discrFlag set:
               'd' - to discrete-time linSys
               not 'd' - to continuous-time linSys.

    Output:
      self: elltool.linsys.LinSysDiscrete[1, 1] - discrete linear system.

    Example:
      for k = 1:20
         atMat = {'0' '1 + cos(pi*k/2)'; '-2' '0'};
         btMat =  [0; 1];
         uBoundsEllObj = ellipsoid(4);
         ctMat = [1; 0];
         distBounds = 1/(k+1);
         lsys = elltool.linsys.LinSysDiscrete(atMat, btMat,...
             uBoundsEllObj, ctMat,distBounds);
      end

See the description of the following methods in section
[secClassDescr:elltool.linsys.ALinSys] for elltool.linsys.ALinSys:

elltool.linsys.LinSysFactory
----------------------------

::

    Factory class of linear system objects of the Ellipsoidal Toolbox.

::

    CREATE - returns linear system object.

    Continuous-time linear system:
              dx/dt  =  A(t) x(t)  +  B(t) u(t)  +  C(t) v(t)

    Discrete-time linear system:
              x[k+1]  =  A[k] x[k]  +  B[k] u[k]  +  C[k] v[k]

    Input:
      regular:
          atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

          btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.

          uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
              ellipsoid.

          ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

          distBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds
              ellipsoid.

          discrFlag: char[1, 1] - if discrFlag set:
              'd' - to discrete-time linSys
              not 'd' - to continuous-time linSys.

    Output:
      linSys: elltool.linsys.LinSysContinuous[1, 1]/
          elltool.linsys.LinSysDiscrete[1, 1] - linear system.

    Examples:
      aMat = [0 1; 0 0]; bMat = eye(2);
      SUBounds = struct();
      SUBounds.center = {'sin(t)'; 'cos(t)'};
      SUBounds.shape = [9 0; 0 2];
      sys = elltool.linsys.LinSysFactory.create(aMat, bMat,SUBounds);

.. raw:: html

   <div class="references">

“$d/dt$ Homepage.” www-verimag.imag.fr/\\~tdang/ddt.html.

“CDD/CDD+ Homepage.” www.cs.mcgill.ca/\\~fukuda/soft/cdd\_home/cdd.html.

“CheckMate Homepage.” www.ece.cmu.edu/\\~webk/checkmate.

“CVX Homepage.” cvxr.com/cvx.

“Geometric Bounding Toolbox Homepage.” www.sysbrain.com/gbt.

“Level Set Toolbox Homepage.” www.cs.ubc.ca/\\~mitchell/ToolboxLS.

“MATISSE Homepage.” www.seas.upenn.edu/ãgirard/Software/MATISSE.

“Multi-Parametric Toolbox Homepage.” control.ee.ethz.ch/\\~mpt.

“Requiem Homepage.” www.seas.upenn.edu/\\~hybrid/requiem/requiem.html.

“SDPT3 Homepage.” http://www.math.nus.edu.sg/\\~mattohkc/sdpt3.html.

“SeDuMi Homepage.” sedumi.mcmaster.ca.

“Stanley Chan Article Homepage.”
http://videoprocessing.ucsd.edu/~stanleychan/publication/unpublished/Ellipse.pdf.

“Zonotope Methods on Wolfgang Kühn Homepage.” www.decatur.de.

A. A. Kurzhanskiy, P. Varaiya. 2007. “Ellipsoidal Techniques for
Reachability Analysis of Discrete-time Linear Systems.” *IEEE
Transactions on Automatic Control* 52 (1): 26–38.

A.B.Kurzhanski, and P.Varaiya. 2001. “Reachability Analysis for
Uncertain Systems - the Ellipsoidal Technique.” *Dynamics of Continuous,
Discrete and Impulsive Systems Series B: Applications and Algorithms* 9:
347–367.

A.Girard, C.Le Guernic, and O.Maler. 2006. “Computation of Reachable
Sets of Linear Time-invariant Systems with Inputs.” In *Hybrid Systems:
Computation and Control*, edited by J.Hespanha and A.Tiwari,
3927:257–271. Springer.

Avis, D., D. Bremner, and R. Seidel. 1997. “How Good Are Convex Hull
Algorithms?” *Computational Geometry: Theory and Applications* 7:
265–301.

Boyd, S., and L. Vandenberghe. 2004. *Convex Optimization*. Cambridge
University Press.

Dariyn, A. N., and A. B. Kurzhanski. 2012. “Method of Invariant Sets for
Linear Systems of High Dimensionality Under Uncertain Disturbances.”
*Doklady Akademii Nauk* 446 (6): 607–611.

E.Asarin, O.Bournez, T.Dang, and O.Maler. 2000. “Approximate
Reachability Analysis of Piecewise Linear Dynamical Systems.” In *Hybrid
Systems: Computation and Control*, edited by N.Lynch and B.H.Krogh,
1790:482–497. Springer.

Gantmacher, F. R. 1960. *Matrix Theory, I-II*. Chelsea.

Girard, A. 2005. “Reachability of Uncertain Linear Systems Using
Zonotopes.” In *Hybrid Systems: Computation and Control*, edited by M.
Morari, L. Thiele, and F. Rossi, 3414:291–305. Springer.

Kostousova, E. K. 2001. “Control Synthesis via Parallelotopes:
Optimization and Parallel Computations.” *Optimization Methods and
Software* 14 (4): 267–310.

Kurzhanski, A. B., and P. Varaiya. 2000. “On Ellipsoidal Techniques for
Reachability Analysis.” *Optimization Methods and Software* 17: 177–237.

Kurzhanski, A. B., and I. Vályi. 1997. *Ellipsoidal Calculus for
Estimation and Control*. *Ser. SCFA*. Birkhäuser.

Kvasnica, M., P. Grieder, M. Baotić, and M. Morari. 2004.
“Multi-Parametric Toolbox (MPT).” In *Hybrid Systems: Computation and
Control*, edited by R. Alur and G. J. Pappas, 2993:448–462. Springer.

L. Ros, A. Sabater, F. Thomas. 2002. “An Ellipsoidal Calculus Based on
Propagation and Fusion.” *IEEE Transactions on Systems, Man and
Cybernetics, Part B: Cybernetics* 32 (4).

L.Muñoz, X.Sun, R.Horowitz, and L.Alvarez. 2003. “Traffic Density
Estimation with the Cell Transmission Model.” In *Proceedings of the
American Control Conference*, 3750–3755. Denver, Colorado, USA.

Lafferriere, G., G. J. Pappas, and S. Yovine. 2001. “Symbolic
Reachability Computation for Families of Linear Vector Fields.” *Journal
of Symbolic Computation* 32: 231–253.

Lin, A., and S. Han. 2002. “On the Distance Between Two Ellipsoids.”
*SIAM Journal on Optimization* 13 (1): 298–308.

Mitchell, I., and C. Tomlin. 2000. “Level Set Methods for Computation in
Hybrid Systems.” In *Hybrid Systems: Computation and Control*, edited by
N. Lynch and B. H. Krogh, 1790:21–31. Springer.

Motzkin, T. S., H. Raiffa, G. L. Thompson, and R. M. Thrall. 1953. “The
Double Description Method.” In *Conttributions to Theory of Games*,
edited by H. W. Kuhn and A. W. Tucker. Vol. 2. Princeton University
Press.

Sturm, J. F. 1999. “Using SeDuMi 1.02, A MATLAB Toolbox for Optimization
over Symmetric Cones.” *Optimization Methods and Software* 11-12:
625–653.

Stursberg, O., and B. H. Krogh. 2003. “Efficient Representation and
Computation of Reachable Sets for Hybrid Systems.” In *Hybrid Systems:
Computation and Control*, edited by O. Maler and A. Pnueli,
2623:482–497. Springer.

Varaiya, P. 1998. “Reach Set Computation Using Optimal Control.” Proc.
of KIT Workshop on Verification on Hybrid Systems. Verimag, Grenoble.

Vazhentsev, A. Yu. 1999. “On Internal Ellipsoidal Approximations for
Problems of Control and Synthesis with Bounded Coordinates.” *Izvestiya
Rossiiskoi Akademii Nauk. Teoriya I Systemi Upravleniya.*

Veres, S. M., A. V. Kuntsevich, I. V. Vályi, S. Hermsmeyer, and D. S.
Wall. 2001. “Geometric Bounding Toolbox for MATLAB.” *MATLAB/Simulink
Connections Catalogue*.

.. raw:: html

   </div>

.. [1]
   In discrete-time case :math:`t` assumes integer values.

.. [2]
   We are being general when giving the basic definitions. However, it
   is important to understand that for any specific *continuous-time*
   dynamical system it must be determined whether the solution exists
   and is unique, and in which class of solutions these conditions are
   met. Here we shall assume that function :math:`f` is such that the
   solution of the differential equation ([ctds1]) exists and is unique
   in Fillipov sense. This allows the right-hand side to be
   discontinuous. For discrete-time systems this problem does not exist.

.. [3]
   Minkowski sum of sets
   :math:`{\mathcal W}, {\mathcal Z}\subseteq {\bf R}^n` is defined as
   :math:`{\mathcal W}\oplus {\mathcal Z}= \{w+z ~|~ w\in{\mathcal W}, ~ z\in{\mathcal Z}\}`.
   Set :math:`{\mathcal W}\oplus{\mathcal Z}` is nonempty if and only if
   both, :math:`{\mathcal W}` and :math:`{\mathcal Z}` are nonempty. If
   :math:`{\mathcal W}` and :math:`{\mathcal Z}` are convex, set
   :math:`{\mathcal W}\oplus{\mathcal Z}` is convex.

.. [4]
   :math:`{\mathcal M}` is weakly invariant with respect to the target
   set :math:`{\mathcal Y}_1` and times :math:`t_0` and :math:`t`, if
   for every state :math:`x_0\in{\mathcal M}` there exists a control
   :math:`u(\tau, x(\tau))\in{\mathcal U}(\tau)`,
   :math:`t_0\leqslant\tau< t`, that steers the system from :math:`x_0`
   at time :math:`t_0` to some state in :math:`{\mathcal Y}_1` at time
   :math:`t`. If *all* controls in :math:`{\mathcal U}(\tau)`,
   :math:`t_0\leqslant\tau<t` steer the system from every
   :math:`x_0\in{\mathcal M}` at time :math:`t_0` to
   :math:`{\mathcal Y}_1` at time :math:`t`, set :math:`{\mathcal M}` is
   said to be *strongly* invariant with respect to
   :math:`{\mathcal Y}_1`, :math:`t_0` and :math:`t`.

.. [5]
   There exists :math:`f^{-1}(t,x,u)` such that
   :math:`x(t)=f^{-1}(t, x(t+1), u, v)`.

.. [6]
   Hausdorff semidistance between compact sets
   :math:`{\mathcal W}, {\mathcal Z}\subseteq {\bf R}^n` is defined as

   .. math::

      {\bf dist}({\mathcal W}, {\mathcal Z}) = \min\{\langle w-z, w-z\rangle^{1/2}
      ~|~ w\in{\mathcal W}, \; z\in{\mathcal Z}\},

    where :math:`\langle\cdot, \cdot\rangle` denotes inner product.

.. [7]
   The Minkowski difference of sets
   :math:`{\mathcal W}, {\mathcal Z}\in{\bf R}^n` is defined as
   :math:`{\mathcal W}\dot{-}{\mathcal Z}= \left\{\xi\in{\bf R}^n ~|~
   \xi \oplus {\mathcal Z}\subseteq {\mathcal W}\right\}`. If
   :math:`{\mathcal W}` and :math:`{\mathcal Z}` are convex,
   :math:`{\mathcal W}\dot{-}{\mathcal Z}` is convex if it is nonempty.

.. [8]
   So-called verification problems often consist in ensuring that the
   system is unable to reach an ‘unsafe’ target set within a given time
   interval.

.. [9]
   The case when :math:`A(t)` is singular is described in A. A.
   Kurzhanskiy (2007). The idea is to substitute :math:`A(t)` with the
   nonsingular :math:`A_\delta(t) = A(t) + \delta U(t)W(t)`, in which
   :math:`U(t)` and :math:`W(t)` are obtained from the singular value
   decomposition

   .. math:: A(t) = U(t)\Sigma(t)V(t) .

    The parameter :math:`\delta` can be chosen based on the number of
   time steps for which the reach set must be computed and the required
   accuracy. The issue of inverting ill-conditioned matrices is also
   addressed in A. A. Kurzhanskiy (2007).

.. [10]
   Note that for ([adjointdt]) :math:`A(t)` must be invertible.

.. |image| image:: ddt.eps
