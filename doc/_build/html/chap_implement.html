<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementation &mdash; Ellipsoidal Toolbox 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Ellipsoidal Toolbox 0.1 documentation" href="index.html" />
    <link rel="next" title="Examples" href="chap_examples.html" />
    <link rel="prev" title="Installation" href="chap_install.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chap_examples.html" title="Examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chap_install.html" title="Installation"
             accesskey="P">previous</a> |</li>
        <li><a href="main_manual.html">Ellipsoidal Toolbox 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="implementation">
<h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="operations-with-ellipsoids">
<h2>Operations with ellipsoids<a class="headerlink" href="#operations-with-ellipsoids" title="Permalink to this headline">¶</a></h2>
<p>In the <em>Ellipsoidal Toolbox</em> we define a new class ellipsoid inside the
MATLAB programming environment. The following three commands define the
same ellipsoid <span class="math">\({\mathcal E}(q,Q)\)</span>, with <span class="math">\(q\in{\bf R}^n\)</span> and
<span class="math">\(Q\in{\bf R}^{n\times n}\)</span> being symmetric positive semidefinite:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre> <span class="n">centVec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span><span class="err">&#39;</span><span class="p">;</span>
 <span class="n">shMat</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
 <span class="n">ellObj</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="n">centVec</span><span class="p">,</span> <span class="n">shMat</span><span class="p">);</span>
 <span class="n">ellObj</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="n">shMat</span><span class="p">)</span> <span class="o">+</span> <span class="n">centVec</span><span class="p">;</span>
 <span class="n">ellObj</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">shMat</span><span class="p">)</span><span class="o">*</span><span class="n">ell_unitball</span><span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">shMat</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">centVec</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>For the ellipsoid class we overload the following functions and
operators:</p>
<ul class="simple">
<li>isEmpty(ellObj) - checks if <span class="math">\({\mathcal E}(q,Q)\)</span> is an empty
ellipsoid.</li>
<li>display(ellObj) - displays the details of ellipsoid
<span class="math">\({\mathcal E}(q,Q)\)</span>, namely, its center <span class="math">\(q\)</span> and the shape
matrix <span class="math">\(Q\)</span>.</li>
<li>plot(ellObj) - plots ellipsoid <span class="math">\({\mathcal E}(q,Q)\)</span> if its
dimension is not greater than 3.</li>
<li>firstEllObj == secEllObj - checks if ellipsoids
<span class="math">\({\mathcal E}(q_1,Q_1)\)</span> and <span class="math">\({\mathcal E}(q_2,Q_2)\)</span> are
equal.</li>
<li>firstEllObj ~= secEllObj - checks if ellipsoids
<span class="math">\({\mathcal E}(q_1,Q_1)\)</span> and <span class="math">\({\mathcal E}(q_2,Q_2)\)</span> are
not equal.</li>
<li>[ , ] - concatenates the ellipsoids into the horizontal array, e.g. ellVec
= [firstEllObj secEllObj thirdEllObj].</li>
<li>[ ; ] - concatenates the ellipsoids into the vertical array, e.g. ellMat =
[firstEllObj secEllObj; thirdEllObj fourthEllObj] defines
<span class="math">\(2\times 2\)</span> array of ellipsoids.</li>
<li>firstEllObj &gt;= secEllObj - checks if the ellipsoid firstEllObj is
bigger than the ellipsoid secEllObj, or equivalently
<span class="math">\({\mathcal E}(0,Q_1)\subseteq{\mathcal E}(0,Q_2)\)</span>.</li>
<li>firstEllObj &lt;= secEllObj - checks if
<span class="math">\({\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)\)</span>.</li>
<li>-ellObj - defines ellipsoid <span class="math">\({\mathcal E}(-q,Q)\)</span>.</li>
<li>ellObj + bScal - defines ellipsoid <span class="math">\({\mathcal E}(q+b,Q)\)</span>.</li>
<li>ellObj - bScal - defines ellipsoid <span class="math">\({\mathcal E}(q-b,Q)\)</span>.</li>
<li>aMat * ellObj - defines ellipsoid <span class="math">\({\mathcal E}(q,AQA^T)\)</span>.</li>
<li>ellObj.inv() - inverts the shape matrix of the ellipsoid:
<span class="math">\({\mathcal E}(q,Q^{-1})\)</span>.</li>
</ul>
<p>All the listed operations can be applied to a single ellipsoid as well
as to a two-dimensional array of ellipsoids. For example,</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% nondegenerate ellipsoid in R^2</span>
<span class="n">firstEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">2</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span> <span class="o">-</span><span class="mi">5</span> <span class="mi">4</span><span class="p">]);</span> 
<span class="n">secEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">polar</span><span class="p">();</span><span class="c">% secEll is polar ellipsoid for firstEllObj</span>
<span class="c">% thirdEllObj is generated from secEllObj by inverting its shape matrix</span>
<span class="n">thirdEllObj</span> <span class="p">=</span> <span class="n">secEllObj</span><span class="p">.</span><span class="n">getInv</span><span class="p">();</span> 
<span class="c">% 2x2 array of ellipsoids</span>
<span class="n">ellMat</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span><span class="p">;</span> <span class="n">thirdEllObj</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">))];</span> 
<span class="c">% check if firstEllObj is bigger than each of the ellipsoids in ellMat</span>
<span class="n">ellMat</span> <span class="o">&lt;</span><span class="p">=</span> <span class="n">firstEllObj</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     0</span>
<span class="c">%      1     0</span>
</pre></div>
</td></tr></table></div>
<p>To access individual elements of the array, the usual MATLAB subindexing is used:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">aMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">0</span><span class="p">];</span>  <span class="o">%</span> <span class="n">aMat</span> <span class="o">-</span> <span class="mi">2</span><span class="n">x2</span> <span class="n">real</span> <span class="n">matrix</span>
<span class="n">bVec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span> <span class="o">%</span> <span class="n">bVec</span> <span class="o">-</span> <span class="n">vector</span> <span class="n">in</span> <span class="n">R</span><span class="o">^</span><span class="mi">2</span>
<span class="o">%</span> <span class="n">affine</span> <span class="n">transformation</span> <span class="n">of</span> <span class="n">ellipsoids</span> <span class="n">in</span> <span class="n">the</span> <span class="n">second</span> <span class="n">column</span> <span class="n">of</span> <span class="n">ellMat</span>
<span class="n">aTransMat</span> <span class="o">=</span> <span class="n">aMat</span> <span class="o">*</span> <span class="n">ellMat</span><span class="p">(</span><span class="o">:</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">bVec</span><span class="p">;</span>  
</pre></div>
</td></tr></table></div>
<p>Sometimes it may be useful to modify the shape of the ellipsoid without
affecting its center. Say, we would like to bloat or squeeze the
ellipsoid:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bltEllObj</span> <span class="o">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">getShape</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="o">%</span> <span class="n">bloats</span> <span class="n">ellipsoid</span> <span class="n">firstEllObj</span>
<span class="n">sqzEllObj</span> <span class="o">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">getShape</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>  <span class="o">%</span> <span class="n">squeezes</span> <span class="n">ellipsoid</span> <span class="n">firstEllObj</span>
</pre></div>
</td></tr></table></div>
<p>Since function shape does not change the center of the
ellipsoid, it only accepts scalars or square matrices as its second
input parameter. Several functions access the internal data of the
ellipsoid object:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">[</span><span class="n">centVec</span><span class="p">,</span> <span class="n">shMat</span><span class="p">]</span> <span class="o">=</span> <span class="n">secEllObj</span><span class="p">.</span><span class="kt">double</span><span class="p">()</span>
<span class="o">%</span> <span class="n">centVec</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="o">-</span><span class="mf">0.5000</span>
<span class="o">%</span>    <span class="o">-</span><span class="mf">0.1667</span>
<span class="o">%</span> 
<span class="o">%</span> <span class="n">shMat</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="mf">0.9167</span>     <span class="mf">0.9167</span>
<span class="o">%</span>    <span class="mf">0.9167</span>     <span class="mf">1.5278</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define new ellipsoid</span>
<span class="n">fourthEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">42</span> <span class="o">-</span><span class="mi">7</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">4</span><span class="p">;</span> <span class="o">-</span><span class="mi">7</span> <span class="mi">10</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">2</span><span class="p">]);</span>  
<span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">:)</span> <span class="n">fourthEllObj</span><span class="p">];</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">isdegenerate</span><span class="p">()</span> <span class="c">% check if given ellipsoids are degenerate</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0     0     1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="o">=</span> <span class="p">[</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">:</span><span class="p">)</span> <span class="n">fourthEllObj</span><span class="p">];</span>
<span class="p">[</span><span class="n">dimVec</span><span class="p">,</span> <span class="n">rankVec</span><span class="p">]</span> <span class="o">=</span> <span class="n">bufEllVec</span><span class="p">.</span><span class="n">dimension</span><span class="p">()</span> 


<span class="o">%</span> <span class="n">dimVec</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="mi">2</span>     <span class="mi">2</span>     <span class="mi">4</span>
<span class="o">%</span> 
<span class="o">%</span> <span class="n">rankVec</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="mi">2</span>     <span class="mi">2</span>     <span class="mi">3</span>
</pre></div>
</td></tr></table></div>
<p>One way to check if two ellipsoids intersect, is to
compute the distance between them ( (“Stanley Chan Article Homepage”),
Lin and Han (2002)):</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% distance between thirdEllObj and each of the ellipsoids in ellMat</span>
<span class="n">ellMat</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">)</span> 

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%          0         0</span>
<span class="c">%          0    0.1683</span>
</pre></div>
</td></tr></table></div>
<p>This result indicates that the ellipsoid
thirdEllObj does not intersect with the ellipsoid ellMat(2, 2), with all
the other ellipsoids in ellMat it has nonempty intersection. If the
intersection of the two ellipsoids is nonempty, it can be approximated
by ellipsoids from the outside as well as from the inside. See
L. Ros, A. Sabater, F. Thomas (2002)
for more information about these methods.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% external approximation of intersection of firstEllObj and thirdEllObj</span>
<span class="n">externalEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">intersection_ea</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">);</span> 
<span class="c">% internal approximation of intersection of firstEllObj and thirdEllObj</span>
<span class="n">internalEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">intersection_ia</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">);</span> 
</pre></div>
</td></tr></table></div>
<p>It can be checked that
resulting ellipsoid externalEllObj contains the given intersection,
whereas internalEllObj is contained in this intersection:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% array [firstEllObj secEllObj] should be treated as intersection</span>
<span class="n">externalEllObj</span><span class="p">.</span><span class="n">doesIntersectionContain</span><span class="p">([</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span><span class="p">],</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="o">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">thirdEllObj</span><span class="p">]</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">doesIntersectionContain</span><span class="p">(</span><span class="n">internalEllObj</span><span class="p">)</span> 

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p>Function
isInside in general checks if the intersection of ellipsoids in the
given array contains the union or intersection of ellipsoids or
polytopes.</p>
<p>It is also possible to solve the feasibility problem, that is, to check
if the intersection of more than two ellipsoids is empty:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="sc">&#39;i&#39;</span><span class="p">)</span>  

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="o">-</span><span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p>In this
particular example the result <span class="math">\(-1\)</span> indicates that the intersection
of ellipsoids in ellMat is empty. Function intersect in general checks
if an ellipsoid, hyperplane or polytope intersects the union or the
intersection of ellipsoids in the given array:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="o">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span> <span class="n">thirdEllObj</span><span class="p">]</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="sc">&#39;i&#39;</span><span class="p">)</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">0</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="o">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span> <span class="n">thirdEllObj</span><span class="p">];</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="sc">&#39;u&#39;</span><span class="p">)</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p>For the ellipsoids in
<span class="math">\({\bf R}\)</span>, <span class="math">\({\bf R}^2\)</span> and <span class="math">\({\bf R}^3\)</span> the geometric
sum can be computed explicitely and plotted:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">.</span><span class="n">minksum</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p>Figure
<span class="math">\(\ref{minksumPic}\)</span> displays the geometric sum of ellipsoids. If
the dimension of the space in which the ellipsoids are defined exceeds
<span class="math">\(3\)</span>, an error is returned. The result of the geometric sum
operation is not generally an ellipsoid, but it can be approximated by
families of external and internal ellipsoids parametrized by the
direction vector:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define the set of directions:</span>
<span class="c">% columns of matrix dirsMat are vectors in R^2</span>
<span class="n">dirsMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>
<span class="c">% compute external ellipsoids for the directions in dirsMat</span>
<span class="n">externalEllVec</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">.</span><span class="n">minksum_ea</span><span class="p">(</span><span class="n">dirsMat</span><span class="p">)</span> 

<span class="c">% externalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% compute internal ellipsoids for the directions in dirsMat</span>
<span class="n">internalEllVec</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">.</span><span class="n">minksum_ia</span><span class="p">(</span><span class="n">dirsMat</span><span class="p">)</span>  

<span class="c">% internalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% intersection of external ellipsoids should always contain </span>
<span class="c">% the union of internal ellipsoids:</span>
<span class="n">externalEllVec</span><span class="p">.</span><span class="n">doesIntersectionContain</span><span class="p">(</span><span class="n">internalEllVec</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">)</span> 
<span class="c">% </span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Functions minksum_ea and minksum_ia work for
ellipsoids of arbitrary dimension. They should be used for general
computations whereas minksum is there merely for visualization purposes.</p>
<p>If the geometric difference of two ellipsoids is not an empty set, it
can be computed explicitely and plotted for ellipsoids in
<span class="math">\({\bf R}\)</span>, <span class="math">\({\bf R}^2\)</span> and <span class="math">\({\bf R}^3\)</span>:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% ellipsoid defined by squeezing the ellipsoid ellMat(2, 2)</span>
<span class="n">fourthEllObj</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="n">getShape</span><span class="p">(</span><span class="mf">0.4</span><span class="p">);</span>  
<span class="c">% check if the geometric difference firstEllObj - fourthEllObj is nonempty</span>
<span class="n">firstEllObj</span> <span class="o">&gt;</span><span class="p">=</span> <span class="n">fourthEllObj</span>  
<span class="c">% </span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>

<span class="c">% compute and plot this geometric difference</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkdiff</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Figure
<span class="math">\(\ref{minkdiffPic}\)</span> shows the geometric difference of ellipsoids.</p>
<p>Similar to minksum, minkdiff is there for visualization purpose. It
works only for dimensions <span class="math">\(1\)</span>, <span class="math">\(2\)</span> and <span class="math">\(3\)</span>, and for
higher dimensions it returns an error. For arbitrary dimensions, the
geometric difference can be approximated by families of external and
internal ellipsoids parametrized by the direction vector, provided this
direction is not bad:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">absTol</span> <span class="o">=</span> <span class="n">getAbsTol</span><span class="p">(</span><span class="n">firstEllObj</span><span class="p">);</span>
<span class="o">%</span> <span class="n">find</span> <span class="n">out</span> <span class="n">which</span> <span class="n">of</span> <span class="n">the</span> <span class="n">directions</span> <span class="n">in</span> <span class="n">dirsMat</span> <span class="n">are</span> <span class="n">bad</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">isbaddirection</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">absTol</span><span class="p">)</span>  

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>     <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">1</span>     <span class="mi">0</span> 


<span class="o">%</span> <span class="n">two</span> <span class="n">of</span> <span class="n">five</span> <span class="n">directions</span> <span class="n">specified</span> <span class="n">by</span> <span class="n">dirsMat</span> <span class="n">are</span> <span class="n">bad</span><span class="p">,</span>
<span class="o">%</span> <span class="n">so</span><span class="p">,</span> <span class="n">only</span> <span class="n">three</span> <span class="n">ellipsoidal</span> <span class="n">approximations</span> 
<span class="o">%</span> <span class="n">can</span> <span class="n">be</span> <span class="n">produced</span> <span class="k">for</span> <span class="n">this</span> <span class="n">dirsMat</span><span class="o">:</span>
<span class="n">externalEllVec</span> <span class="o">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkdiff_ea</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span> 

<span class="o">%</span> <span class="n">externalEllVec</span> <span class="o">=</span>
<span class="o">%</span> <span class="n">Array</span> <span class="n">of</span> <span class="n">ellipsoids</span> <span class="n">with</span> <span class="n">dimensionality</span> <span class="mi">1</span><span class="n">x3</span>

<span class="n">internalEllVec</span> <span class="o">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkdiff_ia</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>

<span class="o">%</span> <span class="n">internalEllVec</span> <span class="o">=</span>
<span class="o">%</span> <span class="n">Array</span> <span class="n">of</span> <span class="n">ellipsoids</span> <span class="n">with</span> <span class="n">dimensionality</span> <span class="mi">1</span><span class="n">x3</span>
</pre></div>
</td></tr></table></div>
<p>Operation ’difference-sum’ described in section
2.2.4 is implemented in functions minkmp, minkmp_ea, minkmp_ia, the
first one of which is used for visualization and works for dimensions
not higher than <span class="math">\(3\)</span>, whereas the last two can deal with ellipsoids
of arbitrary dimension.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% ellipsoidal approximations for (firstEllObj - thirdEllObj + secEllObj)</span>

<span class="c">% external</span>
<span class="n">externalEllVec</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkmp_ea</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">secEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span> 
<span class="c">% externalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% internal</span>
<span class="n">internalEllVec</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkmp_ia</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">secEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>
<span class="c">% internalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% plot the set (firstEllObj - thirdEllObj + secEllObj)</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkmp</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">secEllObj</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Figure <span class="math">\(\ref{minkPic}\)</span> displays results of
the implementation of minkpm and minkmp operations.</p>
<p>Similarly, operation
’sum-difference’ described in section 2.2.5 is implemented in functions
minkpm, minkpm_ea, minkpm_ia, the first one of which is used for
visualization and works for dimensions not higher than <span class="math">\(3\)</span>,
whereas the last two can deal with ellipsoids of arbitrary dimension.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% ellipsoidal approximations for (firstEllObj + secEllObj - thirdEllObj)</span>
<span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span><span class="p">];</span>
<span class="n">externalEllVec</span> <span class="p">=</span> <span class="n">bufEllVec</span><span class="p">.</span><span class="n">minkpm_ea</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>  <span class="c">% external</span>

<span class="c">% externalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="n">internalEllVec</span> <span class="p">=</span> <span class="n">bufEllVec</span><span class="p">.</span><span class="n">minkpm_ia</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>  <span class="c">% internal</span>

<span class="c">% internalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x4</span>

<span class="c">% plot the set (firstEllObj + secEllObj - thirdEllObj)</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkpm</span><span class="p">(</span><span class="n">secEllObj</span><span class="p">,</span> <span class="n">thirdEllObj</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="operations-with-hyperplanes">
<h2>Operations with hyperplanes<a class="headerlink" href="#operations-with-hyperplanes" title="Permalink to this headline">¶</a></h2>
<p>The class hyperplane of the <em>Ellipsoidal Toolbox</em> is used to describe
hyperplanes and halfspaces. The following two commands define one and
the same hyperplane but two different halfspaces:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">firstHypObj</span> <span class="o">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>  <span class="o">%</span> <span class="n">defines</span> <span class="n">halfspace</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">&lt;=</span> <span class="mi">1</span>
<span class="n">firstHypObj</span> <span class="o">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="o">%</span> <span class="n">defines</span> <span class="n">halfspace</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">&gt;=</span> <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p>The following functions and operators are overloaded for the hyperplane
class:</p>
<ul class="simple">
<li>isempty(hypObj) &#8211; checks if hypObj is an empty hyperplane.</li>
<li>display(hypObj) &#8211; displays the details of hyperplane
<span class="math">\(H(c,\gamma)\)</span>, namely, its normal <span class="math">\(c\)</span> and the scalar
<span class="math">\(\gamma\)</span>.</li>
<li>plot(hypObj) &#8211; plots hyperplane <span class="math">\(H(c,\gamma)\)</span> if the dimension
of the space in which it is defined is not greater than 3.</li>
<li>firstHypObj == secHypObj &#8211; checks if hyperplanes
<span class="math">\(H(c_1,\gamma_1)\)</span> and <span class="math">\(H(c_2,\gamma_2)\)</span> are equal.</li>
<li>firstHypObj = secHypObj &#8211; checks if hyperplanes
<span class="math">\(H(c_1,\gamma_1)\)</span> and <span class="math">\(H(c_2,\gamma_2)\)</span> are not equal.</li>
<li>[ , ] &#8211; concatenates the hyperplanes into the horizontal array, e.g. hypVec
= [firstHypObj secHypObj thirdHypObj].</li>
<li>[ ; ] &#8211; concatenates the hyperplanes into the vertical array, e.g. hypMat =
[firstHypObj secHypObj; thirdHypObj fourthHypObj] &#8211; defines
<span class="math">\(2\times 2\)</span> array of hyperplanes.</li>
<li>-hypObj &#8211; defines hyperplane <span class="math">\(H(-c,-\gamma)\)</span>, which is the same
as <span class="math">\(H(c,\gamma)\)</span> but specifies different halfspace.</li>
</ul>
<p>There are several ways to access the internal data of the hyperplane
object:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">[</span><span class="n">normVec</span><span class="p">,</span> <span class="n">hypScal</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstHypObj</span><span class="p">.</span><span class="kt">double</span><span class="p">()</span>

<span class="o">%</span> <span class="n">normVec</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="o">-</span><span class="mi">1</span>
<span class="o">%</span>    <span class="o">-</span><span class="mi">1</span>
<span class="o">%</span> 
<span class="o">%</span> <span class="n">hypScal</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="o">-</span><span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">firstHypObj</span><span class="p">.</span><span class="n">dimension</span><span class="p">()</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">2</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define two hyperplanes passing through the origin</span>
<span class="n">secHypObj</span> <span class="p">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]);</span> 
<span class="n">firstHypObj</span><span class="p">.</span><span class="n">isparallel</span><span class="p">(</span><span class="n">secHypObj</span><span class="p">)</span> 

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     0</span>
</pre></div>
</td></tr></table></div>
<p>All the functions of <em>Ellipsoidal Toolbox</em> that accept
hyperplane object as parameter, work with single hyperplanes as well as
with hyperplane arrays. One exception is the function parameters that
allows only single hyperplane object.</p>
<p>An array of hyperplanes can be converted to the polytope object of the
Multi-Parametric Toolbox (Kvasnica et al. (2004), (“Multi-Parametric
Toolbox Homepage”)), and back:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">%define array of four hyperplanes:</span>
<span class="n">hypVec</span> <span class="p">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">]</span><span class="o">&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">])</span>

<span class="c">% array of hyperplanes: </span>
<span class="c">% size: [1 4]</span>
<span class="c">% </span>
<span class="c">% Element: [1 1]</span>
<span class="c">% Normal:</span>
<span class="c">%      1</span>
<span class="c">%      1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>
<span class="c">% </span>
<span class="c">% </span>
<span class="c">% Element: [1 2]</span>
<span class="c">% Normal:</span>
<span class="c">%     -1</span>
<span class="c">%     -1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>
<span class="c">% </span>
<span class="c">% </span>
<span class="c">% Element: [1 3]</span>
<span class="c">% Normal:</span>
<span class="c">%      1</span>
<span class="c">%     -1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>
<span class="c">% </span>
<span class="c">% </span>
<span class="c">% Element: [1 4]</span>
<span class="c">% Normal:</span>
<span class="c">%     -1</span>
<span class="c">%      1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>

<span class="c">% convert array of hyperplanes to polytope</span>
<span class="n">firstPolObj</span>  <span class="p">=</span> <span class="n">hyperplane2polytope</span><span class="p">(</span><span class="n">hypVec</span><span class="p">);</span>
<span class="c">% covert polytope to array of hyperplanes  </span>
<span class="n">convertedHypVec</span> <span class="p">=</span> <span class="n">polytope2hyperplane</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">);</span>  
<span class="n">convertedHypVec</span> <span class="o">==</span> <span class="n">hypVec</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     1     1     1</span>
</pre></div>
</td></tr></table></div>
<p>Functions hyperplane2polytope and
polytope2hyperplane require the Multi-Parametric Toolbox to be
installed.</p>
<p>We can compute distance from ellipsoids to hyperplanes and polytopes:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% distance from ellipsoid firstEllObj to each of the hyperplanes in hypVec</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">hypVec</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      -0.5176    0.8966   -2.6841    0.1444</span>

<span class="c">% distance from each of the ellipsoids in ellMat to the polytope</span>
<span class="c">% firstPolObj</span>
<span class="n">ellMat</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0     0</span>
<span class="c">%      0     0</span>
</pre></div>
</td></tr></table></div>
<p>A negative distance value in the case of ellipsoid and hyperplane means
that the ellipsoid intersects the hyperplane. As we see in this example,
ellipsoid firstEllObj intersects hyperplanes hypVec(1) and hypVec(3) and
has no common points with hypVec(2) and hypVec(4). When distance
function has a polytope as a parameter, it always returns nonnegative
values to be consistent with distance function of the Multi-Parametric
Toolbox. Here, the zero distance values mean that each ellipsoid in
ellMat has nonempty intersection with polytope firstPolObj.</p>
<p>It can be checked if the union or intersection of given ellipsoids
intersects given hyperplanes or polytopes:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">hypVec</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">)</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>     <span class="mi">1</span>     <span class="mi">1</span>     <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">(</span><span class="o">:</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersect</span><span class="p">(</span><span class="n">hypVec</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">)</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">1</span>     <span class="mi">0</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="o">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span> <span class="n">thirdEllObj</span><span class="p">];</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">)</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p>The intersection of ellipsoid and hyperplane can be computed exactly:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% compute the intersections of ellipsoids in the second column of ellMat</span>
<span class="c">% with hyperplane firstHypObj: </span>

<span class="n">intersectEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">2</span><span class="p">).</span><span class="n">hpintersection</span><span class="p">(</span><span class="n">firstHypObj</span><span class="p">)</span>

<span class="c">% intersectEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 2x1</span>

<span class="n">intersectEllMat</span><span class="p">.</span><span class="n">isdegenerate</span><span class="p">()</span>  <span class="c">% resulting ellipsoids should lose rank</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Functions intersection_ea and intersection_ia can be used with
hyperplane objects, which in this case define halfspaces and polytope
objects:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% compute external and internal ellipsoidal approximations</span>
<span class="c">% of the intersections of ellipsoids in the first column of ellMat</span>
<span class="c">% with the halfspace x1 - x2 &lt;= 2:</span>

<span class="c">% get external ellipsoids</span>
<span class="n">firstExternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ea</span><span class="p">(</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>  
<span class="c">% firstExternalEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 2x1</span>

<span class="c">% get internal ellipsoids</span>
<span class="n">firstInternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ia</span><span class="p">(</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>  
<span class="c">% firstInternalEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 2x1</span>

<span class="c">% compute external and internal ellipsoidal approximations</span>
<span class="c">% of the intersections of ellipsoids in the first column of ellMat</span>
<span class="c">% with the halfspace x1 - x2 &gt;= 2:</span>

<span class="c">% get external ellipsoids</span>
<span class="n">secExternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ea</span><span class="p">(</span><span class="o">-</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  
<span class="c">% get internal ellipsoids</span>
<span class="n">secInternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ia</span><span class="p">(</span><span class="o">-</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>  
<span class="c">% compute ellipsoidal approximations of the intersection</span>
<span class="c">% of ellipsoid firstEll and polytope firstPol:</span>

<span class="c">% get external ellipsoid</span>
<span class="n">externalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ea</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">);</span>
<span class="c">% get internal ellipsoid</span>
<span class="n">internalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ia</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">);</span> 
</pre></div>
</td></tr></table></div>
<p>Function isInside can be used to check if a polytope or union of
polytopes is contained in the intersection of given ellipsoids:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% polytope secPolObj is obtained by affine transformation of firstPolObj</span>
<span class="n">secPolObj</span> <span class="p">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">firstPolObj</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>  

<span class="c">% check if the intersection of ellipsoids in the first column of ellMat</span>
<span class="c">% contains the union of polytopes firstPolObj and secPolObj:</span>

<span class="c">% equivalent to: doesIntersectionContain(ellMat(:, 1), firstPolObj | secPolObj)</span>
<span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">doesIntersectionContain</span><span class="p">([</span><span class="n">firstPolObj</span> <span class="n">secPolObj</span><span class="p">])</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% equivalent to: doesIntersectionContain(ellMat(2, 2),...</span>
<span class="c">%                                  firstPolObj &amp; secPolObj)</span>
<span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="n">doesIntersectionContain</span><span class="p">([</span><span class="n">firstPolObj</span> <span class="n">secPolObj</span><span class="p">],</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Functions distance, intersect, intersection_ia and isInside use the CVX
interface ( (“CVX Homepage”)) to the external optimization package. The
default optimization package included in the distribution of the
<em>Ellipsoidal Toolbox</em> is SeDuMi (Sturm (1999), (“SeDuMi Homepage”)).</p>
</div>
<div class="section" id="operations-with-ellipsoidal-tubes">
<h2>Operations with ellipsoidal tubes<a class="headerlink" href="#operations-with-ellipsoidal-tubes" title="Permalink to this headline">¶</a></h2>
<p>There are several classes in <em>Ellipsoidal Toolbox</em> for operations with
ellipsoidal tubes. The class gras.ellapx.smartdb.rels.EllTube is used to
describe ellipsoidal tubes. The class
gras.ellapx.smartdb.rels.EllUnionTube is used to store tubes by the
instant of time:</p>
<div class="math">
\[{\mathcal X}_{U}[t]=\bigcup \limits_{\tau\leqslant t}{\mathcal X}[\tau],\]</div>
<p>where <span class="math">\({\mathcal X}[\tau]\)</span> is single ellipsoidal tube. The class
gras.ellapx.smartdb.rels.EllTubeProj is used to describe the projection
of the ellipsoidal tubes onto time dependent subspaces.There are two
types of projection: static and dynamic. Also there is class
gras.ellapx.smartdb.rels.EllUnionTubeStaticProj for description of the
projection on static plane tubes by the instant of time. Next we provide
some examples of the operations with ellipsoidal tubes.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">nPoints</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">calcPrecision</span><span class="o">=</span><span class="mf">0.001</span><span class="p">;</span>
<span class="n">approxSchemaDescr</span><span class="o">=</span><span class="kt">char</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">approxSchemaName</span><span class="o">=</span><span class="kt">char</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">nDims</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="n">nTubes</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">lsGoodDirVec</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">];</span>
<span class="n">aMat</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="n">nDims</span><span class="p">,</span><span class="n">nPoints</span><span class="p">);</span>
<span class="n">timeVec</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">nPoints</span><span class="p">;</span>
<span class="n">sTime</span><span class="o">=</span><span class="n">nPoints</span><span class="p">;</span>
<span class="n">approxType</span><span class="o">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">enums</span><span class="p">.</span><span class="n">EApproxType</span><span class="p">.</span><span class="n">Internal</span><span class="p">;</span>
<span class="n">qArrayList</span><span class="o">=</span><span class="n">repmat</span><span class="p">({</span><span class="n">repmat</span><span class="p">(</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">nPoints</span><span class="p">])},</span><span class="mi">1</span><span class="p">,</span><span class="n">nTubes</span><span class="p">);</span>
<span class="n">ltGoodDirArray</span><span class="o">=</span><span class="n">repmat</span><span class="p">(</span><span class="n">lsGoodDirVec</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="n">nTubes</span><span class="p">,</span><span class="n">nPoints</span><span class="p">]);</span>
<span class="n">fromMatEllTube</span><span class="o">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">smartdb</span><span class="p">.</span><span class="n">rels</span><span class="p">.</span><span class="n">EllTube</span><span class="p">.</span><span class="n">fromQArrays</span><span class="p">(</span><span class="n">qArrayList</span><span class="p">,...</span>
                <span class="n">aMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">,</span><span class="n">ltGoodDirArray</span><span class="p">,</span> <span class="n">sTime</span><span class="p">,</span> <span class="n">approxType</span><span class="p">,...</span>
                <span class="n">approxSchemaName</span><span class="p">,</span> <span class="n">approxSchemaDescr</span><span class="p">,</span> <span class="n">calcPrecision</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellArray</span><span class="p">(</span><span class="n">nPoints</span><span class="p">)</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">();</span>
<span class="n">approxType</span><span class="o">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">enums</span><span class="p">.</span><span class="n">EApproxType</span><span class="p">.</span><span class="n">Internal</span><span class="p">;</span>
<span class="n">sTime</span><span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">for</span> <span class="n">iElem</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="n">nPoints</span>
   <span class="n">ellArray</span><span class="p">(</span><span class="n">iElem</span><span class="p">)</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">(...</span>
   <span class="n">aMat</span><span class="p">(</span><span class="o">:</span><span class="p">,</span><span class="n">iElem</span><span class="p">),</span> <span class="n">qArrayList</span><span class="p">{</span><span class="mi">1</span><span class="p">}(</span><span class="o">:</span><span class="p">,</span><span class="o">:</span><span class="p">,</span><span class="n">iElem</span><span class="p">));</span> 
<span class="n">end</span>
<span class="n">fromEllArrayEllTube</span> <span class="o">=</span> <span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">smartdb</span><span class="p">.</span><span class="n">rels</span><span class="p">.</span><span class="n">EllTube</span><span class="p">.</span><span class="n">fromEllArray</span><span class="p">(...</span>
                <span class="n">ellArray</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">,</span><span class="n">ltGoodDirArray</span><span class="p">,</span> <span class="n">sTime</span><span class="p">,</span> <span class="n">approxType</span><span class="p">,...</span>
                <span class="n">approxSchemaName</span><span class="p">,</span><span class="n">approxSchemaDescr</span><span class="p">,</span> <span class="n">calcPrecision</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>We may be
interested in the data about ellipsoidal tube in some particular time
interval, smaller than the one for which the ellipsoidal tube was
computed, say <span class="math">\(2\leqslant t\leqslant4\)</span>. This data can be extracted
by the cut function:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">cutTimeVec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="n">cutEllTube</span> <span class="o">=</span> <span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">cut</span><span class="p">(</span><span class="n">cutTimeVec</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">example</span>
   <span class="nx">aMat</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span><span class="cp">]</span><span class="p">;</span> <span class="nx">bMat</span> <span class="o">=</span> <span class="nx">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
   <span class="nx">SUBounds</span> <span class="o">=</span> <span class="nx">struct</span><span class="p">();</span>
   <span class="nx">SUBounds</span><span class="p">.</span><span class="nx">center</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sin(t)&#39;</span><span class="p">;</span> <span class="s1">&#39;cos(t)&#39;</span><span class="p">};</span>  
   <span class="nx">SUBounds</span><span class="p">.</span><span class="nx">shape</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">9</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">2</span><span class="cp">]</span><span class="p">;</span> 
   <span class="nx">sys</span> <span class="o">=</span> <span class="nx">elltool</span><span class="p">.</span><span class="nx">linsys</span><span class="p">.</span><span class="nx">LinSysContinuous</span><span class="p">(</span><span class="nx">aMat</span><span class="p">,</span> <span class="nx">bMat</span><span class="p">,</span> <span class="nx">SUBounds</span><span class="p">);</span>
   <span class="nx">x0EllObj</span> <span class="o">=</span> <span class="nx">ell_unitball</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
   <span class="nx">timeVec</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">0</span> <span class="mi">10</span><span class="cp">]</span><span class="p">;</span> 
   <span class="nx">dirsMat</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span><span class="cp">]</span><span class="s1">&#39;;  </span>
<span class="s1">   rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);</span>
<span class="s1">   ellTubeObj = rsObj.getEllTubeRel();</span>
<span class="s1">   projSpaceList = {</span><span class="cp">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span><span class="mi">0</span> <span class="mi">1</span><span class="cp">]</span><span class="s1">};</span>
<span class="s1">   projType = gras.ellapx.enums.EProjType.Static;</span>
<span class="s1">   statEllTubeProj = ellTubeObj.project(projType,projSpaceList,...</span>
<span class="s1">      @fGetProjMat);</span>
<span class="s1">   projType = gras.ellapx.enums.EProjType.DynamicAlongGoodCurve;</span>
<span class="s1">   dynEllTubeProj=ellTubeObj.project(projType,projSpaceList,...</span>
<span class="s1">      @fGetProjMat);</span>
<span class="s1">   plObj=smartdb.disp.RelationDataPlotter();</span>
<span class="s1">   statEllTubeProj.plot(plObj);</span>
<span class="s1">   dynEllTubeProj.plot(plObj);</span>

<span class="s1">end</span>

<span class="s1">function </span><span class="cp">[</span><span class="nx">projOrthMatArray</span><span class="p">,</span><span class="nx">projOrthMatTransArray</span><span class="cp">]</span><span class="s1">=fGetProjMat(projMat,...</span>
<span class="s1">    timeVec,varargin)</span>
<span class="s1">  nTimePoints=length(timeVec);</span>
<span class="s1">  projOrthMatArray=repmat(projMat,</span><span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nx">nTimePoints</span><span class="cp">]</span><span class="s1">);</span>
<span class="s1">  projOrthMatTransArray=repmat(projMat.&#39;</span><span class="p">,</span><span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nx">nTimePoints</span><span class="cp">]</span><span class="p">);</span>
 <span class="nx">end</span>
</pre></div>
</td></tr></table></div>
<p>We can compute the projection of the ellipsoidal
tube onto time-dependent subspace.</p>
<p>Figure <span class="math">\(\ref{project}\)</span> displays static and dynamic projections.
Also we can see projections of good directions for ellipsoidal tubes.</p>
<p>We can compute tubes by the instant of time using methodfromEllTubes:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">example</span>
   <span class="nx">aMat</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span><span class="cp">]</span><span class="p">;</span> <span class="nx">bMat</span> <span class="o">=</span> <span class="nx">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
   <span class="nx">SUBounds</span> <span class="o">=</span> <span class="nx">struct</span><span class="p">();</span>
   <span class="nx">SUBounds</span><span class="p">.</span><span class="nx">center</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sin(t)&#39;</span><span class="p">;</span> <span class="s1">&#39;cos(t)&#39;</span><span class="p">};</span>  
   <span class="nx">SUBounds</span><span class="p">.</span><span class="nx">shape</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">9</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">2</span><span class="cp">]</span><span class="p">;</span> 
   <span class="nx">sys</span> <span class="o">=</span> <span class="nx">elltool</span><span class="p">.</span><span class="nx">linsys</span><span class="p">.</span><span class="nx">LinSysContinuous</span><span class="p">(</span><span class="nx">aMat</span><span class="p">,</span> <span class="nx">bMat</span><span class="p">,</span> <span class="nx">SUBounds</span><span class="p">);</span>
   <span class="nx">x0EllObj</span> <span class="o">=</span> <span class="nx">ell_unitball</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
   <span class="nx">timeVec</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">0</span> <span class="mi">10</span><span class="cp">]</span><span class="p">;</span> 
   <span class="nx">dirsMat</span> <span class="o">=</span> <span class="cp">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span><span class="cp">]</span><span class="s1">&#39;;  </span>
<span class="s1">   rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);</span>
<span class="s1">   ellTubeObj = rsObj.getEllTubeRel();</span>
<span class="s1">   unionEllTube = ...</span>
<span class="s1">    gras.ellapx.smartdb.rels.EllUnionTube.fromEllTubes(ellTubeObj);</span>
<span class="s1">   projSpaceList = {</span><span class="cp">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span><span class="mi">0</span> <span class="mi">1</span><span class="cp">]</span><span class="s1">};</span>
<span class="s1">   projType = gras.ellapx.enums.EProjType.Static;</span>
<span class="s1">   statEllTubeProj = unionEllTube.project(projType,projSpaceList,...</span>
<span class="s1">      @fGetProjMat);</span>
<span class="s1">   plObj=smartdb.disp.RelationDataPlotter();</span>
<span class="s1">   statEllTubeProj.plot(plObj);</span>
<span class="s1">end</span>

<span class="s1">function </span><span class="cp">[</span><span class="nx">projOrthMatArray</span><span class="p">,</span><span class="nx">projOrthMatTransArray</span><span class="cp">]</span><span class="s1">=fGetProjMat(projMat,...</span>
<span class="s1">    timeVec,varargin)</span>
<span class="s1">  nTimePoints=length(timeVec);</span>
<span class="s1">  projOrthMatArray=repmat(projMat,</span><span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nx">nTimePoints</span><span class="cp">]</span><span class="s1">);</span>
<span class="s1">  projOrthMatTransArray=repmat(projMat.&#39;</span><span class="p">,</span><span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nx">nTimePoints</span><span class="cp">]</span><span class="p">);</span>
 <span class="nx">end</span>
</pre></div>
</td></tr></table></div>
<p>Figure <span class="math">\(\ref{unionTubeStatProj}\)</span> shows projection of ellipsoidal
tubes by the instant of time. ellipsoidal tutbes.</p>
<p>Also we can get initial data from the resulting tube:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">approxType</span><span class="o">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">enums</span><span class="p">.</span><span class="n">EApproxType</span><span class="p">.</span><span class="n">Internal</span><span class="p">;</span>
<span class="n">ellArray</span> <span class="o">=</span> <span class="n">fromEllArrayEllTube</span><span class="p">.</span><span class="n">getEllArray</span><span class="p">(</span><span class="n">approxType</span><span class="p">)</span>

<span class="o">%</span> <span class="n">ellArray</span> <span class="o">=</span>
<span class="o">%</span> <span class="n">Array</span> <span class="n">of</span> <span class="n">ellipsoids</span> <span class="n">with</span> <span class="n">dimensionality</span> <span class="mi">5</span><span class="n">x1</span>
</pre></div>
</td></tr></table></div>
<p>There is a method
to display a content of ellipsoidal tubes.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">aMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span> <span class="n">bMat</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
<span class="n">SUBounds</span> <span class="o">=</span> <span class="k">struct</span><span class="p">();</span>
<span class="n">SUBounds</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="p">{</span><span class="err">&#39;</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="err">&#39;</span><span class="p">;</span> <span class="err">&#39;</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="err">&#39;</span><span class="p">};</span>  
<span class="n">SUBounds</span><span class="p">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">];</span> 
<span class="n">sys</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysContinuous</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">);</span>
<span class="n">x0EllObj</span> <span class="o">=</span> <span class="n">ell_unitball</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">timeVec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">10</span><span class="p">];</span> 
<span class="k">for</span> <span class="n">iElem</span> <span class="o">=</span> <span class="mi">1</span><span class="o">:</span><span class="mi">5</span>
    <span class="n">dirInitial</span><span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
    <span class="n">dirInitial</span> <span class="o">=</span> <span class="n">dirInitial</span> <span class="p">.</span><span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">dirInitial</span><span class="p">);</span>
    <span class="n">dirsMat</span><span class="p">(</span><span class="o">:</span><span class="p">,</span> <span class="n">iElem</span><span class="p">)</span> <span class="o">=</span> <span class="n">dirInitial</span><span class="p">;</span>
<span class="n">end</span>
<span class="n">rsObj</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachContinuous</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">x0EllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">);</span>
<span class="n">ellTubeObj</span> <span class="o">=</span> <span class="n">rsObj</span><span class="p">.</span><span class="n">getEllTubeRel</span><span class="p">();</span>
<span class="n">ellTubeObj</span><span class="p">.</span><span class="n">dispOnUI</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p>Figure <span class="math">\(\ref{dispPic}\)</span>
displays all fields of the ellipsoidal tube.</p>
<p>There are several methods to find the tubes with necessary parameters.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">newEllTube</span> <span class="o">=</span> <span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuplesFilteredBy</span><span class="p">(</span><span class="err">&#39;</span><span class="n">sTime</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">newEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="o">%</span>
<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>
<span class="o">%</span> 
<span class="n">newEllTube</span> <span class="o">=</span> <span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuplesFilteredBy</span><span class="p">(</span><span class="err">&#39;</span><span class="n">sTime</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">newEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="o">%</span>
<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">0</span>
<span class="o">%</span> 
</pre></div>
</td></tr></table></div>
<p>Also you can use the method display to see the result of the method’s
work.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="o">%</span>
<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>
<span class="o">%</span> 
<span class="n">fromEllArrayEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="o">%</span>
<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>
<span class="o">%</span> 
<span class="n">origFromMatEllTube</span><span class="o">=</span><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getCopy</span><span class="p">();</span>
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">unionWith</span><span class="p">(</span><span class="n">fromEllArrayEllTube</span><span class="p">);</span>
<span class="o">%</span>
<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">2</span>
<span class="o">%</span> 
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="n">isOk</span><span class="o">=</span><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuples</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">isEqual</span><span class="p">(</span><span class="n">origFromMatEllTube</span><span class="p">)</span>
<span class="o">%</span>
<span class="o">%</span> <span class="n">isOk</span> <span class="o">=</span>
<span class="o">%</span>
<span class="o">%</span>     <span class="mi">1</span>

<span class="n">isOk</span><span class="o">=</span><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuples</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">isEqual</span><span class="p">(</span><span class="n">fromEllArrayEllTube</span><span class="p">)</span>

<span class="o">%</span>
<span class="o">%</span> <span class="n">isOk</span> <span class="o">=</span>
<span class="o">%</span>
<span class="o">%</span>     <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p>We can sort our tubes by certain fields:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">sortBy</span><span class="p">(</span><span class="err">&#39;</span><span class="n">sTime</span><span class="err">&#39;</span><span class="p">);</span>
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="reachability">
<h2>Reachability<a class="headerlink" href="#reachability" title="Permalink to this headline">¶</a></h2>
<p>To compute the reach sets of the systems described in chapter 3, we
define few new classes in the <em>Ellipsoidal Toolbox</em>: class
LinSysContinuous for the continuous-time system description, class
LinSysDiscrete for the discrete-time system description and classes
ReachContinuous<span class="math">\(\backslash\)</span>ReachDiscrete for the reach set
data. We start by explaining how to define a system using
LinSysContinuous object. Also we can use LinSysFactory class for the
description of this system. Through it’s method create user can get
LinSysContinuous or LinSysDiscrete object. For example, description of
the system</p>
<div class="math">
\[\begin{split}\left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 &amp; 1\\
0 &amp; 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right], ~~~ u(t)\in{\mathcal E}(p(t), P)\end{split}\]</div>
<p>with</p>
<div class="math">
\[\begin{split}p(t) = \left[\begin{array}{c}
\sin(t)\\
\cos(t)\end{array}\right], ~~~ P = \left[\begin{array}{cc}
9 &amp; 0\\
0 &amp; 2\end{array}\right],\end{split}\]</div>
<p>is done by the following sequence of commands:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">aMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span> <span class="n">bMat</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="o">%</span> <span class="n">matrices</span> <span class="n">A</span> <span class="n">and</span> <span class="n">B</span><span class="p">,</span> <span class="n">B</span> <span class="n">is</span> <span class="n">identity</span>
<span class="n">SUBounds</span> <span class="o">=</span> <span class="k">struct</span><span class="p">();</span>
<span class="o">%</span> <span class="n">center</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ellipsoid</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">t</span>
<span class="n">SUBounds</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="p">{</span><span class="err">&#39;</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="err">&#39;</span><span class="p">;</span> <span class="err">&#39;</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="err">&#39;</span><span class="p">};</span>  
<span class="n">SUBounds</span><span class="p">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">9</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">];</span> <span class="o">%</span> <span class="n">shape</span> <span class="n">matrix</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ellipsoid</span> <span class="n">is</span> <span class="k">static</span>
<span class="o">%</span> <span class="n">create</span> <span class="n">linear</span> <span class="n">system</span> <span class="n">object</span>
<span class="n">sys</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysContinuous</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">);</span> 
<span class="o">%</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">sys</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysFactory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>If matrices <span class="math">\(A\)</span> or
<span class="math">\(B\)</span> depend on time, say <span class="math">\(A(t)=\left[\begin{array}{cc}
0 &amp; 1-\cos(2t)\\
-\frac{1}{t} &amp; 0\end{array}\right]\)</span>, then matrix aMat should be
symbolic:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">atMat</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;0&#39;</span> <span class="err">&#39;</span><span class="mi">1</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="err">&#39;</span><span class="p">;</span> <span class="err">&#39;</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">t</span><span class="sc">&#39; &#39;</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">};</span>  
<span class="kt">sys_t</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysFactory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">atMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>To describe the system with disturbance</p>
<div class="math">
\[\begin{split}\left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 &amp; 1\\
0 &amp; 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]v(t),\end{split}\]</div>
<p>with bounds on control as before, and disturbance being
<span class="math">\(-1\leqslant v(t)\leqslant1\)</span>, we type:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">gMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>  <span class="o">%</span> <span class="n">matrix</span> <span class="n">G</span>
<span class="n">vEllObj</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="o">%</span> <span class="n">disturbance</span> <span class="n">bounds</span><span class="o">:</span> <span class="n">unit</span> <span class="n">ball</span> <span class="n">in</span> <span class="n">R</span>
<span class="n">sys_d</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysContinuous</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">,...</span>
    <span class="n">gMat</span><span class="p">,</span> <span class="n">vEllObj</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Control and disturbance
bounds SUBounds and vEllObj can have different types. If the bound is
constant, it should be described by ellipsoid object. If the bound
depends on time, then it is represented by a structure with fields
center and shape, one or both of which are symbolic. In system sys, the
control bound SUBounds is defined as such a structure. Finally, if the
control or disturbance is known and fixed, it should be defined as a
vector, of type double if constant, or symbolic, if it depends on time.</p>
<p>To declare a discrete-time system</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c}
x_1[k+1]\\
x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
0 &amp; 1\\
-1 &amp; -0.5\end{array}\right]\left[\begin{array}{c}
x_1[k]\\
x_2[k]\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]u[k], ~~~ -1\leqslant u[k]\leqslant1,\end{split}\]</div>
<p>we use LinSysDiscrete constructor:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">adMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span> <span class="n">bdMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>  <span class="o">%</span> <span class="n">matrices</span> <span class="n">A</span> <span class="n">and</span> <span class="n">B</span>
<span class="n">udBoundsEllObj</span>  <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="o">%</span> <span class="n">control</span> <span class="n">bounds</span><span class="o">:</span> <span class="n">unit</span> <span class="n">ball</span> <span class="n">in</span> <span class="n">R</span>
<span class="o">%</span> <span class="n">discrete</span><span class="o">-</span><span class="n">time</span> <span class="n">system</span>
<span class="n">dtsys</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysDiscrete</span><span class="p">(</span><span class="n">adMat</span><span class="p">,</span> <span class="n">bdMat</span><span class="p">,</span> <span class="n">udBoundsEllObj</span><span class="p">);</span> 
<span class="o">%</span> <span class="n">is</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">dtsys</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysFactory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">adMat</span><span class="p">,</span> <span class="n">bdMat</span><span class="p">,...</span>
<span class="o">%</span>         <span class="n">udBoundsEllObj</span><span class="p">,...[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="sc">&#39;d&#39;</span><span class="p">);</span> 
</pre></div>
</td></tr></table></div>
<p>Once the LinSysDiscrete object is
created, we need to specify the set of initial conditions, the time
interval and values of the direction vector, for which the reach set
approximations must be computed:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">x0EllObj</span> <span class="o">=</span> <span class="n">ell_unitball</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="o">%</span> <span class="n">set</span> <span class="n">of</span> <span class="n">initial</span> <span class="n">conditions</span>
<span class="n">timeVec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">10</span><span class="p">];</span>  <span class="o">%</span> <span class="n">time</span> <span class="n">interval</span>
<span class="n">dirsMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span><span class="err">&#39;</span><span class="p">;</span>  <span class="o">%</span> <span class="n">columns</span> <span class="n">of</span> <span class="n">L</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">directions</span>
</pre></div>
</td></tr></table></div>
<p>The reach set approximation is computed
by calling the constructor of the ReachContinuous object:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% reach set of continuos-time system</span>
<span class="n">firstRsObj</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachContinuous</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">x0EllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">);</span> 
</pre></div>
</td></tr></table></div>
<p>At this point,
variable firstRsObj contains the reach set approximations for the
specified continuous-time system, time interval and set of initial
conditions computed for given directions. Both external and internal
approximations are computed. The reach set approximation data can be
extracted in the form of arrays of ellipsoids:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">externallEllMat</span> <span class="o">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_ea</span><span class="p">()</span>  <span class="o">%</span> <span class="n">external</span> <span class="n">approximating</span> <span class="n">ellipsoids</span>

<span class="o">%</span> <span class="n">externallEllMat</span> <span class="o">=</span>
<span class="o">%</span> <span class="n">Array</span> <span class="n">of</span> <span class="n">ellipsoids</span> <span class="n">with</span> <span class="n">dimensionality</span> <span class="mi">2</span><span class="n">x100</span>

<span class="o">%</span> <span class="n">internal</span> <span class="n">approximating</span> <span class="n">ellipsoids</span>
<span class="p">[</span><span class="n">internalEllMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_ia</span><span class="p">();</span>  
</pre></div>
</td></tr></table></div>
<p>Ellipsoidal arrays externallEllMat and internalEllMat have <span class="math">\(4\)</span>
rows because we computed the reach set approximations for <span class="math">\(4\)</span>
directions. Each row of ellipsoids corresponds to one direction. The
number of columns in externallEllMat and internalEllMat is defined by
the nTimeGridPoints parameter, which is available from
elltool.conf.Properties static class (see chapter 6 for details). It
represents the number of time values in our time interval, at which the
approximations are evaluated. These time values are returned in the
optinal output parameter, array timeVec, whose length is the same as the
number of columns in externallEllMat and internalEllMat. Intersection of
ellipsoids in a particular column of externallEllMat gives external
ellipsoidal approximation of the reach set at corresponding time.
Internal ellipsoidal approximation of this set at this time is given by
the union of ellipsoids in the same column of internalEllMat.</p>
<p>We may be interested in the reachability data of our system in some
particular time interval, smaller than the one for which the reach set
was computed, say <span class="math">\(3\leqslant t\leqslant5\)</span>. This data can be
extracted and returned in the form of ReachContinuous object by the cut
function:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">cutObj</span> <span class="o">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">cut</span><span class="p">([</span><span class="mi">3</span> <span class="mi">5</span><span class="p">]);</span>  <span class="o">%</span> <span class="n">reach</span> <span class="n">set</span> <span class="k">for</span> <span class="n">the</span> <span class="n">time</span> <span class="n">interval</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</pre></div>
</td></tr></table></div>
<p>To obtain a snap shot of the reach set at given time, the same function
cut is used:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">cutObj</span> <span class="o">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="o">%</span> <span class="n">reach</span> <span class="n">set</span> <span class="n">at</span> <span class="n">time</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</td></tr></table></div>
<p>It can be checked if the external or internal reach set
approximation intersects with given ellipsoids, hyperplanes or
polytopes:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellObj</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="o">-</span><span class="mi">17</span><span class="p">;</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">]);</span>  <span class="o">%</span> <span class="n">define</span> <span class="n">ellipsoid</span>
<span class="o">%</span> <span class="n">define</span> <span class="mi">4</span> <span class="n">hyperplanes</span>
<span class="n">hypVec</span> <span class="o">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">]</span><span class="err">&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]);</span> 
<span class="n">polObj</span> <span class="o">=</span> <span class="n">hyperplane2polytope</span><span class="p">(</span><span class="n">hypVec</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">10</span><span class="p">];</span>  <span class="o">%</span> <span class="n">define</span> <span class="n">polytope</span>
<span class="o">%</span> <span class="n">check</span> <span class="k">if</span> <span class="n">ellipsoid</span> <span class="n">ell</span> <span class="n">intersects</span> <span class="n">with</span> <span class="n">external</span> <span class="n">approximation</span><span class="o">:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellObj</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">)</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>      <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% check if ellipsoid ellObj intersects with internal approximation:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellObj</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>

<span class="c">% </span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% check if hyperplanes in hypVec intersect with internal approximation:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">hypVec</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     1     1     1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% check if polytope polObj intersects with external approximation:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">polObj</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0</span>
</pre></div>
</td></tr></table></div>
<p>If a given set intersects with the internal approximation of the reach
set, then this set intersects with the actual reach set. If the given
set does not intersect with external approximation, this set does not
intersect the actual reach set. There are situations, however, when the
given set intersects with the external approximation but does not
intersect with the internal one. In our example above, ellipsoid ellObj
is such a case: the quality of the approximation does not allow us to
determine whether or not ellObj intersects with the actual reach set. To
improve the quality of approximation, refine function should be used:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define new directions, in this case one, but could be more</span>
<span class="n">newDirsMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="c">% compute approximations for the new directions</span>
<span class="n">firstRsObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="n">newDirsMat</span><span class="p">);</span>
<span class="c">% snap shot of the reach set at time t = 5</span>
<span class="n">cutObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c">% check if ellObj intersects the internal approximation</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellObj</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Now we are sure that ellipsoid ellObj intersects with the actual reach
set. However, to use the refine function, the reach set object must
contain all calculated data, otherwise, an error is returned.</p>
<p>Having a reach set object resulting from the ReachContinuous, cut or
refine operations, we can obtain the trajectory of the center of the
reach set and the good curves along which the actual reach set is
touched by its ellipsoidal approximations:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">[</span><span class="n">ctrMat</span><span class="p">,</span> <span class="n">ttVec</span><span class="p">]</span> <span class="o">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_center</span><span class="p">();</span> <span class="o">%</span> <span class="n">trajectory</span> <span class="n">of</span> <span class="n">the</span> <span class="n">center</span>
<span class="n">gcCVec</span> <span class="o">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_goodcurves</span><span class="p">()</span>  <span class="o">%</span> <span class="n">get</span> <span class="n">good</span> <span class="n">curves</span>

<span class="o">%</span> <span class="n">gcCVec</span> <span class="o">=</span>
<span class="o">%</span> <span class="p">[</span><span class="mi">2</span><span class="n">x100</span> <span class="kt">double</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="n">x100</span> <span class="kt">double</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="n">x100</span> <span class="kt">double</span><span class="p">]</span> 
</pre></div>
</td></tr></table></div>
<p>Variable ctrMat here is a matrix whose columns are the points ofthe
reach set center trajectory evaluated at time values returned in the
array ttVec. Variable gcCMat contains <span class="math">\(4\)</span> matrices each of which
corresponds to a good curve (columns of such matrix are points of the
good curve evaluated at time values in ttVec). The analytic expression
for the control driving the system along a good curve is given by
formula <a href="#equation-uct">(?)</a>.</p>
<p>We computed the reach set up to time <span class="math">\(10\)</span>. It is possible to
continue the reach set computation for a longer time horizon using the
reach set data at time <span class="math">\(10\)</span> as initial condition. It is also
possible that the dynamics and inputs of the system change at certain
time, and from that point on the system evolves according to the new
system of differential equations. For example, starting at time
<span class="math">\(10\)</span>, our reach set may evolve in time according to the
time-variant system sys_t defined above. Switched systems are a special
case of this situation. To compute the further evolution in time of the
existing reach set, function evolve should be used:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% reach set from time 10 to 14 with the same dynamics</span>
<span class="n">secRsObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span> 
<span class="c">% reach set from time 10 to 12 with new dynamics</span>
<span class="n">secRsObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">sys_t</span><span class="p">);</span>  

<span class="c">% not only the dynamics, but the inputs can change as well,</span>
<span class="c">% from time 12 to 13 disturbance is added to the system:</span>

<span class="c">% sys_d - system with disturbance defined above</span>
<span class="n">thirdRsObj</span> <span class="p">=</span> <span class="n">secRsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">);</span>  
</pre></div>
</td></tr></table></div>
<p>Function evolve can
be viewed as an implementation of the semigroup property.</p>
<p>To compute the backward reach set for some specified target set, we
declare the time interval so that the terminating time comes first:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% target set in the form of ellipsoid</span>
<span class="n">yEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">8</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">tbTimeVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">5</span><span class="p">];</span>  <span class="c">% backward time interval</span>
<span class="c">% backward reach set</span>
<span class="n">firstBrsObj</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachContinuous</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">yEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span><span class="c">...</span>
        <span class="n">tbTimeVec</span><span class="p">);</span>  
<span class="n">firstBrsObj</span> <span class="p">=</span> <span class="n">firstBrsObj</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="n">newDirsMat</span><span class="p">);</span>  <span class="c">% refine the approximation</span>
<span class="c">% further evolution in backward time from 5 to 0; </span>
<span class="n">secBrsObj</span> <span class="p">=</span> <span class="n">firstBrsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
</pre></div>
</td></tr></table></div>
<p>Reach set and backward reach set computation for discrete-time systems
and manipulations with the resulting reach set object are performed
using the same functions as for continuous-time systems:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">timeVec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">100</span><span class="p">];</span>  <span class="o">%</span> <span class="n">represents</span> <span class="mi">100</span> <span class="n">time</span> <span class="n">steps</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">100</span>
<span class="o">%</span> <span class="n">reach</span> <span class="n">set</span> <span class="k">for</span> <span class="mi">100</span> <span class="n">time</span> <span class="n">steps</span>
<span class="n">secDtrsObj</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachDiscrete</span><span class="p">(</span><span class="n">dtsys</span><span class="p">,</span> <span class="n">x0EllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">);</span> 
<span class="n">secDtrsObj</span> <span class="o">=</span> <span class="n">secDtrsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>  <span class="o">%</span> <span class="n">compute</span> <span class="n">next</span> <span class="mi">100</span> <span class="n">time</span> <span class="n">steps</span>

<span class="n">tbTimeVec</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span> <span class="mi">0</span><span class="p">];</span>  <span class="o">%</span> <span class="n">backward</span> <span class="n">time</span> <span class="n">interval</span>
<span class="o">%</span> <span class="n">backward</span> <span class="n">reach</span> <span class="n">set</span>
<span class="n">dtbrsObj</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachDiscrete</span><span class="p">(</span><span class="n">dtsys</span><span class="p">,</span> <span class="n">yEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">tbTimeVec</span><span class="p">);</span>  
<span class="n">dtbrsObj</span> <span class="o">=</span> <span class="n">dtbrsObj</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="n">newDirsMat</span><span class="p">);</span>  <span class="o">%</span> <span class="n">refine</span> <span class="n">the</span> <span class="n">approximation</span>
<span class="o">%</span> <span class="n">get</span> <span class="n">external</span> <span class="n">approximating</span> <span class="n">ellipsoids</span> <span class="n">and</span> <span class="n">time</span> <span class="n">values</span>
<span class="p">[</span><span class="n">externallEllMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtbrsObj</span><span class="p">.</span><span class="n">get_ea</span><span class="p">();</span>
<span class="o">%</span> <span class="n">get</span> <span class="n">internal</span> <span class="n">approximating</span> <span class="n">ellipsoids</span>
<span class="n">internalEllMat</span> <span class="o">=</span> <span class="n">dtbrsObj</span><span class="p">.</span><span class="n">get_ia</span><span class="p">()</span>

<span class="o">%</span> <span class="n">internalEllMat</span> <span class="o">=</span>
<span class="o">%</span> <span class="n">Array</span> <span class="n">of</span> <span class="n">ellipsoids</span> <span class="n">with</span> <span class="n">dimensionality</span> <span class="mi">3</span><span class="n">x51</span>
</pre></div>
</td></tr></table></div>
<p>Number of columns in the ellipsoidal arrays externalEllMat and
internalEllMat is <span class="math">\(51\)</span> because the backward reach set is computed
for <span class="math">\(50\)</span> time steps, and the first column of these arrays contains
<span class="math">\(3\)</span> ellipsoids yEllObj - the terminating condition.</p>
<p>When dealing with discrete-time systems, all functions that accept time
or time interval as an input parameter, round the time values and treat
them as integers.</p>
</div>
<div class="section" id="properties">
<h2>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h2>
<p>Functions of the <em>Ellipsoidal Toolbox</em> can be called with user-specified
values of certain global parameters. System of the parameters are
configured using xml files, which available from a set of command-line
utilities:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">elltool</span><span class="p">.</span><span class="n">setconf</span><span class="p">(</span><span class="err">&#39;</span><span class="k">default</span><span class="err">&#39;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Here we list system parameters available from the ’default’
configuration:</p>
<ol class="arabic simple">
<li>version = ’1.4dev’ - current version of <em>ET</em>.</li>
<li>isVerbose = false - makes all the calls to <em>ET</em> routines silent, and
no information except errors is displayed.</li>
<li>absTol = 1e-7 - absolute tolerance.</li>
<li>relTol = 1e-5 - relative tolerance.</li>
<li>nTimeGridPoints = 200 - density of the time grid for the continuous
time reach set computation. This parameter directly affects the
number of ellipsoids to be stored in the
ReachContinuous<span class="math">\(\backslash\)</span>ReachDiscrete object.</li>
<li>ODESolverName = ode45 - specifies the ODE solver for continuous time
reach set computation.</li>
<li>isODENormControl = ’on’ - switches on and off the norm control in the
ODE solver. When turned on, it slows down the computation, but
improves the accuracy.</li>
<li>isEnabledOdeSolverOptions = false - when set to false, calls the ODE
solver without any additional options like norm control. It makes the
computation faster but less accurate. Otherwise, it is assumed to be
true, and only in this case the previous option makes a difference.</li>
<li>nPlot2dPoints = 200 - the number of points used to plot a 2D
ellipsoid. This parameter also affects the quality of 2D reach tube
and reach set plots.</li>
<li>nPlot3dPoints = 200 - the number of points used to plot a 3D
ellipsoid. This parameter also affects the quality of 3D reach set
plots.</li>
</ol>
<p>Once the configuration is loaded, the system parameters are available
through elltool.conf.Properties. elltool.conf.Properties is a static
class, providing emulation of static properties for toolbox. It has two
function types: setters and getters. Using getters we obtain system
parameters.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">elltool</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">Properties</span><span class="p">.</span><span class="n">getAbsTol</span><span class="p">()</span>
<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="mf">1.0000e-07</span>

<span class="n">elltool</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">Properties</span><span class="p">.</span><span class="n">getNPlot2dPoints</span><span class="p">()</span>

<span class="o">%</span> <span class="n">ans</span> <span class="o">=</span>
<span class="o">%</span> 
<span class="o">%</span>    <span class="mi">200</span>
</pre></div>
</td></tr></table></div>
<p>Some of the parameters can be changed in run-time via
setters.</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">elltool</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">Properties</span><span class="p">.</span><span class="n">setNTimeGridPoints</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p><em>Ellipsoidal Toolbox</em> has several plotting routines:</p>
<ul class="simple">
<li>ellipsoid/plot - plots one or more ellipsoids, or arrays of
ellipsoids, defined in <span class="math">\({\bf R}\)</span>, <span class="math">\({\bf R}^2\)</span> or
<span class="math">\({\bf R}^3\)</span>.</li>
<li>ellipsoid/minksum - plots geometric sum of finite number of
ellipsoids defined in <span class="math">\({\bf R}\)</span>, <span class="math">\({\bf R}^2\)</span> or
<span class="math">\({\bf R}^3\)</span>.</li>
<li>ellipsoid/minkdiff - plots geometric difference (if it is not an
empty set) of two ellipsoids defined in <span class="math">\({\bf R}\)</span>,
<span class="math">\({\bf R}^2\)</span> or <span class="math">\({\bf R}^3\)</span>.</li>
<li>ellipsoid/minkmp - plots geometric (Minkowski) sum of the geometric
difference of two ellipsoids and the geometric sum of <span class="math">\(n\)</span>
ellipsoids defined in <span class="math">\({\bf R}\)</span>, <span class="math">\({\bf R}^2\)</span> or
<span class="math">\({\bf R}^3\)</span>.</li>
<li>ellipsoid/minkpm - plots geometric (Minkowski) difference of the
geometric sum of ellipsoids and a single ellipsoid defined in
<span class="math">\({\bf R}\)</span>, <span class="math">\({\bf R}^2\)</span> or <span class="math">\({\bf R}^3\)</span>.</li>
<li>hyperplane/plot - plots one or more hyperplanes, or arrays of
hyperplanes, defined in <span class="math">\({\bf R}^2\)</span> or <span class="math">\({\bf R}^3\)</span>.</li>
<li>reach/plot_ea - plots external approximation of the reach set whose
dimension is <span class="math">\(2\)</span> or <span class="math">\(3\)</span>.</li>
<li>reach/plot_ia - plots internal approximation of the reach set whose
dimension is <span class="math">\(2\)</span> or <span class="math">\(3\)</span>.</li>
</ul>
<p>All these functions allow the user to specify the color of the plotted
objects, line width for 1D and 2D plots, and transparency level of the
3D objects. Hyperplanes are displayed as line segments in 2D and square
facets in 3D. In the hyperplane/plot method it is possible to specify
the center of the line segment or facet and its size.</p>
<p>Ellipsoids of dimensions higher than three must be projected onto a two-
or three-dimensional subspace before being plotted. This is done by
means of projection function:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% create two 4-dimensional ellipsoids:</span>
<span class="n">firstEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">14</span> <span class="o">-</span><span class="mi">4</span> <span class="mi">2</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span> <span class="o">-</span><span class="mi">4</span> <span class="mi">6</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">5</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">secEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">getInv</span><span class="p">();</span>

<span class="c">% specify 3-dimensional subspace by its basis:</span>

<span class="c">% columns of basisMat must be orthogonal</span>
<span class="n">basisMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">].</span><span class="s">&#39;</span><span class="err">; </span>

<span class="c">% get 3-dimensional projections of firstEllObj and secEllObj:</span>
<span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span><span class="p">];</span>
<span class="c">% array ellVec contains projections of firstEllObj and secEllObj</span>
<span class="n">ellVec</span> <span class="p">=</span> <span class="n">bufEllVec</span><span class="p">.</span><span class="n">projection</span><span class="p">(</span><span class="n">basisMat</span><span class="p">)</span>  

<span class="c">% ellVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x2</span>

<span class="n">ellVec</span><span class="p">.</span><span class="n">plot</span><span class="p">();</span>  <span class="c">% plot ellipsoids in ellVec</span>
</pre></div>
</td></tr></table></div>
<p>Since the operation of projection is linear, the projection of the
geometric sum of ellipsoids equals the geometric sum of the projected
ellipsoids. The same is true for the geometric difference of two
ellipsoids.</p>
<p>Function projection exists also for the
ReachContinuous<span class="math">\(\backslash\)</span>ReachDiscrete objects:</p>
<div class="highlight-guess"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">aMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>
<span class="n">bMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>
<span class="n">uBoundsEllObj</span> <span class="o">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="o">%</span> <span class="mi">4</span><span class="o">-</span><span class="n">dimensional</span> <span class="n">system</span>
<span class="n">sys</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysFactory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">uBoundsEllObj</span><span class="p">);</span>
<span class="n">dirsMat</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">].</span><span class="err">&#39;</span><span class="p">;</span> <span class="o">%</span> <span class="n">matrix</span> <span class="n">of</span> <span class="n">directions</span>
<span class="o">%</span> <span class="n">reach</span> <span class="n">set</span> <span class="n">from</span> <span class="n">time</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">5</span>
<span class="n">rsObj</span> <span class="o">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachContinuous</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">ell_unitball</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">dirsMat</span><span class="p">,...</span>
    <span class="p">[</span><span class="mi">0</span> <span class="mi">5</span><span class="p">],</span> <span class="err">&#39;</span><span class="n">isRegEnabled</span><span class="err">&#39;</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">isJustCheck</span><span class="err">&#39;</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">regTol</span><span class="err">&#39;</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">);</span>
<span class="n">basisMat</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">].</span><span class="err">&#39;</span><span class="p">;</span>  <span class="o">%</span> <span class="n">basis</span> <span class="n">of</span> <span class="mi">2</span><span class="o">-</span><span class="n">dimensional</span> <span class="n">subspace</span>

<span class="o">%</span> <span class="n">project</span> <span class="n">reach</span> <span class="n">set</span> <span class="n">rs</span> <span class="n">onto</span> <span class="n">basis</span> <span class="n">basisMat</span>
<span class="n">psObj</span> <span class="o">=</span> <span class="n">rsObj</span><span class="p">.</span><span class="n">projection</span><span class="p">(</span><span class="n">basisMat</span><span class="p">);</span>
<span class="n">psObj</span><span class="p">.</span><span class="n">plotByEa</span><span class="p">();</span>  <span class="o">%</span> <span class="n">plot</span> <span class="n">external</span> <span class="n">approximation</span>
<span class="n">hold</span> <span class="n">on</span><span class="p">;</span>
<span class="n">psObj</span><span class="p">.</span><span class="n">plotByIa</span><span class="p">();</span>  <span class="o">%</span> <span class="n">plot</span> <span class="n">internal</span> <span class="n">approximation</span>
</pre></div>
</td></tr></table></div>
<p>The quality of the ellipsoid and reach set plots is controlled by the
parameters nPlot2dPoints and nPlot3dPoints, which are available from
getters of ellipsoid class.</p>
<div class="references"><p>“CVX Homepage.” cvxr.com/cvx.</p>
<p>“Multi-Parametric Toolbox Homepage.” control.ee.ethz.ch/\~mpt.</p>
<p>“SeDuMi Homepage.” sedumi.mcmaster.ca.</p>
<p>“Stanley Chan Article Homepage.”
<a class="reference external" href="http://videoprocessing.ucsd.edu/~stanleychan/publication/unpublished/Ellipse.pdf">http://videoprocessing.ucsd.edu/~stanleychan/publication/unpublished/Ellipse.pdf</a>.</p>
<p>Kvasnica, M., P. Grieder, M. Baotić, and M. Morari. 2004.
“Multi-Parametric Toolbox (MPT).” In <em>Hybrid Systems: Computation and
Control</em>, edited by R. Alur and G. J. Pappas, 2993:448–462. Springer.</p>
<p>Lin, A., and S. Han. 2002. “On the Distance Between Two Ellipsoids.”
<em>SIAM Journal on Optimization</em> 13 (1): 298–308.</p>
<p>Sturm, J. F. 1999. “Using SeDuMi 1.02, A MATLAB Toolbox for Optimization
over Symmetric Cones.” <em>Optimization Methods and Software</em> 11-12:
625–653.</p>
<p>L. Ros, A. Sabater, F. Thomas. 2002. “An Ellipsoidal Calculus Based on
Propagation and Fusion.” <em>IEEE
Transactions on Systems, Man and Cybernetics, Part B: Cybernetics</em> 32 (4).</p>
</div></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="main_manual.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementation</a><ul>
<li><a class="reference internal" href="#operations-with-ellipsoids">Operations with ellipsoids</a></li>
<li><a class="reference internal" href="#operations-with-hyperplanes">Operations with hyperplanes</a></li>
<li><a class="reference internal" href="#operations-with-ellipsoidal-tubes">Operations with ellipsoidal tubes</a></li>
<li><a class="reference internal" href="#reachability">Reachability</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chap_install.html"
                        title="previous chapter">Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chap_examples.html"
                        title="next chapter">Examples</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chap_implement.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chap_examples.html" title="Examples"
             >next</a> |</li>
        <li class="right" >
          <a href="chap_install.html" title="Installation"
             >previous</a> |</li>
        <li><a href="main_manual.html">Ellipsoidal Toolbox 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Lukashevichus K..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b2.
    </div>
  </body>
</html>