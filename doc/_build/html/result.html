<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction &mdash; elltool_manual 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="elltool_manual 0.1 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="main_manual.html">elltool_manual 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>Research on dynamical and hybrid systems has produced several methods
for verification and controller synthesis. A common step in these
methods is the reachability analysis of the system. Reachability
analysis is concerned with the computation of the reach set in a way
that can effectively meet requests like the following:</p>
<ol class="arabic simple">
<li>For a given target set and time, determine whether the reach set and
the target set have nonempty intersection.</li>
<li>For specified reachable state and time, find a feasible initial
condition and control that steers the system from this initial
condition to the given reachable state in given time.</li>
<li>Graphically display the projection of the reach set onto any
specified two- or three-dimensional subspace.</li>
</ol>
<p>Except for very specific classes of systems, exact computation of reach
sets is not possible, and approximation techniques are needed. For
controlled linear systems with convex bounds on the control and initial
conditions, the efficiency and accuracy of these techniques depend on
how they represent convex sets and how well they perform the operations
of unions, intersections, geometric (Minkowski) sums and differences of
convex sets. Two basic objects are used as convex approximations:
polytopes of various types, including general polytopes, zonotopes,
parallelotopes, rectangular polytopes; and ellipsoids.</p>
<p>Reachability analysis for general polytopes is implemented in the Multi
Parametric Toolbox (MPT) for Matlab Kvasnica et al. (2004;
“Multi-Parametric Toolbox Homepage”). The reach set at every time step
is computed as the geometric sum of two polytopes. The procedure
consists in finding the vertices of the resulting polytope and
calculating their convex hull. MPT’s convex hull algorithm is based on
the Double Description method Motzkin et al. (1953) and implemented in
the CDD/CDD+ package (“CDD/CDD+ Homepage”). Its complexity is
<span class="math">V^n</span>, where <span class="math">V</span> is the number of vertices and <span class="math">n</span> is
the state space dimension. Hence the use of MPT is practicable for low
dimensional systems. But even in low dimensional systems the number of
vertices in the reach set polytope can grow very large with the number
of time steps. For example, consider the system,</p>
<div class="math">
\[x_{k+1} = Ax_k + u_k ,\]\[with :math:`A=\left[\begin{array}{cc}\]</div>
<p>cos 1 &amp; -sin 1\
sin 1 &amp; cos 1end{array}right]`,
<span class="math">u_k \in \{u\in {\bf R}^2 ~|~ \|u\|_{\infty}\leqslant1\}</span>, and
<span class="math">x_0 \in \{x\in {\bf R}^2 ~|~ \|x\|_{\infty}\leqslant1\}</span>.
Starting with a rectangular initial set, the number of vertices of the
reach set polytope is <span class="math">4k + 4</span> at the <span class="math">k</span>th step.</p>
<p>In <span class="math">d/dt</span> (“$d/dt$ Homepage”), the reach set is approximated by
unions of rectangular polytopes E.Asarin et al. (2000).</p>
<p><img alt="image" src="_images/ddt.eps" /></p>
<p>[ddtfig]</p>
<p>The algorithm works as follows. First, given the set of initial
conditions defined as a polytope, the evolution in time of the
polytope’s extreme points is computed (figure [ddtfig](a)).
<span class="math">R(t_1)</span> in figure [ddtfig](a) is the reach set of the system at
time <span class="math">t_1</span>, and <span class="math">R[t_0, t_1]</span> is the set of all points that
can be reached during <span class="math">[t_0, t_1]</span>. Second, the algorithm computes
the convex hull of vertices of both, the initial polytope and
<span class="math">R(t_1)</span> (figure [ddtfig](b)). The resulting polytope is then
bloated to include all the reachable states in <span class="math">[t_0,t_1]</span> (figure
[ddtfig](c)). Finally, this overapproximating polytope is in its turn
overapproximated by the union of rectangles (figure [ddtfig](d)). The
same procedure is repeated for the next time interval <span class="math">[t_1,t_2]</span>,
and the union of both rectangular approximations is taken (figure
[ddtfig](e,f)), and so on. Rectangular polytopes are easy to represent
and the number of facets grows linearly with dimension, but a large
number of rectangles must be used to assure the approximation is not
overly conservative. Besides, the important part of this method is again
the convex hull calculation whose implementation relies on the same
CDD/CDD+ library. This limits the dimension of the system and time
interval for which it is feasible to calculate the reach set.</p>
<p>Polytopes can give arbitrarily close approximations to any convex set,
but the number of vertices can grow prohibitively large and, as shown in
Avis, Bremner, and Seidel (1997), the computation of a polytope by its
convex hull becomes intractable for large number of vertices in high
dimensions.</p>
<p>The method of zonotopes for approximation of reach sets Girard (2005;
A.Girard, Guernic, and O.Maler 2006; “MATISSE Homepage”) uses a special
class of polytopes (see (“Zonotope Methods on Wolfgang Kühn Homepage”))
of the form,</p>
<div class="math">
\[  Z=\{x \in {\bf R}^n ~|~
  x=c+\sum_{i=1}^p\alpha_ig_i,~ -1\leqslant\alpha_i\leqslant1\},\]\[wherein :math:`c` and :math:`g_1, ..., g_p` are vectors in\]</div>
<p><span class="math">{\bf R}^n</span>. Thus, a zonotope <span class="math">Z</span> is represented by its
center <span class="math">c</span> and ‘generator’ vectors <span class="math">g_1, ..., g_p</span>. The
value <span class="math">p/n</span> is called the order of the zonotope. The main benefit
of zonotopes over general polytopes is that a symmetric polytope can be
represented more compactly than a general polytope. The geometric sum of
two zonotopes is a zonotope:</p>
<div class="math">
\[Z(c_1, G_1)\oplus Z(c_2, G_2) = Z(c_1+c_2, [G_1 ~ G_2]),\]\[wherein :math:`G_1` and :math:`G_2` are matrices whose columns are\]</div>
<p>generator vectors, and <span class="math">[G_1 ~ G_2]</span> is their concatenation. Thus,
in the reach set computation, the order of the zonotope increases by
<span class="math">p/n</span> with every time step. This difficulty can be averted by
limiting the number of generator vectors, and overapproximating
zonotopes whose number of generator vectors exceeds the limit by lower
order zonotopes. The benefits of the compact zonotype representation,
however, appear to diminish because in order to plot them or check if
they intersect with given objects and compute those intersections, these
operations are performed after converting zonotopes to polytopes.</p>
<p>CheckMate (“CheckMate Homepage”) is a Matlab toolbox that can evaluate
specifications for trajectories starting from the set of initial
(continuous) states corresponding to the parameter values at the
vertices of the parameter set. This provides preliminary insight into
whether the specifications will be true for all parameter values. The
method of oriented rectangluar polytopes for external approximation of
reach sets is introduced in Stursberg and Krogh (2003). The basic idea
is to construct an oriented rectangular hull of the reach set for every
time step, whose orientation is determined by the singular value
decomposition of the sample covariance matrix for the states reachable
from the vertices of the initial polytope. The limitation of CheckMate
and the method of oriented rectangles is that only autonomous (i.e.
uncontrolled) systems, or systems with fixed input are allowed, and only
an external approximation of the reach set is provided.</p>
<p>All the methods described so far employ the notion of time step, and
calculate the reach set or its approximation at each time step. This
approach can be used only with discrete-time systems. By contrast, the
analytic methods which we are about to discuss, provide a formula or
differential equation describing the (continuous) time evolution of the
reach set or its approximation.</p>
<p>The level set method Mitchell and Tomlin (2000; “Level Set Toolbox
Homepage”) deals with general nonlinear controlled systems and gives
exact representation of their reach sets, but requires solving the HJB
equation and finding the set of states that belong to sub-zero level set
of the value function. The method (“Level Set Toolbox Homepage”) is
impractical for systems of dimension higher than three.</p>
<p>Requiem (“Requiem Homepage”) is a Mathematica notebook which, given a
linear system, the set of initial conditions and control bounds,
symbolically computes the exact reach set, using the experimental
quantifier elimination package. Quantifier elimination is the removal of
all quantifiers (the universal quantifier <span class="math">\forall</span> and the
existential quantifier <span class="math">\exists</span>) from a quantified system. Each
quantified formula is substituted with quantifier-free expression with
operations <span class="math">+</span>, <span class="math">\times</span>, <span class="math">=</span> and <span class="math"><</span>. For
example, consider the discrete-time system</p>
<div class="math">
\[x_{k+1} = Ax_k + Bu_k\]\[with :math:`A=\left[\begin{array}{cc}\]</div>
<p>0 &amp; 1\
0 &amp; 0end{array}right]` and <span class="math">B=\left[\begin{array}{c}
0\\
1\end{array}\right]</span>. For initial conditions
<span class="math">x_0\in\{x\in {\bf R}^2 ~|~ \|x\|_{\infty} \leqslant1\}</span> and
controls <span class="math">u_k\in\{u\in {\bf R} ~|~ -1\leqslantu\leqslant1\}</span>, the
reach set for <span class="math">k\geqslant0</span> is given by the quantified formula</p>
<div class="math">
\[  \{ x\in{\bf R}^2 ~|~ \exists x_0, ~~ \exists k\geqslant0, ~~
  \exists u_i, ~ 0\leqslanti\leqslantk: ~~
  x = A^kx_0+\sum_{i=0}^{k-1}A^{k-i-1}Bu_i \},\]\[which is equivalent to the quantifier-free expression\]</div>
<div class="math">
\[-1\leqslant[1 ~~ 0]x\leqslant1 ~ \wedge ~ -1\leqslant[0 ~~ 1]x\leqslant1.\]\[It is proved in Lafferriere, Pappas, and Yovine (2001) that for\]</div>
<p>continuous-time systems, <span class="math">\dot{x}(t) = Ax(t) + Bu(t)</span>, if
<span class="math">A</span> is constant and nilpotent or is diagonalizable with rational
real or purely imaginary eigenvalues, and with suitable restrictions on
the control and initial conditions, the quantifier elimination package
returns a quantifier free formula describing the reach set. Quantifier
elimination has limited applicability.</p>
<p>The reach set approximation via parallelotopes Kostousova (2001) employs
the idea of parametrization described in Kurzhanski and Varaiya (2000)
for ellipsoids. The reach set is represented as the intersection of
tight external, and the union of tight internal, parallelotopes. The
evolution equations for the centers and orientation matrices of both
external and internal parallelotopes are provided. This method also
finds controls that can drive the system to the boundary points of the
reach set, similarly to Varaiya (1998) and Kurzhanski and Varaiya
(2000). It works for general linear systems. The computation to solve
the evolution equation for tight approximating parallelotopes, however,
is more involved than that for ellipsoids, and for discrete-time systems
this method does not deal with singular state transition matrices.</p>
<p><em>Ellipsoidal Toolbox</em> (ET) implements in MATLAB the ellipsoidal calculus
Kurzhanski and Vályi (1997) and its application to the reachability
analysis of continuous-time Kurzhanski and Varaiya (2000), discrete-time
A. A. Kurzhanskiy (2007), possibly time-varying linear systems, and
linear systems with disturbances A.B.Kurzhanski and P.Varaiya (2001),
for which ET calculates both open-loop and close-loop reach sets. The
ellipsoidal calculus provides the following benefits:</p>
<ul class="simple">
<li>The complexity of the ellipsoidal representation is quadratic in the
dimension of the state space, and linear in the number of time steps.</li>
<li>It is possible to exactly represent the reach set of linear system
through both external and internal ellipsoids.</li>
<li>It is possible to single out individual external and internal
approximating ellipsoids that are optimal to some given criterion
(e.g. trace, volume, diameter), or combination of such criteria.</li>
<li>We obtain simple analytical expressions for the control that steers
the state to a desired target.</li>
</ul>
<p>The report is organized as follows. Chapter 2 describes the operations
of the ellipsoidal calculus: affine transformation, geometric sum,
geometric difference, intersections with hyperplane, ellipsoid,
halfspace and polytope, calculation of maximum ellipsoid, calculation of
minimum ellipsoid. Chapter 3 presents the reachability problem and
ellipsoidal methods for the reach set approximation. Chapter 4 contains
<em>Ellipsoidal Toolbox</em> installation and quick start instructions, and
lists the software packages used by the toolbox. Chapter 5 describes
structures and objects implemented and used in toolbox. Also it
describes the implementation of methods from chapters 2 and 3 and
visualization routines. Chapter 6 describes structures and objects
implemented and used in the toolbox. Chapter 6 gives examples of how to
use the toolbox. Chapter 7 collects some conclusions and plans for
future toolbox development. The functions provided by the toolbox
together with their descriptions are listed in appendix A.</p>
</div>
<div class="section" id="ellipsoidal-calculus">
<h1>Ellipsoidal Calculus<a class="headerlink" href="#ellipsoidal-calculus" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basic-notions">
<h2>Basic Notions<a class="headerlink" href="#basic-notions" title="Permalink to this headline">¶</a></h2>
<p>We start with basic definitions. Ellipsoid <span class="math">{\mathcal E}(q,Q)</span> in
<span class="math">{\bf R}^n</span> with center <span class="math">q</span> and shape matrix <span class="math">Q</span> is
the set</p>
<div class="math">
\[{\mathcal E}(q,Q) = \{ x \in {\bf R}^n ~|~ \langle (x-q), Q^{-1}(x-q)\rangle\leqslant1 \},
\label{ellipsoid}\]</div>
<p>wherein <span class="math">Q</span> is positive definite (<span class="math">Q=Q^T</span> and
<span class="math">\langle x, Qx\rangle>0</span> for all nonzero <span class="math">x\in{\bf R}^n</span>).
[ellipsoiddef0] Here <span class="math">\langle\cdot,\cdot\rangle</span> denotes inner
product. The support function of a set
<span class="math">{\mathcal X}\subseteq{\bf R}^n</span> is</p>
<div class="math">
\[\rho(l~|~{\mathcal X}) = \sup_{x\in{\mathcal X}} \langle l,x\rangle.\]\[In particular, the support function of the ellipsoid ([ellipsoid]) is\]</div>
<div class="math">
\[\rho(l~|~{\mathcal E}(q,Q)) = \langle l, q\rangle + \langle l, Ql\rangle^{1/2}.
\label{ellsupp}\]</div>
<p>Although in ([ellipsoid]) <span class="math">Q</span> is assumed to be positive definite,
in practice we may deal with situations when <span class="math">Q</span> is singular, that
is, with degenerate ellipsoids flat in those directions for which the
corresponding eigenvalues are zero. Therefore, it is useful to give an
alternative definition of an ellipsoid using the expression ([ellsupp]).
Ellipsoid <span class="math">{\mathcal E}(q,Q)</span> in <span class="math">{\bf R}^n</span> with center
<span class="math">q</span> and shape matrix <span class="math">Q</span> is the set</p>
<div class="math">
\[{\mathcal E}(q,Q) = \{ x \in {\bf R}^n ~|~
\langle l,x\rangle\leqslant\langle l,q\rangle + \langle l,Ql\rangle^{1/2}
\mbox{ for all } l\in{\bf R}^n \},
\label{ellipsoid2}\]</div>
<p>wherein matrix <span class="math">Q</span> is positive semidefinite (<span class="math">Q=Q^T</span> and
<span class="math">\langle x, Qx\rangle\geqslant0</span> for all <span class="math">x\in{\bf R}^n</span>).
[ellipsoiddef] The volume of ellipsoid <span class="math">{\mathcal E}(q,Q)</span> is</p>
<div class="math">
\[{\bf Vol}(E(q,Q)) = {\bf Vol}_{\langle x,x\rangle\leqslant1}\sqrt{\det Q},
\label{ellvolume}\]</div>
<p>where <span class="math">{\bf Vol}_{\langle x,x\rangle\leqslant1}</span> is the volume of
the unit ball in <span class="math">{\bf R}^n</span>:</p>
<div class="math">
\[\begin{split}{\bf Vol}_{\langle x,x\rangle\leqslant1} = \left\{\begin{array}{ll}
\frac{\pi^{n/2}}{(n/2)!}, &amp;
\mbox{ for even } n,\\
\frac{2^n\pi^{(n-1)/2}\left((n-1)/2\right)!}{n!}, &amp;
\mbox{ for odd } n. \end{array}\right.
\label{ellunitball}\end{split}\]</div>
<p>The distance from <span class="math">{\mathcal E}(q,Q)</span> to the fixed point <span class="math">a</span>
is</p>
<div class="math">
\[{\bf dist}({\mathcal E}(q,Q),a) = \max_{\langle l,l\rangle=1}\left(\langle l,a\rangle -
\rho(l ~|~ {\mathcal E}(q,Q)) \right) =
\max_{\langle l,l\rangle=1}\left(\langle l,a\rangle - \langle l,q\rangle -
\langle l,Ql\rangle^{1/2}\right). \label{dist_point}\]</div>
<p>If <span class="math">{\bf dist}({\mathcal E}(q,Q),a) > 0</span>, <span class="math">a</span> lies outside
<span class="math">{\mathcal E}(q,Q)</span>; if
<span class="math">{\bf dist}({\mathcal E}(q,Q),a) = 0</span>, <span class="math">a</span> is a boundary
point of <span class="math">{\mathcal E}(q,Q)</span>; if
<span class="math">{\bf dist}({\mathcal E}(q,Q),a) < 0</span>, <span class="math">a</span> is an internal
point of <span class="math">{\mathcal E}(q,Q)</span>.</p>
<p>Given two ellipsoids, <span class="math">{\mathcal E}(q_1,Q_1)</span> and
<span class="math">{\mathcal E}(q_2,Q_2)</span>, the distance between them is</p>
<div class="math">
\[\begin{split}\begin{aligned}
{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) &amp; = &amp; \max_{\langle l,l\rangle=1}
\left(-\rho(-l ~|~ {\mathcal E}(q_1,Q_1)) - \rho(l ~|~ {\mathcal E}(q_2,Q_2))\right) \\
&amp; = &amp; \max_{\langle l,l\rangle=1}\left(\langle l,q_1\rangle -
\langle l,Q_1l\rangle^{1/2} - \langle l,q_2\rangle -
\langle l,Q_2l\rangle^{1/2}\right). \label{dist_ell}\end{aligned}\end{split}\]</div>
<p>If <span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) > 0</span>,
the ellipsoids have no common points; if
<span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) = 0</span>, the
ellipsoids have one common point - they touch; if
<span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) < 0</span>, the
ellipsoids intersect.</p>
<p>Finding <span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))</span>
using QCQP is</p>
<div class="math">
\[d({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) = \min \langle (x-y), (x-y)\rangle\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
\langle (q_1-x), Q_1^{-1}(q_1-x)\rangle &amp; \leqslant&amp; 1,\\
\langle (q_2-x), Q_2^{-1}(q_2-y)\rangle &amp; \leqslant&amp; 1,\end{aligned}\end{split}\]</div>
<p>where</p>
<div class="math">
\[\begin{split}d({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))=\left\{\begin{array}{ll}
{\bf dist}^2({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2)) &amp;
\mbox{ if } {\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))&gt;0, \\
0 &amp; \mbox{ otherwise}. \end{array}\right.\end{split}\]</div>
<p>Checking if <span class="math">k</span> nondegenerate ellipsoids
<span class="math">{\mathcal E}(q_1,Q_1),\cdots,{\mathcal E}(q_k,Q_k)</span> have nonempty
intersection, can be cast as a quadratically constrained quadratic
programming (QCQP) problem:</p>
<div class="math">
\[\min 0\]\[subject to:\]</div>
<div class="math">
\[\langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leqslant0, ~~~ i=1,\cdots,k.\]\[If this problem is feasible, the intersection is nonempty. Given\]</div>
<p>compact convex set <span class="math">{\mathcal X}\subseteq{\bf R}^n</span>, its polar
set, denoted <span class="math">{\mathcal X}^\circ</span>, is</p>
<div class="math">
\[{\mathcal X}^\circ = \{x\in{\bf R}^n ~|~ \langle x,y\rangle\leqslant1, ~ y\in{\mathcal X}\},\]\[or, equivalently,\]</div>
<div class="math">
\[{\mathcal X}^\circ = \{l\in{\bf R}^n ~|~ \rho(l ~|~ {\mathcal X})\leqslant1\}.\]\[The properties of the polar set are\]</div>
<ul class="simple">
<li>If <span class="math">{\mathcal X}</span> contains the origin,
<span class="math">({\mathcal X}^\circ)^\circ = {\mathcal X}</span>;</li>
<li>If <span class="math">{\mathcal X}_1\subseteq{\mathcal X}_2</span>,
<span class="math">{\mathcal X}_2^\circ\subseteq{\mathcal X}_1^\circ</span>;</li>
<li>For any nonsingular matrix <span class="math">A\in{\bf R}^{n\times n}</span>,
<span class="math">(A{\mathcal X})^\circ = (A^T)^{-1}{\mathcal X}^\circ</span>.</li>
</ul>
<p>If a nondegenerate ellipsoid <span class="math">{\mathcal E}(q,Q)</span> contains the
origin, its polar set is also an ellipsoid:</p>
<div class="math">
\[\begin{split}\begin{aligned}
{\mathcal E}^\circ(q,Q) &amp; = &amp; \{l\in{\bf R}^n ~|~ \langle l,q\rangle +
\langle l,Ql\rangle^{1/2}\leqslant1 \}\\
&amp; = &amp; \{l\in{\bf R}^n ~|~ \langle l,(Q-qq^T)^{-1}l\rangle +
2\langle l,q\rangle\leqslant1 \}\\
&amp; = &amp; \{l\in{\bf R}^n ~|~ \langle(l+(Q-qq^T)^{-1}q),
(Q-qq^T)(l+(Q-qq^T)^{-1}q)\rangle\leqslant1+\langle q,(Q-qq^T)^{-1}q\rangle \}.\end{aligned}\end{split}\]</div>
<p>The special case is</p>
<div class="math">
\[{\mathcal E}^\circ(0,Q) = {\mathcal E}(0,Q^{-1}).\]\[Given :math:`k` compact sets\]</div>
<p><span class="math">{\mathcal X}_1, \cdots, {\mathcal X}_k\subseteq{\bf R}^n</span>, their
geometric (Minkowski) sum is</p>
<div class="math">
\[{\mathcal X}_1\oplus\cdots\oplus{\mathcal X}_k=\bigcup_{x_1\in{\mathcal X}_1}\cdots\bigcup_{x_k\in{\mathcal X}_k}
\{x_1 + \cdots + x_k\} .  \label{minksum}\]</div>
<p>Given two compact sets
<span class="math">{\mathcal X}_1, {\mathcal X}_2 \subseteq{\bf R}^n</span>, their
geometric (Minkowski) difference is</p>
<div class="math">
\[{\mathcal X}_1\dot{-}{\mathcal X}_2 = \{x\in{\bf R}^n ~|~ x + {\mathcal X}_2 \subseteq {\mathcal X}_1 \}.
\label{minkdiff}\]</div>
<p>Ellipsoidal calculus concerns the following set of operations:</p>
<ul class="simple">
<li>affine transformation of ellipsoid;</li>
<li>geometric sum of finite number of ellipsoids;</li>
<li>geometric difference of two ellipsoids;</li>
<li>intersection of finite number of ellipsoids.</li>
</ul>
<p>These operations occur in reachability calculation and verification of
piecewise affine dynamical systems. The result of all of these
operations, except for the affine transformation, is <em>not</em> generally an
ellipsoid but some convex set, for which we can compute external and
internal ellipsoidal approximations.</p>
<p>Additional operations implemented in the <em>Ellipsoidal Toolbox</em> include
external and internal approximations of intersections of ellipsoids with
hyperplanes, halfspaces and polytopes. Hyperplane <span class="math">H(c,\gamma)</span> in
<span class="math">{\bf R}^n</span> is the set</p>
<div class="math">
\[H = \{x\in{\bf R}^n ~|~ \langle c, x\rangle = \gamma\}
\label{hyperplane}\]</div>
<p>with <span class="math">c\in{\bf R}^n</span> and <span class="math">\gamma\in{\bf R}</span> fixed.
[hyperplanedef] The distance from ellipsoid <span class="math">{\mathcal E}(q,Q)</span> to
hyperplane <span class="math">H(c,\gamma)</span> is</p>
<div class="math">
\[{\bf dist}({\mathcal E}(q,Q),H(c,\gamma)) =
\frac{\left|\gamma-\langle c,q\rangle\right| -
\langle c,Qc\rangle^{1/2}}{\langle c,c\rangle^{1/2}}. \label{dist_hp}\]</div>
<p>If <span class="math">{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))>0</span>, the ellipsoid
and the hyperplane do not intersect; if
<span class="math">{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))=0</span>, the hyperplane is a
supporting hyperplane for the ellipsoid; if
<span class="math">{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))<0</span>, the ellipsoid
intersects the hyperplane. The intersection of an ellipsoid with a
hyperplane is always an ellipsoid and can be computed directly.</p>
<p>Checking if the intersection of <span class="math">k</span> nondegenerate ellipsoids
<span class="math">E(q_1,Q_1),\cdots,{\mathcal E}(q_k,Q_k)</span> intersects hyperplane
<span class="math">H(c,\gamma)</span>, is equivalent to the feasibility check of the QCQP
problem:</p>
<div class="math">
\[\min 0\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
\langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leqslant0, &amp; &amp; i=1,\cdots,k,\\
\langle c, x\rangle - \gamma = 0. &amp; &amp;\end{aligned}\end{split}\]</div>
<p>A hyperplane defines two (closed) <em>halfspaces</em>:</p>
<div class="math">
\[{\bf S}_1 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \leqslant\gamma\}
\label{halfspace1}\]</div>
<p>and</p>
<div class="math">
\[{\bf S}_2 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \geqslant\gamma\}.
\label{halfspace2}\]</div>
<p>To avoid confusion, however, we shall further assume that a hyperplane
<span class="math">H(c,\gamma)</span> specifies the halfspace in the sense ([halfspace1]).
In order to refer to the other halfspace, the same hyperplane should be
defined as <span class="math">H(-c,-\gamma)</span>.</p>
<p>The idea behind the calculation of intersection of an ellipsoid with a
halfspace is to treat the halfspace as an unbounded ellipsoid, that is,
as the ellipsoid with the shape matrix all but one of whose eigenvalues
are <span class="math">\infty</span>. [polytope] Polytope <span class="math">P(C,g)</span> is the
intersection of a finite number of closed halfspaces:</p>
<div class="math">
\[P = \{x\in{\bf R}^n ~|~ Cx\leqslantg\},\]\[wherein :math:`C=[c_1 ~ \cdots ~ c_m]^T\in{\bf R}^{m\times n}` and\]</div>
<p><span class="math">g=[\gamma_1 ~ \cdots ~ \gamma_m]^T\in{\bf R}^m</span>. The distance
from ellipsoid <span class="math">{\mathcal E}(q,Q)</span> to the polytope <span class="math">P(C,g)</span>
is</p>
<div class="math">
\[{\bf dist}({\mathcal E}(q,Q),P(C,g))=\min_{y\in P(C,g)}{\bf dist}({\mathcal E}(q,Q),y),
\label{dist_poly}\]</div>
<p>where <span class="math">{\bf dist}({\mathcal E}(q,Q),y)</span> comes from
([dist:sub:<cite>p</cite>oint]). If
<span class="math">{\bf dist}({\mathcal E}(q,Q),P(C,g))>0</span>, the ellipsoid and the
polytope do not intersect; if
<span class="math">{\bf dist}({\mathcal E}(q,Q),P(C,g))=0</span>, the ellipsoid touches
the polytope; if <span class="math">{\bf dist}({\mathcal E}(q,Q),P(C,g))<0</span>, the
ellipsoid intersects the polytope.</p>
<p>Checking if the intersection of <span class="math">k</span> nondegenerate ellipsoids
<span class="math">E(q_1,Q_1),\cdots,{\mathcal E}(q_k,Q_k)</span> intersects polytope
<span class="math">P(C,g)</span> is equivalent to the feasibility check of the QCQP
problem:</p>
<div class="math">
\[\min 0\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
\langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leqslant0, &amp; &amp; i=1,\cdots,k,\\
\langle c_j, x\rangle - \gamma_j \leqslant0, &amp; &amp; j=1,\cdots,m.\end{aligned}\end{split}\]</div>
</div>
<div class="section" id="operations-with-ellipsoids">
<h2>Operations with Ellipsoids<a class="headerlink" href="#operations-with-ellipsoids" title="Permalink to this headline">¶</a></h2>
<div class="section" id="affine-transformation">
<h3>Affine Transformation<a class="headerlink" href="#affine-transformation" title="Permalink to this headline">¶</a></h3>
<p>The simplest operation with ellipsoids is an affine transformation. Let
ellipsoid <span class="math">{\mathcal E}(q,Q)\subseteq{\bf R}^n</span>, matrix
<span class="math">A\in{\bf R}^{m\times n}</span> and vector <span class="math">b\in{\bf R}^m</span>. Then</p>
<div class="math">
\[A{\mathcal E}(q,Q) + b = {\mathcal E}(Aq+b, AQA^T) .\label{affinetrans}\]</div>
<p>Thus, ellipsoids are preserved under affine transformation. If the rows
of <span class="math">A</span> are linearly independent (which implies
<span class="math">m\leqslantn</span>), and <span class="math">b=0</span>, the affine transformation is
called <em>projection</em>.</p>
</div>
<div class="section" id="geometric-sum">
<h3>Geometric Sum<a class="headerlink" href="#geometric-sum" title="Permalink to this headline">¶</a></h3>
<p>Consider the geometric sum ([minksum]) in which
<span class="math">{\mathcal X}_1,\cdots</span>,<span class="math">{\mathcal X}_k</span> are nondegenerate
ellipsoids <span class="math">{\mathcal E}(q_1,Q_1),\cdots</span>,
<span class="math">{\mathcal E}(q_k,Q_k)\subseteq{\bf R}^n</span>. The resulting set is
not generally an ellipsoid. However, it can be tightly approximated by
the parametrized families of external and internal ellipsoids.</p>
<p>Let parameter <span class="math">l</span> be some nonzero vector in <span class="math">{\bf R}^n</span>.
Then the external approximation <span class="math">{\mathcal E}(q,Q_l^+)</span> and the
internal approximation <span class="math">{\mathcal E}(q,Q_l^-)</span> of the sum
<span class="math">{\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k)</span> are
<em>tight</em> along direction <span class="math">l</span>, i.e.,</p>
<div class="math">
\[  {\mathcal E}(q,Q_l^-)\subseteq{\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k)
  \subseteq{\mathcal E}(q,Q_l^+)\]\[and\]</div>
<div class="math">
\[  \rho(\pm l ~|~ {\mathcal E}(q,Q_l^-)) =
  \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k)) =
  \rho(\pm l ~|~ {\mathcal E}(q,Q_l^+)).\]\[Here the center :math:`q` is\]</div>
<div class="math">
\[q = q_1 + \cdots + q_k , \label{minksum_c}\]</div>
<p>the shape matrix of the external ellipsoid <span class="math">Q_l^+</span> is</p>
<div class="math">
\[Q_l^+ = \left(\langle l,Q_1l\rangle^{1/2} + \cdots
+ \langle l,Q_kl\rangle^{1/2}\right)
\left(\frac{1}{\langle l,Q_1l\rangle^{1/2}}Q_1 + \cdots +
\frac{1}{\langle l,Q_kl\rangle^{1/2}}Q_k\right), \label{minksum_ea}\]</div>
<p>and the shape matrix of the internal ellipsoid <span class="math">Q_l^-</span> is</p>
<div class="math">
\[Q_l^- = \left(Q_1^{1/2} + S_2Q_2^{1/2} + \cdots + S_kQ_k^{1/2}\right)^T
\left(Q_1^{1/2} + S_2Q_2^{1/2} + \cdots + S_kQ_k^{1/2}\right),\label{minksum_ia}\]</div>
<p>with matrices <span class="math">S_i</span>, <span class="math">i=2,\cdots,k</span>, being orthogonal
(<span class="math">S_iS_i^T=I</span>) and such that vectors
<span class="math">Q_1^{1/2}l, S_2Q_2^{1/2}l, \cdots, S_kQ_k^{1/2}l</span> are parallel.</p>
<p>Varying vector <span class="math">l</span> we get exact external and internal
approximations,</p>
<div class="math">
\[  \bigcup_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^-) =
  {\mathcal E}(q_1,Q_1)\oplus\cdots\oplus{\mathcal E}(q_k,Q_k) =
  \bigcap_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^+) .\]\[For proofs of formulas given in this section, see Kurzhanski and Vályi\]</div>
<p>(1997), Kurzhanski and Varaiya (2000).</p>
<p>One last comment is about how to find orthogonal matrices
<span class="math">S_2,\cdots,S_k</span> that align vectors
<span class="math">Q_2^{1/2}l, \cdots, Q_k^{1/2}l</span> with <span class="math">Q_1^{1/2}l</span>. Let
<span class="math">v_1</span> and <span class="math">v_2</span> be some unit vectors in <span class="math">{\bf R}^n</span>.
We have to find matrix <span class="math">S</span> such that
<span class="math">Sv_2\uparrow\uparrow v_1</span>. We suggest explicit formulas for the
calculation of this matrix ( Dariyn and Kurzhanski (2012)):</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;T = I + Q_1(S - I)Q_1^T,\\ \label{valign1}
&amp;&amp; S = \begin{pmatrix}
     c &amp; s\\
     -s &amp; c
    \end{pmatrix},\quad c = \langle\hat{v_1}, \hat{v_2}\rangle,\quad s = \sqrt{1 - c^2},\quad \hat{v_i} = \dfrac{v_i}{\|v_i\|}\\ \label{valign2}
&amp;&amp;  Q_1 = [q_1 \,q_2]\in \mathbb{R}^{n\times2},\quad q_1 = \hat{v_1}, \quad
q_2 = \begin{cases}
s^{-1}(\hat{v_2} - c\hat{v_1}),&amp; s\ne 0\\
0,&amp; s = 0.
\end{cases} \label{valign3}\end{aligned}\end{split}\]</div>
</div>
<div class="section" id="geometric-difference">
<h3>Geometric Difference<a class="headerlink" href="#geometric-difference" title="Permalink to this headline">¶</a></h3>
<p>Consider the geometric difference ([minkdiff]) in which the sets
<span class="math">{\mathcal X}_1</span> and <span class="math">{\mathcal X}_2</span> are nondegenerate
ellipsoids <span class="math">{\mathcal E}(q_1,Q_1)</span> and
<span class="math">{\mathcal E}(q_2,Q_2)</span>. We say that ellipsoid
<span class="math">{\mathcal E}(q_1,Q_1)</span> is <em>bigger</em> than ellipsoid
<span class="math">{\mathcal E}(q_2,Q_2)</span> if</p>
<div class="math">
\[{\mathcal E}(0,Q_2) \subseteq {\mathcal E}(0,Q_1).\]\[If this condition is not fulfilled, the geometric difference\]</div>
<p><span class="math">{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)</span> is an empty
set:</p>
<div class="math">
\[  {\mathcal E}(0,Q_2) \not\subseteq {\mathcal E}(0,Q_1) ~~~ \Rightarrow ~~~
  {\mathcal E}(q_1,Q_1) \dot{-}{\mathcal E}(q_2,Q_2) = \emptyset.\]\[If :math:`{\mathcal E}(q_1,Q_1)` is bigger than\]</div>
<p><span class="math">{\mathcal E}(q_2,Q_2)</span> and <span class="math">{\mathcal E}(q_2,Q_2)</span> is
bigger than <span class="math">{\mathcal E}(q_1,Q_1)</span>, in other words, if
<span class="math">Q_1=Q_2</span>,</p>
<div class="math">
\[  {\mathcal E}(q_1,Q_1) \dot{-}{\mathcal E}(q_2,Q_2) = \{q_1-q_2\} ~~~ \mbox{and} ~~~
  {\mathcal E}(q_2,Q_2) \dot{-}{\mathcal E}(q_1,Q_1) = \{q_2-q_1\}.\]\[To check if ellipsoid :math:`{\mathcal E}(q_1,Q_1)` is bigger than\]</div>
<p>ellipsoid <span class="math">{\mathcal E}(q_2,Q_2)</span>, we perform simultaneous
diagonalization of matrices <span class="math">Q_1</span> and <span class="math">Q_2</span>, that is, we
find matrix <span class="math">T</span> such that</p>
<div class="math">
\[TQ_1T^T = I ~~~ \mbox{and} ~~~ TQ_2T^T=D,\]\[where :math:`D` is some diagonal matrix. Simultaneous diagonalization\]</div>
<p>of <span class="math">Q_1</span> and <span class="math">Q_2</span> is possible because both are symmetric
positive definite (see Gantmacher (1960)). To find such matrix
<span class="math">T</span>, we first do the SVD of <span class="math">Q_1</span>:</p>
<div class="math">
\[Q_1 = U_1\Sigma_1V_1^T . \label{simdiag1}\]</div>
<p>Then the SVD of matrix
<span class="math">\Sigma_1^{-1/2}U_1^TQ_2U_1\Sigma_1^{-1/2}</span>:</p>
<div class="math">
\[\Sigma_1^{-1/2}U_1^TQ_2U_1\Sigma_1^{-1/2} = U_2\Sigma_2V_2^T. \label{simdiag2}\]</div>
<p>Now, <span class="math">T</span> is defined as</p>
<div class="math">
\[T = U_2^T \Sigma_1^{-1/2}U_1^T.  \label{simdiag3}\]</div>
<p>If the biggest diagonal element (eigenvalue) of matrix <span class="math">D=TQ_2T^T</span>
is less than or equal to <span class="math">1</span>,
<span class="math">{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)</span>.</p>
<p>Once it is established that ellipsoid <span class="math">{\mathcal E}(q_1,Q_1)</span> is
bigger than ellipsoid <span class="math">{\mathcal E}(q_2,Q_2)</span>, we know that their
geometric difference
<span class="math">{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)</span> is a nonempty
convex compact set. Although it is not generally an ellipsoid, we can
find tight external and internal approximations of this set parametrized
by vector <span class="math">l\in{\bf R}^n</span>. Unlike geometric sum, however,
ellipsoidal approximations for the geometric difference do not exist for
every direction <span class="math">l</span>. Vectors for which the approximations do not
exist are called <em>bad directions</em>.</p>
<p>Given two ellipsoids <span class="math">{\mathcal E}(q_1,Q_1)</span> and
<span class="math">{\mathcal E}(q_2,Q_2)</span> with
<span class="math">{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)</span>, <span class="math">l</span> is a
bad direction if</p>
<div class="math">
\[\begin{split}\frac{\langle l,Q_1l\rangle^{1/2}}{\langle l,Q_2l\rangle^{1/2}}&gt;r,\end{split}\]\[in which :math:`r` is a minimal root of the equation\]</div>
<div class="math">
\[{\bf det}(Q_1-rQ_2) = 0.\]\[To find :math:`r`, compute matrix :math:`T` by ([simdiag1]-[simdiag3])\]</div>
<p>and define</p>
<div class="math">
\[r = \frac{1}{\max({\bf diag}(TQ_2T^T))}.\]\[If :math:`l` is *not* a bad direction, we can find tight external and\]</div>
<p>internal ellipsoidal approximations <span class="math">{\mathcal E}(q,Q^+_l)</span> and
<span class="math">{\mathcal E}(q,Q^-_l)</span> such that</p>
<div class="math">
\[{\mathcal E}(q,Q^-_l)\subseteq{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q,Q^+_l)\]\[and\]</div>
<div class="math">
\[  \rho(\pm l ~|~ {\mathcal E}(q,Q_l^-)) =
  \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)) =
  \rho(\pm l ~|~ {\mathcal E}(q,Q_l^+)).\]\[The center :math:`q` is\]</div>
<div class="math">
\[q = q_1 - q_2;  \label{minkdiff_c}\]</div>
<p>the shape matrix of the internal ellipsoid <span class="math">Q^-_l</span> is</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp; P = \frac{\sqrt{\langle l, Q_1 l\rangle}}{\sqrt{\langle l, Q_2 \rangle}};\nonumber\\
&amp;&amp; Q^-_l = \left(1 - \dfrac{1}{P}\right)Q_1 + \left(1 - P\right)Q_2.
\label{minkdiff_ia}\end{aligned}\end{split}\]</div>
<p>and the shape matrix of the external ellipsoid <span class="math">Q^+_l</span> is</p>
<div class="math">
\[Q^+_l = \left(Q_1^{1/2} - SQ_2^{1/2}\right)^T
\left(Q_1^{1/2} - SQ_2^{1/2}\right).  \label{minkdiff_ea}\]</div>
<p>Here <span class="math">S</span> is an orthogonal matrix such that vectors
<span class="math">Q_1^{1/2}l</span> and <span class="math">SQ_2^{1/2}l</span> are parallel. <span class="math">S</span> is
found from ([valign1]-[valign3]), with <span class="math">v_1=Q_2^{1/2}l</span> and
<span class="math">v_2=Q_1^{1/2}l</span>.</p>
<p>Running <span class="math">l</span> over all unit directions that are not bad, we get</p>
<div class="math">
\[  \bigcup_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^-) =
  {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2) =
  \bigcap_{\langle l,l\rangle=1} {\mathcal E}(q,Q_l^+) .\]\[For proofs of formulas given in this section, see Kurzhanski and Vályi\]</div>
<p>(1997).</p>
</div>
<div class="section" id="geometric-difference-sum">
<h3>Geometric Difference-Sum<a class="headerlink" href="#geometric-difference-sum" title="Permalink to this headline">¶</a></h3>
<p>Given ellipsoids <span class="math">{\mathcal E}(q_1,Q_1)</span>,
<span class="math">{\mathcal E}(q_2,Q_2)</span> and <span class="math">{\mathcal E}(q_3,Q_3)</span>, it is
possible to compute families of external and internal approximating
ellipsoids for</p>
<div class="math">
\[{\mathcal E}(q_1,Q_1) \dot{-} {\mathcal E}(q_2,Q_2) \oplus {\mathcal E}(q_3,Q_3) \label{minkmp}\]</div>
<p>parametrized by direction <span class="math">l</span>, if this set is nonempty
(<span class="math">{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)</span>).</p>
<p>First, using the result of the previous section, for any direction
<span class="math">l</span> that is not bad, we obtain tight external
<span class="math">{\mathcal E}(q_1-q_2, Q_l^{0+})</span> and internal
<span class="math">{\mathcal E}(q_1-q_2, Q_l^{0-})</span> approximations of the set
<span class="math">{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)</span>.</p>
<p>The second and last step is, using the result of section 2.2.2, to find
tight external ellipsoidal approximation
<span class="math">{\mathcal E}(q_1-q_2+q_3,Q_l^+)</span> of the sum
<span class="math">{\mathcal E}(q_1-q_2,Q_l^{0+})\oplus{\mathcal E}(q_3,Q_3)</span>, and
tight internal ellipsoidal approximation
<span class="math">{\mathcal E}(q_1-q_2+q_3,Q_l^-)</span> for the sum
<span class="math">{\mathcal E}(q_1-q_2,Q_l^{0-})\oplus{\mathcal E}(q_3,Q_3)</span>.</p>
<p>As a result, we get</p>
<div class="math">
\[  {\mathcal E}(q_1-q_2+q_3,Q_l^-) \subseteq
  {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\oplus{\mathcal E}(q_3,Q_3) \subseteq
  {\mathcal E}(q_1-q_2+q_3,Q_l^+)\]\[and\]</div>
<div class="math">
\[  \rho(\pm l ~|~{\mathcal E}(q_1-q_2+q_3,Q_l^-)) =
  \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\oplus{\mathcal E}(q_3,Q_3)) =
  \rho(\pm l ~|~ {\mathcal E}(q_1-q_2+q_3,Q_l^+)).\]\[Running :math:`l` over all unit vectors that are not bad, this\]</div>
<p>translates to</p>
<div class="math">
\[\bigcup_{\langle l,l\rangle=1} {\mathcal E}(q_1-q_2+q_3,Q_l^-) =
{\mathcal E}(q_1,Q_1)\dot{-}{\mathcal E}(q_2,Q_2)\oplus{\mathcal E}(q_3,Q_3) =
\bigcap_{\langle l,l\rangle=1} {\mathcal E}(q_1-q_2+q_3,Q_l^+) .\]</div>
</div>
<div class="section" id="geometric-sum-difference">
<h3>Geometric Sum-Difference<a class="headerlink" href="#geometric-sum-difference" title="Permalink to this headline">¶</a></h3>
<p>Given ellipsoids <span class="math">{\mathcal E}(q_1,Q1)</span>,
<span class="math">{\mathcal E}(q_2,Q_2)</span> and <span class="math">{\mathcal E}(q_3,Q_3)</span>, it is
possible to compute families of external and internal approximating
ellipsoids for</p>
<div class="math">
\[{\mathcal E}(q_1,Q_1) \oplus {\mathcal E}(q_2,Q_2) \dot{-} {\mathcal E}(q_3,Q_3) \label{minkpm}\]</div>
<p>parametrized by direction <span class="math">l</span>, if this set is nonempty
(<span class="math">{\mathcal E}(0,Q_3)\subseteq{\mathcal E}(0,Q_1)\oplus{\mathcal E}(0,Q_2)</span>).</p>
<p>First, using the result of section 2.2.2, we obtain tight external
<span class="math">{\mathcal E}(q_1+q_2,Q_l^{0+})</span> and internal
<span class="math">{\mathcal E}(q_1+q_2,Q_l^{0-})</span> ellipsoidal approximations of the
set <span class="math">{\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)</span>. In order
for the set ([minkpm]) to be nonempty, inclusion
<span class="math">{\mathcal E}(0,Q_3)\subseteq{\mathcal E}(0,Q_l^{0+})</span> must be
true for any <span class="math">l</span>. Note, however, that even if ([minkpm]) is
nonempty, it may be that
<span class="math">{\mathcal E}(0,Q_3)\not\subseteq{\mathcal E}(0,Q_l^{0-})</span>, then
internal approximation for this direction does not exist.</p>
<p>Assuming that ([minkpm]) is nonempty and
<span class="math">{\mathcal E}(0,Q_3)\subseteq{\mathcal E}(0,Q_l^{0-})</span>, the second
step would be, using the results of section 2.2.3, to compute tight
external ellipsoidal approximation
<span class="math">{\mathcal E}(q_1+q_2-q_3,Q_l^+)</span> of the difference
<span class="math">{\mathcal E}(q_1+q_2,Q_l^{0+})\dot{-}{\mathcal E}(q_3,Q_3)</span>,
which exists only if <span class="math">l</span> is not bad, and tight internal
ellipsoidal approximation <span class="math">{\mathcal E}(q_1+q_2-q_3,Q_l^-)</span> of the
difference
<span class="math">{\mathcal E}(q_1+q_2,Q_l^{0-})\dot{-}{\mathcal E}(q_3,Q_3)</span>,
which exists only if <span class="math">l</span> is not bad for this difference.</p>
<p>If approximation <span class="math">{\mathcal E}(q_1+q_2-q_3,Q_l^+)</span> exists, then</p>
<div class="math">
\[  {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3) \subseteq
  {\mathcal E}(q_1+q_2-q_3,Q_l^+)\]\[and\]</div>
<div class="math">
\[  \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3)) =
  \rho(\pm l ~|~ {\mathcal E}(q_1+q_2-q_3,Q_l^+)).\]\[If approximation :math:`{\mathcal E}(q_1+q_2-q_3,Q_l^-)` exists, then\]</div>
<div class="math">
\[  {\mathcal E}(q_1+q_2-q_3,Q_l^-) \subseteq
  {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3)\]\[and\]</div>
<div class="math">
\[  \rho(\pm l ~|~{\mathcal E}(q_1+q_2-q_3,Q_l^-)) =
  \rho(\pm l ~|~ {\mathcal E}(q_1,Q_1)\oplus{\mathcal E}(q_2,Q_2)\dot{-}{\mathcal E}(q_3,Q_3)) .\]\[For any fixed direction :math:`l` it may be the case that neither\]</div>
<p>external nor internal tight ellipsoidal approximations exist.</p>
</div>
<div class="section" id="intersection-of-ellipsoid-and-hyperplane">
<h3>Intersection of Ellipsoid and Hyperplane<a class="headerlink" href="#intersection-of-ellipsoid-and-hyperplane" title="Permalink to this headline">¶</a></h3>
<p>Let nondegenerate ellipsoid <span class="math">{\mathcal E}(q,Q)</span> and hyperplane
<span class="math">H(c,\gamma)</span> be such that
<span class="math">{\bf dist}({\mathcal E}(q,Q),H(c,\gamma))<0</span>. In other words,</p>
<div class="math">
\[{\mathcal E}_H(w,W) = {\mathcal E}(q,Q)\cap H(c,\gamma) \neq \emptyset .\]\[The intersection of ellipsoid with hyperplane, if nonempty, is always\]</div>
<p>an ellipsoid. Here we show how to find it.</p>
<p>First of all, we transform the hyperplane <span class="math">H(c,\gamma)</span> into
<span class="math">H([1~0~\cdots~0]^T, 0)</span> by the affine transformation</p>
<div class="math">
\[y = Sx - \frac{\gamma}{\langle c,c\rangle^{1/2}}Sc,\]\[where :math:`S` is an orthogonal matrix found by ([valign1]-[valign3])\]</div>
<p>with <span class="math">v_1=c</span> and <span class="math">v_2=[1~0~\cdots~0]^T</span>. The ellipsoid in
the new coordinates becomes <span class="math">{\mathcal E}(q',Q')</span> with</p>
<div class="math">
\[\begin{split}\begin{aligned}
q' &amp; = &amp; q-\frac{\gamma}{\langle c,c\rangle^{1/2}}Sc, \\
Q' &amp; = &amp; SQS^T.\end{aligned}\end{split}\]</div>
<p>Define matrix <span class="math">M=Q'^{-1}</span>; <span class="math">m_{11}</span> is its element in
position <span class="math">(1,1)</span>, <span class="math">\bar{m}</span> is the first column of <span class="math">M</span>
without the first element, and <span class="math">\bar{M}</span> is the submatrix of
<span class="math">M</span> obtained by stripping <span class="math">M</span> of its first row and first
column:</p>
<div class="math">
\[\begin{split}  M = \left[\begin{array}{c|cl}
  m_{11} &amp; &amp; \bar{m}^T\\
   &amp; \\
  \hline
   &amp; \\
  \bar{m} &amp; &amp; \bar{M}\end{array}\right].\end{split}\]\[The ellipsoid resulting from the intersection is\]</div>
<p><span class="math">{\mathcal E}_H(w',W')</span> with</p>
<div class="math">
\[\begin{split}\begin{aligned}
w' &amp; = &amp; q' + q_1'\left[\begin{array}{c}
-1\\
\bar{M}^{-1}\bar{m}\end{array}\right],\\
W' &amp; = &amp; \left(1-q_1'^2(m_{11}-
\langle\bar{m},\bar{M}^{-1}\bar{m}\rangle)\right)\left[\begin{array}{c|cl}
0 &amp; &amp; {\bf 0}\\
 &amp; \\
\hline
 &amp; \\
{\bf 0} &amp; &amp; \bar{M}^{-1}\end{array}\right],\end{aligned}\end{split}\]</div>
<p>in which <span class="math">q_1'</span> represents the first element of vector <span class="math">q'</span>.</p>
<p>Finally, it remains to do the inverse transform of the coordinates to
obtain ellipsoid <span class="math">{\mathcal E}_H(w,W)</span>:</p>
<div class="math">
\[\begin{split}\begin{aligned}
w &amp; = &amp; S^Tw' + \frac{\gamma}{\langle c,c\rangle^{1/2}}c, \\
W &amp; = &amp; S^TW'S.\end{aligned}\end{split}\]</div>
</div>
<div class="section" id="intersection-of-ellipsoid-and-ellipsoid">
<h3>Intersection of Ellipsoid and Ellipsoid<a class="headerlink" href="#intersection-of-ellipsoid-and-ellipsoid" title="Permalink to this headline">¶</a></h3>
<p>Given two nondegenerate ellipsoids <span class="math">{\mathcal E}(q_1,Q_1)</span> and
<span class="math">{\mathcal E}(q_2,Q_2)</span>,
<span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),{\mathcal E}(q_2,Q_2))<0</span>
implies that</p>
<div class="math">
\[{\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)\neq\emptyset .\]\[This intersection can be approximated by ellipsoids from the outside\]</div>
<p>and from the inside. Trivially, both <span class="math">{\mathcal E}(q_1,Q_1)</span> and
<span class="math">{\mathcal E}(q_2,Q_2)</span> are external approximations of this
intersection. Here, however, we show how to find the external
ellipsoidal approximation of minimal volume.</p>
<p>Define matrices</p>
<div class="math">
\[W_1 = Q_1^{-1}, ~~~~ W_2 = Q_2^{-1} .\label{wmatrices}\]</div>
<p>Minimal volume external ellipsoidal approximation
<span class="math">{\mathcal E}(q+,Q^+)</span> of the intersection
<span class="math">{\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)</span> is determined
from the set of equations:</p>
<div class="math">
\[\begin{split}\begin{aligned}
Q^+ &amp; = &amp; \alpha X^{-1} \label{fusion1} \\
X &amp; = &amp; \pi W_1 + (1-\pi)W_2 \label{fusion2} \\
\alpha &amp; = &amp; 1-\pi(1-\pi)\langle(q_2-q_1), W_2X^{-1}W_1(q_2-q_1)\rangle
\label{fusion3} \\
q^+ &amp; = &amp; X^{-1}(\pi W_1q_1 + (1-\pi)W_2q_2) \label{fusion4} \\
0 &amp; = &amp; \alpha({\bf det}(X))^2{\bf trace}(X^{-1}(W_1-W_2)) \nonumber \\
&amp; - &amp; n({\bf det}(X))^2
\big{(}2\langle q^+,W_1q_1-W_2q_2\rangle +
\langle q^+,(W_2-W_1)q^+\rangle \nonumber\\
&amp;  &amp; - \langle q_1,W_1q_1\rangle +
\langle q_2,W_2q_2\rangle\big{)}, \label{fusion5}\end{aligned}\end{split}\]</div>
<p>with <span class="math">0\leqslant\pi\leqslant1</span>. We substitute <span class="math">X</span>,
<span class="math">\alpha</span>, <span class="math">q^+</span> defined in ([fusion2]-[fusion4]) into
([fusion5]) and get a polynomial of degree <span class="math">2n-1</span> with respect to
<span class="math">\pi</span>, which has only one root in the interval <span class="math">[0,1]</span>,
<span class="math">\pi_0</span>. Then, substituting <span class="math">\pi=\pi_0</span> into
([fusion1]-[fusion4]), we obtain <span class="math">q^+</span> and <span class="math">Q^+</span>. Special
cases are <span class="math">\pi_0=1</span>, whence
<span class="math">{\mathcal E}(q^+,Q^+)={\mathcal E}(q_1,Q_1)</span>, and
<span class="math">\pi_0=0</span>, whence
<span class="math">{\mathcal E}(q^+,Q^+)={\mathcal E}(q_2,Q_2)</span>. These situations
may occur if, for example, one ellipsoid is contained in the other:</p>
<div class="math">
\[\begin{split}\begin{aligned}
{\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2) &amp; \Rightarrow &amp; \pi_0 = 1,\\
{\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q_1,Q_1) &amp; \Rightarrow &amp; \pi_0 = 0.\\\end{aligned}\end{split}\]</div>
<p>The proof that the system of equations ([fusion1]-[fusion5]) correctly
defines the minimal volume external ellipsoidal approximationi of the
intersection <span class="math">{\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)</span> is
given in L. Ros (2002).</p>
<p>To find the internal approximating ellipsoid
<span class="math">{\mathcal E}(q^-,Q^-)\subseteq{\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)</span>,
define</p>
<div class="math">
\[\begin{split}\begin{aligned}
\beta_1 &amp; = &amp;
\min_{\langle x,W_2x\rangle=1}\langle x,W_1x\rangle, \label{beta1}\\
\beta_2 &amp; = &amp; \min_{\langle x,W_1x\rangle=1}\langle x,W_2x\rangle, \label{beta2}\end{aligned}\end{split}\]</div>
<p>Notice that ([beta1]) and ([beta2]) are QCQP problems. Parameters
<span class="math">\beta_1</span> and <span class="math">\beta_2</span> are invariant with respect to affine
coordinate transformation and describe the position of ellipsoids
<span class="math">{\mathcal E}(q_1,Q_1)</span>, <span class="math">{\mathcal E}(q_2,Q_2)</span> with
respect to each other:</p>
<div class="math">
\[\begin{split}\begin{aligned}
\beta_1\geqslant1,~\beta_2\geqslant1 &amp; \Rightarrow &amp;
{\bf int}({\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2))=\emptyset, \\
\beta_1\geqslant1,~\beta_2\leqslant1 &amp; \Rightarrow &amp; {\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2), \\
\beta_1\leqslant1,~\beta_2\geqslant1 &amp; \Rightarrow &amp; {\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q_1,Q_1), \\
\beta_1&lt;1,~\beta_2&lt;1 &amp; \Rightarrow &amp;
{\bf int}({\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2))\neq\emptyset \\
&amp; &amp; \mbox{and} ~ {\mathcal E}(q_1,Q_1)\not\subseteq{\mathcal E}(q_2,Q_2) \\
&amp; &amp; \mbox{and} ~ {\mathcal E}(q_2,Q_2)\not\subseteq{\mathcal E}(q_1,Q_1).\end{aligned}\end{split}\]</div>
<p>Define parametrized family of internal ellipsoids
<span class="math">{\mathcal E}(q^-_{\theta_1\theta_2},Q^-_{\theta_1\theta_2})</span> with</p>
<div class="math">
\[\begin{split}\begin{aligned}
q^-_{\theta_1\theta_2} &amp; = &amp; (\theta_1W_1 +
\theta_2W_2)^{-1}(\theta_1W_1q_1 + \theta_2W_2q_2), \label{paramell1} \\
Q^-_{\theta_1\theta_2} &amp; = &amp; (1 - \theta_1\langle q_1,W_1q_1\rangle -
\theta_2\langle q_2,W_2q_2\rangle +
\langle q^-_{\theta_1\theta_2},(Q^-)^{-1}q^-_{\theta_1\theta_2}\rangle)
(\theta_1W_1 + \theta_2W_2)^{-1} .\label{paramell2}\end{aligned}\end{split}\]</div>
<p>The best internal ellipsoid
<span class="math">{\mathcal E}(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})</span>
in the class ([paramell1]-[paramell2]), namely, such that</p>
<div class="math">
\[  {\mathcal E}(q^-_{{\theta}_1{\theta}_2},Q^-_{{\theta}_1{\theta}_2})\subseteq
  {\mathcal E}(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})
  \subseteq {\mathcal E}(q_1,Q_1)\cap{\mathcal E}(q_2,Q_2)\]\[for all :math:`0\leqslant\theta_1,\theta_2\leqslant1`, is specified by\]</div>
<p>the parameters</p>
<div class="math">
\[\hat{\theta}_1 = \frac{1-\hat{\beta}_2}{1-\hat{\beta}_1\hat{\beta}_2}, ~~~~
\hat{\theta}_2 = \frac{1-\hat{\beta}_1}{1-\hat{\beta}_1\hat{\beta}_2},
\label{thetapar}\]</div>
<p>with</p>
<div class="math">
\[\hat{\beta}_1=\min(1,\beta_1), ~~~~ \hat{\beta}_2=\min(1,\beta_2).\]\[It is the ellipsoid that we look for:\]</div>
<p><span class="math">{\mathcal E}(q^-,Q^-)={\mathcal E}(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})</span>.
Two special cases are</p>
<div class="math">
\[  \hat{\theta}_1=1, ~ \hat{\theta}_2=0 ~~~ \Rightarrow ~~~
  {\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2) ~~~ \Rightarrow ~~~
  {\mathcal E}(q^-,Q^-)={\mathcal E}(q_1,Q_1),\]\[and\]</div>
<div class="math">
\[  \hat{\theta}_1=0, ~ \hat{\theta}_2=1 ~~~ \Rightarrow ~~~
  {\mathcal E}(q_2,Q_2)\subseteq{\mathcal E}(q_1,Q_1) ~~~ \Rightarrow ~~~
  {\mathcal E}(q^-,Q^-)={\mathcal E}(q_2,Q_2).\]\[The method of finding the internal ellipsoidal approximation of the\]</div>
<p>intersection of two ellipsoids is described in Vazhentsev (1999).</p>
</div>
<div class="section" id="intersection-of-ellipsoid-and-halfspace">
<h3>Intersection of Ellipsoid and Halfspace<a class="headerlink" href="#intersection-of-ellipsoid-and-halfspace" title="Permalink to this headline">¶</a></h3>
<p>Finding the intersection of ellipsoid and halfspace can be reduced to
finding the intersection of two ellipsoids, one of which is unbounded.
Let <span class="math">{\mathcal E}(q_1,Q_1)</span> be a nondegenerate ellipsoid and let
<span class="math">H(c,\gamma)</span> define the halfspace</p>
<div class="math">
\[{\bf S}(c,\gamma) = \{x\in{\bf R}^n ~|~ \langle c,x\rangle\leqslant\gamma\}.\]\[We have to determine if the intersection\]</div>
<p><span class="math">{\mathcal E}(q_1,Q_1)\cap{\bf S}(c,\gamma)</span> is empty, and if not,
find its external and internal ellipsoidal approximations,
<span class="math">{\mathcal E}(q^+,Q^+)</span> and <span class="math">{\mathcal E}(q^-,Q^-)</span>. Two
trivial situations are:</p>
<ul class="simple">
<li><span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),H(c,\gamma))>0</span> and
<span class="math">\langle c, q_1\rangle>0</span>, which implies that
<span class="math">{\mathcal E}(q_1,Q_1)\cap{\bf S}(c,\gamma)=\emptyset</span>;</li>
<li><span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),H(c,\gamma))>0</span> and
<span class="math">\langle c, q_1\rangle<0</span>, so that
<span class="math">{\mathcal E}(q_1,Q_1)\subseteq{\bf S}(c,\gamma)</span>, and then
<span class="math">{\mathcal E}(q^+,Q^+)={\mathcal E}(q^-,Q^-)={\mathcal E}(q_1,Q_1)</span>.</li>
</ul>
<p>In case <span class="math">{\bf dist}({\mathcal E}(q_1,Q_1),H(c,\gamma)<0</span>, i.e. the
ellipsoid intersects the hyperplane,</p>
<div class="math">
\[  {\mathcal E}(q_1,Q_1)\cap{\bf S}(c,\gamma) =
  {\mathcal E}(q_1,Q_1)\cap\{x ~|~ \langle (x-q_2),W_2(x-q_2)\rangle\leqslant1\},\]\[with\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
q_2 &amp; = &amp; (\gamma + 2\sqrt{\overline{\lambda}})c,\label{hsell1} \\
W_2 &amp; = &amp; \frac{1}{4\overline{\lambda}}cc^T,\label{hsell2}\end{aligned}\end{split}\]</div>
<p><span class="math">\overline{\lambda}</span> being the biggest eigenvalue of matrix
<span class="math">Q_1</span>. After defining <span class="math">W_1=Q_1^{-1}</span>, we obtain
<span class="math">{\mathcal E}(q^+,Q^+)</span> from equations ([fusion1]-[fusion5]), and
<span class="math">{\mathcal E}(q^-,Q^-)</span> from ([paramell1]-[paramell2]),
([thetapar]).</p>
<p><strong>Remark.</strong> Notice that matrix <span class="math">W_2</span> has rank <span class="math">1</span>, which
makes it singular for <span class="math">n>1</span>. Nevertheless, expressions
([fusion1]-[fusion2]), ([paramell1]-[paramell2]) make sense because
<span class="math">W_1</span> is nonsingular, <span class="math">\pi_0\neq0</span> and
<span class="math">\hat{\theta}_1\neq0</span>.</p>
<p>To find the ellipsoidal approximations <span class="math">{\mathcal E}(q^+,Q^+)</span> and
<span class="math">{\mathcal E}(q^-,Q^-)</span> of the intersection of ellipsoid
<span class="math">{\mathcal E}(q,Q)</span> and polytope <span class="math">P(C,g)</span>,
<span class="math">C\in{\bf R}^{m\times n}</span>, <span class="math">b\in{\bf R}^m</span>, such that</p>
<div class="math">
\[{\mathcal E}(q^-,Q^-)\subseteq{\mathcal E}(q,Q)\cap P(C,g)\subseteq{\mathcal E}(q^+,Q^+),\]\[we first compute\]</div>
<div class="math">
\[  {\mathcal E}(q^-_1,Q^-_1)\subseteq{\mathcal E}(q,Q)\cap{\bf S}(c_1,\gamma_1)\subseteq
  {\mathcal E}(q^+_1,Q^+_1),\]\[wherein :math:`{\bf S}(c_1,\gamma_1)` is the halfspace defined by the\]</div>
<p>first row of matrix <span class="math">C</span>, <span class="math">c_1</span>, and the first element of
vector <span class="math">g</span>, <span class="math">\gamma_1</span>. Then, one by one, we get</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp; &amp; {\mathcal E}(q^-_2,Q^-_2)\subseteq{\mathcal E}(q^-_1,Q^-_1)\cap{\bf S}(c_2,\gamma_2), ~~~
{\mathcal E}(q^+_1,Q^+_1)\cap{\bf S}(c_2,\gamma_2)\subseteq{\mathcal E}(q^+_2,Q^+_2), \\
&amp; &amp; {\mathcal E}(q^-_3,Q^-_3)\subseteq{\mathcal E}(q^-_2,Q^-_2)\cap{\bf S}(c_3,\gamma_3), ~~~
{\mathcal E}(q^+_2,Q^+_2)\cap{\bf S}(c_3,\gamma_3)\subseteq{\mathcal E}(q^+_3,Q^+_3), \\
&amp; &amp; \cdots \\
&amp; &amp; {\mathcal E}(q^-_m,Q^-_m)\subseteq{\mathcal E}(q^-_{m-1},Q^-_{m-1})\cap{\bf S}(c_m,\gamma_m), ~~~
{\mathcal E}(q^+_{m-1},Q^+_{m-1})\cap{\bf S}(c_m,\gamma_m)\subseteq{\mathcal E}(q^+_m,Q^+_m), \\\end{aligned}\end{split}\]</div>
<p>The resulting ellipsoidal approximations are</p>
<div class="math">
\[{\mathcal E}(q^+,Q^+)={\mathcal E}(q^+_m,Q^+_m), ~~~~ {\mathcal E}(q^-,Q^-)={\mathcal E}(q^-_m,Q^-_m) .\]</div>
</div>
<div class="section" id="checking-if">
<h3>Checking if<a class="headerlink" href="#checking-if" title="Permalink to this headline">¶</a></h3>
<p>Theorem of alternatives, also known as <em>:math:`S`-procedure</em> Boyd and
Vandenberghe (2004), states that the implication</p>
<div class="math">
\[  \langle x, A_1x\rangle + 2\langle b_1,x\rangle + c_1 \leqslant0
  ~~ \Rightarrow ~~
  \langle x, A_2x\rangle + 2\langle b_2,x\rangle + c_2 \leqslant0,\]\[where :math:`A_i\in{\bf R}^{n\times n}` are symmetric matrices,\]</div>
<p><span class="math">b_i\in{\bf R}^n</span>, <span class="math">c_i\in{\bf R}</span>, <span class="math">i=1,2</span>, holds if
and only if there exists <span class="math">\lambda>0</span> such that</p>
<div class="math">
\[\begin{split}\left[\begin{array}{cc}
A_2 &amp; b_2\\
b_2^T &amp; c_2\end{array}\right]
\preceq
\lambda\left[\begin{array}{cc}
A_1 &amp; b_1\\
b_1^T &amp; c_1\end{array}\right].\end{split}\]</div>
<p>By <span class="math">S</span>-procedure,
<span class="math">{\mathcal E}(q_1,Q_1)\subseteq{\mathcal E}(q_2,Q_2)</span> (both
ellipsoids are assumed to be nondegenerate) if and only if the following
SDP problem is feasible:</p>
<div class="math">
\[\min 0\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
\lambda &amp; &gt; &amp; 0, \\
\left[\begin{array}{cc}
Q_2^{-1} &amp; -Q_2^{-1}q_2\\
(-Q_2^{-1}q_2)^T &amp; q_2^TQ_2^{-1}q_2-1\end{array}\right]
&amp; \preceq &amp;
\lambda \left[\begin{array}{cc}
Q_1^{-1} &amp; -Q_1^{-1}q_1\\
(-Q_1^{-1}q_1)^T &amp; q_1^TQ_1^{-1}q_1-1\end{array}\right]\end{aligned}\end{split}\]</div>
<p>where <span class="math">\lambda\in{\bf R}</span> is the variable.</p>
</div>
<div class="section" id="minimum-volume-ellipsoids">
<h3>Minimum Volume Ellipsoids<a class="headerlink" href="#minimum-volume-ellipsoids" title="Permalink to this headline">¶</a></h3>
<p>The minimum volume ellipsoid that contains set <span class="math">S</span> is called
<em>Löwner-John ellipsoid</em> of the set <span class="math">S</span>. To characterize it we
rewrite general ellipsoid <span class="math">{\mathcal E}(q,Q)</span> as</p>
<div class="math">
\[{\mathcal E}(q,Q) = \{x ~|~ \langle (Ax + b), (Ax + b)\rangle \},\]\[where\]</div>
<div class="math">
\[A = Q^{-1/2} ~~~ \mbox{ and } ~~~ b = -Aq .\]\[For positive definite matrix :math:`A`, the volume of\]</div>
<p><span class="math">{\mathcal E}(q,Q)</span> is proportional to <span class="math">\det A^{-1}</span>. So,
finding the minimum volume ellipsoid containing <span class="math">S</span> can be
expressed as semidefinite programming (SDP) problem</p>
<div class="math">
\[\min \log \det A^{-1}\]\[subject to:\]</div>
<div class="math">
\[\sup_{v\in S} \langle (Av + b), (Av + b)\rangle \leqslant1,\]\[where the variables are :math:`A\in{\bf R}^{n\times n}` and\]</div>
<p><span class="math">b\in{\bf R}^n</span>, and there is an implicit constraint
<span class="math">A\succ 0</span> (<span class="math">A</span> is positive definite). The objective and
constraint functions are both convex in <span class="math">A</span> and <span class="math">b</span>, so this
problem is convex. Evaluating the constraint function, however, requires
solving a convex maximization problem, and is tractable only in certain
special cases.</p>
<p>For a finite set <span class="math">S=\{x_1,\cdots,x_m\}\subset{\bf R}^n</span>, an
ellipsoid covers <span class="math">S</span> if and only if it covers its convex hull. So,
finding the minimum volume ellipsoid covering <span class="math">S</span> is the same as
finding the minimum volume ellipsoid containing the polytope
<span class="math">{\bf conv}\{x_1,\cdots,x_m\}</span>. The SDP problem is</p>
<div class="math">
\[\min \log \det A^{-1}\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
A &amp; \succ &amp; 0, \\
\langle (Ax_i + b), (Ax_i + b)\rangle &amp; \leqslant&amp; 1, ~~~ i=1..m.\end{aligned}\end{split}\]</div>
<p>We can find the minimum volume ellipsoid containing the union of
ellipsoids <span class="math">\bigcup_{i=1}^m{\mathcal E}(q_i,Q_i)</span>. Using the fact
that for <span class="math">i=1..m</span>
<span class="math">{\mathcal E}(q_i,Q_i)\subseteq{\mathcal E}(q,Q)</span> if and only if
there exists <span class="math">\lambda_i>0</span> such that</p>
<div class="math">
\[\begin{split}  \left[\begin{array}{cc}
  A^2 - \lambda_i Q_i^{-1} &amp; Ab + \lambda_i Q_i^{-1}q_i\\
  (Ab + \lambda_i Q_i^{-1}q_i)^T &amp; b^Tb-1 - \lambda_i (q_i^TQ_i^{-1}q_i-1) \end{array}
  \right] \preceq 0 .\end{split}\]\[Changing variable :math:`\tilde{b}=Ab`, we get convex SDP in the\]</div>
<p>variables <span class="math">A</span>, <span class="math">\tilde{b}</span>, and
<span class="math">\lambda_1,\cdots,\lambda_m</span>:</p>
<div class="math">
\[\min \log \det A^{-1}\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
\lambda_i &amp; &gt; &amp; 0,\\
\left[\begin{array}{ccc}
A^2-\lambda_iQ_i^{-1} &amp; \tilde{b}+\lambda_iQ_i^{-1}q_i &amp; 0 \\
(\tilde{b}+\lambda_iQ_i^{-1}q_i)^T &amp; -1-\lambda_i(q_i^TQ_i^{-1}q_i-1) &amp; \tilde{b}^T \\
0 &amp; \tilde{b} &amp; -A^2\end{array}\right] &amp; \preceq &amp; 0, ~~~ i=1..m.\end{aligned}\end{split}\]</div>
<p>After <span class="math">A</span> and <span class="math">b</span> are found,</p>
<div class="math">
\[q=-A^{-1}b ~~~ \mbox{ and } ~~~ Q=(A^TA)^{-1}.\]</div>
<p>The results on the minimum volume ellipsoids are explained and proven in
Boyd and Vandenberghe (2004).</p>
</div>
<div class="section" id="maximum-volume-ellipsoids">
<h3>Maximum Volume Ellipsoids<a class="headerlink" href="#maximum-volume-ellipsoids" title="Permalink to this headline">¶</a></h3>
<p>Consider a problem of finding the maximum volume ellipsoid that lies
inside a bounded convex set <span class="math">S</span> with nonempty interior. To
formulate this problem we rewrite general ellipsoid
<span class="math">{\mathcal E}(q,Q)</span> as</p>
<div class="math">
\[{\mathcal E}(q,Q) = \{Bx + q ~|~ \langle x,x\rangle\leqslant1\},\]\[where :math:`B=Q^{1/2}`, so the volume of :math:`{\mathcal E}(q,Q)` is\]</div>
<p>proportional to <span class="math">\det B</span>.</p>
<p>The maximum volume ellipsoid that lies inside <span class="math">S</span> can be found by
solving the following SDP problem:</p>
<div class="math">
\[\max \log \det B\]\[subject to:\]</div>
<div class="math">
\[\sup_{\langle v,v\rangle\leqslant1} I_S(Bv+q)\leqslant0 ,\]\[in the variables :math:`B\in{\bf R}^{n\times n}` - symmetric matrix,\]</div>
<p>and <span class="math">q\in{\bf R}^n</span>, with implicit constraint <span class="math">B\succ 0</span>,
where <span class="math">I_S</span> is the indicator function:</p>
<div class="math">
\[\begin{split}I_S(x) = \left\{\begin{array}{ll}
0, &amp; \mbox{ if } x\in S,\\
\infty, &amp; \mbox{ otherwise.}\end{array}\right.\end{split}\]</div>
<p>In case of polytope, <span class="math">S=P(C,g)</span> with <span class="math">P(C,g)</span> defined in
([polytope]), the SDP has the form</p>
<div class="math">
\[\min \log \det B^{-1}\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
B &amp; \succ &amp; 0,\\
\langle c_i, Bc_i\rangle + \langle c_i, q\rangle &amp; \leqslant&amp; \gamma_i,
~~~ i=1..m.\end{aligned}\end{split}\]</div>
<p>We can find the maximum volume ellipsoid that lies inside the
intersection of given ellipsoids
<span class="math">\bigcap_{i=1}^m{\mathcal E}(q_i,Q_i)</span>. Using the fact that for
<span class="math">i=1..m</span> <span class="math">{\mathcal E}(q,Q)\subseteq{\mathcal E}(q_i,Q_i)</span>
if and only if there exists <span class="math">\lambda_i>0</span> such that</p>
<div class="math">
\[\begin{split}\left[\begin{array}{cc}
-\lambda_i - q^TQ_i^{-1}q + 2q_i^TQ_i^{-1}q - q_i^TQ_i^{-1}q_i + 1 &amp; (Q_i^{-1}q-Q_i^{-1}q_i)^TB\\
B(Q_i^{-1}q-Q_i^{-1}q_i) &amp; \lambda_iI-BQ_i^{-1}B\end{array}\right] \succeq 0.\end{split}\]</div>
<p>To find the maximum volume ellipsoid, we solve convex SDP in variables
<span class="math">B</span>, <span class="math">q</span>, and <span class="math">\lambda_1,\cdots,\lambda_m</span>:</p>
<div class="math">
\[\min \log \det B^{-1}\]\[subject to:\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
\lambda_i &amp; &gt; &amp; 0, \\
\left[\begin{array}{ccc}
1-\lambda_i &amp; 0 &amp; (q - q_i)^T\\
0 &amp; \lambda_iI &amp; B\\
q - q_i &amp; B &amp; Q_i\end{array}\right] &amp; \succeq &amp; 0, ~~~ i=1..m.\end{aligned}\end{split}\]</div>
<p>After <span class="math">B</span> and <span class="math">q</span> are found,</p>
<div class="math">
\[Q = B^TB.\]</div>
<p>The results on the maximum volume ellipsoids are explained and proven in
Boyd and Vandenberghe (2004).</p>
</div>
</div>
</div>
<div class="section" id="reachability">
<h1>Reachability<a class="headerlink" href="#reachability" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basics-of-reachability-analysis">
<h2>Basics of Reachability Analysis<a class="headerlink" href="#basics-of-reachability-analysis" title="Permalink to this headline">¶</a></h2>
<div class="section" id="systems-without-disturbances">
<h3>Systems without disturbances<a class="headerlink" href="#systems-without-disturbances" title="Permalink to this headline">¶</a></h3>
<p>Consider a general continuous-time</p>
<div class="math">
\[\dot{x}(t) = f(t, x, u),
\label{ctds1}\]</div>
<p>or discrete-time dynamical system</p>
<div class="math">
\[x(t+1) = f(t, x, u),
\tag*{(\ref{ctds1}d)}
\label{dtds1}\]</div>
<p>wherein <span class="math">t</span> is time <a class="footnote-reference" href="#id13" id="id1">[1]</a>, <span class="math">x\in{\bf R}^n</span> is the state,
<span class="math">u\in{\bf R}^m</span> is the control, and <span class="math">f</span> is a measurable
vector function taking values in <span class="math">{\bf R}^n</span>. <a class="footnote-reference" href="#id14" id="id2">[2]</a> The control
values <span class="math">u(t, x(t))</span> are restricted to a closed compact control set
<span class="math">{\mathcal U}(t)\subset{\bf R}^m</span>. An <em>open-loop</em> control does not
depend on the state, <span class="math">u=u(t)</span>; for a <em>closed-loop</em> control,
<span class="math">u=u(t, x(t))</span>.</p>
<p>The (forward) reach set <span class="math">{\mathcal X}(t, t_0, x_0)</span> at time
<span class="math">t>t_0</span> from the initial position <span class="math">(t_0, x_0)</span> is the set of
all states <span class="math">x(t)</span> reachable at time <span class="math">t</span> by system ([ctds1]),
or [dtds1], with <span class="math">x(t_0)=x_0</span> through all possible controls
<span class="math">u(\tau, x(\tau))\in{\mathcal U}(\tau)</span>,
<span class="math">t_0\leqslant\tau< t</span>. For a given set of initial states
<span class="math">{\mathcal X}_0</span>, the reach set
<span class="math">{\mathcal X}(t, t_0, {\mathcal X}_0)</span> is</p>
<div class="math">
\[{\mathcal X}(t, t_0, {\mathcal X}_0) = \bigcup_{x_0\in{\mathcal X}_0}{\mathcal X}(t, t_0, x_0).\]\[[def:sub:`o`\ lrs] Here are two facts about forward reach sets.\]</div>
<ol class="arabic">
<li><p class="first"><span class="math">{\mathcal X}(t, t_0, {\mathcal X}_0)</span> is the same for
open-loop and closed-loop control.</p>
</li>
<li><p class="first"><span class="math">{\mathcal X}(t, t_0, {\mathcal X}_0)</span> satisfies the semigroup
property,</p>
<div class="math">
\[\begin{split}{\mathcal X}(t, t_0, {\mathcal X}_0) = {\mathcal X}(t, \tau, {\mathcal X}(\tau, t_0, {\mathcal X}_0)), \;\;\;
t_0\leqslant\tau&lt; t.
\label{semigroup}\end{split}\]</div>
</li>
</ol>
<p>For linear systems</p>
<div class="math">
\[f(t, x, u) = A(t)x(t) + B(t)u,
\label{linearrhs}\]</div>
<p>with matrices <span class="math">A(t)</span> in <span class="math">{\bf R}^{n\times n}</span> and
<span class="math">B(t)</span> in <span class="math">{\bf R}^{m\times n}</span>. For continuous-time linear
system the state transition matrix is</p>
<div class="math">
\[\dot{\Phi}(t, t_0) = A(t)\Phi(t, t_0), \;\;\; \Phi(t, t) = I,\]\[which for constant :math:`A(t)\equiv A` simplifies as\]</div>
<div class="math">
\[\Phi(t, t_0) = e^{A(t-t_0)} .\]\[For discrete-time linear system the state transition matrix is\]</div>
<div class="math">
\[\Phi(t+1, t_0) = A(t)\Phi(t, t_0), \;\;\; \Phi(t, t) = I,\]\[which for constant :math:`A(t)\equiv A` simplifies as\]</div>
<div class="math">
\[\Phi(t, t_0) = A^{t-t_0} .\]</div>
<p>If the state transition matrix is invertible,
<span class="math">\Phi^{-1}(t, t_0) = \Phi(t_0, t)</span>. The transition matrix is
always invertible for continuous-time and for sampled discrete-time
systems. However, if for some <span class="math">\tau</span>, <span class="math">t_0\leqslant\tau<t</span>,
<span class="math">A(\tau)</span> is degenerate (singular),
<span class="math">\Phi(t, t_0)=\prod_{\tau=t_0}^{t-1}A(\tau)</span>, is also degenerate
and cannot be inverted.</p>
<p>Following Cauchy’s formula, the reach set
<span class="math">{\mathcal X}(t, t_0, {\mathcal X}_0)</span> for a linear system can be
expressed as</p>
<div class="math">
\[{\mathcal X}(t, t_0, {\mathcal X}_0) =
\Phi(t, t_0){\mathcal X}_0 \oplus \int_{t_0}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau
\label{ctlsrs}\]</div>
<p>in continuous-time, and as</p>
<div class="math">
\[{\mathcal X}(t, t_0, {\mathcal X}_0) =
\Phi(t, t_0){\mathcal X}_0 \oplus \sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)
\tag*{(\ref{ctlsrs}d)}
\label{dtlsrs}\]</div>
<p>in discrete-time case.</p>
<p>The operation ‘<span class="math">\oplus</span>’ is the <em>geometric sum</em>, also known as
<em>Minkowski sum</em>. <a class="footnote-reference" href="#id15" id="id3">[3]</a> The geometric sum and linear (or affine)
transformations preserve compactness and convexity. Hence, if the
initial set <span class="math">{\mathcal X}_0</span> and the control sets
<span class="math">{\mathcal U}(\tau)</span>, <span class="math">t_0\leqslant\tau<t</span>, are compact and
convex, so is the reach set
<span class="math">{\mathcal X}(t, t_0, {\mathcal X}_0)</span>.</p>
<p>The backward reach set <span class="math">{\mathcal Y}(t_1, t, y_1)</span> for the target
position <span class="math">(t_1, y_1)</span> is the set of all states <span class="math">y(t)</span> for
which there exists some control
<span class="math">u(\tau, x(\tau))\in{\mathcal U}(\tau)</span>,
<span class="math">t\leqslant\tau<t_1</span>, that steers system ([ctds1]), or [dtds1] to
the state <span class="math">y_1</span> at time <span class="math">t_1</span>. For the target set
<span class="math">{\mathcal Y}_1</span> at time <span class="math">t_1</span>, the backward reach set
<span class="math">{\mathcal Y}(t_1, t, {\mathcal Y}_1)</span> is</p>
<div class="math">
\[{\mathcal Y}(t_1, t, {\mathcal Y}_1) = \bigcup_{y_1\in{\mathcal Y}_1}{\mathcal Y}(t_1, t, y_1).\]\[[def:sub:`o`\ lbrs] The backward reach set\]</div>
<p><span class="math">{\mathcal Y}(t_1, t, {\mathcal Y}_1)</span> is the largest <em>weakly
invariant</em> set with respect to the target set <span class="math">{\mathcal Y}_1</span> and
time values <span class="math">t</span> and <span class="math">t_1</span>. <a class="footnote-reference" href="#id16" id="id4">[4]</a></p>
<p><strong>Remark.</strong> Backward reach set can be computed for continuous-time
system only if the solution of ([ctds1]) exists for <span class="math">t<t_1</span>; and
for discrete-time system only if the right hand side of [dtds1] is
invertible <a class="footnote-reference" href="#id17" id="id5">[5]</a>.</p>
<p>These two facts about the backward reach set <span class="math">{\mathcal Y}</span> are
similar to those for forward reach sets.</p>
<ol class="arabic">
<li><p class="first"><span class="math">{\mathcal Y}(t_1, t, {\mathcal Y}_1)</span> is the same for
open-loop and closed-loop control.</p>
</li>
<li><p class="first"><span class="math">{\mathcal Y}(t_1, t, {\mathcal Y}_1)</span> satisfies the semigroup
property,</p>
<div class="math">
\[\begin{split}{\mathcal Y}(t_1, t, {\mathcal Y}_1) = {\mathcal Y}(\tau, t, {\mathcal Y}(t_1, \tau, {\mathcal Y}_1)), \;\;\;
t\leqslant\tau&lt; t_1.
\label{semigroup_b}\end{split}\]</div>
</li>
</ol>
<p>For the linear system ([linearrhs]) the backward reach set can be
expressed as</p>
<div class="math">
\[{\mathcal Y}(t_1, t, {\mathcal Y}_1) =
\Phi(t, t_1){\mathcal Y}_1 \oplus \int_{t_1}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau
\label{ctlsbrs}\]</div>
<p>in the continuous-time case, and as</p>
<div class="math">
\[{\mathcal Y}(t_1, t, {\mathcal Y}_1) =
\Phi(t, t_1){\mathcal Y}_1 \oplus \sum_{\tau =t}^{t_1-1}-\Phi(t, \tau)B(\tau){\mathcal U}(\tau)
\tag*{(\ref{ctlsbrs}d)}
\label{dtlsbrs}\]</div>
<p>in discrete-time case. The last formula makes sense only for
discrete-time linear systems with invertible state transition matrix.
Degenerate discrete-time linear systems have unbounded backward reach
sets and such sets cannot be computed with available software tools.</p>
<p>Just as in the case of forward reach set, the backward reach set of a
linear system <span class="math">{\mathcal Y}(t_1, t, {\mathcal Y}_1)</span> is compact
and convex if the target set <span class="math">{\mathcal Y}_1</span> and the control sets
<span class="math">{\mathcal U}(\tau)</span>, <span class="math">t\leqslant\tau<t_1</span>, are compact and
convex.</p>
<p><strong>Remark.</strong> In the computer science literature the reach set is said to
be the result of operator <em>post</em>, and the backward reach set is the
result of operator <em>pre</em>. In the control literature the backward reach
set is also called the <em>solvability set</em>.</p>
</div>
<div class="section" id="systems-with-disturbances">
<h3>Systems with disturbances<a class="headerlink" href="#systems-with-disturbances" title="Permalink to this headline">¶</a></h3>
<p>Consider the continuous-time dynamical system with disturbance</p>
<div class="math">
\[\dot{x}(t) = f(t, x, u, v),
\label{ctds2}\]</div>
<p>or the discrete-time dynamical system with disturbance</p>
<div class="math">
\[x(t+1) = f(t, x, u, v),
\tag*{(\ref{ctds2}d)}
\label{dtds2}\]</div>
<p>in which we also have the disturbance input <span class="math">v\in{\bf R}^d</span> with
values <span class="math">v(t)</span> restricted to a closed compact set
<span class="math">{\mathcal V}(t)\subset{\bf R}^d</span>.</p>
<p>In the presence of disturbances the open-loop reach set (OLRS) is
different from the closed-loop reach set (CLRS).</p>
<p>Given the initial time <span class="math">t_0</span>, the set of initial states
<span class="math">{\mathcal X}_0</span>, and terminal time <span class="math">t</span>, there are two types
of OLRS.</p>
<p>The maxmin open-loop reach set
<span class="math">\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)</span> is the set
of all states <span class="math">x</span>, such that for any disturbance
<span class="math">v(\tau)\in{\mathcal V}(\tau)</span>, there exist an initial state
<span class="math">x_0\in{\mathcal X}_0</span> and a control
<span class="math">u(\tau)\in{\mathcal U}(\tau)</span>, <span class="math">t_0\leqslant\tau<t</span>, that
steers system ([ctds2]) or [dtds2] from <span class="math">x(t_0)=x_0</span> to
<span class="math">x(t)=x</span>. [def:sub:<cite>m</cite>axminolrs] The minmax open-loop reach set
<span class="math">\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)</span> is the set
of all states <span class="math">x</span>, such that there exists a control
<span class="math">u(\tau)\in{\mathcal U}(\tau)</span> that for all disturbances
<span class="math">v(\tau)\in{\mathcal V}(\tau)</span>, <span class="math">t_0\leqslant\tau<t</span>,
assigns an initial state <span class="math">x_0\in{\mathcal X}_0</span> and steers system
([ctds2]), or [dtds2], from <span class="math">x(t_0)=x_0</span> to <span class="math">x(t)=x</span>.
[def:sub:<cite>m</cite>inmaxolrs] In the maxmin case the control is chosen
<em>after</em> knowing the disturbance over the entire time interval
<span class="math">[t_0, t]</span>, whereas in the minmax case the control is chosen
<em>before</em> any knowledge of the disturbance. Consequently, the OLRS do not
satisfy the semigroup property.</p>
<p>The terms ‘maxmin’ and ‘minmax’ come from the fact that
<span class="math">\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)</span> is the
subzero level set of the value function</p>
<div class="math">
\[\begin{split}\underline{V}(t, x) =
\max_v\min_u\{{\bf dist}(x(t_0), {\mathcal X}_0) ~|~ x(t)=x, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t_0\leqslant\tau&lt;t\},
\label{maxminvf}\end{split}\]</div>
<p>i.e.,
<span class="math">\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \{ x~|~\underline{V}(t, x) \leqslant0\}</span>,
and <span class="math">\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)</span> is the
subzero level set of the value function</p>
<div class="math">
\[\begin{split}\overline{V}(t, x) =
\min_u\max_v\{{\bf dist}(x(t_0), {\mathcal X}_0) ~|~ x(t)=x, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t_0\leqslant\tau&lt;t\},
\label{minmaxvf}\end{split}\]</div>
<p>in which <span class="math">{\bf dist}(\cdot, \cdot)</span> denotes Hausdorff
semidistance. <a class="footnote-reference" href="#id18" id="id6">[6]</a> Since
<span class="math">\underline{V}(t, x)\leqslant\overline{V}(t, x)</span>,
<span class="math">\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)\subseteq\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0)</span>.</p>
<p>Note that maxmin and minmax OLRS imply <em>guarantees</em>: these are states
that can be reached no matter what the disturbance is, whether it is
known in advance (maxmin case) or not (minmax case). The OLRS may be
empty.</p>
<p>Fixing time instant <span class="math">\tau_1</span>, <span class="math">t_0<\tau_1<t</span>, define the
<em>piecewise maxmin open-loop reach set with one correction</em>,</p>
<div class="math">
\[\overline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) = \overline{{\mathcal X}}_{OL}(t, \tau_1, \overline{{\mathcal X}}_{OL}(\tau_1, t_0, {\mathcal X}_0)),
\label{maxmin1}\]</div>
<p>and the <em>piecewise minmax open-loop reach set with one correction</em>,</p>
<div class="math">
\[\underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) = \underline{{\mathcal X}}_{OL}(t, \tau_1, \underline{{\mathcal X}}_{OL}(\tau_1, t_0, {\mathcal X}_0)).
\label{minmax1}\]</div>
<p>The piecewise maxmin OLRS
<span class="math">\overline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0)</span> is the
subzero level set of the value function</p>
<div class="math">
\[\begin{split}\underline{V}^1(t, x) =
\max_v\min_u\{\underline{V}(\tau_1, x(\tau_1)) ~|~ x(t)=x, \;
u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_1\leqslant\tau&lt;t\},
\label{maxminvf1}\end{split}\]</div>
<p>with <span class="math">V(\tau_1, x(\tau_1))</span> given by ([maxminvf]), which yields</p>
<div class="math">
\[\underline{V}^1(t, x) \geqslant\underline{V}(t, x),\]\[and thus,\]</div>
<div class="math">
\[\overline{{\mathcal X}}_{OL}^1(t, t_0 {\mathcal X}_0) \subseteq \overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) .\]\[On the other hand, the piecewise minmax OLRS\]</div>
<p><span class="math">\underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0)</span> is the
subzero level set of the value function</p>
<div class="math">
\[\begin{split}\overline{V}^1(t, x) =
\min_u\max_v\{\overline{V}(\tau_1, x(\tau_1)) ~|~ x(t)=x, \;
u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_1\leqslant\tau&lt;t\},
\label{minmaxvf1}\end{split}\]</div>
<p>with <span class="math">V(\tau_1, x(\tau_1))</span> given by ([minmaxvf]), which yields</p>
<div class="math">
\[\overline{V}(t, x) \geqslant\overline{V}^1(t, x),\]\[and thus,\]</div>
<div class="math">
\[\underline{{\mathcal X}}_{OL}(t, t_0 {\mathcal X}_0) \subseteq \underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) .\]\[We can now recursively define piecewise maxmin and minmax OLRS with\]</div>
<p><span class="math">k</span> corrections for <span class="math">t_0<\tau_1<\cdots<\tau_k<t</span>. The maxmin
piecewise OLRS with <span class="math">k</span> corrections is</p>
<div class="math">
\[\overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) =
\overline{{\mathcal X}}_{OL}(t, \tau_k, \overline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0)),
\label{maxmink}\]</div>
<p>which is the subzero level set of the corresponding value function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\underline{V}^k(t, x) = \nonumber \\
&amp;&amp;\max_v\min_u\{\underline{V}^{k-1}(\tau_k, x(\tau_k)) ~|~ x(t)=x, \;
u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_k\leqslant\tau&lt;t\}.
\label{maxminvfk}\end{aligned}\end{split}\]</div>
<p>The minmax piecewise OLRS with <span class="math">k</span> corrections is</p>
<div class="math">
\[\underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) =
\underline{{\mathcal X}}_{OL}(t, \tau_k, \underline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0)),
\label{minmaxk}\]</div>
<p>which is the subzero level set of the corresponding value function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\overline{V}^k(t, x) = \nonumber \\
&amp;&amp;\min_u\max_v\{\overline{V}^{k-1}(\tau_k, x(\tau_k)) ~|~ x(t)=x, \;
u(\tau)\in{\mathcal U}(\tau), \; v(\tau)\in{\mathcal V}(\tau), \; \tau_k\leqslant\tau&lt;t\}.
\label{minmaxvfk}\end{aligned}\end{split}\]</div>
<p>From ([maxminvf1]), ([minmaxvf1]), ([maxminvfk]) and ([minmaxvfk]) it
follows that</p>
<div class="math">
\[  \underline{V}(t, x) \leqslant\underline{V}^1(t, x)\leqslant\cdots
  \leqslant\underline{V}^k(t, x) \leqslant\overline{V}^k(t, x) \leqslant\cdots
  \leqslant\overline{V}^1(t, x) \leqslant\overline{V}(t, x) .\]\[Hence,\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) \subseteq \underline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0) \subseteq \cdots
\subseteq \underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) \subseteq \nonumber \\
&amp;&amp;\overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) \subseteq \cdots \subseteq \overline{{\mathcal X}}_{OL}^1(t, t_0, {\mathcal X}_0)
\subseteq \overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) .
\label{olrsinclusion}\end{aligned}\end{split}\]</div>
<p>We call</p>
<div class="math">
\[\begin{split}\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = \overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0), \;\;
k = \left\{\begin{array}{ll}
\infty &amp; \mbox{ for continuous-time system}\\
t-t_0-1 &amp; \mbox{ for discrete-time system}\end{array}\right.
\label{maxminclrs}\end{split}\]</div>
<p>the <em>maxmin closed-loop reach set</em> of system ([ctds2]) or [dtds2] at
time <span class="math">t</span>, and we call</p>
<div class="math">
\[\begin{split}\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = \underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0), \;\;
k = \left\{\begin{array}{ll}
\infty &amp; \mbox{ for continuous-time system}\\
t-t_0-1 &amp; \mbox{ for discrete-time system}\end{array}\right.
\label{minmaxclrs}\end{split}\]</div>
<p>the <em>minmax closed-loop reach set</em> of system ([ctds2]) or [dtds2] at
time <span class="math">t</span>. Given initial time <span class="math">t_0</span> and the set of initial
states <span class="math">{\mathcal X}_0</span>, the maxmin CLRS
<span class="math">\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)</span> of system
([ctds2]) or [dtds2] at time <span class="math">t>t_0</span>, is the set of all states
<span class="math">x</span>, for each of which and for every disturbance
<span class="math">v(\tau)\in{\mathcal V}(\tau)</span>, there exist an initial state
<span class="math">x_0\in{\mathcal X}_0</span> and a control
<span class="math">u(\tau, x(\tau))\in{\mathcal U}(\tau)</span>, such that the trajectory
<span class="math">x(\tau | v(\tau), u(\tau, x(\tau)))</span> satisfying
<span class="math">x(t_0) = x_0</span> and</p>
<div class="math">
\[  \dot{x}(\tau | v(\tau), u(\tau, x(\tau))) \in
  f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))\]\[in the continuous-time case, or\]</div>
<div class="math">
\[  x(\tau+1 | v(\tau), u(\tau, x(\tau))) \in
  f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))\]\[\begin{split}in the discrete-time case, with :math:`t_0\leqslant\tau&lt;t`, is such\end{split}\]</div>
<p>that <span class="math">x(t)=x</span>. [def:sub:<cite>m</cite>axminclrs] Given initial time
<span class="math">t_0</span> and the set of initial states <span class="math">{\mathcal X}_0</span>, the
maxmin CLRS
<span class="math">\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)</span> of system
([ctds2]) or [dtds2], at time <span class="math">t>t_0</span>, is the set of all states
<span class="math">x</span>, for each of which there exists a control
<span class="math">u(\tau, x(\tau))\in{\mathcal U}(\tau)</span>, and for every disturbance
<span class="math">v(\tau)\in{\mathcal V}(\tau)</span> there exists an initial state
<span class="math">x_0\in{\mathcal X}_0</span>, such that the trajectory
<span class="math">x(\tau, v(\tau) | u(\tau, x(\tau)))</span> satisfying
<span class="math">x(t_0) = x_0</span> and</p>
<div class="math">
\[  \dot{x}(\tau, v(\tau) | u(\tau, x(\tau))) \in
  f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))\]\[in the continuous-time case, or\]</div>
<div class="math">
\[  x(\tau+1, v(\tau) | u(\tau, x(\tau))) \in
  f(\tau, x(\tau), u(\tau, x(\tau)), v(\tau))\]\[\begin{split}in the discrete-time case, with :math:`t_0\leqslant\tau&lt;t`, is such\end{split}\]</div>
<p>that <span class="math">x(t)=x</span>. [def:sub:<cite>m</cite>inmaxclrs] By construction, both
maxmin and minmax CLRS satisfy the semigroup property ([semigroup]).</p>
<p>For some classes of dynamical systems and some types of constraints on
initial conditions, controls and disturbances, the maxmin and minmax
CLRS may coincide. This is the case for continuous-time linear systems
with convex compact bounds on the initial set, controls and disturbances
under the condition that the initial set <span class="math">{\mathcal X}_0</span> is large
enough to ensure that
<span class="math">{\mathcal X}(t_0+\epsilon, t_0, {\mathcal X}_0)</span> is nonempty for
some small <span class="math">\epsilon>0</span>.</p>
<p>Consider the linear system case,</p>
<div class="math">
\[f(t, x, u) = A(t)x(t) + B(t)u + G(t)v,
\label{linearrhsdist}\]</div>
<p>where <span class="math">A(t)</span> and <span class="math">B(t)</span> are as in ([linearrhs]), and
<span class="math">G(t)</span> takes its values in <span class="math">{\bf R}^d</span>.</p>
<p>The maxmin OLRS for the continuous-time linear system can be expressed
through set valued integrals,</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, t_0){\mathcal X}_0 \oplus
\int_{t_0}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
\int_{t_0}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau,
\end{array}
\label{ctlsmaxmin}\end{split}\]</div>
<p>and for discrete-time linear system through set-valued sums,</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, t_0){\mathcal X}_0 \oplus
\sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
\sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau).
\end{array}
\tag*{(\ref{ctlsmaxmin}d)}
\label{dtlsmaxmin}\end{split}\]</div>
<p>Similarly, the minmax OLRS for the continuous-time linear system is</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, t_0){\mathcal X}_0 \dot{-}
\int_{t_0}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau\right)
\oplus \\
\int_{t_0}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
\end{array}
\label{ctlsminmax}\end{split}\]</div>
<p>and for the discrete-time linear system it is</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal X}}_{OL}(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, t_0){\mathcal X}_0 \dot{-}
\sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau)\right)
\oplus \\
\sum_{\tau=t_0}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
\end{array}
\tag*{(\ref{ctlsminmax}d)}
\label{dtlsminmax}\end{split}\]</div>
<p>The operation ‘<span class="math">\dot{-}</span>’ is <em>geometric difference</em>, also known as
<em>Minkowski difference</em>. <a class="footnote-reference" href="#id19" id="id7">[7]</a></p>
<p>Now consider the piecewise OLRS with <span class="math">k</span> corrections. Expression
([maxmink]) translates into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, \tau_k)\overline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0) \oplus
\int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
\int_{\tau_k}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau,
\end{array}
\label{ctlsmaxmink}\end{split}\]</div>
<p>in the continuous-time case, and for the discrete-time case into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, \tau_k)\overline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0) \oplus
\sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
\sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau).
\end{array}
\tag*{(\ref{ctlsmaxmink}d)}
\label{dtlsmaxmink}\end{split}\]</div>
<p>Expression ([minmaxk]) translates into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, \tau_k)\underline{{\mathcal X}}_{OL}^{k-1}(t, t_0, {\mathcal X}_0) \dot{-}
\int_{\tau_k}^t\Phi(t, \tau)(-G(\tau)){\mathcal V}(\tau)d\tau\right)
\oplus \\
\int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
\end{array}
\label{ctlsminmaxk}\end{split}\]</div>
<p>in the continuous-time case, and for the discrete-time case into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal X}}_{OL}^k(t, t_0, {\mathcal X}_0) = \\
\left(\Phi(t, \tau_k)\underline{{\mathcal X}}_{OL}^{k-1}(\tau_k, t_0, {\mathcal X}_0) \dot{-}
\sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)(-G(\tau)){\mathcal V}(\tau)\right)
\oplus \\
\sum_{\tau=\tau_k}^{t-1}\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
\end{array}
\tag*{(\ref{ctlsminmaxk}d)}
\label{dtlsminmaxk}\end{split}\]</div>
<p>Since for any
<span class="math">{\mathcal W}_1, {\mathcal W}_2, {\mathcal W}_3 \subseteq {\bf R}^n</span>
it is true that</p>
<div class="math">
\[  ({\mathcal W}_1 \dot{-} {\mathcal W}_2) \oplus {\mathcal W}_3 =
  ({\mathcal W}_1 \oplus {\mathcal W}_3) \dot{-} ({\mathcal W}_2 \oplus {\mathcal W}_3) \subseteq
  ({\mathcal W}_1 \oplus {\mathcal W}_3) \dot{-} {\mathcal W}_2,\]\[from ([ctlsmaxmink]), ([ctlsminmaxk]) and from [dtlsmaxmink],\]</div>
<p>[dtlsminmaxk], it is clear that ([olrsinclusion]) is true.</p>
<p>For linear systems, if the initial set <span class="math">{\mathcal X}_0</span>, control
bounds <span class="math">{\mathcal U}(\tau)</span> and disturbance bounds
<span class="math">{\mathcal V}(\tau)</span>, <span class="math">t_0\leqslant\tau<t</span>, are compact and
convex, the CLRS
<span class="math">\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)</span> and
<span class="math">\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0)</span> are
compact and convex, provided they are nonempty. For continuous-time
linear systems,
<span class="math">\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = \underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal X}_0) = {\mathcal X}_{CL}(t, t_0, {\mathcal X}_0)</span>.</p>
<p>Just as for forward reach sets, the backward reach sets can be open-loop
(OLBRS) or closed-loop (CLBRS).</p>
<p>Given the terminal time <span class="math">t_1</span> and target set
<span class="math">{\mathcal Y}_1</span>, the maxmin open-loop backward reach set
<span class="math">\overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)</span> of system
([ctds2]) or [dtds2] at time <span class="math">t<t_1</span>, is the set of all <span class="math">y</span>,
such that for any disturbance <span class="math">v(\tau)\in{\mathcal V}(\tau)</span> there
exists a terminal state <span class="math">y_1\in{\mathcal Y}_1</span> and control
<span class="math">u(\tau)\in{\mathcal U}(\tau)</span>, <span class="math">t\leqslant\tau<t_1</span>, which
steers the system from <span class="math">y(t)=y</span> to <span class="math">y(t_1)=y_1</span>.
[def:sub:<cite>m</cite>axminolbrs]
<span class="math">\overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)</span> is the
subzero level set of the value function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\underline{V}_b(t, y) = \nonumber \\
&amp;&amp;\max_v\min_u\{{\bf dist}(y(t_1), {\mathcal Y}_1) ~|~ y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau&lt;t_1\},
\label{maxminvfb}\end{aligned}\end{split}\]</div>
<p>Given the terminal time <span class="math">t_1</span> and target set
<span class="math">{\mathcal Y}_1</span>, the minmax open-loop backward reach set
<span class="math">\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)</span> of system
([ctds2]) or [dtds2] at time <span class="math">t<t_1</span>, is the set of all <span class="math">y</span>,
such that there exists a control <span class="math">u(\tau)\in{\mathcal U}(\tau)</span>
that for all disturbances <span class="math">v(\tau\in{\mathcal V}(\tau)</span>,
<span class="math">t\leqslant\tau<t_1</span>, assigns a terminal state
<span class="math">y_1\in{\mathcal Y}_1</span> and steers the system from <span class="math">y(t)=y</span>
to <span class="math">y(t_1)=y_1</span>. [def:sub:<cite>m</cite>inmaxolbrs]
<span class="math">\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1)</span> is the
subzero level set of the value function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\overline{V}_b(t, y) = \nonumber \\
&amp;&amp;\min_u\max_v\{{\bf dist}(y(t_1), {\mathcal Y}_1) ~|~ y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau&lt;t_1\},
\label{minmaxvfb}\end{aligned}\end{split}\]</div>
<p><strong>Remark.</strong> The backward reach set can be computed for a continuous-time
system only if the solution of ([ctds2]) exists for <span class="math">t<t_1</span>, and
for a discrete-time system only if the right hand side of [dtds2] is
invertible.</p>
<p>Similarly to the forward reachability case, we construct piecewise OLBRS
with one correction at time <span class="math">\tau_1</span>, <span class="math">t<\tau_1<t_1</span>. The
piecewise maxmin OLBRS with one correction is</p>
<div class="math">
\[\overline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1) = \overline{{\mathcal Y}}_{OL}(\tau_1, t, \overline{{\mathcal Y}}_{OL}(t_1, \tau_1, {\mathcal Y}_1)),
\label{maxminb1}\]</div>
<p>and it is the subzero level set of the function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\underline{V}^1_b(t, y) = \nonumber \\
&amp;&amp;\max_v\min_u\{\underline{V}_b(\tau_1, y(\tau_1)) ~|~
y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau&lt;\tau_1\}.
\label{maxminvfb1}\end{aligned}\end{split}\]</div>
<p>The piecewise minmax OLBRS with one correction is</p>
<div class="math">
\[\underline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{OL}(\tau_1, t, \underline{{\mathcal Y}}_{OL}(t_1, \tau_1, {\mathcal Y}_1)),
\label{minmaxb1}\]</div>
<p>and it is the subzero level set of the function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\overline{V}^1_b(t, y) = \nonumber \\
&amp;&amp;\min_u\max_v\{\overline{V}_b(\tau_1, y(\tau_1)) ~|~
y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau&lt;\tau_1\},
\label{minmaxvfb1}\end{aligned}\end{split}\]</div>
<p>Recursively define maxmin and minmax OLBRS with <span class="math">k</span> corrections
for <span class="math">t<\tau_k<\cdots<\tau_1<t_1</span>. The maxmin OLBRS with <span class="math">k</span>
corrections is</p>
<div class="math">
\[\overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \overline{{\mathcal Y}}_{OL}(\tau_k, t, \overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1)),
\label{maxminbk}\]</div>
<p>which is the subzero level set of function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\underline{V}^k_b(t, y) = \nonumber \\
&amp;&amp;\max_v\min_u\{\underline{V}^{k-1}_b(\tau_k, y(\tau_k)) ~|~
y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau&lt;\tau_k\}.
\label{maxminvfbk}\end{aligned}\end{split}\]</div>
<p>The minmax OLBRS with <span class="math">k</span> corrections is</p>
<div class="math">
\[\underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{OL}(\tau_k, t, \underline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1)),
\label{minmaxbk}\]</div>
<p>which is the subzero level set of the function</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\overline{V}^k_b(t, y) = \nonumber \\
&amp;&amp;\min_u\max_v\{\overline{V}^{k-1}_b(\tau_k, y(\tau_k)) ~|~
y(t)=y, \; u(\tau)\in{\mathcal U}(\tau), \;
v(\tau)\in{\mathcal V}(\tau), \; t\leqslant\tau&lt;\tau_k\},
\label{minmaxvfbk}\end{aligned}\end{split}\]</div>
<p>From ([maxminvfb1]), ([minmaxvfb1]), ([maxminvfbk]) and ([minmaxvfbk])
it follows that</p>
<div class="math">
\[  \underline{V}_b(t, y) \leqslant\underline{V}^1_b(t, y)\leqslant\cdots
  \leqslant\underline{V}^k_b(t, y) \leqslant\overline{V}^k_b(t, y) \leqslant\cdots
  \leqslant\overline{V}^1_b(t, y) \leqslant\overline{V}_b(t, y) .\]\[Hence,\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
&amp;&amp;\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) \subseteq \underline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1) \subseteq \cdots
\subseteq \underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) \subseteq \nonumber \\
&amp;&amp;\overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) \subseteq \cdots \subseteq \overline{{\mathcal Y}}_{OL}^1(t_1, t, {\mathcal Y}_1)
\subseteq \overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) .
\label{olbrsinclusion}\end{aligned}\end{split}\]</div>
<p>We say that</p>
<div class="math">
\[\begin{split}\overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = \overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1), \;\;
k = \left\{\begin{array}{ll}
\infty &amp; \mbox{ for continuous-time system}\\
t_1-t-1 &amp; \mbox{ for discrete-time system}\end{array}\right.
\label{maxminclbrs}\end{split}\]</div>
<p>is the <em>maxmin closed-loop backward reach set</em> of system ([ctds2]) or
[dtds2] at time <span class="math">t</span>.</p>
<p>We say that</p>
<div class="math">
\[\begin{split}\underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1), \;\;
k = \left\{\begin{array}{ll}
\infty &amp; \mbox{ for continuous-time system}\\
t_1-t-1 &amp; \mbox{ for discrete-time system}\end{array}\right.
\label{minmaxclbrs}\end{split}\]</div>
<p>is the <em>minmax closed-loop backward reach set</em> of system ([ctds2]) or
[dtds2] at time <span class="math">t</span>. Given the terminal time <span class="math">t_1</span> and
target set <span class="math">{\mathcal Y}_1</span>, the maxmin CLBRS
<span class="math">\overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)</span> of system
([ctds2]) or [dtds2] at time <span class="math">t<t_1</span>, is the set of all states
<span class="math">y</span>, for each of which for every disturbance
<span class="math">v(\tau)\in{\mathcal V}(\tau)</span> there exists terminal state
<span class="math">y_1\in{\mathcal Y}_1</span> and control
<span class="math">u(\tau, y(\tau))\in{\mathcal U}(\tau)</span> that assigns trajectory
<span class="math">y(\tau, | v(\tau), u(\tau, y(\tau)))</span> satisfying</p>
<div class="math">
\[  \dot{y}(\tau | v(\tau), u(\tau, y(\tau))) \in
  f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))\]\[in continuous-time case, or\]</div>
<div class="math">
\[  y(\tau+1 | v(\tau), u(\tau, y(\tau))) \in
  f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))\]\[\begin{split}in discrete-time case, with :math:`t\leqslant\tau&lt;t_1`, such that\end{split}\]</div>
<p><span class="math">y(t) = y</span> and <span class="math">y(t_1)=y_1</span>. [def:sub:<cite>m</cite>axminclbrs] Given
the terminal time <span class="math">t_1</span> and target set <span class="math">{\mathcal Y}_1</span>, the
minmax CLBRS
<span class="math">\underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)</span> of system
([ctds2]) or [dtds2] at time <span class="math">t<t_1</span>, is the set of all states
<span class="math">y</span>, for each of which there exists control
<span class="math">u(\tau, y(\tau))\in{\mathcal U}(\tau)</span> that for every disturbance
<span class="math">v(\tau)\in{\mathcal V}(\tau)</span> assigns terminal state
<span class="math">y_1\in{\mathcal Y}_1</span> and trajectory
<span class="math">y(\tau, v(\tau) | u(\tau, y(\tau)))</span> satisfying</p>
<div class="math">
\[  \dot{y}(\tau, v(\tau) | u(\tau, y(\tau))) \in
  f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))\]\[in the continuous-time case, or\]</div>
<div class="math">
\[  y(\tau+1, v(\tau) | u(\tau, y(\tau))) \in
  f(\tau, y(\tau), u(\tau, y(\tau)), v(\tau))\]\[\begin{split}in the discrete-time case, with :math:`t\leqslant\tau&lt;t_1`, such that\end{split}\]</div>
<p><span class="math">y(t) = y</span> and <span class="math">y(t_1)=y_1</span>. [def:sub:<cite>m</cite>inmaxclbrs] Both
maxmin and minmax CLBRS satisfy the semigroup property
([semigroup:sub:<cite>b</cite>]).</p>
<p>The maxmin OLBRS for the continuous-time linear system can be expressed
through set valued integrals,</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, t_1){\mathcal Y}_1 \oplus
\int_{t_1}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
\int_{t}^{t_1}\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau,
\end{array}
\label{ctlsmaxminb}\end{split}\]</div>
<p>and for the discrete-time linear system through set-valued sums,</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, t_1){\mathcal Y}_1 \oplus
\sum_{\tau=t}^{t_1-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
\sum_{\tau=t}^{t_1-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau).
\end{array}
\tag*{(\ref{ctlsmaxminb}d)}
\label{dtlsmaxminb}\end{split}\]</div>
<p>Similarly, the minmax OLBRS for the continuous-time linear system is</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, t_1){\mathcal Y}_1 \dot{-}
\int_{t}^{t_1}\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau\right)
\oplus \\
\int_{t_1}^{t}\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
\end{array}
\label{ctlsminmaxb}\end{split}\]</div>
<p>and for the discrete-time linear system it is</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal Y}}_{OL}(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, t_1){\mathcal Y}_1 \dot{-}
\sum_{\tau=t}^{t_1-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau)\right)
\oplus \\
\sum_{\tau=t}^{t_1-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
\end{array}
\tag*{(\ref{ctlsminmaxb}d)}
\label{dtlsminmaxb}\end{split}\]</div>
<p>Now consider piecewise OLBRS with <span class="math">k</span> corrections. Expression
([maxminbk]) translates into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \oplus
\int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau\right) \dot{-} \\
\int^{\tau_k}_t\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau,
\end{array}
\label{ctlsmaxminbk}\end{split}\]</div>
<p>in the continuous-time case, and for the discrete-time case into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\overline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \oplus
\sum_{\tau=t}^{\tau_k-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau)\right) \dot{-} \\
\sum_{\tau=t}^{\tau_k-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau).
\end{array}
\tag*{(\ref{ctlsmaxminbk}d)}
\label{dtlsmaxminbk}\end{split}\]</div>
<p>Expression ([minmaxbk]) translates into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \dot{-}
\int^{\tau_k}_t\Phi(t, \tau)G(\tau){\mathcal V}(\tau)d\tau\right)
\oplus \\
\int_{\tau_k}^t\Phi(t, \tau)B(\tau){\mathcal U}(\tau)d\tau,
\end{array}
\label{ctlsminmaxbk}\end{split}\]</div>
<p>in the continuous-time case, and for the discrete-time case into</p>
<div class="math">
\[\begin{split}\begin{array}{l}
\underline{{\mathcal Y}}_{OL}^k(t_1, t, {\mathcal Y}_1) = \\
\left(\Phi(t, \tau_k)\overline{{\mathcal Y}}_{OL}^{k-1}(t_1, \tau_k, {\mathcal Y}_1) \dot{-}
\sum_{\tau=t}^{\tau_k-1}\Phi(t, \tau+1)G(\tau){\mathcal V}(\tau)\right)
\oplus \\
\sum_{\tau=t}^{\tau_k-1}-\Phi(t, \tau+1)B(\tau){\mathcal U}(\tau).
\end{array}
\tag*{(\ref{ctlsminmaxk}d)}
\label{dtlsminmaxbk}\end{split}\]</div>
<p>For continuous-time linear systems
<span class="math">\overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = \underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1) = {\mathcal Y}_{CL}(t_1, t, {\mathcal Y}_1)</span>
under the condition that the target set <span class="math">{\mathcal Y}_1</span> is large
enough to ensure that
<span class="math">\underline{{\mathcal Y}}_{CL}(t_1, t_1-\epsilon, {\mathcal Y}_1)</span>
is nonempty for some small <span class="math">\epsilon>0</span>.</p>
<p>Computation of backward reach sets for discrete-time linear systems
makes sense only if the state transition matrix <span class="math">\Phi(t_1, t)</span> is
invertible.</p>
<p>If the target set <span class="math">{\mathcal Y}_1</span>, control sets
<span class="math">{\mathcal U}(\tau)</span> and disturbance sets
<span class="math">{\mathcal V}(\tau)</span>, <span class="math">t\leqslant\tau<t_1</span>, are compact and
convex, then CLBRS
<span class="math">\overline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)</span> and
<span class="math">\underline{{\mathcal Y}}_{CL}(t_1, t, {\mathcal Y}_1)</span> are
compact and convex, if they are nonempty.</p>
</div>
<div class="section" id="reachability-problem">
<h3>Reachability problem<a class="headerlink" href="#reachability-problem" title="Permalink to this headline">¶</a></h3>
<p>Reachability analysis is concerned with the computation of the forward
<span class="math">{\mathcal X}(t, t_0, {\mathcal X}_0)</span> and backward
<span class="math">{\mathcal Y}(t_1, t, {\mathcal Y}_1)</span> reach sets (the reach sets
may be maxmin or minmax) in a way that can effectively meet requests
like the following:</p>
<ol class="arabic">
<li><p class="first">For the given time interval <span class="math">[t_0, t]</span>, determine whether the
system can be steered into the given target set
<span class="math">{\mathcal Y}_1</span>. In other words, is the set
<span class="math">{\mathcal Y}_1\cap\bigcup_{t_0 \leqslant\tau\leqslantt}{\mathcal X}(\tau, t_0, {\mathcal X}_0)</span>
nonempty? And if the answer is ‘yes’, find a control that steers the
system to the target set (or avoids the target set). <a class="footnote-reference" href="#id20" id="id8">[8]</a></p>
</li>
<li><p class="first">If the target set <span class="math">{\mathcal Y}_1</span> is reachable from the given
initial condition <span class="math">\{t_0, {\mathcal X}_0\}</span> in the time
interval <span class="math">[t_0, t]</span>, find the shortest time to reach
<span class="math">{\mathcal Y}_1</span>,</p>
<div class="math">
\[\arg\min_{\tau}
\{{\mathcal X}(\tau,t_0,{\mathcal X}_0)\cap{\mathcal Y}_1\neq\emptyset ~|~ t_0\leqslant\tau\leqslantt\}.\]</div>
</li>
<li><p class="first">Given the terminal time <span class="math">t_1</span>, target set
<span class="math">{\mathcal Y}_1</span> and time <span class="math">t<t_1</span> find the set of states
starting at time <span class="math">t</span> from which the system can reach
<span class="math">{\mathcal Y}_1</span> within time interval <span class="math">[t, t_1]</span>. In
other words, find
<span class="math">\bigcup_{t\leqslant\tau<t_1}{\mathcal Y}(t_1, \tau, {\mathcal Y}_1)</span>.</p>
</li>
<li><p class="first">Find a closed-loop control that steers a system with disturbances to
the given target set in given time.</p>
</li>
<li><p class="first">Graphically display the projection of the reach set along any
specified two- or three-dimensional subspace.</p>
</li>
</ol>
<p>For linear systems, if the initial set <span class="math">{\mathcal X}_0</span>, target
set <span class="math">{\mathcal Y}_1</span>, control bounds <span class="math">{\mathcal U}(\cdot)</span>
and disturbance bounds <span class="math">{\mathcal V}(\cdot)</span> are compact and
convex, so are the forward <span class="math">{\mathcal X}(t, t_0, {\mathcal X}_0)</span>
and backward <span class="math">{\mathcal Y}(t_1, t, {\mathcal Y}_1)</span> reach sets.
Hence reachability analysis requires the computationally effective
manipulation of convex sets, and performing the set-valued operations of
unions, intersections, geometric sums and differences.</p>
<p>Existing reach set computation tools can deal reliably only with linear
systems with convex constraints. A claim that certain tool or method can
be used <em>effectively</em> for nonlinear systems must be treated with
caution, and the first question to ask is for what class of nonlinear
systems and with what limit on the state space dimension does this tool
work? Some “reachability methods for nonlinear systems” reduce to the
local linearization of a system followed by the use of well-tested
techniques for linear system reach set computation. Thus these
approaches in fact use reachability methods for linear systems.</p>
</div>
</div>
<div class="section" id="ellipsoidal-method">
<h2>Ellipsoidal Method<a class="headerlink" href="#ellipsoidal-method" title="Permalink to this headline">¶</a></h2>
<div class="section" id="continuous-time-systems">
<h3>Continuous-time systems<a class="headerlink" href="#continuous-time-systems" title="Permalink to this headline">¶</a></h3>
<p>Consider the system</p>
<div class="math">
\[\dot{x}(t) = A(t)x(t) + B(t)u + G(t)v, \label{ctsystem}\]</div>
<p>in which <span class="math">x\in{\bf R}^n</span> is the state, <span class="math">u\in{\bf R}^m</span> is
the control and <span class="math">v\in{\bf R}^d</span> is the disturbance. <span class="math">A(t)</span>,
<span class="math">B(t)</span> and <span class="math">G(t)</span> are continuous and take their values in
<span class="math">{\bf R}^{n\times n}</span>, <span class="math">{\bf R}^{n\times m}</span> and
<span class="math">{\bf R}^{n\times d}</span> respectively. Control <span class="math">u(t,x(t))</span> and
disturbance <span class="math">v(t)</span> are measurable functions restricted by
ellipsoidal constraints: <span class="math">u(t,x(t)) \in {\mathcal E}(p(t), P(t))</span>
and <span class="math">v(t) \in {\mathcal E}(q(t), Q(t))</span>. The set of initial states
at initial time <span class="math">t_0</span> is assumed to be the ellipsoid
<span class="math">{\mathcal E}(x_0,X_0)</span>.</p>
<p>The reach sets for systems with disturbances computed by the Ellipsoidal
Toolbox are CLRS. Henceforth, when describing backward reachability,
reach sets refer to CLRS or CLBRS. Recall that for continuous-time
linear systems maxmin and minmax CLRS coincide, and the same is true for
maxmin and minmax CLBRS.</p>
<p>If the matrix <span class="math">Q(\cdot)=0</span>, the system ([ctsystem]) becomes an
ordinary affine system with known <span class="math">v(\cdot)=q(\cdot)</span>. If
<span class="math">G(\cdot) = 0</span>, the system becomes linear. For these two cases
(<span class="math">Q(\cdot)=0</span> or <span class="math">G(\cdot)=0</span>) the reach set is as given in
Definition [def:sub:<cite>o</cite>lrs], and so the reach set will be denoted as
<span class="math">{\mathcal X}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)) = {\mathcal X}(t, t_0, {\mathcal E}(x_0,X_0))</span>.</p>
<p>The reach set <span class="math">{\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0))</span> is a
symmetric compact convex set, whose center evolves in time according to</p>
<div class="math">
\[\dot{x}_c(t) = A(t)x_c(t) + B(t)p(t) + G(t)q(t), \;\;\;
x_c(t_0)=x_0. \label{fwdcenter}\]</div>
<p>Fix a vector <span class="math">l_0\in{\bf R}^n</span>, and consider the solution
<span class="math">l(t)</span> of the adjoint equation</p>
<div class="math">
\[\dot{l}(t) = -A^T(t)l(t), \;\;\; l(t_0) = l_0,
\label{adjointct}\]</div>
<p>which is equivalent to</p>
<div class="math">
\[l(t) = \Phi^T(t_0, t)l_0.\]\[If the reach set :math:`{\mathcal X}(t, t_0, {\mathcal E}(x_0,X_0))` is\]</div>
<p>nonempty, there exist tight external and tight internal approximating
ellipsoids <span class="math">{\mathcal E}(x_c(t), X^+_l(t))</span> and
<span class="math">{\mathcal E}(x_c(t), X^-_l(t))</span>, respectively, such that</p>
<div class="math">
\[{\mathcal E}(x_c(t), X^-_l(t))\subseteq{\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0))
\subseteq {\mathcal E}(x_c(t), X^+_l(t)),
\label{fwdinclusion}\]</div>
<p>and</p>
<div class="math">
\[\rho(l(t) ~|~ {\mathcal E}(x_c(t), X^-_l(t))) =
\rho(l(t) ~|~ {\mathcal X}(t, t_0, {\mathcal E}(x_0,X_0))) =
\rho(l(t) ~|~ {\mathcal E}(x_c(t), X^+_l(t))) .
\label{fwdtightness}\]</div>
<p>The equation for the shape matrix of the external ellipsoid is</p>
<div class="math">
\[\begin{split}\begin{aligned}
\dot{X}^+_l(t) &amp; = &amp; A(t)X^+_l(t) + X^+_l(t)A^T(t) +\nonumber \\
&amp; &amp; \pi_l(t)X^+_l(t) + \frac{1}{\pi_l(t)}B(t)P(t)B^T(t) -\nonumber \\
&amp; &amp; (X_l^{+}(t))^{1/2}S_l(t)(G(t)Q(t)G^T(t))^{1/2} \nonumber -\\
&amp; &amp; (G(t)Q(t)G^T(t))^{1/2}S_l^T(t)(X_l^{+}(t))^{1/2}, \label{fwdext1} \\
X^+_l(t_0) &amp; = &amp; X_0, \label{fwdext2}\end{aligned}\end{split}\]</div>
<p>in which</p>
<div class="math">
\[  \pi_l(t) = \frac{\langle l(t),
  B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t), X^+_l(t)l(t)\rangle^{1/2}},\]\[and the orthogonal matrix :math:`S_l(t)` (:math:`S_l(t)S_l^T(t) = I`)\]</div>
<p>is determined by the equation</p>
<div class="math">
\[  S_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t) = \frac{\langle l(t),
  G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t),
  X_l^+(t)l(t)\rangle^{1/2}}(X_l^{+}(t))^{1/2}l(t).\]\[In the presence of disturbance, if the reach set is empty, the matrix\]</div>
<p><span class="math">X^+_l(t)</span> becomes sign indefinite. For a system without
disturbance, the terms containing <span class="math">G(t)</span> and <span class="math">Q(t)</span> vanish
from the equation ([fwdext1]).</p>
<p>The equation for the shape matrix of the internal ellipsoid is</p>
<div class="math">
\[\begin{split}\begin{aligned}
\dot{X}^-_l(t) &amp; = &amp; A(t)X^-_l(t) + X^-_l(t)A^T(t) +\nonumber \\
&amp; &amp; (X_l^{-}(t))^{1/2}T_l(t)(B(t)P(t)B^T(t))^{1/2} +\nonumber \\
&amp; &amp; (B(t)P(t)B^T(t))^{1/2}T_l^T(t)(X_l^{-}(t))^{1/2} -\nonumber \\
&amp; &amp; \eta_l(t)X^-_l(t) - \frac{1}{\eta_l(t)}G(t)Q(t)G^T(t), \label{fwdint1} \\
X^-_l(t_0) &amp; = &amp; X_0, \label{fwdint2}\end{aligned}\end{split}\]</div>
<p>in which</p>
<div class="math">
\[  \eta_l(t) = \frac{\langle l(t),
  G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t), X^+_l(t)l(t)\rangle^{1/2}},\]\[and the orthogonal matrix :math:`T_l(t)` is determined by the equation\]</div>
<div class="math">
\[  T_l(t)(B(t)P(t)B^T(t))^{1/2}l(t) = \frac{\langle l(t),
  B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t),
  X_l^-(t)l(t)\rangle^{1/2}}(X_l^{-}(t))^{1/2}l(t).\]\[Similarly to the external case, the terms containing :math:`G(t)` and\]</div>
<p><span class="math">Q(t)</span> vanish from the equation ([fwdint1]) for a system without
disturbance.</p>
<p>The point where the external and internal ellipsoids touch the boundary
of the reach set is given by</p>
<div class="math">
\[  x_l^*(t) = x_c(t) +
  \frac{X^+_l(t)l(t)}{\langle l(t), X^+_l(t)l(t)\rangle^{1/2}} .\]\[The boundary points :math:`x^*_l(t)` form trajectories, which we call\]</div>
<p><em>extremal trajectories</em>. Due to the nonsingular nature of the state
transition matrix <span class="math">\Phi(t,t_0)</span>, every boundary point of the reach
set belongs to an extremal trajectory. To follow an extremal trajectory
specified by parameter <span class="math">l_0</span>, the system has to start at time
<span class="math">t_0</span> at initial state</p>
<div class="math">
\[x^0_l = x_0 + \frac{X_0l_0}{\langle l_0,X_0l_0\rangle^{1/2}}. \label{x0lct}\]</div>
<p>In the absence of disturbances, the open-loop control</p>
<div class="math">
\[u_l(t) = p(t) + \frac{P(t)B^T(t)l(t)}{\langle l(t),
B(t)P(t)B^T(t)l(t)\rangle^{1/2}}. \label{uct}\]</div>
<p>steers the system along the extremal trajectory defined by the vector
<span class="math">l_0</span>. When a disturbance is present, this control keeps the
system on an extremal trajectory if and only if the disturbance plays
against the control always taking its extreme values.</p>
<p>Expressions ([fwdinclusion]) and ([fwdtightness]) lead to the following
fact,</p>
<div class="math">
\[  \bigcup_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),X^-_l(t)) =
  {\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0)) =
  \bigcap_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),X^+_l(t)).\]\[In practice this means that the more values of :math:`l_0` we use to\]</div>
<p>compute <span class="math">X^+_l(t)</span> and <span class="math">X^-_l(t)</span>, the better will be our
approximation.</p>
<p>Analogous results hold for the backward reach set.</p>
<p>Given the terminal time <span class="math">t_1</span> and ellipsoidal target set
<span class="math">{\mathcal E}_(y_1,Y_1)</span>, the CLBRS
<span class="math">{\mathcal Y}_{CL}(t_1, t, {\mathcal Y}_1)={\mathcal Y}(t_1, t, {\mathcal Y}_1)</span>,
<span class="math">t<t_1</span>, if it is nonempty, is a symmetric compact convex set
whose center is governed by</p>
<div class="math">
\[y_c(t) = Ay_c(t) + B(t)p(t) + G(t)q(t), \;\;\; y_c(t_1) = y_1.\label{bckcenter}\]</div>
<p>Fix a vector <span class="math">l_1\in{\bf R}^n</span>, and consider</p>
<div class="math">
\[l(t) = \Phi(t_1, t)^Tl_1 .
\label{bckadjoint}\]</div>
<p>If the backward reach set
<span class="math">{\mathcal Y}(t_1, t, {\mathcal E}(y_1,Y_1))</span> is nonempty, there
exist tight external and tight internal approximating ellipsoids
<span class="math">{\mathcal E}(y_c(t), Y^+_l(t))</span> and
<span class="math">{\mathcal E}(y_c(t), Y^-_l(t))</span> respectively, such that</p>
<div class="math">
\[{\mathcal E}(y_c(t), Y^-_l(t))\subseteq{\mathcal Y}(t_1,t,{\mathcal E}(y_1,Y_1))
\subseteq {\mathcal E}(y_c(t), Y^+_l(t)),
\label{bckinclusion}\]</div>
<p>and</p>
<div class="math">
\[\rho(l(t) ~|~ {\mathcal E}(y_c(t), Y^-_l(t))) =
\rho(l(t) ~|~ {\mathcal Y}(t_1, t, {\mathcal E}(y_0,Y_0))) =
\rho(l(t) ~|~ {\mathcal E}(y_c(t), Y^+_l(t))) .
\label{bcktightness}\]</div>
<p>The equation for the shape matrix of the external ellipsoid is</p>
<div class="math">
\[\begin{split}\begin{aligned}
\dot{Y}^+_l(t) &amp; = &amp; A(t)Y^+_l(t) + Y^+_l(t)A^T(t) -\nonumber \\
&amp; &amp; \pi_l(t)Y^+_l(t) - \frac{1}{\pi_l(t)}B(t)P(t)B^T(t) +\nonumber \\
&amp; &amp; (Y_l^{+}(t))^{1/2}S_l(t)(G(t)Q(t)G^T(t))^{1/2} +\nonumber \\
&amp; &amp; (G(t)Q(t)G^T(t))^{1/2}S_l^T(t)(Y_l^{+}(t))^{1/2}, \label{bckext1} \\
Y^+_l(t_1) &amp; = &amp; Y_1, \label{bckext2}\end{aligned}\end{split}\]</div>
<p>in which</p>
<div class="math">
\[  \pi_l(t) = \frac{\langle l(t),
  B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t),
  Y^+_l(t)l(t)\rangle^{1/2}},\]\[and the orthogonal matrix :math:`S_l(t)` satisfies the equation\]</div>
<div class="math">
\[  S_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t) = \frac{\langle l(t),
  G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t),
  Y_l^+(t)l(t)\rangle^{1/2}}(Y_l^{+}(t))^{1/2}l(t).\]\[The equation for the shape matrix of the internal ellipsoid is\]</div>
<div class="math">
\[\begin{split}\begin{aligned}
\dot{Y}^-_l(t) &amp; = &amp; A(t)Y^-_l(t) + Y^-_l(t)A^T(t) -\nonumber \\
&amp; &amp; (Y_l^{-}(t))^{1/2}T_l(t)(B(t)P(t)B^T(t))^{1/2} -\nonumber \\
&amp; &amp; (B(t)P(t)B^T(t))^{1/2}T_l^T(t)(Y_l^{-}(t))^{1/2} +\nonumber \\
&amp; &amp; \eta_l(t)Y^-_l(t) + \frac{1}{\eta_l(t)}G(t)Q(t)G^T(t), \label{bckint1} \\
Y^-_l(t_1) &amp; = &amp; Y_1, \label{bckint2}\end{aligned}\end{split}\]</div>
<p>in which</p>
<div class="math">
\[  \eta_l(t) = \frac{\langle l(t),
  G(t)Q(t)G^T(t)l(t)\rangle^{1/2}}{\langle l(t),
  Y^+_l(t)l(t)\rangle^{1/2}},\]\[and the orthogonal matrix :math:`T_l(t)` is determined by the equation\]</div>
<div class="math">
\[  T_l(t)(B(t)P(t)B^T(t))^{1/2}l(t) = \frac{\langle l(t),
  B(t)P(t)B^T(t)l(t)\rangle^{1/2}}{\langle l(t),
  Y_l^-(t)l(t)\rangle^{1/2}}(Y_l^{-}(t))^{1/2}l(t).\]\[Just as in the forward reachability case, the terms containing\]</div>
<p><span class="math">G(t)</span> and <span class="math">Q(t)</span> vanish from equations ([bckext1]) and
([bckint1]) in the absence of disturbances. The boundary value problems
([bckcenter]), ([bckext1]) and ([bckint1]) are converted to the initial
value problems by the change of variables <span class="math">s = -t</span>.</p>
<p>Due to ([bckinclusion]) and ([bcktightness]),</p>
<div class="math">
\[\bigcup_{\langle l_1,l_1\rangle=1}{\mathcal E}(y_c(t),Y^-_l(t)) =
{\mathcal Y}(t_1,t,{\mathcal E}(y_1,Y_1)) =
\bigcap_{\langle l_1,l_1\rangle=1}{\mathcal E}(y_c(t),Y^+_l(t)).\]</div>
<p><strong>Remark.</strong> In expressions ([fwdext1]), ([fwdint1]), ([bckext1]) and
([bckint1]) the terms <span class="math">\frac{1}{\pi_l(t)}</span> and
<span class="math">\frac{1}{\eta_l(t)}</span> may not be well defined for some vectors
<span class="math">l</span>, because matrices <span class="math">B(t)P(t)B^T(t)</span> and
<span class="math">G(t)Q(t)G^T(t)</span> may be singular. In such cases, we set these
entire expressions to zero.</p>
</div>
<div class="section" id="discrete-time-systems">
<h3>Discrete-time systems<a class="headerlink" href="#discrete-time-systems" title="Permalink to this headline">¶</a></h3>
<p>Consider the discrete-time linear system,</p>
<div class="math">
\[x(t+1) = A(t)x(t) + B(t)u(t,x(t)) + G(t)v(t),
\tag*{(\ref{ctsystem})}
\label{dtsystem}\]</div>
<p>in which <span class="math">x(t)\in{\bf R}^n</span> is the state,
<span class="math">u(t, x(t))\in{\bf R}^m</span> is the control bounded by the ellipsoid
<span class="math">{\mathcal E}(p(t),P(t))</span>, <span class="math">v(t)\in{\bf R}^d</span> is disturbance
bounded by ellipsoid <span class="math">{\mathcal E}(q(t),Q(t))</span>, and matrices
<span class="math">A(t)</span>, <span class="math">B(t)</span>, <span class="math">G(t)</span> are in
<span class="math">{\bf R}^{n\times n}</span>, <span class="math">{\bf R}^{n\times m}</span>,
<span class="math">{\bf R}^{n\times d}</span> respectively. Here we shall assume
<span class="math">A(t)</span> to be nonsingular. <a class="footnote-reference" href="#id21" id="id9">[9]</a> The set of initial conditions at
initial time <span class="math">t_0</span> is ellipsoid <span class="math">{\mathcal E}(x_0,X_0)</span>.</p>
<p>Ellipsoidal Toolbox computes maxmin and minmax CLRS
<span class="math">\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)</span> and
<span class="math">\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)</span> for
discrete-time systems.</p>
<p>If matrix <span class="math">Q(\cdot)=0</span>, the system ([dtsystem]) becomes an
ordinary affine system with known <span class="math">v(\cdot)=q(\cdot)</span>. If matrix
<span class="math">G(\cdot)=0</span>, the system reduces to a linear controlled system. In
the absence of disturbance (<span class="math">Q(\cdot)=0</span> or <span class="math">G(\cdot)=0</span>),
<span class="math">\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))=\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))={\mathcal X}(t,t_0,{\mathcal E}(x_0,X_0))</span>,
the reach set is as in Definition [def:sub:<cite>o</cite>lrs].</p>
<p>Maxmin and minmax CLRS
<span class="math">\overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)</span> and
<span class="math">\underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0, X_0)</span>, if
nonempty, are symmetric convex and compact, with the center evolving in
time according to</p>
<div class="math">
\[x_c(t+1) = A(t)x_c(t) + B(t)p(t) + G(t)v(t), \;\;\; x_c(t_0)=x_0.
\label{fwdcenterd}\]</div>
<p>Fix some vector <span class="math">l_0\in{\bf R}^n</span> and consider <span class="math">l(t)</span> that
satisfies the discrete-time adjoint equation, <a class="footnote-reference" href="#id22" id="id10">[10]</a></p>
<div class="math">
\[l(t+1) = \left(A^T\right)^{-1}(t)l(t), \;\;\; l(t_0) = l_0,
\label{adjointdt}\]</div>
<p>or, equivalently</p>
<div class="math">
\[l(t) = \Phi^T(t_0, t)l_0 .\]\[There exist tight external ellipsoids\]</div>
<p><span class="math">{\mathcal E}(x_c(t), \overline{X}^+_l(t))</span>,
<span class="math">{\mathcal E}(x_c(t), \underline{X}^+_l(t))</span> and tight internal
ellipsoids <span class="math">{\mathcal E}(x_c(t), \overline{X}^-_l(t))</span>,
<span class="math">{\mathcal E}(x_c(t), \underline{X}^-_l(t))</span> such that</p>
<div class="math">
\[{\mathcal E}(x_c(t), \overline{X}^-_l(t))\subseteq\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))
\subseteq {\mathcal E}(x_c(t), \overline{X}^+_l(t)),
\label{maxmininclusion}\]</div>
<div class="math">
\[\rho(l(t) ~|~ {\mathcal E}(x_c(t), \overline{X}^-_l(t))) =
\rho(l(t) ~|~ \overline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0,X_0))) =
\rho(l(t) ~|~ {\mathcal E}(x_c(t), \overline{X}^+_l(t))) .
\label{maxmintightness}\]</div>
<p>and</p>
<div class="math">
\[{\mathcal E}(x_c(t), \underline{X}^-_l(t))\subseteq\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))
\subseteq {\mathcal E}(x_c(t), \underline{X}^+_l(t)),
\label{minmaxinclusion}\]</div>
<div class="math">
\[\rho(l(t) ~|~ {\mathcal E}(x_c(t), \underline{X}^-_l(t))) =
\rho(l(t) ~|~ \underline{{\mathcal X}}_{CL}(t, t_0, {\mathcal E}(x_0,X_0))) =
\rho(l(t) ~|~ {\mathcal E}(x_c(t), \underline{X}^+_l(t))) .
\label{minmaxtightness}\]</div>
<p>The shape matrix of the external ellipsoid for maxmin reach set is
determined from</p>
<div class="math">
\[\begin{split}\begin{aligned}
\hat{X}^+_l(t) &amp; = &amp; (1+\overline{\pi}_l(t))A(t)\overline{X}^+_l(t)A^T(t) +
\left(1+\frac{1}{\overline{\pi}_l(t)}\right)
B(t)P(t)B^T(t), \label{fwdextmaxmin1} \\
\overline{X}^+_l(t+1) &amp; = &amp; \left((\hat{X}^+_l(t))^{1/2} +
\overline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right)^T
\times \nonumber \\
&amp; &amp;\left((\hat{X}^+_l(t))^{1/2} + \overline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right),
\label{fwdextmaxmin2}\\
\overline{X}^+_l(t_0) &amp; = &amp; X_0, \label{fwdextmaxmin3}\end{aligned}\end{split}\]</div>
<p>wherein</p>
<div class="math">
\[  \overline{\pi}_l(t) = \frac{\langle l(t+1),
  B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
  \overline{X}^+_l(t)l(t)\rangle^{1/2}},\]\[and the orthogonal matrix :math:`\overline{S}_l(t)` is determined by\]</div>
<p>the equation</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp; &amp; \overline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t+1) = \\
&amp; &amp; \frac{\langle l(t+1),
G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
\hat{X}^+_l(t)l(t+1)\rangle^{1/2}}(\hat{X}^+_l(t))^{1/2}l(t+1).\end{aligned}\end{split}\]</div>
<p>Equation ([fwdextmaxmin2]) is valid only if
<span class="math">{\mathcal E}(0,G(t)Q(t)G^T(t))\subseteq{\mathcal E}(0,\hat{X}^+_l(t))</span>,
otherwise the maxmin CLRS
<span class="math">\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))</span> is
empty.</p>
<p>The shape matrix of the external ellipsoid for minmax reach set is
determined from</p>
<div class="math">
\[\begin{split}\begin{aligned}
\breve{X}^+_l(t) &amp; = &amp;
\left((A(t)\underline{X}^+_l(t)A^T(t))^{1/2} +
\underline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right)^T
\times \nonumber \\
&amp; &amp;\left((A(t)\underline{X}^+_l(t)A^T(t))^{1/2} +
\underline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}\right)
\label{fwdextminmax1}\\
\underline{X}^+_l(t+1) &amp; = &amp;
(1+\underline{\pi}_l(t))\breve{X}^+_l(t) +
\left(1+\frac{1}{\underline{\pi}_l(t)}\right)
B(t)P(t)B^T(t), \label{fwdextminmax2} \\
\underline{X}^+_l(t_0) &amp; = &amp; X_0, \label{fwdextminmax3}\end{aligned}\end{split}\]</div>
<p>where</p>
<div class="math">
\[  \underline{\pi}_l(t) = \frac{\langle l(t+1),
  B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
  \breve{X}^+_l(t)l(t+1)\rangle^{1/2}},\]\[and :math:`\underline{S}_l(t)` is orthogonal matrix determined from the\]</div>
<p>equation</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp; &amp; \underline{S}_l(t)(G(t)Q(t)G^T(t))^{1/2}l(t+1) = \\
&amp; &amp; \frac{\langle l(t+1),
G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
\underline{X}^+_l(t)l(t)\rangle^{1/2}}(A(t)\underline{X}^+_l(t)A^T(t))^{1/2}l(t+1).\end{aligned}\end{split}\]</div>
<p>Equations ([fwdextminmax1]), ([fwdextminmax2]) are valid only if
<span class="math">{\mathcal E}(0,G(t)Q(t)G^T(t)\subseteq{\mathcal E}(0,A(t)\underline{X}^+_l(t)A^T(t))</span>,
otherwise minmax CLRS
<span class="math">\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))</span> is
empty.</p>
<p>The shape matrix of the internal ellipsoid for maxmin reach set is
determined from</p>
<div class="math">
\[\begin{split}\begin{aligned}
\hat{X}^-_l(t) &amp; = &amp;
\left((A(t)\overline{X}^-_l(t)A^T(t))^{1/2} +
\overline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right)^T
\times \nonumber \\
&amp; &amp;\left((A(t)\overline{X}^-_l(t)A^T(t))^{1/2} +
\overline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right)
\label{fwdintmaxmin1}\\
\overline{X}^-_l(t+1) &amp; = &amp;
(1+\overline{\eta}_l(t))\hat{X}^-_l(t) +
\left(1+\frac{1}{\underline{\eta}_l(t)}\right)
G(t)Q(t)G^T(t), \label{fwdintmaxmin2} \\
\overline{X}^-_l(t_0) &amp; = &amp; X_0, \label{fwdintmaxmin3}\end{aligned}\end{split}\]</div>
<p>where</p>
<div class="math">
\[  \overline{\eta}_l(t) = \frac{\langle l(t+1),
  G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
  \hat{X}^-_l(t)l(t+1)\rangle^{1/2}},\]\[and :math:`\overline{T}_l(t)` is orthogonal matrix determined from the\]</div>
<p>equation</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp; &amp; \overline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}l(t+1) = \\
&amp; &amp; \frac{\langle l(t+1),
B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
\overline{X}^-_l(t)l(t)\rangle^{1/2}}(A(t)\overline{X}^-_l(t)A^T(t))^{1/2}l(t+1).\end{aligned}\end{split}\]</div>
<p>Equation ([fwdintmaxmin2]) is valid only if
<span class="math">{\mathcal E}(0,G(t)Q(t)G^T(t)\subseteq{\mathcal E}(0,\hat{X}^-_l(t))</span>.</p>
<p>The shape matrix of the internal ellipsoid for the minmax reach set is
determined by</p>
<div class="math">
\[\begin{split}\begin{aligned}
\breve{X}^-_l(t) &amp; = &amp; (1+\underline{\eta}_l(t))A(t)\underline{X}^-_l(t)A^T(t) +
\left(1+\frac{1}{\underline{\eta}_l(t)}\right)
G(t)Q(t)G^T(t), \label{fwdintminmax1} \\
\underline{X}^-_l(t+1) &amp; = &amp; \left((\breve{X}^-_l(t))^{1/2} +
\underline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right)^T
\times \nonumber \\
&amp; &amp;\left((\breve{X}^-_l(t))^{1/2} + \underline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}\right),
\label{fwdintminmax2}\\
\underline{X}^-_l(t_0) &amp; = &amp; X_0, \label{fwdintminmax3}\end{aligned}\end{split}\]</div>
<p>wherein</p>
<div class="math">
\[  \underline{\eta}_l(t) = \frac{\langle l(t+1),
  G(t)Q(t)G^T(t)l(t+1)\rangle^{1/2}}{\langle l(t),
  \underline{X}^-_l(t)l(t)\rangle^{1/2}},\]\[and the orthogonal matrix :math:`\underline{T}_l(t)` is determined by\]</div>
<p>the equation</p>
<div class="math">
\[\begin{split}\begin{aligned}
&amp; &amp; \underline{T}_l(t)(B(t)P(t)B^T(t))^{1/2}l(t+1) = \\
&amp; &amp; \frac{\langle l(t+1),
B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}{\langle l(t+1),
\breve{X}^-_l(t)l(t+1)\rangle^{1/2}}(\breve{X}^-_l(t))^{1/2}l(t+1).\end{aligned}\end{split}\]</div>
<p>Equations ([fwdintminmax1]), ([fwdintminmax2]) are valid only if
<span class="math">{\mathcal E}(0,G(t)Q(t)G^T(t)\subseteq{\mathcal E}(0,A(t)\underline{X}^-_l(t)A^T(t))</span>.</p>
<p>The point where the external and the internal ellipsoids both touch the
boundary of the maxmin CLRS is</p>
<div class="math">
\[  x_l^+(t) = x_c(t) + \frac{\overline{X}^+_l(t)l(t)}{\langle l(t),
  \overline{X}^+_l(t)l(t)\rangle^{1/2}} ,\]\[and the bounday point of minmax CLRS is\]</div>
<div class="math">
\[  x_l^-(t) = x_c(t) + \frac{\overline{X}^-_l(t)l(t)}{\langle l(t),
  \overline{X}^-_l(t)l(t)\rangle^{1/2}} .\]\[Points :math:`x^{\pm}_l(t)`, :math:`t\geqslantt_0`, form extremal\]</div>
<p>trajectories. In order for the system to follow the extremal trajectory
specified by some vector <span class="math">l_0</span>, the initial state must be</p>
<div class="math">
\[x_l^0 = x_0 + \frac{X_0l_0}{\langle l_0, X_0l_0\rangle^{1/2}}. \label{dx0l}\]</div>
<p>When there is no disturbance (<span class="math">G(t)=0</span> or <span class="math">Q(t)=0</span>),
<span class="math">\overline{X}^+_l(t)=\underline{X}^+_l(t)</span> and
<span class="math">\overline{X}^-_l(t)=\underline{X}^-_l(t)</span>, and the open-loop
control that steers the system along the extremal trajectory defined by
<span class="math">l_0</span> is</p>
<div class="math">
\[u_l(t) = p(t) + \frac{P(t)B^T(t)l(t+1)}{\langle l(t+1),
B(t)P(t)B^T(t)l(t+1)\rangle^{1/2}}. \label{udt}\]</div>
<p>Each choice of <span class="math">l_0</span> defines an external and internal
approximation. If
<span class="math">\overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))</span> is
nonempty,</p>
<div class="math">
\[  \bigcup_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\overline{X}^-_l(t)) =
  \overline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0)) =
  \bigcap_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\overline{X}^+_l(t)).\]\[Similarly for\]</div>
<p><span class="math">\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0))</span>,</p>
<div class="math">
\[\bigcup_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\underline{X}^-_l(t)) =
\underline{{\mathcal X}}_{CL}(t,t_0,{\mathcal E}(x_0,X_0)) =
\bigcap_{\langle l_0,l_0\rangle=1}{\mathcal E}(x_c(t),\underline{X}^+_l(t)).\]</div>
<p>Similarly, tight ellipsoidal approximations of maxmin and minmax CLBRS
with terminating conditions <span class="math">(t_1, {\mathcal E}(y_1,Y_1))</span> can be
obtained for those directions <span class="math">l(t)</span> satisfying</p>
<div class="math">
\[l(t) = \Phi^T(t_1,t)l_1,
\tag*{(\ref{bckadjoint})}
\label{bckadjointd}\]</div>
<p>with some fixed <span class="math">l_1</span>, for which they exist.</p>
<p>With boundary conditions</p>
<div class="math">
\[y_c(t_1)=y_1, ~~~ \overline{Y}^+_l(t_1)=\overline{Y}^-_l(t_1)=\underline{Y}^+_l(t_1)=\underline{Y}^-_l(t_1)=Y_1,
\label{bndconds}\]</div>
<p>external and internal ellipsoids for maxmin CLBRS
<span class="math">\overline{{\mathcal Y}}_{CL}(t_1,t,{\mathcal E}(y_1,Y_1))</span> at
time <span class="math">t</span>, <span class="math">{\mathcal E}(y_c(t),\overline{Y}^+_l(t))</span> and
<span class="math">{\mathcal E}(y_c(t),\overline{Y}^-_l(t))</span>, are computed as
external and internal ellipsoidal approximations of the geometric
sum-difference</p>
<div class="math">
\[  A^{-1}(t)\left(
  {\mathcal E}(y_c(t+1),\overline{Y}^+_l(t+1)) \oplus B(t){\mathcal E}(-p(t),P(t))
  \dot{-}G(t){\mathcal E}(-q(t),Q(t))
  \right)\]\[and\]</div>
<div class="math">
\[  A^{-1}(t)\left(
  {\mathcal E}(y_c(t+1),\overline{Y}^-_l(t+1)) \oplus B(t){\mathcal E}(-p(t),P(t))
  \dot{-}G(t){\mathcal E}(-q(t),Q(t))
  \right)\]\[in direction :math:`l(t)` from [bckadjointd]. Section\]</div>
<p>[subsec:sub:<cite>s</cite>umdiff] describes the operation of geometric
sum-difference for ellipsoids.</p>
<p>External and internal ellipsoids for minmax CLBRS
<span class="math">\underline{{\mathcal Y}}_{CL}(t_1,t,{\mathcal E}(y_1,Y_1))</span> at
time <span class="math">t</span>, <span class="math">{\mathcal E}(y_c(t),\underline{Y}^+_l(t))</span> and
<span class="math">{\mathcal E}(y_c(t),\underline{Y}^-_l(t))</span>, are computed as
external and internal ellipsoidal approximations of the geometric
difference-sum</p>
<div class="math">
\[  A^{-1}(t)\left(
  {\mathcal E}(y_c(t+1),\underline{Y}^+_l(t+1))
  \dot{-}G(t){\mathcal E}(-q(t),Q(t))
  \oplus B(t){\mathcal E}(-p(t),P(t))
  \right)\]\[and\]</div>
<div class="math">
\[  A^{-1}(t)\left(
  {\mathcal E}(y_c(t+1),\underline{Y}^-_l(t+1))
  \dot{-}G(t){\mathcal E}(-q(t),Q(t))
  \oplus B(t){\mathcal E}(-p(t),P(t))
  \right)\]\[in direction :math:`l(t)` from [bckadjointd]. Section\]</div>
<p>[subsec:sub:<cite>d</cite>iffsum] describes the operation of geometric
difference-sum for ellipsoids.</p>
</div>
</div>
</div>
<div class="section" id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="additional-software">
<h2>Additional Software<a class="headerlink" href="#additional-software" title="Permalink to this headline">¶</a></h2>
<p>These packages aren’t included in the ET distribution. So, you need to
download them separately.</p>
<div class="section" id="cvx">
<h3>CVX<a class="headerlink" href="#cvx" title="Permalink to this headline">¶</a></h3>
<p>Some methods of the <em>Ellipsoidal Toolbox</em>, namely,</p>
<ul class="simple">
<li>distance</li>
<li>intersect</li>
<li>isInside</li>
<li>doesContain</li>
<li>ellintersection_ia</li>
<li>ellunion_ea</li>
</ul>
<p>require solving semidefinite programming (SDP) problems. We use CVX (
(“CVX Homepage”)) as an interface to an external SDP solver. CVX is a
reliable toolbox for solving SDP problems of high dimensionality. CVX is
implemented in Matlab, effectively turning Matlab into an optimization
modeling language. Model specifications are constructed using common
Matlab operations and functions, and standard Matlab code can be freely
mixed with these specifications. This combination makes it simple to
perform the calculations needed to form optimization problems, or to
process the results obtained from their solution. CVX distribution
includes two freeware solvers: SeDuMi(Sturm (1999), (“SeDuMi Homepage”))
and SDPT3( (“SDPT3 Homepage”)). The default solver used in the toolbox
is SeDuMi.</p>
</div>
<div class="section" id="mpt">
<h3>MPT<a class="headerlink" href="#mpt" title="Permalink to this headline">¶</a></h3>
<p>Multi-Parametric Toolbox( (“Multi-Parametric Toolbox Homepage”)) - a
Matlab toolbox for multi-parametric optimization and computational
geometry. MPT is a toolbox that defines polytope class used in <em>ET</em>. We
need MPT for the following methods operating with polytopes.</p>
<ul class="simple">
<li>distance</li>
<li>intersect</li>
<li>intersection_ia</li>
<li>intersection_ea</li>
<li>isInside</li>
<li>hyperplane2polytope</li>
<li>polytope2hyperplane</li>
</ul>
</div>
</div>
<div class="section" id="installation-and-quick-start">
<h2>Installation and Quick Start<a class="headerlink" href="#installation-and-quick-start" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">Go to and download the <em>Ellipsoidal Toolbox</em>.</p>
</li>
<li><p class="first">Unzip the distribution file into the directory where you would like
the toolbox to be.</p>
</li>
<li><p class="first">Unzip CVX into cvx folder next to products folder.</p>
</li>
<li><p class="first">Unzip MPT into mpt folder next to products folder.</p>
</li>
<li><p class="first">Read the copyright notice.</p>
</li>
<li><p class="first">In MATLAB command window change the working directory to the one
where you unzipped the toolbox and type</p>
</li>
<li><p class="first">At this point, the directory tree of the <em>Ellipsoidal Toolbox</em> is
added to the MATLAB path list. In order to save the updated path
list, in your MATLAB window menu go to File <span class="math">\rightarrow</span> Set
Path... and click Save.</p>
</li>
<li><p class="first">To get an idea of what the toolbox is about, type</p>
<p>This will produce a demo of basic <em>ET</em> functionality: how to create
and manipulate ellipsoids.</p>
<p>Type</p>
<p>to learn how to plot ellipsoids and hyperplanes in 2 and 3D. For a
quick tutorial on how to use the toolbox for reachability analysis
and verification, type</p>
</li>
</ol>
</div>
</div>
<div class="section" id="implementation">
<h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id11">
<h2>Operations with ellipsoids<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>In the <em>Ellipsoidal Toolbox</em> we define a new class ellipsoid inside the
MATLAB programming environment. The following three commands define the
same ellipsoid <span class="math">{\mathcal E}(q,Q)</span>, with <span class="math">q\in{\bf R}^n</span> and
<span class="math">Q\in{\bf R}^{n\times n}</span> being symmetric positive semidefinite:
For the ellipsoid class we overload the following functions and
operators:</p>
<ul>
<li><p class="first">isEmpty(ellObj) - checks if <span class="math">{\mathcal E}(q,Q)</span> is an empty
ellipsoid.</p>
</li>
<li><p class="first">display(ellObj) - displays the details of ellipsoid
<span class="math">{\mathcal E}(q,Q)</span>, namely, its center <span class="math">q</span> and the shape
matrix <span class="math">Q</span>.</p>
</li>
<li><p class="first">plot(ellObj) - plots ellipsoid <span class="math">{\mathcal E}(q,Q)</span> if its
dimension is not greater than 3.</p>
</li>
<li><p class="first">firstEllObj == secEllObj - checks if ellipsoids
<span class="math">{\mathcal E}(q_1,Q_1)</span> and <span class="math">{\mathcal E}(q_2,Q_2)</span> are
equal.</p>
</li>
<li><p class="first">firstEllObj = secEllObj - checks if ellipsoids
<span class="math">{\mathcal E}(q_1,Q_1)</span> and <span class="math">{\mathcal E}(q_2,Q_2)</span> are
not equal.</p>
</li>
<li><ul class="first simple">
<li>concatenates the ellipsoids into the horizontal array, e.g. ellVec</li>
</ul>
<p>= [firstEllObj secEllObj thirdEllObj].</p>
</li>
<li><ul class="first simple">
<li>concatenates the ellipsoids into the vertical array, e.g. ellMat =</li>
</ul>
<p>[firstEllObj secEllObj; thirdEllObj fourthEllObj] defines
<span class="math">2\times 2</span> array of ellipsoids.</p>
</li>
<li><p class="first">firstEllObj &gt;= secEllObj - checks if the ellipsoid firstEllObj is
bigger than the ellipsoid secEllObj, or equivalently
<span class="math">{\mathcal E}(0,Q_1)\subseteq{\mathcal E}(0,Q_2)</span>.</p>
</li>
<li><p class="first">firstEllObj &lt;= secEllObj - checks if
<span class="math">{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)</span>.</p>
</li>
<li><p class="first">-ellObj - defines ellipsoid <span class="math">{\mathcal E}(-q,Q)</span>.</p>
</li>
<li><p class="first">ellObj + bScal - defines ellipsoid <span class="math">{\mathcal E}(q+b,Q)</span>.</p>
</li>
<li><p class="first">ellObj - bScal - defines ellipsoid <span class="math">{\mathcal E}(q-b,Q)</span>.</p>
</li>
<li><p class="first">aMat * ellObj - defines ellipsoid <span class="math">{\mathcal E}(q,AQA^T)</span>.</p>
</li>
<li><p class="first">ellObj.inv() - inverts the shape matrix of the ellipsoid:
<span class="math">{\mathcal E}(q,Q^{-1})</span>.</p>
</li>
</ul>
<p>All the listed operations can be applied to a single ellipsoid as well
as to a two-dimensional array of ellipsoids. For example, To access
individual elements of the array, the usual MATLAB subindexing is used:
Sometimes it may be useful to modify the shape of the ellipsoid without
affecting its center. Say, we would like to bloat or squeeze the
ellipsoid: Since function shape does not change the center of the
ellipsoid, it only accepts scalars or square matrices as its second
input parameter. Several functions access the internal data of the
ellipsoid object: One way to check if two ellipsoids intersect, is to
compute the distance between them ( (“Stanley Chan Article Homepage”),
Lin and Han (2002)): This result indicates that the ellipsoid
thirdEllObj does not intersect with the ellipsoid ellMat(2, 2), with all
the other ellipsoids in ellMat it has nonempty intersection. If the
intersection of the two ellipsoids is nonempty, it can be approximated
by ellipsoids from the outside as well as from the inside. See
<span class="math">\mbox{\!\!\@OldCite{ROS_SABATER_THOMAS_EN_ELLIPSOIDAL_CALCULUS_BASED_ON_PROPAGATION_AND_FUSION}}</span>
for more information about these methods. It can be checked that
resulting ellipsoid externalEllObj contains the given intersection,
whereas internalEllObj is contained in this intersection: Function
isInside in general checks if the intersection of ellipsoids in the
given array contains the union or intersection of ellipsoids or
polytopes.</p>
<p>It is also possible to solve the feasibility problem, that is, to check
if the intersection of more than two ellipsoids is empty: In this
particular example the result <span class="math">-1</span> indicates that the intersection
of ellipsoids in ellMat is empty. Function intersect in general checks
if an ellipsoid, hyperplane or polytope intersects the union or the
intersection of ellipsoids in the given array: For the ellipsoids in
<span class="math">{\bf R}</span>, <span class="math">{\bf R}^2</span> and <span class="math">{\bf R}^3</span> the geometric
sum can be computed explicitely and plotted: Figure
<span class="math">\ref{minksumPic}</span> displays the geometric sum of ellipsoids. If
the dimension of the space in which the ellipsoids are defined exceeds
<span class="math">3</span>, an error is returned. The result of the geometric sum
operation is not generally an ellipsoid, but it can be approximated by
families of external and internal ellipsoids parametrized by the
direction vector: Functions minksum_ea and minksum_ia work for
ellipsoids of arbitrary dimension. They should be used for general
computations whereas minksum is there merely for visualization purposes.</p>
<p>If the geometric difference of two ellipsoids is not an empty set, it
can be computed explicitely and plotted for ellipsoids in
<span class="math">{\bf R}</span>, <span class="math">{\bf R}^2</span> and <span class="math">{\bf R}^3</span>: Figure
<span class="math">\ref{minkdiffPic}</span> shows the geometric difference of ellipsoids.
Similar to minksum, minkdiff is there for visualization purpose. It
works only for dimensions <span class="math">1</span>, <span class="math">2</span> and <span class="math">3</span>, and for
higher dimensions it returns an error. For arbitrary dimensions, the
geometric difference can be approximated by families of external and
internal ellipsoids parametrized by the direction vector, provided this
direction is not bad: Operation ’difference-sum’ described in section
2.2.4 is implemented in functions minkmp, minkmp_ea, minkmp_ia, the
first one of which is used for visualization and works for dimensions
not higher than <span class="math">3</span>, whereas the last two can deal with ellipsoids
of arbitrary dimension. Figure <span class="math">\ref{minkPic}</span> displays results of
the implementation of minkpm and minkmp operations. Similarly, operation
’sum-difference’ described in section 2.2.5 is implemented in functions
minkpm, minkpm_ea, minkpm_ia, the first one of which is used for
visualization and works for dimensions not higher than <span class="math">3</span>,
whereas the last two can deal with ellipsoids of arbitrary dimension.</p>
</div>
<div class="section" id="operations-with-hyperplanes">
<h2>Operations with hyperplanes<a class="headerlink" href="#operations-with-hyperplanes" title="Permalink to this headline">¶</a></h2>
<p>The class hyperplane of the <em>Ellipsoidal Toolbox</em> is used to describe
hyperplanes and halfspaces. The following two commands define one and
the same hyperplane but two different halfspaces:</p>
<p>The following functions and operators are overloaded for the hyperplane
class:</p>
<ul>
<li><p class="first">isempty(hypObj) - checks if hypObj is an empty hyperplane.</p>
</li>
<li><p class="first">display(hypObj) - displays the details of hyperplane
<span class="math">H(c,\gamma)</span>, namely, its normal <span class="math">c</span> and the scalar
<span class="math">\gamma</span>.</p>
</li>
<li><p class="first">plot(hypObj) - plots hyperplane <span class="math">H(c,\gamma)</span> if the dimension
of the space in which it is defined is not greater than 3.</p>
</li>
<li><p class="first">firstHypObj == secHypObj - checks if hyperplanes
<span class="math">H(c_1,\gamma_1)</span> and <span class="math">H(c_2,\gamma_2)</span> are equal.</p>
</li>
<li><p class="first">firstHypObj = secHypObj - checks if hyperplanes
<span class="math">H(c_1,\gamma_1)</span> and <span class="math">H(c_2,\gamma_2)</span> are not equal.</p>
</li>
<li><ul class="first simple">
<li>concatenates the hyperplanes into the horizontal array, e.g. hypVec</li>
</ul>
<p>= [firstHypObj secHypObj thirdHypObj].</p>
</li>
<li><ul class="first simple">
<li>concatenates the hyperplanes into the vertical array, e.g. hypMat =</li>
</ul>
<p>[firstHypObj secHypObj; thirdHypObj fourthHypObj] - defines
<span class="math">2\times 2</span> array of hyperplanes.</p>
</li>
<li><p class="first">-hypObj - defines hyperplane <span class="math">H(-c,-\gamma)</span>, which is the same
as <span class="math">H(c,\gamma)</span> but specifies different halfspace.</p>
</li>
</ul>
<p>There are several ways to access the internal data of the hyperplane
object: All the functions of <em>Ellipsoidal Toolbox</em> that accept
hyperplane object as parameter, work with single hyperplanes as well as
with hyperplane arrays. One exception is the function parameters that
allows only single hyperplane object.</p>
<p>An array of hyperplanes can be converted to the polytope object of the
Multi-Parametric Toolbox (Kvasnica et al. (2004), (“Multi-Parametric
Toolbox Homepage”)), and back: Functions hyperplane2polytope and
polytope2hyperplane require the Multi-Parametric Toolbox to be
installed.</p>
<p>We can compute distance from ellipsoids to hyperplanes and polytopes: A
negative distance value in the case of ellipsoid and hyperplane means
that the ellipsoid intersects the hyperplane. As we see in this example,
ellipsoid firstEllObj intersects hyperplanes hypVec(1) and hypVec(3) and
has no common points with hypVec(2) and hypVec(4). When distance
function has a polytope as a parameter, it always returns nonnegative
values to be consistent with distance function of the Multi-Parametric
Toolbox. Here, the zero distance values mean that each ellipsoid in
ellMat has nonempty intersection with polytope firstPolObj.</p>
<p>It can be checked if the union or intersection of given ellipsoids
intersects given hyperplanes or polytopes:</p>
<p>The intersection of ellipsoid and hyperplane can be computed exactly:
Functions intersection_ea and intersection_ia can be used with
hyperplane objects, which in this case define halfspaces and polytope
objects:</p>
<p>Function isInside can be used to check if a polytope or union of
polytopes is contained in the intersection of given ellipsoids:</p>
<p>Functions distance, intersect, intersection_ia and isInside use the CVX
interface ( (“CVX Homepage”)) to the external optimization package. The
default optimization package included in the distribution of the
<em>Ellipsoidal Toolbox</em> is SeDuMi (Sturm (1999), (“SeDuMi Homepage”)).</p>
</div>
<div class="section" id="operations-with-ellipsoidal-tubes">
<h2>Operations with ellipsoidal tubes<a class="headerlink" href="#operations-with-ellipsoidal-tubes" title="Permalink to this headline">¶</a></h2>
<p>There are several classes in <em>Ellipsoidal Toolbox</em> for operations with
ellipsoidal tubes. The class gras.ellapx.smartdb.rels.EllTube is used to
describe ellipsoidal tubes. The class
gras.ellapx.smartdb.rels.EllUnionTube is used to store tubes by the
instant of time:</p>
<div class="math">
\[{\mathcal X}_{U}[t]=\bigcup \limits_{\tau\leqslantt}{\mathcal X}[\tau],\]\[where :math:`{\mathcal X}[\tau]` is single ellipsoidal tube. The class\]</div>
<p>gras.ellapx.smartdb.rels.EllTubeProj is used to describe the projection
of the ellipsoidal tubes onto time dependent subspaces.There are two
types of projection: static and dynamic. Also there is class
gras.ellapx.smartdb.rels.EllUnionTubeStaticProj for description of the
projection on static plane tubes by the instant of time. Next we provide
some examples of the operations with ellipsoidal tubes. We may be
interested in the data about ellipsoidal tube in some particular time
interval, smaller than the one for which the ellipsoidal tube was
computed, say <span class="math">2\leqslantt\leqslant4</span>. This data can be extracted
by the cut function: We can compute the projection of the ellipsoidal
tube onto time-dependent subspace.</p>
<p>Figure <span class="math">\ref{project}</span> displays static and dynamic projections.
Also we can see projections of good directions for ellipsoidal tubes.</p>
<p>We can compute tubes by the instant of time using methodfromEllTubes:
Figure <span class="math">\ref{unionTubeStatProj}</span> shows projection of ellipsoidal
tubes by the instant of time. ellipsoidal tutbes.</p>
<p>Also we can get initial data from the resulting tube: There is a method
to display a content of ellipsoidal tubes. Figure <span class="math">\ref{dispPic}</span>
displays all fields of the ellipsoidal tube.</p>
<p>There are several methods to find the tubes with necessary parameters.
Also you can use the method display to see the result of the method’s
work. We can sort our tubes by certain fields:</p>
</div>
<div class="section" id="id12">
<h2>Reachability<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>To compute the reach sets of the systems described in chapter 3, we
define few new classes in the <em>Ellipsoidal Toolbox</em>: class
LinSysContinuous for the continuous-time system description, class
LinSysDiscrete for the discrete-time system description and classes
ReachContinuous<span class="math">\backslash</span>ReachDiscrete for the reach set
data. We start by explaining how to define a system using
LinSysContinuous object. Also we can use LinSysFactory class for the
description of this system. Through it’s method create user can get
LinSysContinuous or LinSysDiscrete object. For example, description of
the system</p>
<div class="math">
\[\begin{split}  \left[\begin{array}{cc}
  \dot{x}_1\\
  \dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
  0 &amp; 1\\
  0 &amp; 0\end{array}\right]\left[\begin{array}{c}
  x_1\\
  x_2\end{array}\right] + \left[\begin{array}{c}
  u_1(t)\\
  u_2(t)\end{array}\right], ~~~ u(t)\in{\mathcal E}(p(t), P)\end{split}\]\[with\]</div>
<div class="math">
\[\begin{split}  p(t) = \left[\begin{array}{c}
  \sin(t)\\
  \cos(t)\end{array}\right], ~~~ P = \left[\begin{array}{cc}
  9 &amp; 0\\
  0 &amp; 2\end{array}\right],\end{split}\]\[is done by the following sequence of commands: If matrices :math:`A` or\]</div>
<p><span class="math">B</span> depend on time, say <span class="math">A(t)=\left[\begin{array}{cc}
0 & 1-\cos(2t)\\
-\frac{1}{t} & 0\end{array}\right]</span>, then matrix aMat should be
symbolic: To describe the system with disturbance</p>
<div class="math">
\[\begin{split}  \left[\begin{array}{cc}
  \dot{x}_1\\
  \dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
  0 &amp; 1\\
  0 &amp; 0\end{array}\right]\left[\begin{array}{c}
  x_1\\
  x_2\end{array}\right] + \left[\begin{array}{c}
  u_1(t)\\
  u_2(t)\end{array}\right] + \left[\begin{array}{c}
  0\\
  1\end{array}\right]v(t),\end{split}\]\[with bounds on control as before, and disturbance being\]</div>
<p><span class="math">-1\leqslantv(t)\leqslant1</span>, we type: Control and disturbance
bounds SUBounds and vEllObj can have different types. If the bound is
constant, it should be described by ellipsoid object. If the bound
depends on time, then it is represented by a structure with fields
center and shape, one or both of which are symbolic. In system sys, the
control bound SUBounds is defined as such a structure. Finally, if the
control or disturbance is known and fixed, it should be defined as a
vector, of type double if constant, or symbolic, if it depends on time.</p>
<p>To declare a discrete-time system</p>
<div class="math">
\[\begin{split}  \left[\begin{array}{c}
  x_1[k+1]\\
  x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
  0 &amp; 1\\
  -1 &amp; -0.5\end{array}\right]\left[\begin{array}{c}
  x_1[k]\\
  x_2[k]\end{array}\right] + \left[\begin{array}{c}
  0\\
  1\end{array}\right]u[k], ~~~ -1\leqslantu[k]\leqslant1,\end{split}\]\[we use LinSysDiscrete constructor: Once the LinSysDiscrete object is\]</div>
<p>created, we need to specify the set of initial conditions, the time
interval and values of the direction vector, for which the reach set
approximations must be computed: The reach set approximation is computed
by calling the constructor of the ReachContinuous object: At this point,
variable firstRsObj contains the reach set approximations for the
specified continuous-time system, time interval and set of initial
conditions computed for given directions. Both external and internal
approximations are computed. The reach set approximation data can be
extracted in the form of arrays of ellipsoids:</p>
<p>Ellipsoidal arrays externallEllMat and internalEllMat have <span class="math">4</span>
rows because we computed the reach set approximations for <span class="math">4</span>
directions. Each row of ellipsoids corresponds to one direction. The
number of columns in externallEllMat and internalEllMat is defined by
the nTimeGridPoints parameter, which is available from
elltool.conf.Properties static class (see chapter 6 for details). It
represents the number of time values in our time interval, at which the
approximations are evaluated. These time values are returned in the
optinal output parameter, array timeVec, whose length is the same as the
number of columns in externallEllMat and internalEllMat. Intersection of
ellipsoids in a particular column of externallEllMat gives external
ellipsoidal approximation of the reach set at corresponding time.
Internal ellipsoidal approximation of this set at this time is given by
the union of ellipsoids in the same column of internalEllMat.</p>
<p>We may be interested in the reachability data of our system in some
particular time interval, smaller than the one for which the reach set
was computed, say <span class="math">3\leqslantt\leqslant5</span>. This data can be
extracted and returned in the form of ReachContinuous object by the cut
function:</p>
<p>To obtain a snap shot of the reach set at given time, the same function
cut is used: It can be checked if the external or internal reach set
approximation intersects with given ellipsoids, hyperplanes or
polytopes:</p>
<p>If a given set intersects with the internal approximation of the reach
set, then this set intersects with the actual reach set. If the given
set does not intersect with external approximation, this set does not
intersect the actual reach set. There are situations, however, when the
given set intersects with the external approximation but does not
intersect with the internal one. In our example above, ellipsoid ellObj
is such a case: the quality of the approximation does not allow us to
determine whether or not ellObj intersects with the actual reach set. To
improve the quality of approximation, refine function should be used:</p>
<p>Now we are sure that ellipsoid ellObj intersects with the actual reach
set. However, to use the refine function, the reach set object must
contain all calculated data, otherwise, an error is returned.</p>
<p>Having a reach set object resulting from the ReachContinuous, cut or
refine operations, we can obtain the trajectory of the center of the
reach set and the good curves along which the actual reach set is
touched by its ellipsoidal approximations:</p>
<p>Variable ctrMat here is a matrix whose columns are the points ofthe
reach set center trajectory evaluated at time values returned in the
array ttVec. Variable gcCMat contains <span class="math">4</span> matrices each of which
corresponds to a good curve (columns of such matrix are points of the
good curve evaluated at time values in ttVec). The analytic expression
for the control driving the system along a good curve is given by
formula ([uct]).</p>
<p>We computed the reach set up to time <span class="math">10</span>. It is possible to
continue the reach set computation for a longer time horizon using the
reach set data at time <span class="math">10</span> as initial condition. It is also
possible that the dynamics and inputs of the system change at certain
time, and from that point on the system evolves according to the new
system of differential equations. For example, starting at time
<span class="math">10</span>, our reach set may evolve in time according to the
time-variant system sys_t defined above. Switched systems are a special
case of this situation. To compute the further evolution in time of the
existing reach set, function evolve should be used: Function evolve can
be viewed as an implementation of the semigroup property.</p>
<p>To compute the backward reach set for some specified target set, we
declare the time interval so that the terminating time comes first:</p>
<p>Reach set and backward reach set computation for discrete-time systems
and manipulations with the resulting reach set object are performed
using the same functions as for continuous-time systems:</p>
<p>Number of columns in the ellipsoidal arrays externalEllMat and
internalEllMat is <span class="math">51</span> because the backward reach set is computed
for <span class="math">50</span> time steps, and the first column of these arrays contains
<span class="math">3</span> ellipsoids yEllObj - the terminating condition.</p>
<p>When dealing with discrete-time systems, all functions that accept time
or time interval as an input parameter, round the time values and treat
them as integers.</p>
</div>
<div class="section" id="properties">
<h2>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h2>
<p>Functions of the <em>Ellipsoidal Toolbox</em> can be called with user-specified
values of certain global parameters. System of the parameters are
configured using xml files, which available from a set of command-line
utilities: Here we list system parameters available from the ’default’
configuration:</p>
<ol class="arabic simple">
<li>version = ’1.4dev’ - current version of <em>ET</em>.</li>
<li>isVerbose = false - makes all the calls to <em>ET</em> routines silent, and
no information except errors is displayed.</li>
<li>absTol = 1e-7 - absolute tolerance.</li>
<li>relTol = 1e-5 - relative tolerance.</li>
<li>nTimeGridPoints = 200 - density of the time grid for the continuous
time reach set computation. This parameter directly affects the
number of ellipsoids to be stored in the
ReachContinuous<span class="math">\backslash</span>ReachDiscrete object.</li>
<li>ODESolverName = ode45 - specifies the ODE solver for continuous time
reach set computation.</li>
<li>isODENormControl = ’on’ - switches on and off the norm control in the
ODE solver. When turned on, it slows down the computation, but
improves the accuracy.</li>
<li>isEnabledOdeSolverOptions = false - when set to false, calls the ODE
solver without any additional options like norm control. It makes the
computation faster but less accurate. Otherwise, it is assumed to be
true, and only in this case the previous option makes a difference.</li>
<li>nPlot2dPoints = 200 - the number of points used to plot a 2D
ellipsoid. This parameter also affects the quality of 2D reach tube
and reach set plots.</li>
<li>nPlot3dPoints = 200 - the number of points used to plot a 3D
ellipsoid. This parameter also affects the quality of 3D reach set
plots.</li>
</ol>
<p>Once the configuration is loaded, the system parameters are available
through elltool.conf.Properties. elltool.conf.Properties is a static
class, providing emulation of static properties for toolbox. It has two
function types: setters and getters. Using getters we obtain system
parameters. Some of the parameters can be changed in run-time via
setters.</p>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p><em>Ellipsoidal Toolbox</em> has several plotting routines:</p>
<ul class="simple">
<li>ellipsoid/plot - plots one or more ellipsoids, or arrays of
ellipsoids, defined in <span class="math">{\bf R}</span>, <span class="math">{\bf R}^2</span> or
<span class="math">{\bf R}^3</span>.</li>
<li>ellipsoid/minksum - plots geometric sum of finite number of
ellipsoids defined in <span class="math">{\bf R}</span>, <span class="math">{\bf R}^2</span> or
<span class="math">{\bf R}^3</span>.</li>
<li>ellipsoid/minkdiff - plots geometric difference (if it is not an
empty set) of two ellipsoids defined in <span class="math">{\bf R}</span>,
<span class="math">{\bf R}^2</span> or <span class="math">{\bf R}^3</span>.</li>
<li>ellipsoid/minkmp - plots geometric (Minkowski) sum of the geometric
difference of two ellipsoids and the geometric sum of <span class="math">n</span>
ellipsoids defined in <span class="math">{\bf R}</span>, <span class="math">{\bf R}^2</span> or
<span class="math">{\bf R}^3</span>.</li>
<li>ellipsoid/minkpm - plots geometric (Minkowski) difference of the
geometric sum of ellipsoids and a single ellipsoid defined in
<span class="math">{\bf R}</span>, <span class="math">{\bf R}^2</span> or <span class="math">{\bf R}^3</span>.</li>
<li>hyperplane/plot - plots one or more hyperplanes, or arrays of
hyperplanes, defined in <span class="math">{\bf R}^2</span> or <span class="math">{\bf R}^3</span>.</li>
<li>reach/plot_ea - plots external approximation of the reach set whose
dimension is <span class="math">2</span> or <span class="math">3</span>.</li>
<li>reach/plot_ia - plots internal approximation of the reach set whose
dimension is <span class="math">2</span> or <span class="math">3</span>.</li>
</ul>
<p>All these functions allow the user to specify the color of the plotted
objects, line width for 1D and 2D plots, and transparency level of the
3D objects. Hyperplanes are displayed as line segments in 2D and square
facets in 3D. In the hyperplane/plot method it is possible to specify
the center of the line segment or facet and its size.</p>
<p>Ellipsoids of dimensions higher than three must be projected onto a two-
or three-dimensional subspace before being plotted. This is done by
means of projection function:</p>
<p>Since the operation of projection is linear, the projection of the
geometric sum of ellipsoids equals the geometric sum of the projected
ellipsoids. The same is true for the geometric difference of two
ellipsoids.</p>
<p>Function projection exists also for the
ReachContinuous<span class="math">\backslash</span>ReachDiscrete objects:</p>
<p>The quality of the ellipsoid and reach set plots is controlled by the
parameters nPlot2dPoints and nPlot3dPoints, which are available from
getters of ellipsoid class.</p>
</div>
</div>
<div class="section" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="ellipsoids-vs-polytopes">
<h2>Ellipsoids vs. Polytopes<a class="headerlink" href="#ellipsoids-vs-polytopes" title="Permalink to this headline">¶</a></h2>
<p>Depending on the particular dynamical system, certain methods of reach
set computation may be more suitable than others. Even for a simple
2-dimensional discrete-time linear time-invariant system, application of
ellipsoidal methods may be more effective than using polytopes.</p>
<p>Consider the system from chapter 1:</p>
<div class="math">
\[\begin{split}  \left[\begin{array}{c}
  x_1[k+1]\\
  x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
  \cos(1) &amp; \sin(1)\\
  -\sin(1) &amp; \cos(1)\end{array}\right]\left[\begin{array}{c}
  x_1[k]\\
  x_2[k]\end{array}\right] + \left[\begin{array}{c}\
  u_1[k]\\
  u_2[k]\end{array}\right], ~~~ x[0]\in{\mathcal X}_0, ~~~ u[k]\in U, ~~~ k\geqslant0,\end{split}\]\[where :math:`{\mathcal X}_0` is the set of initial conditions, and\]</div>
<p><span class="math">U</span> is the control set.</p>
<p>Let <span class="math">{\mathcal X}_0</span> and <span class="math">U</span> be unit boxes in
<span class="math">{\bf R}^2</span>, and compute the reach set using the polytope method
implemented in MPT ( (“Multi-Parametric Toolbox Homepage”)). With every
time step the number of vertices of the reach set polytope increases by
<span class="math">4</span>. The complexity of the convex hull computation increases
exponentially with number of vertices. In figure [ellpolyfig], the time
required to compute the reach set for different time steps using
polytopes is shown in red.</p>
<p>To compute the reach set of the system using <em>Ellipsoidal Toolbox</em>, we
assume <span class="math">{\mathcal X}_0</span> and <span class="math">U</span> to be unit balls in
<span class="math">{\bf R}^2</span>, fix any number of initial direction values that
corresponds to the number of ellipsoidal approximations, and obtain
external and internal ellipsoidal approximations of the reach set:</p>
<p>In figure [ellpolyfig], the time required to compute both external and
internal ellipsoidal approximations, with <span class="math">32</span> ellipsoids each,
for different number of time steps is shown in blue.</p>
<p>Figure [ellpolyfig] illustrates the fact that the complexity of polytope
method grows exponentially with number of time steps, whereas the
complexity of ellipsoidal method grows linearly.</p>
</div>
<div class="section" id="system-with-disturbance">
<h2>System with Disturbance<a class="headerlink" href="#system-with-disturbance" title="Permalink to this headline">¶</a></h2>
<p>The mechanical system presented in figure [springmassfig], is described
by the following system of equations:</p>
<div class="math">
\[\begin{split}\begin{aligned}
m_1\ddot{x}_1+(k_1+k_2)x_1-k_2x_2 &amp; = &amp; u_1, \label{spmass1}\\
m_2\ddot{x}_2-k_2x_1+(k_1+k_2)x_2 &amp; = &amp; u_2 . \label{spmass2}\end{aligned}\end{split}\]</div>
<p>Here <span class="math">u_1</span> and <span class="math">u_2</span> are the forces applied to masses
<span class="math">m_1</span> and <span class="math">m_2</span>, and we shall assume
<span class="math">[u_1 ~~ u_2]^T\in{\mathcal E}(0,I)</span>. The initial conditions can
be taken as <span class="math">x_1(0)=0</span>, <span class="math">x_2(0)=2</span>. Defining
<span class="math">x_3=\dot{x}_1</span> and <span class="math">x_4=\dot{x}_2</span>, we can rewrite
([spmass1]-[spmass2]) as a linear system in standard form:</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c}
\dot{x}_1 \\
\dot{x}_2 \\
\dot{x}_3 \\
\dot{x}_4 \end{array}\right] = \left[\begin{array}{cccc}
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1\\
-\frac{k_1+k_2}{m_1} &amp; \frac{k_2}{m_1} &amp; 0 &amp; 0\\
\frac{k_2}{m_2} &amp; -\frac{k_1+k_2}{m_2} &amp; 0 &amp; 0\end{array}\right]
\left[\begin{array}{c}
x_1 \\
x_2 \\
x_3 \\
x_4 \end{array}\right] + \left[\begin{array}{cc}
0 &amp; 0\\
0 &amp; 0\\
\frac{1}{m_1} &amp; 0\\
0 &amp; \frac{1}{m_2}\end{array}\right]\left[\begin{array}{c}
u_1\\
u_2\end{array}\right]. \label{spmassls}\end{split}\]</div>
<p>Now we can compute the reach set of system ([spmass1]-[spmass2]) for
given time by computing the reach set of the linear system ([spmassls])
and taking its projection onto <span class="math">(x_1, x_2)</span> subspace. Figure
[mechreachfig](a) shows the reach set of the system
([spmass1]-[spmass2]) evolving in time from <span class="math">t=0</span> to <span class="math">t=4</span>.
Figure [mechreachfig](b) presents a snapshot of this reach set at time
<span class="math">t=4</span>.</p>
<p>So far we considered an ideal system without any disturbance, such as
friction. We introduce disturbance to ([spmass1]-[spmass2]) by adding
extra terms, <span class="math">v_1</span> and <span class="math">v_2</span>,</p>
<div class="math">
\[\begin{split}\begin{aligned}
m_1\ddot{x}_1+(k_1+k_2)x_1-k_2x_2 &amp; = &amp; u_1 + v_1, \label{smdist1}\\
m_2\ddot{x}_2-k_2x_1+(k_1+k_2)x_2 &amp; = &amp; u_2 + v_2, \label{smdist2}\end{aligned}\end{split}\]</div>
<p>which results in equation ([spmassls]) getting an extra term</p>
<div class="math">
\[\begin{split}  \left[\begin{array}{cc}
  0 &amp; 0\\
  0 &amp; 0\\
  1 &amp; 0\\
  0 &amp; 1\end{array}\right]\left[\begin{array}{c}
  v_1\\
  v_2\end{array}\right].\end{split}\]\[Assuming that :math:`[v_1 ~~ v_2]^T` is unknown but bounded by\]</div>
<p>ellipsoid <span class="math">{\mathcal E}(0, \frac{1}{4}I)</span>, we can compute the
closed-loop reach set of the system with disturbance.</p>
<p>Figure [mechreachfig](c) shows the reach set of the system
([smdist1]-[smdist2]) evolving in time from <span class="math">t=0</span> to <span class="math">t=4</span>.
Figure [mechreachfig](d) presents a snapshot of this reach set at time
<span class="math">t=4</span>.</p>
</div>
<div class="section" id="switched-system">
<h2>Switched System<a class="headerlink" href="#switched-system" title="Permalink to this headline">¶</a></h2>
<p>By <em>switched systems</em> we mean systems whose dynamics changes at known
times. Consider the RLC circuit shown in figure [rlcfig]. It has two
inputs - the voltage (<span class="math">v</span>) and current (<span class="math">i</span>) sources. Define</p>
<ul class="simple">
<li><span class="math">x_1</span> - voltage across capacitor <span class="math">C_1</span>, so
<span class="math">C_1\dot{x}_1</span> is the corresponding current;</li>
<li><span class="math">x_2</span> - voltage across capacitor <span class="math">C_2</span>, so the
corresponding current is <span class="math">C_2\dot{x}_2</span>.</li>
<li><span class="math">x_3</span> - current through the inductor <span class="math">L</span>, so the voltage
across the inductor is <span class="math">L\dot{x}_3</span>.</li>
</ul>
<p>Applying Kirchoff current and voltage laws we arrive at the linear
system,</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c}
\dot{x}_1\\
\dot{x}_2\\
\dot{x}_3\end{array}\right] = \left[\begin{array}{ccc}
-\frac{1}{R_1C_1} &amp; 0 &amp; -\frac{1}{C_1}\\
0 &amp; 0 &amp; \frac{1}{C_2}\\
\frac{1}{L} &amp; -\frac{1}{L} &amp; -\frac{R_2}{L}\end{array}\right]
\left[\begin{array}{c}
x_1\\
x_2\\
x_3\end{array}\right] + \left[\begin{array}{cc}
\frac{1}{R_1C_1} &amp; \frac{1}{C_1}\\
0 &amp; 0\\
0 &amp; 0\end{array}\right]\left[\begin{array}{c}
v\\
i\end{array}\right]. \label{rlceq}\end{split}\]</div>
<p>The parameters <span class="math">R_1</span>, <span class="math">R_2</span>, <span class="math">C_1</span>, <span class="math">C_2</span> and
<span class="math">L</span>, as well as the inputs, may depend on time. Suppose, for time
<span class="math">0\leqslantt<2</span>, <span class="math">R_1=2</span> Ohm, <span class="math">R_2=1</span> Ohm,
<span class="math">C_1=3</span> F, <span class="math">C_2=7</span> F, <span class="math">L=2</span> H, both inputs, <span class="math">v</span>
and <span class="math">i</span> are present and bounded by ellipsoid
<span class="math">{\mathcal E}(0,I)</span>; and for time <span class="math">t\geqslant2</span>,
<span class="math">R_1=R_2=2</span> Ohm, <span class="math">C_1=C_2=3</span> F, <span class="math">L=6</span> H, the current
source is turned off, and <span class="math">|v|\leqslant1</span>. Then, system ([rlceq])
can be rewritten as</p>
<div class="math">
\[\begin{split}\left[\begin{array}{c}
\dot{x}_1\\
\dot{x}_2\\
\dot{x}_3\end{array}\right] = \left\{\begin{array}{ll}
\left[\begin{array}{ccc}
-\frac{1}{6} &amp; 0 &amp; -\frac{1}{3}\\
0 &amp; 0 &amp; \frac{1}{7}\\
\frac{1}{2} &amp; -\frac{1}{2} &amp; -\frac{1}{2}\end{array}\right]
\left[\begin{array}{c}
x_1\\
x_2\\
x_3\end{array}\right] + \left[\begin{array}{cc}
\frac{1}{6} &amp; \frac{1}{3}\\
0 &amp; 0\\
0 &amp; 0\end{array}\right]\left[\begin{array}{c}
v\\
i\end{array}\right], &amp; 0\leqslantt&lt; 2, \\
\left[\begin{array}{ccc}
-\frac{1}{6} &amp; 0 &amp; -\frac{1}{3}\\
0 &amp; 0 &amp; \frac{1}{3}\\
\frac{1}{6} &amp; -\frac{1}{6} &amp; -\frac{1}{3}\end{array}\right]
\left[\begin{array}{c}
x_1\\
x_2\\
x_3\end{array}\right] + \left[\begin{array}{c}
\frac{1}{6} \\
0 \\
0 \end{array}\right]v, &amp; 2\leqslantt. \end{array}\right.
\label{rlceq2}\end{split}\]</div>
<p>We can compute the reach set of ([rlceq2]) for some time <span class="math">t>2</span>,
say, <span class="math">t=3</span>.</p>
<p>Figure [rlcreachfig](a) shows how the reach set projection onto
<span class="math">(x_1, x_2)</span> of system ([rlceq2]) evolves in time from <span class="math">t=0</span>
to <span class="math">t=3</span>. The external reach set approximation for the first
dynamics is in red, the internal approximation is in green. The dynamics
switches at <span class="math">t=2</span>. The external reach set approximation for the
second dynamics is in yellow, its internal approximation is in blue. The
full three-dimensional external (yellow) and internal (blue)
approximations of the reach set are shown in figure [rlcreachfig](b).</p>
<p>To find out where the system should start at time <span class="math">t=0</span> in order
to reach a neighborhood M of the origin at time <span class="math">t=3</span>, we compute
the backward reach set from <span class="math">t=3</span> to <span class="math">t=0</span>. Figure
[rlcreachfig](c) presents the evolution of the reach set projection onto
<span class="math">(x_1, x_2)</span> in backward time. Again, external and internal
approximations corresponding to the first dynamics are shown in red and
green, and to the second dynamics in yellow and blue. The full
dimensional backward reach set external and internal approximations of
system ([rlceq2]) at time <span class="math">t=0</span> is shown in figure
[rlcreachfig](d).</p>
</div>
<div class="section" id="hybrid-system">
<h2>Hybrid System<a class="headerlink" href="#hybrid-system" title="Permalink to this headline">¶</a></h2>
<p>There is no explicit implementation of the reachability analysis for
hybrid systems in the <em>Ellipsoidal Toolbox</em>. Nonetheless, the operations
of intersection available in the toolbox allow us to work with certain
class of hybrid systems, namely, hybrid systems with affine continuous
dynamics whose guards are ellipsoids, hyperplanes, halfspaces or
polytopes.</p>
<p>We consider the <em>switching-mode model</em> of highway traffic presented in
L.Muñoz et al. (2003). The highway segment is divided into <span class="math">N</span>
cells as shown in figure [hwfig]. In this particular case, <span class="math">N=4</span>.
The traffic density in cell <span class="math">i</span> is <span class="math">x_i</span> vehicles per mile,
<span class="math">i=1,2,3,4</span>.</p>
<p>Define</p>
<ul class="simple">
<li><span class="math">v_i</span> - average speed in mph, in the <span class="math">i</span>-th cell,
<span class="math">i=1,2,3,4</span>;</li>
<li><span class="math">w_i</span> - backward congestion wave propagation speed in mph, in
the <span class="math">i</span>-th highway cell, <span class="math">i=1,2,3,4</span>;</li>
<li><span class="math">x_{Mi}</span> - maximum allowed density in the <span class="math">i</span>-th cell;
when this velue is reached, there is a traffic jam,
<span class="math">i=1,2,3,4</span>;</li>
<li><span class="math">d_i</span> - length of <span class="math">i</span>-th cell in miles,
<span class="math">i=1,2,3,4</span>;</li>
<li><span class="math">T_s</span> - sampling time in hours;</li>
<li><span class="math">b</span> - split ratio for the off-ramp;</li>
<li><span class="math">u_1</span> - traffic flow coming into the highway segment, in
vehicles per hour (vph);</li>
<li><span class="math">u_2</span> - traffic flow coming out of the highway segment (vph);</li>
<li><span class="math">u_3</span> - on-ramp traffic flow (vph).</li>
</ul>
<p>Highway traffic operates in two modes: <em>free-flow</em> in normal operation;
and <em>congested</em> mode, when there is a jam. Traffic flow in free-flow
mode is described by</p>
<div class="math">
\[\begin{split}\begin{aligned}
\left[\begin{array}{c}
x_1[t+1]\\
x_2[t+1]\\
x_3[t+1]\\
x_4[t+1]\end{array}\right] &amp; = &amp; \left[\begin{array}{cccc}
1-\frac{v_1T_s}{d_1} &amp; 0 &amp; 0 &amp; 0\\
\frac{v_1T_s}{d_2} &amp; 1-\frac{v_2T_s}{d_2} &amp; 0 &amp; 0\\
0 &amp; \frac{v_2T_s}{d_3} &amp; 1-\frac{v_3T_s}{d_3} &amp; 0\\
0 &amp; 0 &amp; (1-b)\frac{v_3T_s}{d_4} &amp; 1-\frac{v_4T_s}{d_4}\end{array}\right]
\left[\begin{array}{c}
x_1[t]\\
x_2[t]\\
x_3[t]\\
x_4[t]\end{array}\right] \nonumber\\
&amp; + &amp; \left[\begin{array}{ccc}
\frac{v_1T_s}{d_1} &amp; 0 &amp; 0\\
0 &amp; 0 &amp; \frac{v_2T_s}{d_2}\\
0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0\end{array}\right]\left[\begin{array}{c}
u_1\\
u_2\\
u_3\end{array}\right]. \label{fflow}\end{aligned}\end{split}\]</div>
<p>The equation for the congested mode is</p>
<div class="math">
\[\begin{split}\begin{aligned}
\left[\begin{array}{c}
x_1[t+1]\\
x_2[t+1]\\
x_3[t+1]\\
x_4[t+1]\end{array}\right] &amp; = &amp; \left[\begin{array}{cccc}
1-\frac{w_1T_s}{d_1} &amp; \frac{w_2T_s}{d_1} &amp; 0 &amp; 0\\
0 &amp; 1-\frac{w_2T_s}{d_2} &amp; \frac{w_3T_s}{d_2} &amp; 0\\
0 &amp; 0 &amp; 1-\frac{w_3T_s}{d_3} &amp; \frac{1}{1-b}\frac{w_4T_s}{d_3}\\
0 &amp; 0 &amp; 0 &amp; 1-\frac{w_4T_s}{d_4}\end{array}\right]
\left[\begin{array}{c}
x_1[t]\\
x_2[t]\\
x_3[t]\\
x_4[t]\end{array}\right] \nonumber\\
&amp; + &amp; \left[\begin{array}{ccc}
0 &amp; 0 &amp; \frac{w_1T_s}{d_1}\\
0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0\\
0 &amp; -\frac{w_4T_s}{d_4} &amp; 0\end{array}\right]\left[\begin{array}{c}
u_1\\
u_2\\
u_3\end{array}\right] \nonumber\\
&amp; + &amp; \left[\begin{array}{cccc}
\frac{w_1T_s}{d_1} &amp; -\frac{w_2T_s}{d_1} &amp; 0 &amp; 0\\
0 &amp; \frac{w_2T_s}{d_2} &amp; -\frac{w_3T_s}{d_2} &amp; 0\\
0 &amp; 0 &amp; \frac{w_3T_s}{d_3} &amp; -\frac{1}{1-b}\frac{w_4T_s}{d_3}\\
0 &amp; 0 &amp; 0 &amp; \frac{w_4T_s}{d_4}\end{array}\right]
\left[\begin{array}{c}
x_{M1}\\
x_{M2}\\
x_{M3}\\
x_{M4}\end{array}\right]. \label{cflow}\end{aligned}\end{split}\]</div>
<p>The switch from the free-flow to the congested mode occurs when the
density <span class="math">x_2</span> reaches <span class="math">x_{M2}</span>. In other words, the
hyperplane <span class="math">H([0 ~ 1 ~ 0 ~ 0]^T, x_{M2})</span> is the guard.</p>
<p>We indicate how to implement the reach set computation of this hybrid
system. We first define the two linear systems and the guard.</p>
<p>We assume that initially the system is in free-flow mode. Given a set of
initial conditions, we compute the reach set according to dynamics
([fflow]) for certain number of time steps. We will consider the
external approximation of the reach set by a single ellipsoid.</p>
<p>Having obtained the ellipsoidal array externalEllMat representing the
reach set evolving in time, we determine the ellipsoids in the array
that intersect the guard.</p>
<p>Analyzing the values in array dVec, we conclude that the free-flow reach
set has nonempty intersection with hyperplane grdHyp at <span class="math">t=18</span> for
the first time, and at <span class="math">t=68</span> for the last time. Between
<span class="math">t=18</span> and <span class="math">t=68</span> it crosses the guard. Figure
[hwreachfig](a) shows the free-flow reach set projection onto
<span class="math">(x_1,x_2,x_3)</span> subspace for <span class="math">t=10</span>, before the guard
crossing; figure [hwreachfig](b) for <span class="math">t=50</span>, during the guard
crossing; and figure [hwreachfig](c) for <span class="math">t=80</span>, after the guard
was crossed.</p>
<p>For each time step that the intersection of the free-flow reach set and
the guard is nonempty, we establish a new initial time and a set of
initial conditions for the reach set computation according to dynamics
([cflow]). The initial time is the array index minus one, and the set of
initial conditions is the intersection of the free-flow reach set with
the guard.</p>
<p>The union of reach sets in array crs forms the reach set for the
congested dynamics.</p>
<p>A summary of the reach set computation of the linear hybrid system
([fflow]-[cflow]) for <span class="math">N=100</span> time steps with one guard crossing
is given in figure [hwreachfig](d), which shows the projection of the
reach set trace onto <span class="math">(x_1,x_2)</span> subspace. The system starts
evolving in time in free-flow mode from a set of initial conditions at
<span class="math">t=0</span>, whose boundary is shown in magenta. The free-flow reach set
evolving from <span class="math">t=0</span> to <span class="math">t=100</span> is shown in blue. Between
<span class="math">t=18</span> and <span class="math">t=68</span> the free-flow reach set crosses the guard.
The guard is shown in red. For each nonempty intersection of the
free-flow reach set and the guard, the congested mode reach set starts
evolving in time until <span class="math">t=100</span>. All the congested mode reach sets
are shown in green. Observe that in the congested mode, the density
<span class="math">x_2</span> in the congested part decreases slightly, while the density
<span class="math">x_1</span> upstream of the congested part increases. The blue set above
the guard is not actually reached, because the state evolves according
to the green region.</p>
</div>
</div>
<div class="section" id="summary-and-outlook">
<h1>Summary and Outlook<a class="headerlink" href="#summary-and-outlook" title="Permalink to this headline">¶</a></h1>
<p>Although some of the operations with ellipsoids are present in the
commercial Geometric Bounding Toolbox Veres et al. (2001; “Geometric
Bounding Toolbox Homepage”), the ellipsoid-related functionality of that
toolbox is rather limited.</p>
<p><em>Ellipsoidal Toolbox</em> is the first free MATLAB package that implements
ellipsoidal calculus and uses ellipsoidal methods for reachability
analysis of continuous- and discrete-time affine systems,
continuous-time linear systems with disturbances and switched systems,
whose dynamics changes at known times. The reach set computation for
hybrid systems whose guards are hyperplanes or polyhedra is not
implemented explicitly, but the tool for such computation exists,
namely, the operations of intersection of ellipsoid with hyperplane and
ellipsoid with halfspace.</p>
</div>
<div class="section" id="acknowledgement">
<h1>Acknowledgement<a class="headerlink" href="#acknowledgement" title="Permalink to this headline">¶</a></h1>
<p>The authors would like to thank Alexander B. Kurzhanski, Manfred Morari,
Johan Löfberg, Michal Kvasnica and Goran Frehse for their support of
this work by useful advice and encouragement.</p>
</div>
<div class="section" id="function-reference">
<h1>Function Reference<a class="headerlink" href="#function-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="ellipsoid">
<h2>ellipsoid<a class="headerlink" href="#ellipsoid" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>CALCGRID - computes grid of 2d or 3d sphere and vertices for each face
           in the grid with number of points taken from ellObj
           nPlot2dPoints or nPlot3dPoints parameters</pre>
</div>
<div class="highlight-python"><pre>CHECKISME - determine whether input object is ellipsoid. And display
            message and abort function if input object
            is not ellipsoid

Input:
  regular:
      someObjArr: any[] - any type array of objects.

Example:
  ellObj = ellipsoid([1; 2], eye(2));
  ellipsoid.checkIsMe(ellObj)</pre>
</div>
<div class="highlight-python"><pre>Ellipsoid library of the Ellipsoidal Toolbox.


Constructor and data accessing functions:
-----------------------------------------
 ellipsoid    - Constructor of ellipsoid object.
 double       - Returns parameters of ellipsoid, i.e. center and shape
                matrix.
 parameters   - Same function as 'double'(legacy matter).
 dimension    - Returns dimension of ellipsoid and its rank.
 isdegenerate - Checks if ellipsoid is degenerate.
 isempty      - Checks if ellipsoid is empty.
 maxeig       - Returns the biggest eigenvalue of the ellipsoid.
 mineig       - Returns the smallest eigenvalue of the ellipsoid.
 trace        - Returns the trace of the ellipsoid.
 volume       - Returns the volume of the ellipsoid.


Overloaded operators and functions:
-----------------------------------
 eq      - Checks if two ellipsoids are equal.
 ne      - The opposite of 'eq'.
 gt, ge  - E1 &gt; E2 (E1 &gt;= E2) checks if, given the same center ellipsoid
           E1 contains E2.
 lt, le  - E1 &lt; E2 (E1 &lt;= E2) checks if, given the same center ellipsoid
           E2 contains E1.
 mtimes  - Given matrix A in R^(mxn) and ellipsoid E in R^n, returns
           (A * E).
 plus    - Given vector b in R^n and ellipsoid E in R^n, returns (E + b).
 minus   - Given vector b in R^n and ellipsoid E in R^n, returns (E - b).
 uminus  - Changes the sign of the center of ellipsoid.
 display - Displays the details about given ellipsoid object.
 inv     - inverts the shape matrix of the ellipsoid.
 plot    - Plots ellipsoid in 1D, 2D and 3D.


Geometry functions:
-------------------
 move2origin        - Moves the center of ellipsoid to the origin.
 shape              - Same as 'mtimes', but modifies only shape matrix of
                      the ellipsoid leaving its center as is.
 rho                - Computes the value of support function and
                      corresponding boundary point of the ellipsoid in
                      the given direction.
 polar              - Computes the polar ellipsoid to an ellipsoid that
                      contains the origin.
 projection         - Projects the ellipsoid onto a subspace specified
                      by  orthogonal basis vectors.
 minksum            - Computes and plots the geometric (Minkowski) sum of
                      given ellipsoids in 1D, 2D and 3D.
 minksum_ea         - Computes the external ellipsoidal approximation of
                      geometric sum of given ellipsoids in given
                      direction.
 minksum_ia         - Computes the internal ellipsoidal approximation of
                      geometric sum of given ellipsoids in given
                      direction.
 minkdiff           - Computes and plots the geometric (Minkowski)
                      difference of given ellipsoids in 1D, 2D and 3D.
 minkdiff_ea        - Computes the external ellipsoidal approximation of
                      geometric difference of two ellipsoids in given
                      direction.
 minkdiff_ia        - Computes the internal ellipsoidal approximation of
                      geometric difference of two ellipsoids in given
                      direction
 minkpm             - Computes and plots the geometric (Minkowski)
                      difference of a geometric sum of ellipsoids and a
                      single ellipsoid in 1D, 2D and 3D.
 minkpm_ea          - Computes the external ellipsoidal approximation of
                      the geometric difference of a geometric sum of
                      ellipsoids and a single ellipsoid in given
                      direction.
 minkpm_ia          - Computes the internal ellipsoidal approximation of
                      the geometric difference of a geometric sum of
                      ellipsoids and a single ellipsoid in given
                      direction.
 minkmp             - Computes and plots the geometric (Minkowski) sum of
                      a geometric difference of two single ellipsoids and
                      a geometric sum of ellipsoids in 1D, 2D and 3D.
 minkmp_ea          - Computes the external ellipsoidal approximation of
                      the geometric sum of a geometric difference of two
                      single ellipsoids and a geometric sum of ellipsoids
                      in given direction.
 minkmp_ia          -  Computes the internal ellipsoidal approximation of
                      the geometric sum of a geometric difference of
                      two single ellipsoids and a geometric sum of ellipsoids
                      in given direction.
 isbaddirection     - Checks if ellipsoidal approximation of geometric difference
                      of two ellipsoids in the given direction can be computed.
 doesIntersectionContain           - Checks if the union or intersection of
                      ellipsoids or polytopes lies inside the intersection
                      of given ellipsoids.
 isinternal         - Checks if given vector belongs to the union or intersection
                      of given ellipsoids.
 distance           - Computes the distance from ellipsoid to given point,
                      ellipsoid, hyperplane or polytope.
 intersect          - Checks if the union or intersection of ellipsoids intersects
                      with given ellipsoid, hyperplane, or polytope.
 intersection_ea    - Computes the minimal volume ellipsoid containing intersection
                      of two ellipsoids, ellipsoid and halfspace, or ellipsoid
                      and polytope.
 intersection_ia    - Computes the maximal ellipsoid contained inside the
                      intersection of two ellipsoids, ellipsoid and halfspace
                      or ellipsoid and polytope.
 ellintersection_ia - Computes maximum volume ellipsoid that is contained
                      in the intersection of given ellipsoids (can be more than 2).
 ellunion_ea        - Computes minimum volume ellipsoid that contains
                      the union of given ellipsoids.
 hpintersection     - Computes the intersection of ellipsoid with hyperplane.</pre>
</div>
<div class="highlight-python"><pre>DIMENSION - returns the dimension of the space in which the ellipsoid is
            defined and the actual dimension of the ellipsoid.

Input:
  regular:
    myEllArr: ellipsoid[nDims1,nDims2,...,nDimsN] - array of ellipsoids.

Output:
  regular:
    dimArr: double[nDims1,nDims2,...,nDimsN] - space dimensions.

  optional:
    rankArr: double[nDims1,nDims2,...,nDimsN] - dimensions of the
           ellipsoids in myEllArr.

Example:
  firstEllObj = ellipsoid();
  tempMatObj = [3 1; 0 1; -2 1];
  secEllObj = ellipsoid([1; -1; 1], tempMatObj*tempMatObj');
  thirdEllObj = ellipsoid(eye(2));
  fourthEllObj = ellipsoid(0);
  ellMat = [firstEllObj secEllObj; thirdEllObj fourthEllObj];
  [dimMat, rankMat] = ellMat.dimension()

  dimMat =

     0     3
     2     1

  rankMat =

     0     2
     2     0</pre>
</div>
<div class="highlight-python"><pre>DISP - Displays ellipsoid object.

Input:
  regular:
    myEllMat: ellipsoid [mRows, nCols] - matrix of ellipsoids.

Example:
  ellObj = ellipsoid([-2; -1], [2 -1; -1 1]);
  disp(ellObj)

  Ellipsoid with parameters
  Center:
      -2
      -1

  Shape Matrix:
       2    -1
      -1     1</pre>
</div>
<div class="highlight-python"><pre>DISPLAY - Displays the details of the ellipsoid object.

Input:
  regular:
      myEllMat: ellipsoid [mRows, nCols] - matrix of ellipsoids.

Example:
  ellObj = ellipsoid([-2; -1], [2 -1; -1 1]);
  display(ellObj)

  ellObj =

  Center:
      -2
      -1

  Shape Matrix:
       2    -1
      -1     1

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>DISTANCE - computes distance between the given ellipsoid (or array of
           ellipsoids) to the specified object (or arrays of objects):
           vector, ellipsoid, hyperplane or polytope.

Input:
  regular:
      ellObjArr: ellipsoid [nDims1, nDims2,..., nDimsN] -  array of
         ellipsoids of the same dimension.
      objArray: double / ellipsoid / hyperplane / polytope [nDims1,
          nDims2,..., nDimsN] - array of vectors or ellipsoids or
          hyperplanes or polytopes. If number of elements in objArray
          is more than 1, then it must be equal to the number of elements
          in ellObjArr.

  optional:
      isFlagOn: logical[1,1] - if true then distance is  computed in
          ellipsoidal metric, if false - in Euclidean metric (by default
          isFlagOn=false).

Output:
  regular:
    distValArray: double [nDims1, nDims2,..., nDimsN] - array of pairwise
          calculated distances.
          Negative distance value means
              for ellipsoid and vector: vector belongs to the ellipsoid,
              for ellipsoid and hyperplane: ellipsoid intersects the
                  hyperplane.
              Zero distance value means for ellipsoid and vector: vector
                  is aboundary point of the ellipsoid,
              for ellipsoid and hyperplane: ellipsoid  touches the
                  hyperplane.
  optional:
      statusArray: double [nDims1, nDims2,..., nDimsN] - array of time of
          computation of ellipsoids-vectors or ellipsoids-ellipsoids
          distances, or status of cvx solver for ellipsoids-polytopes
          distances.

Literature:
 1. Lin, A. and Han, S. On the Distance between Two Ellipsoids.
    SIAM Journal on Optimization, 2002, Vol. 13, No. 1 : pp. 298-308
 2. Stanley Chan, "Numerical method for Finding Minimum Distance to an
    Ellipsoid".
    http://videoprocessing.ucsd.edu/~stanleychan/publication/...
    unpublished/Ellipse.pdf

Example:
  ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  tempMat = [1 1; 1 -1; -1 1; -1 -1]';
  distVec = ellObj.distance(tempMat)

  distVec =

       2.3428    1.0855    1.3799    -1.0000</pre>
</div>
<div class="highlight-python"><pre>DOESCONTAIN - checks if one ellipsoid contains the other ellipsoid or
              polytope. The condition for E1 = firstEllArr to contain
              E2 = secondEllArr is
              min(rho(l | E1) - rho(l | E2)) &gt; 0, subject to &lt;l, l&gt; = 1.
              How checked if ellipsoid contains polytope is explained in
              doesContainPoly.
Input:
  regular:
      firstEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - first
          array of ellipsoids.
      secondObjArr: ellipsoid [nDims1,nDims2,...,nDimsN]/
          polytope[nDims1,nDims2,...,nDimsN]/[1,1] - array of the same
          size as firstEllArr or single ellipsoid or polytope.

   properties:
      mode: char[1, 1] - 'u' or 'i', go to description.
      computeMode: char[1,] - 'highDimFast' or 'lowDimFast'. Determines,
          which way function is computed, when secObjArr is polytope. If
          secObjArr is ellipsoid computeMode is ignored. 'highDimFast'
          works  faster for  high dimensions, 'lowDimFast' for low. If
          this property is omitted if dimension of ellipsoids is greater
          then 10, then 'hightDimFast' is choosen, otherwise -
          'lowDimFast'

Output:
  isPosArr: logical[nDims1,nDims2,...,nDimsN],
      resArr(iCount) = true - firstEllArr(iCount)
      contains secondObjArr(iCount), false - otherwise.

Example:
  firstEllObj = ellipsoid([-2; -1], [2 -1; -1 1]);
  secEllObj = ellipsoid([-1;0], eye(2));
  doesContain(firstEllObj,secEllObj)

  ans =

       0</pre>
</div>
<div class="highlight-python"><pre>DOESINTERSECTIONCONTAIN - checks if the intersection of ellipsoids
                          contains the union or intersection of given
                          ellipsoids or polytopes.

  res = DOESINTERSECTIONCONTAIN(fstEllArr, secEllArr, mode)
      Checks if the union
      (mode = 'u') or intersection (mode = 'i') of ellipsoids in
      secEllArr lies inside the intersection of ellipsoids in
      fstEllArr. Ellipsoids in fstEllArr and secEllArr must be
      of the same dimension. mode = 'u' (default) - union of
      ellipsoids in secEllArr. mode = 'i' - intersection.
  res = DOESINTERSECTIONCONTAIN(fstEllArr, secPolyArr, mode)
       Checks if the union
      (mode = 'u') or intersection (mode = 'i')  of polytopes in
      secPolyArr lies inside the intersection of ellipsoids in
      fstEllArr. Ellipsoids in fstEllArr and polytopes in secPolyArr
      must be of the same dimension. mode = 'u' (default) - union of
      polytopes in secPolyMat. mode = 'i' - intersection.

  To check if the union of ellipsoids secEllArr belongs to the
  intersection of ellipsoids fstEllArr, it is enough to check that
  every ellipsoid of secEllMat is contained in every
  ellipsoid of fstEllArr.
  Checking if the intersection of ellipsoids in secEllMat is inside
  intersection fstEllMat can be formulated as quadratically
  constrained quadratic programming (QCQP) problem.

  Let fstEllArr(iEll) = E(q, Q) be an ellipsoid with center q and shape
  matrix Q. To check if this ellipsoid contains the intersection of
  ellipsoids in secObjArr:
  E(q1, Q1), E(q2, Q2), ..., E(qn, Qn), we define the QCQP problem:
                    J(x) = &lt;(x - q), Q^(-1)(x - q)&gt; --&gt; max
  with constraints:
                    &lt;(x - q1), Q1^(-1)(x - q1)&gt; &lt;= 1   (1)
                    &lt;(x - q2), Q2^(-1)(x - q2)&gt; &lt;= 1   (2)
                    ................................
                    &lt;(x - qn), Qn^(-1)(x - qn)&gt; &lt;= 1   (n)

  If this problem is feasible, i.e. inequalities (1)-(n) do not
  contradict, or, in other words, intersection of ellipsoids
  E(q1, Q1), E(q2, Q2), ..., E(qn, Qn) is nonempty, then we can find
  vector y such that it satisfies inequalities (1)-(n)
  and maximizes function J. If J(y) &lt;= 1, then ellipsoid E(q, Q)
  contains the given intersection, otherwise, it does not.

  The intersection of polytopes is a polytope, which is computed
  by the standard routine of MPT. How checked if intersection of
  ellipsoids contains polytope is explained in doesContainPoly.

  Checking if the union of polytopes belongs to the intersection
  of ellipsoids is the same as checking if its convex hull belongs
  to this intersection.

Input:
  regular:
      fstEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          of the same size.
      secEllArr: ellipsoid /
          polytope [nDims1,nDims2,...,nDimsN] - array of ellipsoids or
          polytopes of the same sizes.

          note: if mode == 'i', then fstEllArr, secEllVec should be
              array.

  properties:
      mode: char[1, 1] - 'u' or 'i', go to description.
      computeMode: char[1,] - 'highDimFast' or 'lowDimFast'. Determines,
          which way function is computed, when secObjArr is polytope. If
          secObjArr is ellipsoid computeMode is ignored. 'highDimFast'
          works  faster for  high dimensions, 'lowDimFast' for low. If
          this property is omitted if dimension of ellipsoids is greater
          then 10, then 'hightDimFast' is choosen, otherwise -
          'lowDimFast'


Output:
  res: double[1, 1] - result:
      -1 - problem is infeasible, for example, if s = 'i',
          but the intersection of ellipsoids in E2 is an empty set;
      0 - intersection is empty;
      1 - if intersection is nonempty.
  status: double[0, 0]/double[1, 1] - status variable. status is empty
      if mode == 'u' or mSecRows == nSecCols == 1.

Example:
  firstEllObj = [0 ; 0] + ellipsoid(eye(2, 2));
  secEllObj = [0 ; 0] + ellipsoid(2*eye(2, 2));
  thirdEllObj = [1; 0] + ellipsoid(0.5 * eye(2, 2));
  secEllObj.doesIntersectionContain([firstEllObj secEllObj], 'i')

  ans =

       1</pre>
</div>
<div class="highlight-python"><pre>DOUBLE - returns parameters of the ellipsoid.

Input:
  regular:
      myEll: ellipsoid [1, 1] - single ellipsoid of dimention nDims.


Output:
  myEllCentVec: double[nDims, 1] - center of the ellipsoid myEll.

  myEllShMat: double[nDims, nDims] - shape matrix of the ellipsoid myEll.

Example:
  ellObj = ellipsoid([-2; -1], [2 -1; -1 1]);
  [centVec, shapeMat] = double(ellObj)
  centVec =

      -2
      -1


  shapeMat =

       2    -1
      -1     1</pre>
</div>
<div class="highlight-python"><pre>ELLBNDR_2D - compute the boundary of 2D ellipsoid. Private method.

Input:
  regular:
      myEll: ellipsoid [1, 1]- ellipsoid of the dimention 2.
  optional:
      nPoints: number of boundary points

Output:
  regular:
      bpMat: double[nPoints,2] - boundary points of ellipsoid
  optional:
      fVec: double[1,nFaces] - indices of points in each face of
          bpMat graph</pre>
</div>
<div class="highlight-python"><pre>ELLBNDR_3D - compute the boundary of 3D ellipsoid.

Input:
  regular:
      myEll: ellipsoid [1, 1]- ellipsoid of the dimention 3.

  optional:
      nPoints: number of boundary points

Output:
  regular:
      bpMat: double[nPoints,3] - boundary points of ellipsoid
  optional:
      fMat: double[nFaces,3] - indices of face verties in bpMat</pre>
</div>
<div class="highlight-python"><pre>ELLINTERSECTION_IA - computes maximum volume ellipsoid that is contained
                     in the intersection of given ellipsoids.


Input:
  regular:
      inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
          ellipsoids of the same dimentions.

Output:
  outEll: ellipsoid [1, 1] - resulting maximum volume ellipsoid.

Example:
  firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
  secEllObj = ellipsoid([1 2], eye(2);
  ellVec = [firstEllObj secEllObj];
  resEllObj = ellintersection_ia(ellVec)

  resEllObj =

  Center:
      0.1847
      1.6914

  Shape Matrix:
      0.0340   -0.0607
     -0.0607    0.1713

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>ELLIPSOID - constructor of the ellipsoid object.

  Ellipsoid E = { x in R^n : &lt;(x - q), Q^(-1)(x - q)&gt; &lt;= 1 }, with current
      "Properties". Here q is a vector in R^n, and Q in R^(nxn) is positive
      semi-definite matrix

  ell = ELLIPSOID - Creates an empty ellipsoid

  ell = ELLIPSOID(shMat) - creates an ellipsoid with shape matrix shMat,
      centered at 0

   ell = ELLIPSOID(centVec, shMat) - creates an ellipsoid with shape matrix
      shMat and center centVec

  ell = ELLIPSOID(centVec, shMat, 'propName1', propVal1,...,
      'propNameN',propValN) - creates an ellipsoid with shape
      matrix shMat, center centVec and propName1 = propVal1,...,
      propNameN = propValN. In other cases "Properties"
      are taken from current values stored in
      elltool.conf.Properties.
  ellMat = Ellipsoid(centVecArray, shMatArray,
      ['propName1', propVal1,...,'propNameN',propValN]) -
      creates an array (possibly multidimensional) of
      ellipsoids with centers centVecArray(:,dim1,...,dimn)
      and matrices shMatArray(:,:,dim1,...dimn) with
      properties if given.

  These parameters can be accessed by DOUBLE(E) function call.
  Also, DIMENSION(E) function call returns the dimension of
  the space in which ellipsoid E is defined and the actual
  dimension of the ellipsoid; function ISEMPTY(E) checks if
  ellipsoid E is empty; function ISDEGENERATE(E) checks if
  ellipsoid E is degenerate.

Input:
  Case1:
    regular:
      shMatArray: double [nDim, nDim] /
          double [nDim, nDim, nDim1,...,nDimn] -
          shape matrices array

  Case2:
    regular:
      centVecArray: double [nDim,1] /
          double [nDim, 1, nDim1,...,nDimn] -
          centers array
      shMatArray: double [nDim, nDim] /
          double [nDim, nDim, nDim1,...,nDimn] -
          shape matrices array


  properties:
      absTol: double [1,1] - absolute tolerance with default value 10^(-7)
      relTol: double [1,1] - relative tolerance with default value 10^(-5)
      nPlot2dPoints: double [1,1] - number of points for 2D plot with
          default value 200
      nPlot3dPoints: double [1,1] - number of points for 3D plot with
           default value 200.

Output:
  ellMat: ellipsoid [1,1] / ellipsoid [nDim1,...nDimn] -
      ellipsoid with specified properties
      or multidimensional array of ellipsoids.

Example:
  ellObj = ellipsoid([1 0 -1 6]', 9*eye(4));</pre>
</div>
<div class="highlight-python"><pre>ELLUNION_EA - computes minimum volume ellipsoid that contains union
              of given ellipsoids.

Input:
  regular:
      inpEllMat: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
          ellipsoids of the same dimentions.

Output:
  outEll: ellipsoid [1, 1] - resulting minimum volume ellipsoid.

Example:
  firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
  secEllObj = ellipsoid([1 2], eye(2));
  ellVec = [firstEllObj secEllObj];
  resEllObj = ellunion_ea(ellVec)
  resEllObj =

  Center:
     -0.3188
      1.2936

  Shape Matrix:
      5.4573    1.3386
      1.3386    4.1037

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>FROMREPMAT - returns array of equal ellipsoids the same
             size as stated in sizeVec argument

  ellArr = fromRepMat(sizeVec) - creates an array  size
           sizeVec of empty ellipsoids.

  ellArr = fromRepMat(shMat,sizeVec) - creates an array
           size sizeVec of ellipsoids with shape matrix
           shMat.

  ellArr = fromRepMat(cVec,shMat,sizeVec) - creates an
           array size sizeVec of ellipsoids with shape
           matrix shMat and center cVec.

Input:
  Case1:
      regular:
          sizeVec: double[1,n] - vector of size, have
          integer values.

  Case2:
      regular:
          shMat: double[nDim, nDim] - shape matrix of
          ellipsoids.
          sizeVec: double[1,n] - vector of size, have
          integer values.

  Case3:
      regular:
          cVec: double[nDim,1] - center vector of
          ellipsoids
          shMat: double[nDim, nDim] - shape matrix of
          ellipsoids.
          sizeVec: double[1,n] - vector of size, have
          integer values.

  properties:
      absTol: double [1,1] - absolute tolerance with default
          value 10^(-7)
      relTol: double [1,1] - relative tolerance with default
          value 10^(-5)
      nPlot2dPoints: double [1,1] - number of points for 2D plot
          with default value 200
      nPlot3dPoints: double [1,1] - number of points for 3D plot
          with default value 200.</pre>
</div>
<div class="highlight-python"><pre>fromStruct -- converts structure array into ellipsoid array.

Input:
  regular:
      SEllArr: struct [nDim1, nDim2, ...] - array
          of structures with the following fields:

      q: double[1, nEllDim] - the center of ellipsoid
      Q: double[nEllDim, nEllDim] - the shape matrix of ellipsoid
Output:
      ellArr: ellipsoid [nDim1, nDim2, ...] - ellipsoid array with size of
          SEllArr.

Example:
s = struct('Q', eye(2), 'q', [0 0]);
ellipsoid.fromStruct(s)

-------ellipsoid object-------
Properties:
   |
   |-- actualClass : 'ellipsoid'
   |--------- size : [1, 1]

Fields (name, type, description):
    'Q'    'double'    'Configuration matrix'
    'q'    'double'    'Center'

Data:
   |
   |-- q : [0 0]
   |       -----
   |-- Q : |1|0|
   |       |0|1|
   |       -----</pre>
</div>
<div class="highlight-python"><pre>GETABSTOL - gives the array of absTol for all elements in ellArr

Input:
  regular:
      ellArr: ellipsoid[nDim1, nDim2, ...] - multidimension array
          of ellipsoids
  optional
      fAbsTolFun: function_handle[1,1] - function that apply
          to the absTolArr. The default is @min.

Output:
  regular:
      absTolArr: double [absTol1, absTol2, ...] - return absTol for
          each element in ellArr
  optional:
      absTol: double[1,1] - return result of work fAbsTolFun with
          the absTolArr

Usage:
  use [~,absTol] = ellArr.getAbsTol() if you want get only
      absTol,
  use [absTolArr,absTol] = ellArr.getAbsTol() if you want get
      absTolArr and absTol,
  use absTolArr = ellArr.getAbsTol() if you want get only absTolArr

Example:
  firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
  secEllObj = ellipsoid([1 2], eye(2));
  ellVec = [firstEllObj secEllObj];
  absTolVec = ellVec.getAbsTol()

  absTolVec =

     1.0e-07 *

      1.0000    1.0000</pre>
</div>
<div class="highlight-python"><pre>GETBOUNDARY - computes the boundary of an ellipsoid.

Input:
  regular:
      myEll: ellipsoid [1, 1]- ellipsoid of the dimention 2 or 3.
  optional:
      nPoints: number of boundary points

Output:
  regular:
      bpMat: double[nPoints,nDim] - boundary points of ellipsoid
  optional:
      fVec: double[1,nFaces]/double[nFacex,nDim] - indices of points in
          each face of bpMat graph</pre>
</div>
<div class="highlight-python"><pre>GETBOUNDARYBYFACTOR - computes grid of 2d or 3d ellipsoid and vertices
                      for each face in the grid</pre>
</div>
<div class="highlight-python"><pre>GETCENTERVEC - returns centerVec vector of given ellipsoid

Input:
  regular:
     self: ellipsoid[1,1]

Output:
  centerVecVec: double[nDims,1] - centerVec of ellipsoid

Example:
  ellObj = ellipsoid([1; 2], eye(2));
  getCenterVec(ellObj)

  ans =

       1
       2</pre>
</div>
<div class="highlight-python"><pre>GETCOPY - gives array the same size as ellArr with copies of elements of
          ellArr.

Input:
  regular:
      ellArr: ellipsoid[nDim1, nDim2,...] - multidimensional array of
          ellipsoids.

Output:
  copyEllArr: ellipsoid[nDim1, nDim2,...] - multidimension array of
      copies of elements of ellArr.

Example:
  firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
  secEllObj = ellipsoid([1; 2], eye(2));
  ellVec = [firstEllObj secEllObj];
  copyEllVec = getCopy(ellVec)

  copyEllVec =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>GETINV - do the same as INV method: inverts shape matrices of ellipsoids
      in the given array, with only difference, that it doesn't modify
      input array of ellipsoids.

Input:
  regular:
    myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids.

Output:
   invEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
      with inverted shape matrices.

Example:
  ellObj = ellipsoid([1; 1], [4 -1; -1 5]);
  invEllObj = ellObj.getInv()

  invEllObj =

  Center:
       1
       1

  Shape Matrix:
      0.2632    0.0526
      0.0526    0.2105

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>GETMOVE2ORIGIN - do the same as MOVE2ORIGIN method: moves ellipsoids in
      the given array to the origin, with only difference, that it doesn't
      modify input array of ellipsoids.

Input:
  regular:
      inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
          ellipsoids.

Output:
  outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
      with the same shapes as in inpEllArr centered at the origin.

Example:
  ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  outEllObj = ellObj.getMove2Origin()

  outEllObj =

  Center:
       0
       0

  Shape:
       4    -1
      -1     1

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>GETNPLOT2DPOINTS - gives value of nPlot2dPoints property of ellipsoids
                   in ellArr

Input:
  regular:
      ellArr: ellipsoid[nDim1, nDim2,...] - mltidimensional array of
          ellipsoids

Output:
      nPlot2dPointsArr: double[nDim1, nDim2,...] - multidimension array
          of nPlot2dPoints property for ellipsoids in ellArr
Example:
  firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
  secEllObj = ellipsoid([1 ;2], eye(2));
  ellVec = [firstEllObj secEllObj];
  ellVec.getNPlot2dPoints()

  ans =

     200   200</pre>
</div>
<div class="highlight-python"><pre>GETNPLOT3DPOINTS - gives value of nPlot3dPoints property of ellipsoids
                   in ellArr

Input:
  regular:
      ellArr: ellipsoid[nDim1, nDim2,...] - mltidimensional array  of
         ellipsoids

Output:
      nPlot2dPointsArr: double[nDim1, nDim2,...] - multidimension array
          of nPlot3dPoints property for ellipsoids in ellArr

Example:
  firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
  secEllObj = ellipsoid([1 ;2], eye(2));
  ellVec = [firstEllObj secEllObj];
  ellVec.getNPlot3dPoints()

  ans =

     200   200</pre>
</div>
<div class="highlight-python"><pre>GETPROJECTION - do the same as PROJECTION method: computes projection of
      the ellipsoid onto the given subspace, with only difference, that
      it doesn't modify input array of ellipsoids.

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.
      basisMat: double[nDim, nSubSpDim] - matrix of orthogonal basis
          vectors

Output:
  projEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
      projected ellipsoids, generally, of lower dimension.

Example:
  ellObj = ellipsoid([-2; -1; 4], [4 -1 0; -1 1 0; 0 0 9]);
  basisMat = [0 1 0; 0 0 1]';
  outEllObj = ellObj.getProjection(basisMat)

  outEllObj =

  Center:
      -1
       4

  Shape:
      1     0
      0     9

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>GETRELTOL - gives the array of relTol for all elements in ellArr

Input:
  regular:
      ellArr: ellipsoid[nDim1, nDim2, ...] - multidimension array
          of ellipsoids
  optional:
      fRelTolFun: function_handle[1,1] - function that apply
          to the relTolArr. The default is @min.
Output:
  regular:
      relTolArr: double [relTol1, relTol2, ...] - return relTol for
          each element in ellArr
  optional:
      relTol: double[1,1] - return result of work fRelTolFun with
          the relTolArr

Usage:
  use [~,relTol] = ellArr.getRelTol() if you want get only
      relTol,
  use [relTolArr,relTol] = ellArr.getRelTol() if you want get
      relTolArr and relTol,
  use relTolArr = ellArr.getRelTol() if you want get only relTolArr

Example:
  firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
  secEllObj = ellipsoid([1 ;2], eye(2));
  ellVec = [firstEllObj secEllObj];
  ellVec.getRelTol()

  ans =

     1.0e-05 *

      1.0000    1.0000</pre>
</div>
<div class="highlight-python"><pre>GETSHAPE -  do the same as SHAPE method: modifies the shape matrix of the
   ellipsoid without changing its center, with only difference, that
   it doesn't modify input array of ellipsoids.

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.
      modMat: double[nDim, nDim]/[1,1] - square matrix or scalar

Output:
   outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of modified
      ellipsoids.

Example:
  ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  tempMat = [0 1; -1 0];
  outEllObj = ellObj.getShape(tempMat)

  outEllObj =

  Center:
      -2
      -1

  Shape:
      1     1
      1     4

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>GETSHAPEMAT - returns shapeMat matrix of given ellipsoid

Input:
  regular:
     self: ellipsoid[1,1]

Output:
  shMat: double[nDims,nDims] - shapeMat matrix of ellipsoid

Example:
  ellObj = ellipsoid([1; 2], eye(2));
  getShapeMat(ellObj)

  ans =

       1     0
       0     1</pre>
</div>
<div class="highlight-python"><pre>HPINTERSECTION - computes the intersection of ellipsoid with hyperplane.

Input:
  regular:
      myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
          of ellipsoids.
      myHypArr: hyperplane [nDims1,nDims2,...,nDimsN]/[1,1] - array
          of hyperplanes of the same size.

Output:
  intEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
      resulting from intersections.

  isnIntersectedArr: logical [nDims1,nDims2,...,nDimsN].
      isnIntersectedArr(iCount) = true, if myEllArr(iCount)
      doesn't intersect myHipArr(iCount),
      isnIntersectedArr(iCount) = false, otherwise.

Example:
  ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  hypMat = [hyperplane([0 -1; -1 0]', 1); hyperplane([0 -2; -1 0]', 1)];
  ellMat = ellObj.hpintersection(hypMat)

  ellMat =
  2x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>INTERSECT - checks if the union or intersection of ellipsoids intersects
            given ellipsoid, hyperplane or polytope.

  resArr = INTERSECT(myEllArr, objArr, mode) - Checks if the union
      (mode = 'u') or intersection (mode = 'i') of ellipsoids
      in myEllArr intersects with objects in objArr.
      objArr can be array of ellipsoids, array of hyperplanes,
      or array of polytopes.
      Ellipsoids, hyperplanes or polytopes in objMat must have
      the same dimension as ellipsoids in myEllArr.
      mode = 'u' (default) - union of ellipsoids in myEllArr.
      mode = 'i' - intersection.

  If we need to check the intersection of union of ellipsoids in
  myEllArr (mode = 'u'), or if myEllMat is a single ellipsoid,
  it can be done by calling distance function for each of the
  ellipsoids in myEllArr and objMat, and if it returns negative value,
  the intersection is nonempty. Checking if the intersection of
  ellipsoids in myEllArr (with size of myEllMat greater than 1)
  intersects with ellipsoids or hyperplanes in objArr is more
  difficult. This problem can be formulated as quadratically
  constrained quadratic programming (QCQP) problem.

  Let objArr(iObj) = E(q, Q) be an ellipsoid with center q and shape
  matrix Q. To check if this ellipsoid intersects (or touches) the
  intersection of ellipsoids in meEllArr: E(q1, Q1), E(q2, Q2), ...,
  E(qn, Qn), we define the QCQP problem:
                    J(x) = &lt;(x - q), Q^(-1)(x - q)&gt; --&gt; min
  with constraints:
                     &lt;(x - q1), Q1^(-1)(x - q1)&gt; &lt;= 1   (1)
                     &lt;(x - q2), Q2^(-1)(x - q2)&gt; &lt;= 1   (2)
                     ................................
                     &lt;(x - qn), Qn^(-1)(x - qn)&gt; &lt;= 1   (n)

  If this problem is feasible, i.e. inequalities (1)-(n) do not
  contradict, or, in other words, intersection of ellipsoids
  E(q1, Q1), E(q2, Q2), ..., E(qn, Qn) is nonempty, then we can find
  vector y such that it satisfies inequalities (1)-(n) and minimizes
  function J. If J(y) &lt;= 1, then ellipsoid E(q, Q) intersects or touches
  the given intersection, otherwise, it does not. To check if E(q, Q)
  intersects the union of E(q1, Q1), E(q2, Q2), ..., E(qn, Qn),
  we compute the distances from this ellipsoids to those in the union.
  If at least one such distance is negative,
  then E(q, Q) does intersect the union.

  If we check the intersection of ellipsoids with hyperplane
  objArr = H(v, c), it is enough to check the feasibility
  of the problem
                      1'x --&gt; min
  with constraints (1)-(n), plus
                    &lt;v, x&gt; - c = 0.

  Checking the intersection of ellipsoids with polytope
  objArr = P(A, b) reduces to checking if there any x, satisfying
  constraints (1)-(n) and
                       Ax &lt;= b.

Input:
  regular:
      myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
           ellipsoids.
      objArr: ellipsoid / hyperplane /
          / polytope [nDims1,nDims2,...,nDimsN] - array of ellipsoids or
          hyperplanes or polytopes of the same sizes.

  optional:
      mode: char[1, 1] - 'u' or 'i', go to description.

          note: If mode == 'u', then mRows, nCols should be equal to 1.

Output:
  resArr: double[nDims1,nDims2,...,nDimsN] - return:
      resArr(iCount) = -1 in case parameter mode is set
          to 'i' and the intersection of ellipsoids in myEllArr
          is empty.
      resArr(iCount) = 0 if the union or intersection of
          ellipsoids in myEllArr does not intersect the object
          in objArr(iCount).
      resArr(iCount) = 1 if the union or intersection of
          ellipsoids in myEllArr and the object in objArr(iCount)
          have nonempty intersection.
  statusArr: double[0, 0]/double[nDims1,nDims2,...,nDimsN] - status
      variable. statusArr is empty if mode = 'u'.

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = firstEllObj + [5; 5];
  hypObj  = hyperplane([1; -1]);
  ellVec = [firstEllObj secEllObj];
  ellVec.intersect(hypObj)

  ans =

       1

  ellVec.intersect(hypObj, 'i')

  ans =

      -1</pre>
</div>
<div class="highlight-python"><pre>INTERSECTION_EA - external ellipsoidal approximation of the
                  intersection of two ellipsoids, or ellipsoid and
                  halfspace, or ellipsoid and polytope.

  outEllArr = INTERSECTION_EA(myEllArr, objArr) Given two ellipsoidal
      matrixes of equal sizes, myEllArr and objArr = ellArr, or,
      alternatively, myEllArr or ellMat must be a single ellipsoid,
      computes the ellipsoid that contains the intersection of two
      corresponding ellipsoids from myEllArr and from ellArr.
  outEllArr = INTERSECTION_EA(myEllArr, objArr) Given matrix of
      ellipsoids myEllArr and matrix of hyperplanes objArr = hypArr
      whose sizes match, computes the external ellipsoidal
      approximations of intersections of ellipsoids
      and halfspaces defined by hyperplanes in hypArr.
      If v is normal vector of hyperplane and c - shift,
      then this hyperplane defines halfspace
              &lt;v, x&gt; &lt;= c.
  outEllArr = INTERSECTION_EA(myEllArr, objArr) Given matrix of
      ellipsoids myEllArr and matrix of polytopes objArr = polyArr
      whose sizes match, computes the external ellipsoidal
      approximations of intersections of ellipsoids myEllMat and
      polytopes polyArr.

  The method used to compute the minimal volume overapproximating
  ellipsoid is described in "Ellipsoidal Calculus Based on
  Propagation and Fusion" by Lluis Ros, Assumpta Sabater and
  Federico Thomas; IEEE Transactions on Systems, Man and Cybernetics,
  Vol.32, No.4, pp.430-442, 2002. For more information, visit
  http://www-iri.upc.es/people/ros/ellipsoids.html

  For polytopes this method won't give the minimal volume
  overapproximating ellipsoid, but just some overapproximating ellipsoid.

Input:
  regular:
      myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
          of ellipsoids.
      objArr: ellipsoid / hyperplane /
          / polytope [nDims1,nDims2,...,nDimsN]/[1,1]  - array of
          ellipsoids or hyperplanes or polytopes of the same sizes.

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = firstEllObj + [5; 5];
  ellVec = [firstEllObj secEllObj];
  thirdEllObj  = ell_unitball(2);
  externalEllVec = ellVec.intersection_ea(thirdEllObj)

  externalEllVec =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>INTERSECTION_IA - internal ellipsoidal approximation of the
                  intersection of ellipsoid and ellipsoid,
                  or ellipsoid and halfspace, or ellipsoid
                  and polytope.

  outEllArr = INTERSECTION_IA(myEllArr, objArr) - Given two
      ellipsoidal matrixes of equal sizes, myEllArr and
      objArr = ellArr, or, alternatively, myEllMat or ellMat must be
      a single ellipsoid, comuptes the internal ellipsoidal
      approximations of intersections of two corresponding ellipsoids
      from myEllMat and from ellMat.
  outEllArr = INTERSECTION_IA(myEllArr, objArr) - Given matrix of
      ellipsoids myEllArr and matrix of hyperplanes objArr = hypArr
      whose sizes match, computes the internal ellipsoidal
      approximations of intersections of ellipsoids and halfspaces
      defined by hyperplanes in hypMat.
      If v is normal vector of hyperplane and c - shift,
      then this hyperplane defines halfspace
                 &lt;v, x&gt; &lt;= c.
  outEllArr = INTERSECTION_IA(myEllArr, objArr) - Given matrix of
      ellipsoids  myEllArr and matrix of polytopes objArr = polyArr
      whose sizes match, computes the internal ellipsoidal
      approximations of intersections of ellipsoids myEllArr
      and polytopes polyArr.

  The method used to compute the minimal volume overapproximating
  ellipsoid is described in "Ellipsoidal Calculus Based on
  Propagation and Fusion" by Lluis Ros, Assumpta Sabater and
  Federico Thomas; IEEE Transactions on Systems, Man and Cybernetics,
  Vol.32, No.4, pp.430-442, 2002. For more information, visit
  http://www-iri.upc.es/people/ros/ellipsoids.html

  The method used to compute maximum volume ellipsoid inscribed in
  intersection of ellipsoid and polytope, is modified version of
  algorithm of finding maximum volume ellipsoid inscribed in intersection
  of ellipsoids discribed in Stephen Boyd and Lieven Vandenberghe "Convex
  Optimization". It works properly for nondegenerate ellipsoid, but for
  degenerate ellipsoid result would not lie in this ellipsoid. The result
  considered as empty ellipsoid, when maximum absolute velue of element
  in its matrix is less than myEllipsoid.getAbsTol().

Input:
  regular:
      myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
          of ellipsoids.
      objArr: ellipsoid / hyperplane /
          / polytope [nDims1,nDims2,...,nDimsN]/[1,1]  - array of
          ellipsoids or hyperplanes or polytopes of the same sizes.

Output:
   outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of internal
      approximating ellipsoids; entries can be empty ellipsoids
      if the corresponding intersection is empty.

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = firstEllObj + [5; 5];
  ellVec = [firstEllObj secEllObj];
  thirdEllObj  = ell_unitball(2);
  internalEllVec = ellVec.intersection_ia(thirdEllObj)

  internalEllVec =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>INV - inverts shape matrices of ellipsoids in the given array,
      modified given array is on output (not its copy).


  invEllArr = INV(myEllArr)  Inverts shape matrices of ellipsoids
      in the array myEllMat. In case shape matrix is sigular, it is
      regularized before inversion.

Input:
  regular:
    myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids.

Output:
   myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
      with inverted shape matrices.

Example:
  ellObj = ellipsoid([1; 1], [4 -1; -1 5]);
  ellObj.inv()

  ans =

  Center:
       1
       1

  Shape Matrix:
      0.2632    0.0526
      0.0526    0.2105

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>ISEMPTY - checks if the ellipsoid object is empty.

Input:
  regular:
      myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
           ellipsoids.

Output:
  isPositiveArr: logical[nDims1,nDims2,...,nDimsN],
      isPositiveArr(iCount) = true - if ellipsoid
      myEllMat(iCount) is empty, false - otherwise.

Example:
  ellObj = ellipsoid();
  isempty(ellObj)

  ans =

       1</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - produces logical array the same size as
          ellFirstArr/ellFirstArr (if they have the same).
          isEqualArr[iDim1, iDim2,...] is true if corresponding
          ellipsoids are equal and false otherwise.

Input:
  regular:
      ellFirstArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
          of ellipsoids.
      ellSecArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
          of ellipsoids.
  properties:
      'isPropIncluded': makes to compare second value properties, such as
      absTol etc.
Output:
  isEqualArr: logical[nDim1, nDim2,...] - multidimension array of
      logical values. isEqualArr[iDim1, iDim2,...] is true if
      corresponding ellipsoids are equal and false otherwise.

  reportStr: char[1,] - comparison report.</pre>
</div>
<div class="highlight-python"><pre>ISINSIDE - checks if given ellipsoid(or array of
           ellipsoids) lies inside given object(or array
           of objects): ellipsoid or polytope.

Input:
  regular:
      ellArr: ellipsoid[nDims1,nDims2,...,nDimsN] - array
              of ellipsoids of the same dimension.
      objArr: ellipsoid/
              polytope[nDims1,nDims2,...,nDimsN] of
              objects of the same dimension. If
              ellArr and objArr both non-scalar, than
              size of ellArr must be the same as size of
              objArr. Note that polytopes could be
              combined only in vector of size [1,N].
Output:
  regular:
      resArr: logical[nDims1,nDims2,...,nDimsN] array of
              results. resArr[iDim1,...,iDimN] = true, if
              ellArr[iDim1,...,iDimN] lies inside
              objArr[iDim1,...,iDimN].

Example:
  firstEllObj = [0 ; 0] + ellipsoid(eye(2, 2));
  secEllObj = [0 ; 0] + ellipsoid(2*eye(2, 2));
  firstEllObj.isInside(secEllObj)

  ans =

       1</pre>
</div>
<div class="highlight-python"><pre>ISBADDIRECTION - checks if ellipsoidal approximations of geometric
                 difference of two ellipsoids can be computed for
                 given directions.
  isBadDirVec = ISBADDIRECTION(fstEll, secEll, dirsMat) - Checks if
      it is possible to build ellipsoidal approximation of the
      geometric difference of two ellipsoids fstEll - secEll in
      directions specified by matrix dirsMat (columns of dirsMat
      are direction vectors). Type 'help minkdiff_ea' or
      'help minkdiff_ia' for more information.

Input:
  regular:
      fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose nDim - space
          dimension.
      secEll: ellipsoid [1, 1] - second ellipsoid of the same dimention.
      dirsMat: numeric[nDims, nCols] - matrix whose columns are
          direction vectors that need to be checked.
      absTol: double [1,1] - absolute tolerance

Output:
   isBadDirVec: logical[1, nCols] - array of true or false with length
      being equal to the number of columns in matrix dirsMat.
      ture marks direction vector as bad - ellipsoidal approximation
      true marks direction vector as bad - ellipsoidal approximation
      cannot be computed for this direction. false means the opposite.</pre>
</div>
<div class="highlight-python"><pre>ISBIGGER - checks if one ellipsoid would contain the other if their
           centers would coincide.

  isPositive = ISBIGGER(fstEll, secEll) - Given two single ellipsoids
      of the same dimension, fstEll and secEll, check if fstEll
      would contain secEll inside if they were both
      centered at origin.

Input:
  regular:
      fstEll: ellipsoid [1, 1] - first ellipsoid.
      secEll: ellipsoid [1, 1] - second ellipsoid
          of the same dimention.

Output:
  isPositive: logical[1, 1], true - if ellipsoid fstEll
      would contain secEll inside, false - otherwise.

Example:
  firstEllObj = ellipsoid([1; 1], eye(2));
  secEllObj = ellipsoid([1; 1], [4 -1; -1 5]);
  isbigger(firstEllObj, secEllObj)

  ans =

       0</pre>
</div>
<div class="highlight-python"><pre>ISDEGENERATE - checks if the ellipsoid is degenerate.

Input:
  regular:
      myEllArr: ellipsoid[nDims1,nDims2,...,nDimsN] - array of ellipsoids.

Output:
  isPositiveArr: logical[nDims1,nDims2,...,nDimsN],
      isPositiveArr(iCount) = true if ellipsoid myEllMat(iCount)
      is degenerate, false - otherwise.

Example:
  ellObj = ellipsoid([1; 1], eye(2));
  isdegenerate(ellObj)

  ans =

       0</pre>
</div>
<div class="highlight-python"><pre>ISINTERNAL - checks if given points belong to the union or intersection
             of ellipsoids in the given array.

  isPositiveVec = ISINTERNAL(myEllArr,  matrixOfVecMat, mode) - Checks
      if vectors specified as columns of matrix matrixOfVecMat
      belong to the union (mode = 'u'), or intersection (mode = 'i')
      of the ellipsoids in myEllArr. If myEllArr is a single
      ellipsoid, then this function checks if points in matrixOfVecMat
      belong to myEllArr or not. Ellipsoids in myEllArr must be
      of the same dimension. Column size of matrix  matrixOfVecMat
      should match the dimension of ellipsoids.

   Let myEllArr(iEll) = E(q, Q) be an ellipsoid with center q and shape
   matrix Q. Checking if given vector matrixOfVecMat = x belongs
   to E(q, Q) is equivalent to checking if inequality
                   &lt;(x - q), Q^(-1)(x - q)&gt; &lt;= 1
   holds.
   If x belongs to at least one of the ellipsoids in the array, then it
   belongs to the union of these ellipsoids. If x belongs to all
   ellipsoids in the array,
   then it belongs to the intersection of these ellipsoids.
   The default value of the specifier s = 'u'.

   WARNING: be careful with degenerate ellipsoids.

Input:
  regular:
      myEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.
      matrixOfVecMat: double [mRows, nColsOfVec] - matrix which
          specifiy points.

  optional:
      mode: char[1, 1] - 'u' or 'i', go to description.

Output:
   isPositiveVec: logical[1, nColsOfVec] -
      true - if vector belongs to the union or intersection
      of ellipsoids, false - otherwise.

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = firstEllObj + [5; 5];
  ellVec = [firstEllObj secEllObj];
  ellVec.isinternal([-2 3; -1 4], 'i')

  ans =

       0     0

  ellVec.isinternal([-2 3; -1 4])

  ans =

       1     1</pre>
</div>
<div class="highlight-python"><pre>MAXEIG - return the maximal eigenvalue of the ellipsoid.

Input:
  regular:
      inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
           ellipsoids.

Output:
  maxEigArr: double[nDims1,nDims2,...,nDimsN] - array of maximal
      eigenvalues of ellipsoids in the input matrix inpEllMat.

Example:
  ellObj = ellipsoid([-2; 4], [4 -1; -1 5]);
  maxEig = maxeig(ellObj)

  maxEig =

      5.6180</pre>
</div>
<div class="highlight-python"><pre>MINEIG - return the minimal eigenvalue of the ellipsoid.

Input:
   regular:
      inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
        ellipsoids.

Output:
   minEigArr: double[nDims1,nDims2,...,nDimsN] - array of minimal
      eigenvalues of ellipsoids in the input array inpEllMat.

Example:
  ellObj = ellipsoid([-2; 4], [4 -1; -1 5]);
  minEig = mineig(ellObj)

  minEig =

      3.3820</pre>
</div>
<div class="highlight-python"><pre>MINKCOMMONACTION - plot Minkowski operation  of ellipsoids in 2D or 3D.
Usage:
minkCommonAction(getEllArr,fCalcBodyTriArr,...
   fCalcCenterTriArr,varargin) -  plot Minkowski operation  of
           ellipsoids in 2D or 3D, using triangulation  of output object

Input:
  regular:
      getEllArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
               array of 2D or 3D Ellipsoids objects. All ellipsoids in
               ellArr must be either 2D or 3D simutaneously.
fCalcBodyTriArr - function, calculeted triangulation of output object
   fCalcCenterTriArr - function, calculeted center  of output object
           properties:
      'shawAll': logical[1,1] - if 1, plot all ellArr.
                   Default value is 0.
      'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
              if 1, ellipsoids in 2D will be filled with color.
              Default value is 0.
      'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   line width for 1D and 2D plots. Default value is 1.
      'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
               sets default colors in the form [x y z].
              Default value is [1 0 0].
      'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
               level of transparency between 0 and 1
                  (0 - transparent, 1 - opaque).
               Default value is 0.4.
      'relDataPlotter' - relation data plotter object.

Output:
  centVec: double[nDim, 1] - center of the resulting set.
  boundPointMat: double[nDim, nBoundPoints] - set of boundary
      points (vertices) of resulting set.</pre>
</div>
<div class="highlight-python"><pre>MINKDIFF - computes geometric (Minkowski) difference of two
            ellipsoids in 2D or 3D.
 Usage:
MINKDIFF(inpEllMat,'Property',PropValue,...) - Computes
geometric difference of two ellipsoids in the array inpEllMat, if
1 &lt;= min(dimension(inpEllMat)) = max(dimension(inpEllMat)) &lt;= 3,
       and plots it if no output arguments are specified.

   [centVec, boundPointMat] = MINKDIFF(inpEllMat) - Computes
       geometric difference of two ellipsoids in inpEllMat.
       Here centVec is
       the center, and boundPointMat - array of boundary points.
   MINKDIFF(inpEllMat) - Plots geometric differencr of two
   ellipsoids in inpEllMat in default (red) color.
   MINKDIFF(inpEllMat, 'Property',PropValue,...) -
    Plots geometric sum of inpEllMat
       with setting properties.

   In order for the geometric difference to be nonempty set,
   ellipsoid fstEll must be bigger than secEll in the sense that
   if fstEll and secEll had the same centerVec, secEll would be
   contained inside fstEll.
 Input:
   regular:
       ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
                array of 2D or 3D Ellipsoids objects. All ellipsoids in ellArr
                must be either 2D or 3D simutaneously.

   properties:
       'shawAll': logical[1,1] - if 1, plot all ellArr.
                    Default value is 0.
       'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
               if 1, ellipsoids in 2D will be filled with color.
               Default value is 0.
       'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                    line width for 1D and 2D plots. Default value is 1.
       'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
                sets default colors in the form [x y z].
               Default value is [1 0 0].
       'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                level of transparency between 0 and 1
                   (0 - transparent, 1 - opaque).
                Default value is 0.4.
       'relDataPlotter' - relation data plotter object.
       Notice that property vector could have different dimensions, only
       total number of elements must be the same.

 Output:
   centVec: double[nDim, 1] - center of the resulting set.
   boundPointMat: double[nDim, nBoundPoints] - set of boundary
       points (vertices) of resulting set.

 Example:
   firstEllObj = ellipsoid([-1; 1], [2 0; 0 3]);
   secEllObj = ellipsoid([1 2], eye(2));
   [centVec, boundPointMat] = minkdiff(firstEllObj, secEllObj);</pre>
</div>
<div class="highlight-python"><pre>MINKDIFF_EA - computation of external approximating ellipsoids
              of the geometric difference of two ellipsoids along
              given directions.

  extApprEllVec = MINKDIFF_EA(fstEll, secEll, directionsMat) -
      Computes external approximating ellipsoids of the
      geometric difference of two ellipsoids fstEll - secEll
      along directions specified by columns of matrix directionsMat

  First condition for the approximations to be computed, is that
  ellipsoid fstEll = E1 must be bigger than ellipsoid secEll = E2
  in the sense that if they had the same center, E2 would be contained
  inside E1. Otherwise, the geometric difference E1 - E2
  is an empty set.
  Second condition for the approximation in the given direction l
  to exist, is the following. Given
      P = sqrt(&lt;l, Q1 l&gt;)/sqrt(&lt;l, Q2 l&gt;)
  where Q1 is the shape matrix of ellipsoid E1, and
  Q2 - shape matrix of E2, and R being minimal root of the equation
      det(Q1 - R Q2) = 0,
  parameter P should be less than R.
  If both of these conditions are satisfied, then external
  approximating ellipsoid is defined by its shape matrix
      Q = (Q1^(1/2) + S Q2^(1/2))' (Q1^(1/2) + S Q2^(1/2)),
  where S is orthogonal matrix such that vectors
      Q1^(1/2)l and SQ2^(1/2)l
  are parallel, and its center
      q = q1 - q2,
  where q1 is center of ellipsoid E1 and q2 - center of E2.

Input:
  regular:
      fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
          nDim - space dimension.
      secEll: ellipsoid [1, 1] - second ellipsoid
          of the same dimention.
      directionsMat: double[nDim, nCols] - matrix whose columns
          specify the directions for which the approximations
          should be computed.

Output:
  extApprEllVec: ellipsoid [1, nCols] - array of external
      approximating ellipsoids (empty, if for all specified
      directions approximations cannot be computed).

Example:
  firstEllObj= ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = 3*ell_unitball(2);
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  externalEllVec = secEllObj.minkdiff_ea(firstEllObj, dirsMat)

  externalEllVec =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINKDIFF_IA - computation of internal approximating ellipsoids
              of the geometric difference of two ellipsoids along
              given directions.

  intApprEllVec = MINKDIFF_IA(fstEll, secEll, directionsMat) -
      Computes internal approximating ellipsoids of the geometric
      difference of two ellipsoids fstEll - secEll along directions
      specified by columns of matrix directionsMat.

  First condition for the approximations to be computed, is that
  ellipsoid fstEll = E1 must be bigger than ellipsoid secEll = E2
  in the sense that if they had the same center, E2 would be contained
  inside E1. Otherwise, the geometric difference E1 - E2 is an
  empty set. Second condition for the approximation in the given
  direction l to exist, is the following. Given
      P = sqrt(&lt;l, Q1 l&gt;)/sqrt(&lt;l, Q2 l&gt;)
  where Q1 is the shape matrix of ellipsoid E1,
  and Q2 - shape matrix of E2, and R being minimal root of the equation
      det(Q1 - R Q2) = 0,
  parameter P should be less than R.
  If these two conditions are satisfied, then internal approximating
  ellipsoid for the geometric difference E1 - E2 along the
  direction l is defined by its shape matrix
      Q = (1 - (1/P)) Q1 + (1 - P) Q2
  and its center
      q = q1 - q2,
  where q1 is center of E1 and q2 - center of E2.

Input:
  regular:
      fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
          nDim - space dimension.
      secEll: ellipsoid [1, 1] - second ellipsoid
          of the same dimention.
      directionsMat: double[nDim, nCols] - matrix whose columns
          specify the directions for which the approximations
          should be computed.

Output:
  intApprEllVec: ellipsoid [1, nCols] - array of internal
      approximating ellipsoids (empty, if for all specified directions
      approximations cannot be computed).

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = 3*ell_unitball(2);
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  internalEllVec = secEllObj.minkdiff_ia(firstEllObj, dirsMat)

  internalEllVec =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINKMP - computes and plots geometric (Minkowski) sum of the
         geometric difference of two ellipsoids and the geometric
         sum of n ellipsoids in 2D or 3D:
         (E - Em) + (E1 + E2 + ... + En),
         where E = firstEll, Em = secondEll,
         E1, E2, ..., En - are ellipsoids in sumEllArr

Usage:
  MINKMP(firEll,secEll,ellMat,'Property',PropValue,...) -
          Computes (E1 - E2) + (E3 + E4+ ... + En), if
      1 &lt;= min(dimension(inpEllMat)) = max(dimension(inpEllMat)) &lt;= 3,
      and plots it if no output arguments are specified.

  [centVec, boundPointMat] = MINKMP(firEll,secEll,ellMat) - Computes
     (E1 - E2) + (E3 + E4+ ... + En). Here centVec is
      the center, and boundPointMat - array of boundary points.
Input:
  regular:
      ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
          array of 2D or 3D Ellipsoids objects. All ellipsoids in ellArr
               must be either 2D or 3D simutaneously.

  properties:
      'showAll': logical[1,1] - if 1, plot all ellArr.
                   Default value is 0.
      'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
              if 1, ellipsoids in 2D will be filled with color.
              Default value is 0.
      'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]-
                   line width for 1D and 2D plots. Default value is 1.
      'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
               sets default colors in the form [x y z].
                  Default value is [1 0 0].
      'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
               level of transparency between 0 and 1
              (0 - transparent, 1 - opaque).
               Default value is 0.4.
      'relDataPlotter' - relation data plotter object.
      Notice that property vector could have different dimensions, only
      total number of elements must be the same.

Output:
  centVec: double[nDim, 1] - center of the resulting set.
  boundPointMat: double[nDim, nBoundPoints] - set of boundary
      points (vertices) of resulting set.

Example:
  firstEllObj = ellipsoid([-2; -1], [2 -1; -1 1]);
  secEllObj = ell_unitball(2);
  ellVec = [firstEllObj secEllObj ellipsoid([-3; 1], eye(2))];
  minkmp(firstEllObj, secEllObj, ellVec);</pre>
</div>
<div class="highlight-python"><pre>MINKMP_EA - computation of external approximating ellipsoids
            of (E - Em) + (E1 + ... + En) along given directions.
            where E = fstEll, Em = secEll,
            E1, E2, ..., En - are ellipsoids in sumEllArr

  extApprEllVec = MINKMP_EA(fstEll, secEll, sumEllArr, dirMat) -
      Computes external approximating
      ellipsoids of (E - Em) + (E1 + E2 + ... + En),
      where E1, E2, ..., En are ellipsoids in array sumEllArr,
      E = fstEll, Em = secEll,
      along directions specified by columns of matrix dirMat.

Input:
  regular:
      fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
          nDims - space dimension.
      secEll: ellipsoid [1, 1] - second ellipsoid
          of the same dimention.
      sumEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array of
          ellipsoids of the same dimentions nDims.
      dirMat: double[nDims, nCols] - matrix whose columns specify the
          directions for which the approximations should be computed.

Output:
  extApprEllVec: ellipsoid [1, nCols] - array of external
      approximating ellipsoids (empty, if for all specified
      directions approximations cannot be computed).

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = 3*ell_unitball(2);
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  bufEllVec = [secEllObj firstEllObj];
  externalEllVec = secEllObj.minkmp_ea(firstEllObj, bufEllVec, dirsMat)

  externalEllVec =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINKMP_IA - computation of internal approximating ellipsoids
            of (E - Em) + (E1 + ... + En) along given directions.
            where E = fstEll, Em = secEll,
            E1, E2, ..., En - are ellipsoids in sumEllArr

  intApprEllVec = MINKMP_IA(fstEll, secEll, sumEllArr, dirMat) -
      Computes internal approximating
      ellipsoids of (E - Em) + (E1 + E2 + ... + En),
      where E1, E2, ..., En are ellipsoids in array sumEllArr,
      E = fstEll, Em = secEll,
      along directions specified by columns of matrix dirMat.

Input:
  regular:
      fstEll: ellipsoid [1, 1] - first ellipsoid. Suppose
          nDim - space dimension.
      secEll: ellipsoid [1, 1] - second ellipsoid
          of the same dimention.
      sumEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array of
          ellipsoids of the same dimentions.
      dirMat: double[nDim, nCols] - matrix whose columns specify the
          directions for which the approximations should be computed.

Output:
  intApprEllVec: ellipsoid [1, nCols] - array of internal
      approximating ellipsoids (empty, if for all specified
      directions approximations cannot be computed).

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = 3*ell_unitball(2);
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  bufEllVec = [secEllObj firstEllObj];
  internalEllVec = secEllObj.minkmp_ia(firstEllObj, bufEllVec, dirsMat)

  internalEllVec =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINKPM - computes and plots geometric (Minkowski) difference
         of the geometric sum of ellipsoids and a single ellipsoid
         in 2D or 3D: (E1 + E2 + ... + En) - E,
         where E = inpEll,
         E1, E2, ... En - are ellipsoids in inpEllArr.

  MINKPM(inpEllArr, inpEll, OPTIONS)  Computes geometric difference
      of the geometric sum of ellipsoids in inpEllMat and
      ellipsoid inpEll, if
      1 &lt;= dimension(inpEllArr) = dimension(inpArr) &lt;= 3,
      and plots it if no output arguments are specified.

  [centVec, boundPointMat] = MINKPM(inpEllArr, inpEll) - pomputes
      (geometric sum of ellipsoids in inpEllArr) - inpEll.
      Here centVec is the center, and boundPointMat - array
      of boundary points.
  MINKPM(inpEllArr, inpEll) - plots (geometric sum of ellipsoids
      in inpEllArr) - inpEll in default (red) color.
  MINKPM(inpEllArr, inpEll, Options) - plots
      (geometric sum of ellipsoids in inpEllArr) - inpEll using
      options given in the Options structure.

Input:
  regular:
      inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array of
          ellipsoids of the same dimentions 2D or 3D.
      inpEll: ellipsoid [1, 1] - ellipsoid of the same
          dimention 2D or 3D.

  optional:
      Options: structure[1, 1] - fields:
          show_all: double[1, 1] - if 1, displays
              also ellipsoids fstEll and secEll.
          newfigure: double[1, 1] - if 1, each plot
              command will open a new figure window.
          fill: double[1, 1] - if 1, the resulting
              set in 2D will be filled with color.
          color: double[1, 3] - sets default colors
              in the form [x y z].
          shade: double[1, 1] = 0-1 - level of transparency
              (0 - transparent, 1 - opaque).

Output:
   centVec: double[nDim, 1]/double[0, 0] - center of the resulting set.
      centerVec may be empty.
   boundPointMat: double[nDim, ]/double[0, 0] - set of boundary
      points (vertices) of resulting set. boundPointMat may be empty.</pre>
</div>
<div class="highlight-python"><pre>MINKPM_EA - computation of external approximating ellipsoids
            of (E1 + E2 + ... + En) - E along given directions.
            where E = inpEll,
            E1, E2, ... En - are ellipsoids in inpEllArr.

  ExtApprEllVec = MINKPM_EA(inpEllArr, inpEll, dirMat) - Computes
      external approximating ellipsoids of
      (E1 + E2 + ... + En) - E, where E1, E2, ..., En are ellipsoids
      in array inpEllArr, E = inpEll,
      along directions specified by columns of matrix dirMat.

Input:
  regular:
      inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] -
          array of ellipsoids of the same dimentions.
      inpEll: ellipsoid [1, 1] - ellipsoid of the same dimention.
      dirMat: double[nDim, nCols] - matrix whose columns specify
          the directions for which the approximations
          should be computed.

Output:
  extApprEllVec: ellipsoid [1, nCols]/[0, 0] - array of external
      approximating ellipsoids. Empty, if for all specified
      directions approximations cannot be computed.

Example:
  firstEllObj = ellipsoid([2; -1], [9 -5; -5 4]);
  secEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  thirdEllObj = ell_unitball(2);
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  ellVec = [thirdEllObj firstEllObj];
  externalEllVec = ellVec.minkpm_ea(secEllObj, dirsMat)

  externalEllVec =
  1x4 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINKPM_IA - computation of internal approximating ellipsoids
            of (E1 + E2 + ... + En) - E along given directions.
            where E = inpEll,
            E1, E2, ... En - are ellipsoids in inpEllArr.

  intApprEllVec = MINKPM_IA(inpEllArr, inpEll, dirMat) - Computes
      internal approximating ellipsoids of
      (E1 + E2 + ... + En) - E, where E1, E2, ..., En are ellipsoids
      in array inpEllArr, E = inpEll,
      along directions specified by columns of matrix dirArr.

Input:
  regular:
      inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] -
          array of ellipsoids of the same dimentions.
      inpEll: ellipsoid [1, 1] - ellipsoid of the same dimention.
      dirMat: double[nDim, nCols] - matrix whose columns specify
          the directions for which the approximations
          should be computed.

Output:
  intApprEllVec: ellipsoid [1, nCols]/[0, 0] - array of internal
      approximating ellipsoids. Empty, if for all specified
      directions approximations cannot be computed.

Example:
  firstEllObj = ellipsoid([2; -1], [9 -5; -5 4]);
  secEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  thirdEllObj = ell_unitball(2);
  ellVec = [thirdEllObj firstEllObj];
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  internalEllVec = ellVec.minkpm_ia(secEllObj, dirsMat)

  internalEllVec =
  1x3 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINKSUM - computes geometric (Minkowski) sum of ellipsoids in 2D or 3D.

Usage:
  MINKSUM(inpEllMat,'Property',PropValue,...) - Computes geometric sum of
      ellipsoids in the array inpEllMat, if
      1 &lt;= min(dimension(inpEllMat)) = max(dimension(inpEllMat)) &lt;= 3,
      and plots it if no output arguments are specified.

  [centVec, boundPointMat] = MINKSUM(inpEllMat) - Computes
      geometric sum of ellipsoids in inpEllMat. Here centVec is
      the center, and boundPointMat - array of boundary points.
  MINKSUM(inpEllMat) - Plots geometric sum of ellipsoids in
      inpEllMat in default (red) color.
  MINKSUM(inpEllMat, 'Property',PropValue,...) - Plots geometric sum of
  inpEllMat with setting properties.

Input:
  regular:
      ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
               array of 2D or 3D Ellipsoids objects. All ellipsoids
               in ellArr must be either 2D or 3D simutaneously.

  properties:
   'showAll': logical[1,1] - if 1, plot all ellArr.
                   Default value is 0.
   'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
              if 1, ellipsoids in 2D will be filled with color. Default
              value is 0.
   'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]-
                   line width for 1D and 2D plots. Default value is 1.
   'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
       sets default colors in the form [x y z]. Default value is [1 0 0].
   'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
     level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
               Default value is 0.4.
      'relDataPlotter' - relation data plotter object.
      Notice that property vector could have different dimensions, only
      total number of elements must be the same.

Output:
  centVec: double[nDim, 1] - center of the resulting set.
  boundPointMat: double[nDim, nBoundPoints] - set of boundary
      points (vertices) of resulting set.

Example:
  firstEllObj = ellipsoid([-2; -1], [2 -1; -1 1]);
  secEllObj = ell_unitball(2);
  ellVec = [firstEllObj, secellObj]
  sumVec = minksum(ellVec);</pre>
</div>
<div class="highlight-python"><pre>MINKSUM_EA - computation of external approximating ellipsoids
             of the geometric sum of ellipsoids along given directions.

  extApprEllVec = MINKSUM_EA(inpEllArr, dirMat) - Computes
      tight external approximating ellipsoids for the geometric
      sum of the ellipsoids in the array inpEllArr along directions
      specified by columns of dirMat.
      If ellipsoids in inpEllArr are n-dimensional, matrix
      dirMat must have dimension (n x k) where k can be
      arbitrarily chosen.
      In this case, the output of the function will contain k
      ellipsoids computed for k directions specified in dirMat.

  Let inpEllArr consists of E(q1, Q1), E(q2, Q2), ..., E(qm, Qm) -
  ellipsoids in R^n, and dirMat(:, iCol) = l - some vector in R^n.
  Then tight external approximating ellipsoid E(q, Q) for the
  geometric sum E(q1, Q1) + E(q2, Q2) + ... + E(qm, Qm)
  along direction l, is such that
      rho(l | E(q, Q)) = rho(l | (E(q1, Q1) + ... + E(qm, Qm)))
  and is defined as follows:
      q = q1 + q2 + ... + qm,
      Q = (p1 + ... + pm)((1/p1)Q1 + ... + (1/pm)Qm),
  where
      p1 = sqrt(&lt;l, Q1l&gt;), ..., pm = sqrt(&lt;l, Qml&gt;).

Input:
  regular:
      inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array
          of ellipsoids of the same dimentions.
      dirMat: double[nDims, nCols] - matrix whose columns specify
          the directions for which the approximations
          should be computed.

Output:
  extApprEllVec: ellipsoid [1, nCols] - array of external
      approximating ellipsoids.

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = ell_unitball(2);
  ellVec = [firstEllObj secEllObj firstEllObj.inv()];
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  externalEllVec = ellVec.minksum_ea(dirsMat)

  externalEllVec =
  1x4 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINKSUM_IA - computation of internal approximating ellipsoids
             of the geometric sum of ellipsoids along given directions.

  intApprEllVec = MINKSUM_IA(inpEllArr, dirMat) - Computes
      tight internal approximating ellipsoids for the geometric
      sum of the ellipsoids in the array inpEllArr along directions
      specified by columns of dirMat. If ellipsoids in
      inpEllArr are n-dimensional, matrix dirMat must have
      dimension (n x k) where k can be arbitrarily chosen.
      In this case, the output of the function will contain k
      ellipsoids computed for k directions specified in dirMat.

  Let inpEllArr consist of E(q1, Q1), E(q2, Q2), ..., E(qm, Qm) -
  ellipsoids in R^n, and dirMat(:, iCol) = l - some vector in R^n.
  Then tight internal approximating ellipsoid E(q, Q) for the
  geometric sum E(q1, Q1) + E(q2, Q2) + ... + E(qm, Qm) along
  direction l, is such that
      rho(l | E(q, Q)) = rho(l | (E(q1, Q1) + ... + E(qm, Qm)))
  and is defined as follows:
      q = q1 + q2 + ... + qm,
      Q = (S1 Q1^(1/2) + ... + Sm Qm^(1/2))' *
          * (S1 Q1^(1/2) + ... + Sm Qm^(1/2)),
  where S1 = I (identity), and S2, ..., Sm are orthogonal
  matrices such that vectors
  (S1 Q1^(1/2) l), ..., (Sm Qm^(1/2) l) are parallel.

Input:
  regular:
      inpEllArr: ellipsoid [nDims1, nDims2,...,nDimsN] - array
          of ellipsoids of the same dimentions.
      dirMat: double[nDim, nCols] - matrix whose columns specify the
          directions for which the approximations should be computed.

Output:
  intApprEllVec: ellipsoid [1, nCols] - array of internal
      approximating ellipsoids.

Example:
  firstEllObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  secEllObj = ell_unitball(2);
  ellVec = [firstEllObj secEllObj firstEllObj.inv()];
  dirsMat = [1 0; 1 1; 0 1; -1 1]';
  internalEllVec = ellVec.minksum_ia(dirsMat)

  internalEllVec =
  1x4 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>MINUS - overloaded operator '-'

  outEllArr = MINUS(inpEllArr, inpVec) implements E(q, Q) - b
      for each ellipsoid E(q, Q) in inpEllArr.
  outEllArr = MINUS(inpVec, inpEllArr) implements b - E(q, Q)
      for each ellipsoid E(q, Q) in inpEllArr.

  Operation E - b where E = inpEll is an ellipsoid in R^n,
  and b = inpVec - vector in R^n. If E(q, Q) is an ellipsoid
  with center q and shape matrix Q, then
  E(q, Q) - b = E(q - b, Q).

Input:
  regular:
      inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
          ellipsoids of the same dimentions nDims.
      inpVec: double[nDims, 1] - vector.

Output:
   outEllVec: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
      with same shapes as inpEllVec, but with centers shifted by vectors
      in -inpVec.

Example:
  ellVec  = [ellipsoid([-2; -1], [4 -1; -1 1]) ell_unitball(2)];
  outEllVec = ellVec - [1; 1];
  outEllVec(1)

  ans =

  Center:
      -3
      -2

  Shape:
       4    -1
      -1     1

  Nondegenerate ellipsoid in R^2.

  outEllVec(2)

  ans =

  Center:
      -1
      -1

  Shape:
       1     0
       0     1

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>MOVE2ORIGIN - moves ellipsoids in the given array to the origin. Modified
              given array is on output (not its copy).

  outEllArr = MOVE2ORIGIN(inpEll) - Replaces the centers of
      ellipsoids in inpEllArr with zero vectors.

Input:
  regular:
      inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
          ellipsoids.

Output:
  inpEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
      with the same shapes as in inpEllArr centered at the origin.

Example:
  ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  outEllObj = ellObj.move2origin()

  outEllObj =

  Center:
       0
       0

  Shape:
       4    -1
      -1     1

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>MTIMES - overloaded operator '*'.

  Multiplication of the ellipsoid by a matrix or a scalar.
  If inpEllVec(iEll) = E(q, Q) is an ellipsoid, and
  multMat = A - matrix of suitable dimensions,
  then A E(q, Q) = E(Aq, AQA').

Input:
  regular:
      multMat: double[mRows, nDims]/[1, 1] - scalar or
          matrix in R^{mRows x nDim}
      inpEllVec: ellipsoid [1, nCols] - array of ellipsoids.

Output:
  outEllVec: ellipsoid [1, nCols] - resulting ellipsoids.

Example:
  ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  tempMat = [0 1; -1 0];
  outEllObj = tempMat*ellObj

  outEllObj =

  Center:
      -1
       2

  Shape:
       1     1
       1     4

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>PARAMETERS - returns parameters of the ellipsoid.

Input:
  regular:
      myEll: ellipsoid [1, 1] - single ellipsoid of dimention nDims.

Output:
  myEllCenterVec: double[nDims, 1] - center of the ellipsoid myEll.
  myEllShapeMat: double[nDims, nDims] - shape matrix
      of the ellipsoid myEll.

Example:
  ellObj = ellipsoid([-2; 4], [4 -1; -1 5]);
  [centVec shapeMat] = parameters(ellObj)
  centVec =

      -2
       4

  shapeMat =

      4    -1
     -1     5</pre>
</div>
<div class="highlight-python"><pre>PLOT - plots ellipsoids in 2D or 3D.


Usage:
      plot(ell) - plots ellipsoid ell in default (red) color.
      plot(ellArr) - plots an array of ellipsoids.
      plot(ellArr, 'Property',PropValue,...) - plots ellArr with setting
                                               properties.

Input:
  regular:
      ellArr:  Ellipsoid: [dim11Size,dim12Size,...,dim1kSize] -
               array of 2D or 3D Ellipsoids objects. All ellipsoids in ellArr
               must be either 2D or 3D simutaneously.
  optional:
      color1Spec: char[1,1] - color specification code, can be 'r','g',
                              etc (any code supported by built-in Matlab function).
      ell2Arr: Ellipsoid: [dim21Size,dim22Size,...,dim2kSize] -
                                          second ellipsoid array...
      color2Spec: char[1,1] - same as color1Spec but for ell2Arr
      ....
      ellNArr: Ellipsoid: [dimN1Size,dim22Size,...,dimNkSize] -
                                           N-th ellipsoid array
      colorNSpec - same as color1Spec but for ellNArr.
  properties:
      'newFigure': logical[1,1] - if 1, each plot command will open a new figure window.
                   Default value is 0.
      'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
              if 1, ellipsoids in 2D will be filled with color. Default value is 0.
      'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   line width for 1D and 2D plots. Default value is 1.
      'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
               sets default colors in the form [x y z]. Default value is [1 0 0].
      'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
               level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
               Default value is 0.4.
      'relDataPlotter' - relation data plotter object.
      Notice that property vector could have different dimensions, only
      total number of elements must be the same.
Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.

Examples:
      plot([ell1, ell2, ell3], 'color', [1, 0, 1; 0, 0, 1; 1, 0, 0]);
      plot([ell1, ell2, ell3], 'color', [1; 0; 1; 0; 0; 1; 1; 0; 0]);
      plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1, 1, 1; 1, 1,
      1]);
      plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1; 1; 1; 1; 1;
      1]);
      plot([ell1, ell2, ell3], 'shade', 0.5);
      plot([ell1, ell2, ell3], 'lineWidth', 1.5);
      plot([ell1, ell2, ell3], 'lineWidth', [1.5, 0.5, 3]);</pre>
</div>
<div class="highlight-python"><pre>PLUS - overloaded operator '+'

  outEllArr = PLUS(inpEllArr, inpVec) implements E(q, Q) + b
      for each ellipsoid E(q, Q) in inpEllArr.
  outEllArr = PLUS(inpVec, inpEllArr) implements b + E(q, Q)
      for each ellipsoid E(q, Q) in inpEllArr.

   Operation E + b (or b+E) where E = inpEll is an ellipsoid in R^n,
  and b=inpVec - vector in R^n. If E(q, Q) is an ellipsoid
  with center q and shape matrix Q, then
  E(q, Q) + b = b + E(q,Q) = E(q + b, Q).

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
          of the same dimentions nDims.
      bVec: double[nDims, 1] - vector.

Output:
  outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids
      with same shapes as ellVec, but with centers shifted by vectors
      in inpVec.

Example:
  ellVec  = [ellipsoid([-2; -1], [4 -1; -1 1]) ell_unitball(2)];
  outEllVec = ellVec + [1; 1];
  outEllVec(1)

  ans =

  Center:
      -1
       0

  Shape:
      4    -1
     -1     1

  Nondegenerate ellipsoid in R^2.

  outEllVec(2)

  ans =

  Center:
       1
       1

  Shape:
      1     0
      0     1

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>POLAR - computes the polar ellipsoids.

  polEllArr = POLAR(ellArr)  Computes the polar ellipsoids for those
      ellipsoids in ellArr, for which the origin is an interior point.
      For those ellipsoids in E, for which this condition does not hold,
      an empty ellipsoid is returned.

  Given ellipsoid E(q, Q) where q is its center, and Q - its shape matrix,
  the polar set to E(q, Q) is defined as follows:
  P = { l in R^n  | &lt;l, q&gt; + sqrt(&lt;l, Q l&gt;) &lt;= 1 }
  If the origin is an interior point of ellipsoid E(q, Q),
  then its polar set P is an ellipsoid.

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.

Output:
  polEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
       polar ellipsoids.

Example:
  ellObj = ellipsoid([4 -1; -1 1]);
  ellObj.polar() == ellObj.inv()

  ans =

      1</pre>
</div>
<div class="highlight-python"><pre>PROJECTION - computes projection of the ellipsoid onto the given subspace.
             modified given array is on output (not its copy).

  projEllArr = projection(ellArr, basisMat)  Computes projection of the
      ellipsoid ellArr onto a subspace, specified by orthogonal
      basis vectors basisMat. ellArr can be an array of ellipsoids of
      the same dimension. Columns of B must be orthogonal vectors.

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.
      basisMat: double[nDim, nSubSpDim] - matrix of orthogonal basis
          vectors

Output:
  ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of
      projected ellipsoids, generally, of lower dimension.

Example:
  ellObj = ellipsoid([-2; -1; 4], [4 -1 0; -1 1 0; 0 0 9]);
  basisMat = [0 1 0; 0 0 1]';
  outEllObj = ellObj.projection(basisMat)

  outEllObj =

  Center:
      -1
       4

  Shape:
      1     0
      0     9

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>REPMAT - is analogous to built-in repmat function with one exception - it
         copies the objects, not just the handles

Example:
  firstEllObj = ellipsoid([1; 2], eye(2));
  secEllObj = ellipsoid([1; 1], 2*eye(2));
  ellVec = [firstEllObj secEllObj];
  repMat(ellVec)

  ans =
  1x2 array of ellipsoids.</pre>
</div>
<div class="highlight-python"><pre>RHO - computes the values of the support function for given ellipsoid
      and given direction.

      supArr = RHO(ellArr, dirsMat)  Computes the support function of the
      ellipsoid ellArr in directions specified by the columns of matrix
      dirsMat. Or, if ellArr is array of ellipsoids, dirsMat is expected
      to be a single vector.

      [supArr, bpArr] = RHO(ellArr, dirstMat)  Computes the support function
      of the ellipsoid ellArr in directions specified by the columns of
      matrix dirsMat, and boundary points bpArr of this ellipsoid that
      correspond to directions in dirsMat. Or, if ellArr is array of
      ellipsoids, and dirsMat - single vector, then support functions and
      corresponding boundary points are computed for all the given
      ellipsoids in the array in the specified direction dirsMat.

      The support function is defined as
  (1)  rho(l | E) = sup { &lt;l, x&gt; : x belongs to E }.
      For ellipsoid E(q,Q), where q is its center and Q - shape matrix,
  it is simplified to
  (2)  rho(l | E) = &lt;q, l&gt; + sqrt(&lt;l, Ql&gt;)
  Vector x, at which the maximum at (1) is achieved is defined by
  (3)  q + Ql/sqrt(&lt;l, Ql&gt;)

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN]/[1,1] - array
          of ellipsoids.
      dirsMat: double[nDim,nDims1,nDims2,...,nDimsN]/
          double[nDim,nDirs]/[nDim,1] - array or matrix of directions.

Output:
      supArr: double [nDims1,nDims2,...,nDimsN]/[1,nDirs] - support function
      of the ellArr in directions specified by the columns of matrix
      dirsMat. Or, if ellArr is array of ellipsoids, support function of
      each ellipsoid in ellArr specified by dirsMat direction.

  bpArr: double[nDim,nDims1,nDims2,...,nDimsN]/
          double[nDim,nDirs]/[nDim,1] - array or matrix of boundary points

Example:
  ellObj = ellipsoid([-2; 4], [4 -1; -1 1]);
  dirsMat = [-2 5; 5 1];
  suppFuncVec = rho(ellObj, dirsMat)

  suppFuncVec =

      31.8102    3.5394</pre>
</div>
<div class="highlight-python"><pre>SHAPE - modifies the shape matrix of the ellipsoid without
  changing its center. Modified given array is on output (not its copy).

   modEllArr = SHAPE(ellArr, modMat)  Modifies the shape matrices of
      the ellipsoids in the ellipsoidal array ellArr. The centers
      remain untouched - that is the difference of the function SHAPE and
      linear transformation modMat*ellArr. modMat is expected to be a
      scalar or a square matrix of suitable dimension.

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.
      modMat: double[nDim, nDim]/[1,1] - square matrix or scalar

Output:
   ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of modified
      ellipsoids.

Example:
  ellObj = ellipsoid([-2; -1], [4 -1; -1 1]);
  tempMat = [0 1; -1 0];
  outEllObj = shape(ellObj, tempMat)

  outEllObj =

  Center:
      -2
      -1

  Shape:
      1     1
      1     4

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>TOPOLYTOPE - for ellipsoid ell makes polytope object represanting the
             boundary of ell

Input:
  regular:
      ell: ellipsoid[1,1] - ellipsoid in 3D or 2D.
  optional:
      nPoints: double[1,1] - number of boundary points.
               Actually number of points in resulting
               polytope will be ecual to lowest
               number of points of icosaeder, that greater
               than nPoints.

Output:
  regular:
      poly: polytope[1,1] - polytop in 3D or 2D.</pre>
</div>
<div class="highlight-python"><pre>toStruct -- converts ellipsoid array into structural array.

Input:
  regular:
      ellArr: ellipsoid [nDim1, nDim2, ...] - array
          of ellipsoids.
Output:
  SDataArr: struct[nDims1,...,nDimsk] - structure array same size, as
      ellArr, contain all data.
  SFieldNiceNames: struct[1,1] - structure with the same fields as SDataArr. Field values
      contain the nice names.
  SFieldDescr: struct[1,1] - structure with same fields as SDataArr,
      values contain field descriptions.

      q: double[1, nEllDim] - the center of ellipsoid
      Q: double[nEllDim, nEllDim] - the shape matrix of ellipsoid

Example:
  ellObj = ellipsoid([1 1]', eye(2));
  ellObj.toStruct()

  ans =

  Q: [2x2 double]
  q: [1 1]</pre>
</div>
<div class="highlight-python"><pre>TRACE - returns the trace of the ellipsoid.

   trArr = TRACE(ellArr)  Computes the trace of ellipsoids in
      ellipsoidal array ellArr.

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.

Output:
   trArr: double [nDims1,nDims2,...,nDimsN] - array of trace values,
      same size as ellArr.

Example:
  firstEllObj = ellipsoid([4 -1; -1 1]);
  secEllObj = ell_unitball(2);
  ellVec = [firstEllObj secEllObj];
  trVec = ellVec.trace()

  trVec =

      5     2</pre>
</div>
<div class="highlight-python"><pre>UMINUS - changes the sign of the centerVec of ellipsoid.

Input:
   regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids.


Output:
   outEllArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array of ellipsoids,
       same size as ellArr.

Example:
  ellObj = -ellipsoid([-2; -1], [4 -1; -1 1])

  ellObj =

  Center:
       2
       1

  Shape:
       4    -1
      -1     1

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>VOLUME - returns the volume of the ellipsoid.

   volArr = VOLUME(ellArr)  Computes the volume of ellipsoids in
      ellipsoidal array ellArr.

   The volume of ellipsoid E(q, Q) with center q and shape matrix Q
   is given by V = S sqrt(det(Q)) where S is the volume of unit ball.

Input:
  regular:
      ellArr: ellipsoid [nDims1,nDims2,...,nDimsN] - array
          of ellipsoids.

Output:
   volArr: double [nDims1,nDims2,...,nDimsN] - array of
      volume values, same size as ellArr.

Example:
  firstEllObj = ellipsoid([4 -1; -1 1]);
  secEllObj = ell_unitball(2);
  ellVec = [firstEllObj secEllObj]
  volVec = ellVec.volume()

  volVec =

      5.4414     3.1416</pre>
</div>
</div>
<div class="section" id="hyperplane">
<h2>hyperplane<a class="headerlink" href="#hyperplane" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>CHECKISME - determine whether input object is hyperplane. And display
            message and abort function if input object
            is not hyperplane

Input:
  regular:
      someObjArr: any[] - any type array of objects.

Example:
  hypObj = hyperplane([-2, 0]);
  hyperplane.checkIsMe(hypObj)</pre>
</div>
<div class="highlight-python"><pre>CONTAINS - checks if given vectors belong to the hyperplanes.

  isPosArr = CONTAINS(myHypArr, xArr) - Checks if vectors specified
      by columns xArr(:, hpDim1, hpDim2, ...) belong
      to hyperplanes in myHypArr.

Input:
  regular:
      myHypArr: hyperplane [nCols, 1]/[1, nCols]/
          /[hpDim1, hpDim2, ...]/[1, 1] - array of hyperplanes
          of the same dimentions nDims.
      xArr: double[nDims, nCols]/[nDims, hpDim1, hpDim2, ...]/
          /[nDims, 1]/[nDims, nVecArrDim1, nVecArrDim2, ...] - array
          whose columns represent the vectors needed to be checked.

          note: if size of myHypArr is [hpDim1, hpDim2, ...], then
              size of xArr is [nDims, hpDim1, hpDim2, ...]
              or [nDims, 1], if size of myHypArr [1, 1], then xArr
              can be any size [nDims, nVecArrDim1, nVecArrDim2, ...],
              in this case output variable will has
              size [1, nVecArrDim1, nVecArrDim2, ...]. If size of
              xArr is [nDims, nCols], then size of myHypArr may be
              [nCols, 1] or [1, nCols] or [1, 1], output variable
              will has size respectively
              [nCols, 1] or [1, nCols] or [nCols, 1].

Output:
  isPosArr: logical[hpDim1, hpDim2,...] /
      / logical[1, nVecArrDim1, nVecArrDim2, ...],
      isPosArr(iDim1, iDim2, ...) = true - myHypArr(iDim1, iDim2, ...)
      contains xArr(:, iDim1, iDim2, ...), false - otherwise.

Example:
  hypObj = hyperplane([-1; 1]);
  tempMat = [100 -1 2; 100 1 2];
  hypObj.contains(tempMat)

  ans =

       1
       0
       1</pre>
</div>
<div class="highlight-python"><pre>Hyperplane object of the Ellipsoidal Toolbox.


Functions:
----------
 hyperplane - Constructor of hyperplane object.
 double     - Returns parameters of hyperplane, i.e. normal vector and
              shift.
 parameters - Same function as 'double' (legacy matter).
 dimension  - Returns dimension of hyperplane.
 isempty    - Checks if hyperplane is empty.
 isparallel - Checks if one hyperplane is parallel to the other one.
 contains   - Check if hyperplane contains given point.


Overloaded operators and functions:
-----------------------------------
 eq      - Checks if two hyperplanes are equal.
 ne      - The opposite of 'eq'.
 uminus  - Switches signs of normal and shift parameters to the opposite.
 display - Displays the details about given hyperplane object.
 plot    - Plots hyperplane in 2D and 3D.</pre>
</div>
<div class="highlight-python"><pre>DIMENSION - returns dimensions of hyperplanes in the array.

  dimsArr = DIMENSION(hypArr) - returns dimensions of hyperplanes
      described by hyperplane structures in the array hypArr.

Input:
  regular:
      hypArr: hyperplane [nDims1, nDims2, ...] - array
          of hyperplanes.

Output:
      dimsArr: double[nDims1, nDims2, ...] - dimensions
          of hyperplanes.

Example:
  firstHypObj = hyperplane([-1; 1]);
  secHypObj = hyperplane([-1; 1; 8; -2; 3], 7);
  thirdHypObj = hyperplane([1; 2; 0], -1);
  hypVec = [firstHypObj secHypObj thirdHypObj];
  dimsVec  = hypVec.dimension()

  dimsVec =

     2     5     3</pre>
</div>
<div class="highlight-python"><pre>DISPLAY - Displays hyperplane object.

Input:
  regular:
      myHypArr: hyperplane [hpDim1, hpDim2, ...] - array
          of hyperplanes.

Example:
  hypObj = hyperplane([-1; 1]);
  display(hypObj)

  hypObj =
  size: [1 1]

  Element: [1 1]
  Normal:
      -1
       1

  Shift:
       0

  Hyperplane in R^2.</pre>
</div>
<div class="highlight-python"><pre>DOUBLE - return parameters of hyperplane - normal vector and shift.

  [normVec, hypScal] = DOUBLE(myHyp) - returns normal vector
      and scalar value of the hyperplane.

Input:
  regular:
      myHyp: hyperplane [1, 1] - single hyperplane of dimention nDims.

Output:
  normVec: double[nDims, 1] - normal vector of the hyperplane myHyp.
  hypScal: double[1, 1] - scalar of the hyperplane myHyp.

Example:
  hypObj = hyperplane([-1; 1]);
  [normVec, hypScal] = double(hypObj)

  normVec =

      -1
       1

  hypScal =

       0</pre>
</div>
<div class="highlight-python"><pre>FROMREPMAT - returns array of equal hyperplanes the same
             size as stated in sizeVec argument

  hpArr = fromRepMat(sizeVec) - creates an array  size
           sizeVec of empty hyperplanes.

  hpArr = fromRepMat(normalVec,sizeVec) - creates an array
           size sizeVec of hyperplanes with normal
           normalVec.

  hpArr = fromRepMat(normalVec,shift,sizeVec) - creates an
           array size sizeVec of hyperplanes with normal normalVec
           and hyperplane shift shift.

Input:
  Case1:
      regular:
          sizeVec: double[1,n] - vector of size, have
          integer values.

  Case2:
      regular:
          normalVec: double[nDim, 1] - normal of
          hyperplanes.
          sizeVec: double[1, n] - vector of size, have
          integer values.

  Case3:
      regular:
          normalVec: double[nDim, 1] - normal of
          hyperplanes.
          shift: double[1, 1] - shift of hyperplane.
          sizeVec: double[1,n] - vector of size, have
          integer values.

  properties:
      absTol: double [1,1] - absolute tolerance with default
          value 10^(-7)</pre>
</div>
<div class="highlight-python"><pre>fromStruct -- converts structural array into hyperplanes array.

Input:
  regular:
  SHpArr: struct [hpDim1, hpDim2, ...] -  structural array with following fields:

       normal: double[nHpDim, 1] - the normal of hyperplane
       shift: double[1, 1] - the shift of hyperplane

Output:
  hpArr : hyperplane [nDim1, nDim2, ...] - hyperplane array with size of
      SHpArr.


Example:
  hpObj = hyperplane([1 1]', 1);
  hpObj.toStruct()

  ans =

  normal: [2x1 double]
  shift: 0.7071</pre>
</div>
<div class="highlight-python"><pre>GETABSTOL - gives the array of absTol for all elements in hplaneArr

Input:
  regular:
      ellArr: hyperplane[nDim1, nDim2, ...] - multidimension array
          of hyperplane
  optional
      fAbsTolFun: function_handle[1,1] - function that apply
          to the absTolArr. The default is @min.

Output:
  regular:
      absTolArr: double [absTol1, absTol2, ...] - return absTol for
          each element in hplaneArr
  optional:
      absTol: double[1, 1] - return result of work fAbsTolFun with
          the absTolArr

Usage:
  use [~,absTol] = hplaneArr.getAbsTol() if you want get only
      absTol,
  use [absTolArr,absTol] = hplaneArr.getAbsTol() if you want get
      absTolArr and absTol,
  use absTolArr = hplaneArr.getAbsTol() if you want get only absTolArr

Example:
  firstHypObj = hyperplane([-1; 1]);
  secHypObj = hyperplane([-2; 5]);
  hypVec = [firstHypObj secHypObj];
  hypVec.getAbsTol()

  ans =

     1.0e-07 *

      1.0000    1.0000</pre>
</div>
<div class="highlight-python"><pre>GETCOPY - gives array the same size as hpArr with copies of elements of
          hpArr.

Input:
  regular:
      hpArr: hyperplane[nDim1, nDim2,...] - multidimensional array of
          hyperplanes.

Output:
  copyHpArr: hyperplane[nDim1, nDim2,...] - multidimension array of
      copies of elements of hpArr.

Example:
  firstHpObj = hyperplane([-1; 1], [2 0; 0 3]);
  secHpObj = hyperplane([1; 2], eye(2));
  hpVec = [firstHpObj secHpObj];
  copyHpVec = getCopy(hpVec)

  copyHpVec =
  1x2 array of hyperplanes.</pre>
</div>
<div class="highlight-python"><pre>GETPROPERTY - gives array the same size as hpArr with values of
              propName properties for each hyperplane in hpArr.
              Private method, used in every public property getter.

Input:
  regular:
      hpArr: hyperplane[nDim1, nDim2,...] - mltidimensional array
          of hyperplanes
      propName: char[1,N] - name property
  optional:
      fPropFun: function_handle[1,1] - function that apply
          to the propArr. The default is @min.

Output:
  regular:
      propArr: double[nDim1, nDim2,...] - multidimension array of
          propName properties for hyperplanes in rsArr
  optional:
      propVal: double[1, 1] - return result of work fPropFun with
          the propArr</pre>
</div>
<div class="highlight-python"><pre>GETRELTOL - gives the array of relTol for all elements in hpArr

Input:
  regular:
      hpArr: hyperplane[nDim1, nDim2, ...] - multidimension array
          of hyperplanes
  optional:
      fRelTolFun: function_handle[1,1] - function that apply
          to the relTolArr. The default is @min.
Output:
  regular:
      relTolArr: double [relTol1, relTol2, ...] - return relTol for
          each element in hpArr
  optional:
      relTol: double[1,1] - return result of work fRelTolFun with
          the relTolArr

Usage:
  use [~,relTol] = hpArr.getRelTol() if you want get only
      relTol,
  use [relTolArr,relTol] = hpArr.getRelTol() if you want get
      relTolArr and relTol,
  use relTolArr = hpArr.getRelTol() if you want get only relTolArr

Example:
  firsthpObj = hyperplane([-1; 1], 1);
  sechpObj = hyperplane([1 ;2], 2);
  hpVec = [firsthpObj sechpObj];
  hpVec.getRelTol()

  ans =

     1.0e-05 *

      1.0000    1.0000</pre>
</div>
<div class="highlight-python"><pre>HYPERPLANE - creates hyperplane structure
             (or array of hyperplane structures).

  Hyperplane H = { x in R^n : &lt;v, x&gt; = c },
  with current "Properties"..
  Here v must be vector in R^n, and c - scalar.

  hypH = HYPERPLANE - create empty hyperplane.

  hypH = HYPERPLANE(hypNormVec) - create
      hyperplane object hypH with properties:
          hypH.normal = hypNormVec,
          hypH.shift = 0.

  hypH = HYPERPLANE(hypNormVec, hypConst) - create
      hyperplane object hypH with properties:
          hypH.normal = hypNormVec,
          hypH.shift = hypConst.

  hypH = HYPERPLANE(hypNormVec, hypConst, ...
      'absTol', absTolVal) - create
      hyperplane object hypH with properties:
          hypH.normal = hypNormVec,
          hypH.shift = hypConst.
          hypH.absTol = absTolVal

  hypObjArr = HYPERPLANE(hypNormArr, hypConstArr) - create
      array of hyperplanes object just as
      hyperplane(hypNormVec, hypConst).

  hypObjArr = HYPERPLANE(hypNormArr, hypConstArr, ...
      'absTol', absTolValArr) - create
      array of hyperplanes object just as
      hyperplane(hypNormVec, hypConst, 'absTol', absTolVal).

Input:
  Case1:
    regular:
      hypNormArr: double[hpDims, nDims1, nDims2,...] -
          array of vectors in R^hpDims. There hpDims -
          hyperplane dimension.

  Case2:
    regular:
      hypNormArr: double[hpDims, nCols] /
          / [hpDims, nDims1, nDims2,...] /
          / [hpDims, 1] - array of vectors
          in R^hpDims. There hpDims - hyperplane dimension.
      hypConstArr: double[1, nCols] / [nCols, 1] /
          / [nDims1, nDims2,...] /
          / [nVecArrDim1, nVecArrDim2,...] -
          array of scalar.

  Case3:
    regular:
      hypNormArr: double[hpDims, nCols] /
          / [hpDims, nDims1, nDims2,...] /
          / [hpDims, 1] - array of vectors
          in R^hpDims. There hpDims - hyperplane dimension.
      hypConstArr: double[1, nCols] / [nCols, 1] /
          / [nDims1, nDims2,...] /
          / [nVecArrDim1, nVecArrDim2,...] -
          array of scalar.
      absTolValArr: double[1, 1] - value of
          absTol propeties.

    properties:
      propMode: char[1,] - property mode, the following
          modes are supported:
          'absTol' - name of absTol properties.

          note: if size of hypNormArr is
              [hpDims, nDims1, nDims2,...], then size of
              hypConstArr is [nDims1, nDims2, ...] or
              [1, 1], if size of hypNormArr [hpDims, 1],
              then hypConstArr can be any size
              [nVecArrDim1, nVecArrDim2, ...],
              in this case output variable will has
              size [nVecArrDim1, nVecArrDim2, ...].
              If size of hypNormArr is [hpDims, nCols],
              then size of hypConstArr may be
              [1, nCols] or [nCols, 1],
              output variable will has size
              respectively [1, nCols] or [nCols, 1].

Output:
  hypObjArr: hyperplane [nDims1, nDims2...] /
      / hyperplane [nVecArrDim1, nVecArrDim2, ...] -
      array of hyperplane structure hypH:
          hypH.normal - vector in R^hpDims,
          hypH.shift  - scalar.

Example:
  hypNormMat = [1 1 1; 1 1 1];
  hypConstVec = [1 -5 0];
  hypObj = hyperplane(hypNormMat, hypConstVec);</pre>
</div>
<div class="highlight-python"><pre>ISEMPTY - checks if hyperplanes in H are empty.

Input:
  regular:
      myHypArr: hyperplane [nDims1, nDims2, ...] - array
          of hyperplanes.

Output:
  isPositiveArr: logical[nDims1, nDims2, ...],
      isPositiveArr(iDim1, iDim2, ...) = true - if ellipsoid
      myHypArr(iDim1, iDim2, ...) is empty, false - otherwise.

Example:
  hypObj = hyperplane();
  isempty(hypObj)

  ans =

       1</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - produces logical array the same size as
          ellFirstArr/ellFirstArr (if they have the same).
          isEqualArr[iDim1, iDim2,...] is true if corresponding
          ellipsoids are equal and false otherwise.

Input:
  regular:
      ellFirstArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
          of ellipsoids.
      ellSecArr: ellipsoid[nDim1, nDim2,...] - multidimensional array
          of ellipsoids.
  properties:
      'isPropIncluded': makes to compare second value properties, such as
      absTol etc.
Output:
  isEqualArr: logical[nDim1, nDim2,...] - multidimension array of
      logical values. isEqualArr[iDim1, iDim2,...] is true if
      corresponding ellipsoids are equal and false otherwise.

  reportStr: char[1,] - comparison report.</pre>
</div>
<div class="highlight-python"><pre>ISPARALLEL - check if two hyperplanes are parallel.

  isResArr = ISPARALLEL(fstHypArr, secHypArr) - Checks if hyperplanes
      in fstHypArr are parallel to hyperplanes in secHypArr and
      returns array of true and false of the size corresponding
      to the sizes of fstHypArr and secHypArr.

Input:
  regular:
      fstHypArr: hyperplane [nDims1, nDims2, ...] - first array
          of hyperplanes
      secHypArr: hyperplane [nDims1, nDims2, ...] - second array
          of hyperplanes

Output:
  isPosArr: logical[nDims1, nDims2, ...] -
      isPosArr(iFstDim, iSecDim, ...) = true -
      if fstHypArr(iFstDim, iSecDim, ...) is parallel
      secHypArr(iFstDim, iSecDim, ...), false - otherwise.

Example:
  hypObj = hyperplane([-1 1 1; 1 1 1; 1 1 1], [2 1 0]);
  hypObj.isparallel(hypObj(2))

  ans =

       0     1     1</pre>
</div>
<div class="highlight-python"><pre>PARAMETERS - return parameters of hyperplane - normal vector and shift.

  [normVec, hypScal] = PARAMETERS(myHyp) - returns normal vector
      and scalar value of the hyperplane.

Input:
  regular:
      myHyp: hyperplane [1, 1] - single hyperplane of dimention nDims.

Output:
  normVec: double[nDims, 1] - normal vector of the hyperplane myHyp.
  hypScal: double[1, 1] - scalar of the hyperplane myHyp.

Example:
  hypObj = hyperplane([-1; 1]);
  [normVec, hypScal] = parameters(hypObj)

  normVec =

      -1
       1


  hypScal =

       0</pre>
</div>
<div class="highlight-python"><pre>PLOT - plots hyperplaces in 2D or 3D.


Usage:
      plot(hyp) - plots hyperplace hyp in default (red) color.
      plot(hypArr) - plots an array of hyperplaces.
      plot(hypArr, 'Property',PropValue,...) - plots hypArr with setting
                                               properties.

Input:
  regular:
      hypArr:  Hyperplace: [dim11Size,dim12Size,...,dim1kSize] -
               array of 2D or 3D hyperplace objects. All hyperplaces in hypArr
               must be either 2D or 3D simutaneously.
  optional:
      color1Spec: char[1,1] - color specification code, can be 'r','g',
                              etc (any code supported by built-in Matlab function).
      hyp2Arr: Hyperplane: [dim21Size,dim22Size,...,dim2kSize] -
                                          second Hyperplane array...
      color2Spec: char[1,1] - same as color1Spec but for hyp2Arr
      ....
      hypNArr: Hyperplane: [dimN1Size,dim22Size,...,dimNkSize] -
                                           N-th Hyperplane array
      colorNSpec - same as color1Spec but for hypNArr.
  properties:
      'newFigure': logical[1,1] - if 1, each plot command will open a new figure window.
                   Default value is 0.
      'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
              if 1, ellipsoids in 2D will be filled with color. Default value is 0.
      'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
                   line width for 1D and 2D plots. Default value is 1.
      'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
               sets default colors in the form [x y z]. Default value is [1 0 0].
      'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
               level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
               Default value is 0.4.
      'size': double[1,1] - length of the line segment in 2D, or square diagonal in 3D.
      'center': double[1,dimHyp] - center of the line segment in 2D, of the square in 3D
      'relDataPlotter' - relation data plotter object.
      Notice that property vector could have different dimensions, only
      total number of elements must be the same.
Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.</pre>
</div>
<div class="highlight-python"><pre>toStruct -- converts hyperplanes array into structural array.

Input:
  regular:
      hpArr: hyperplane [hpDim1, hpDim2, ...] - array
          of hyperplanes.

Output:
  ShpArr : struct[nDim1, nDim2, ...] - structural array with size of
      hpArr with the following fields:

      normal: double[nHpDim, 1] - the normal of hyperplane
      shift: double[1, 1] - the shift of hyperplane</pre>
</div>
<div class="highlight-python"><pre>UMINUS - switch signs of normal vector and the shift scalar
         to the opposite.

Input:
  regular:
      inpHypArr: hyperplane [nDims1, nDims2, ...] - array
          of hyperplanes.

Output:
  outHypArr: hyperplane [nDims1, nDims2, ...] - array
      of the same hyperplanes as in inpHypArr whose
      normals and scalars are multiplied by -1.

Example:
  hypObj = -hyperplane([-1; 1], 1)

  hypObj =
  size: [1 1]

  Element: [1 1]
  Normal:
       1
      -1

  Shift:
      -1

  Hyperplane in R^2.</pre>
</div>
</div>
<div class="section" id="elltool-conf-properties">
<h2>elltool.conf.Properties<a class="headerlink" href="#elltool-conf-properties" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>PROPERTIES - a static class, providing emulation of static properties for
             toolbox.</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.checkSettings()</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getAbsTol();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getConfRepoMgr()

  ans =

    elltool.conf.ConfRepoMgr handle
    Package: elltool.conf

    Properties:
      DEFAULT_STORAGE_BRANCH_KEY: '_default'</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getIsEnabledOdeSolverOptions();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getIsODENormControl();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getIsVerbose();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getNPlot2dPoints();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getNPlot3dPoints();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getNTimeGridPoints();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getODESolverName();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getConfRepoMgr.getCurConf()

  ans =

                    version: '1.4dev'
                  isVerbose: 0
                     absTol: 1.0000e-07
                     relTol: 1.0000e-05
            nTimeGridPoints: 200
              ODESolverName: 'ode45'
           isODENormControl: 'on'
  isEnabledOdeSolverOptions: 0
              nPlot2dPoints: 200
              nPlot3dPoints: 200
                    logging: [1x1 struct]</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.getVersion();</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.init()</pre>
</div>
<div class="highlight-python"><pre>PARSEPROP - parses input into cell array with values of properties listed
           in neededPropNameList.
           Values are  taken from args or, if there no value for some
           property in args, in current Properties.


Input:
  regular:
      args: cell[1,] of any[] - cell array of arguments that
          should be parsed.
  optional
      neededPropNameList: cell[1,nProp] of char[1,] - cell array of strings
          containing names of parameters, that output should consist of.
          The following properties are supported:
              version
              isVerbose
              absTol
              relTol
              regTol
              ODESolverName
              isODENormControl
              isEnabledOdeSolverOptions
              nPlot2dPoints
              nPlot3dPoints
              nTimeGridPoints
          trying to specify other properties would be result in error
          If neededPropNameList is not specified, the list of all
          supported properties is assumed.

Output:
  propVal1:  - value of the first property specified
                             in neededPropNameList in the same order as
                             they listed in neededPropNameList
      ....
  propValN:  - value of the last property from neededPropNameList
  restList: cell[1,nRest] - list of the input arguments that were not
      recognized as properties

Example:
    testAbsTol = 1;
    testRelTol = 2;
    nPlot2dPoints = 3;
    someArg = 4;
    args = {'absTol',testAbsTol, 'relTol',testRelTol,'nPlot2dPoints',...
        nPlot2dPoints, 'someOtherArg', someArg};
    neededPropList = {'absTol','relTol'};
    [absTol, relTol,resList]=elltool.conf.Properties.parseProp(args,...
        neededPropList)

    absTol =

         1


    relTol =

         2


    resList =

        'nPlot2dPoints'    [3]    'someOtherArg'    [4]</pre>
</div>
<div class="highlight-python"><pre>Example:
  prevConfRepo = Properties.getConfRepoMgr();
  prevAbsTol = prevConfRepo.getParam('absTol');
  elltool.conf.Properties.setConfRepoMgr(prevConfRepo);</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.setIsVerbose(true);</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.setNPlot2dPoints(300);</pre>
</div>
<div class="highlight-python"><pre>Example:
  elltool.conf.Properties.setNTimeGridPoints(300);</pre>
</div>
<div class="highlight-python"><pre>SETRELTOL - set global relative tolerance

Input
relTol: double[1,1]</pre>
</div>
</div>
<div class="section" id="elltool-core-genellipsoid">
<h2>elltool.core.GenEllipsoid<a class="headerlink" href="#elltool-core-genellipsoid" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>GENELLIPSOID - class of generalized ellipsoids

Input:
  Case1:
    regular:
      qVec: double[nDim,1] - ellipsoid center
      qMat: double[nDim,nDim] / qVec: double[nDim,1] - ellipsoid matrix
          or diagonal vector of eigenvalues, that may contain infinite
          or zero elements

  Case2:
    regular:
      qMat: double[nDim,nDim] / qVec: double[nDim,1] - diagonal matrix or
          vector, may contain infinite or zero elements

  Case3:
    regular:
      qVec: double[nDim,1] - ellipsoid center
      dMat: double[nDim,nDim] / dVec: double[nDim,1] - diagonal matrix or
          vector, may contain infinite or zero elements
      wMat: double[nDim,nDim] - any square matrix


Output:
  self: GenEllipsoid[1,1] - created generalized ellipsoid

Example:
  ellObj = elltool.core.GenEllipsoid([5;2], eye(2));
  ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);</pre>
</div>
<div class="highlight-python"><pre>Example:
  firstEllObj = elltool.core.GenEllipsoid([1; 1], eye(2));
  secEllObj = elltool.core.GenEllipsoid([0; 5], 2*eye(2));
  ellVec = [firstEllObj secEllObj];
  ellVec.dimension()

  ans =

       2     2</pre>
</div>
<div class="highlight-python"><pre>Example:
  ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
  ellObj.display()
     |
     |----- q : [5 2]
     |          -------
     |----- Q : |10|19|
     |          |19|41|
     |          -------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----</pre>
</div>
<div class="highlight-python"><pre>Example:
  ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
  ellObj.getCenter()

  ans =

       5
       2</pre>
</div>
<div class="highlight-python"><pre>Example:
  ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
  ellObj.getCheckTol()

  ans =

     1.0000e-09</pre>
</div>
<div class="highlight-python"><pre>Example:
  ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
  ellObj.getDiagMat()

  ans =

      0.9796         0
           0   50.0204</pre>
</div>
<div class="highlight-python"><pre>Example:
  ellObj = elltool.core.GenEllipsoid([5;2], eye(2), [1 3; 4 5]);
  ellObj.getEigvMat()

  ans =

      0.9034   -0.4289
     -0.4289   -0.9034</pre>
</div>
<div class="highlight-python"><pre>Example:
  firstEllObj = elltool.core.GenEllipsoid([10;0], 2*eye(2));
  secEllObj = elltool.core.GenEllipsoid([0;0], [1 0; 0 0.1]);
  curDirMat = [1; 0];
  isOk=getIsGoodDir(firstEllObj,secEllObj,dirsMat)

  isOk =

       1</pre>
</div>
<div class="highlight-python"><pre>INV - create generalized ellipsoid whose matrix in pseudoinverse
      to the matrix of input generalized ellipsoid

Input:
  regular:
      ellObj: GenEllipsoid: [1,1] - generalized ellipsoid

Output:
  ellInvObj: GenEllipsoid: [1,1] - inverse generalized ellipsoid

Example:
  ellObj = elltool.core.GenEllipsoid([5;2], [1 0; 0 0.7]);
  ellObj.inv()
     |
     |----- q : [5 2]
     |          -----------------
     |----- Q : |1      |0      |
     |          |0      |1.42857|
     |          -----------------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----</pre>
</div>
<div class="highlight-python"><pre>MINKDIFFEA - computes tight external ellipsoidal approximation for
             Minkowsky difference of two generalized ellipsoids

Input:
  regular:
      ellObj1: GenEllipsoid: [1,1] - first generalized ellipsoid
      ellObj2: GenEllipsoid: [1,1] - second generalized ellipsoid
      dirMat: double[nDim,nDir] - matrix whose columns specify
          directions for which approximations should be computed
Output:
  resEllVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
      external approximation of the dirrence of first and second
      generalized ellipsoids (may contain empty ellipsoids if in specified
      directions approximation cannot be computed)

Example:
  firstEllObj = elltool.core.GenEllipsoid([10;0], 2*eye(2));
  secEllObj = elltool.core.GenEllipsoid([0;0], [1 0; 0 0.1]);
  dirsMat = [1,0].';
  resEllVec  = minkDiffEa( firstEllObj, secEllObj, dirsMat)
     |
     |----- q : [10 0]
     |          -------------------
     |----- Q : |0.171573|0       |
     |          |0       |1.20557 |
     |          -------------------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----</pre>
</div>
<div class="highlight-python"><pre>MINKDIFFIA - computes tight internal ellipsoidal approximation for
             Minkowsky difference of two generalized ellipsoids

Input:
  regular:
      ellObj1: GenEllipsoid: [1,1] - first generalized ellipsoid
      ellObj2: GenEllipsoid: [1,1] - second generalized ellipsoid
      dirMat: double[nDim,nDir] - matrix whose columns specify
          directions for which approximations should be computed
Output:
  resEllVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
      internal approximation of the dirrence of first and second
      generalized ellipsoids

Example:
  firstEllObj = elltool.core.GenEllipsoid([10;0], 2*eye(2));
  secEllObj = elltool.core.GenEllipsoid([0;0], [1 0; 0 0.1]);
  dirsMat = [1,0].';
  resEllVec  = minkDiffIa( firstEllObj, secEllObj, dirsMat)
     |
     |----- q : [10 0]
     |          -------------------
     |----- Q : |0.171573|0       |
     |          |0       |0.544365|
     |          -------------------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----</pre>
</div>
<div class="highlight-python"><pre>MINKSUMEA - computes tight external ellipsoidal approximation for
            Minkowsky sum of the set of generalized ellipsoids

Input:
  regular:
      ellObjVec: GenEllipsoid: [kSize,mSize] - vector of  generalized
                                          ellipsoid
      dirMat: double[nDim,nDir] - matrix whose columns specify
          directions for which approximations should be computed
Output:
  ellResVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
      external approximation of the dirrence of first and second
      generalized ellipsoids

Example:
  firstEllObj = elltool.core.GenEllipsoid([1;1],eye(2));
  secEllObj = elltool.core.GenEllipsoid([5;0],[3 0; 0 2]);
  ellVec = [firstEllObj secEllObj];
  dirsMat = [1 3; 2 4];
  ellResVec  = minkSumEa(ellVec, dirsMat )

  Structure(1)
     |
     |----- q : [6 1]
     |          -----------------
     |----- Q : |7.50584|0      |
     |          |0      |5.83164|
     |          -----------------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----
     O

  Structure(2)
     |
     |----- q : [6 1]
     |          -----------------
     |----- Q : |7.48906|0      |
     |          |0      |5.83812|
     |          -----------------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----
     O</pre>
</div>
<div class="highlight-python"><pre>MINKSUMIA - computes tight internal ellipsoidal approximation for
            Minkowsky sum of the set of generalized ellipsoids

Input:
  regular:
      ellObjVec: GenEllipsoid: [kSize,mSize] - vector of  generalized
                                          ellipsoid
      dirMat: double[nDim,nDir] - matrix whose columns specify
          directions for which approximations should be computed
Output:
  ellResVec: GenEllipsoid[1,nDir] - vector of generalized ellipsoids of
      internal approximation of the dirrence of first and second
      generalized ellipsoids

Example:
  firstEllObj = elltool.core.GenEllipsoid([1;1],eye(2));
  secEllObj = elltool.core.GenEllipsoid([5;0],[3 0; 0 2]);
  ellVec = [firstEllObj secEllObj];
  dirsMat = [1 3; 2 4];
  ellResVec  = minkSumIa(ellVec, dirsMat )

  Structure(1)
     |
     |----- q : [6 1]
     |          ---------------------
     |----- Q : |7.45135  |0.0272432|
     |          |0.0272432|5.81802  |
     |          ---------------------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----
     O

  Structure(2)
     |
     |----- q : [6 1]
     |          ---------------------
     |----- Q : |7.44698  |0.0315642|
     |          |0.0315642|5.81445  |
     |          ---------------------
     |          -----
     |-- QInf : |0|0|
     |          |0|0|
     |          -----
     O</pre>
</div>
<div class="highlight-python"><pre>PLOT - plots ellipsoids in 2D or 3D.


Usage:
      plot(ell) - plots generic ellipsoid ell in default (red) color.
      plot(ellArr) - plots an array of generic ellipsoids.
      plot(ellArr, 'Property',PropValue,...) - plots ellArr with setting
                                               properties.

Input:
  regular:
      ellArr:  elltool.core.GenEllipsoid: [dim11Size,dim12Size,...,
               dim1kSize] - array of 2D or 3D GenEllipsoids objects.
               All ellipsoids in ellArr  must be either 2D or 3D
               simutaneously.
  optional:
      color1Spec: char[1,1] - color specification code, can be 'r','g',
                              etc (any code supported by built-in Matlab
                              function).
      ell2Arr: elltool.core.GenEllipsoid: [dim21Size,dim22Size,...,
                              dim2kSize] - second ellipsoid array...
      color2Spec: char[1,1] - same as color1Spec but for ell2Arr
      ....
      ellNArr: elltool.core.GenEllipsoid: [dimN1Size,dim22Size,...,
                               dimNkSize] - N-th ellipsoid array
      colorNSpec - same as color1Spec but for ellNArr.
  properties:
      'newFigure': logical[1,1] - if 1, each plot command will open a new .
                   figure window Default value is 0.
      'fill': logical[1,1]/logical[dim11Size,dim12Size,...,dim1kSize]  -
              if 1, ellipsoids in 2D will be filled with color.
              Default value is 0.
      'lineWidth': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
               line width for 1D and 2D plots.
               Default value is 1.
      'color': double[1,3]/double[dim11Size,dim12Size,...,dim1kSize,3] -
               sets default colors in the form [x y z].
               Default value is [1 0 0].
      'shade': double[1,1]/double[dim11Size,dim12Size,...,dim1kSize]  -
               level of transparency between 0 and 1 (0 - transparent,
               1 - opaque).
               Default value is 0.4.
      'relDataPlotter' - relation data plotter object.
      Notice that property vector could have different dimensions, only
      total number of elements must be the same.
Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.

Examples:
  plot([ell1, ell2, ell3], 'color', [1, 0, 1; 0, 0, 1; 1, 0, 0]);
  plot([ell1, ell2, ell3], 'color', [1; 0; 1; 0; 0; 1; 1; 0; 0]);
  plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1, 1, 1; 1, 1,
    1]);
  plot([ell1, ell2, ell3; ell1, ell2, ell3], 'shade', [1; 1; 1; 1; 1;
      1]);
  plot([ell1, ell2, ell3], 'shade', 0.5);
  plot([ell1, ell2, ell3], 'lineWidth', 1.5);
  plot([ell1, ell2, ell3], 'lineWidth', [1.5, 0.5, 3]);</pre>
</div>
<div class="highlight-python"><pre>Example:
  ellObj = elltool.core.GenEllipsoid([1;1],eye(2));
  dirsVec = [1; 0];
  [resRho, bndPVec] = rho(ellObj, dirsVec)

  resRho =

       2

 bndPVec =

       2
       1</pre>
</div>
</div>
<div class="section" id="smartdb-relations-atypifiedstaticrelation">
<h2>smartdb.relations.ATypifiedStaticRelation<a class="headerlink" href="#smartdb-relations-atypifiedstaticrelation" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>ATYPIFIEDSTATICRELATION is a constructor of static relation class
object

Usage: self=AStaticRelation(obj) or
       self=AStaticRelation(varargin)

Input:
  optional
    inpObj: ARelation[1,1]/SData: struct[1,1]
        structure with values of all fields
        for all tuples

    SIsNull: struct [1,1] - structure of fields with is-null
       information for the field content, it can be logical for
       plain real numbers of cell of logicals for cell strs or
       cell of cell of str for more complex types

    SIsValueNull: struct [1,1] - structure with logicals
        determining whether value corresponding to each field
        and each tuple is null or not

  properties:
      fillMissingFieldsWithNulls: logical[1,1] - if true,
          the relation fields absent in the input data
          structures are filled with null values

Output:
  regular:
    self: ATYPIFIEDSTATICRELATION [1,1] - constructed class object

Note: In the case the first interface is used, SData and
      SIsNull are taken from class object obj</pre>
</div>
<div class="highlight-python"><pre>ADDDATA - adds a set of field values to existing data in a form of new
          tuples

Input:
  regular:
     self:ARelation [1,1] - class object</pre>
</div>
<div class="highlight-python"><pre>ADDDATAALONGDIM - adds a set of field values to existing data using
                  a concatenation along a specified dimension

Input:
  regular:
      self: CubeStruct [1,1] - the object</pre>
</div>
<div class="highlight-python"><pre>ADDTUPLES - adds a set of new tuples to the relation

Usage: addTuplesInternal(self,varargin)

input:
  regular:
      self: ARelation [1,1] - class object
      SData: struct [1,1] - structure with values of all fields  for all
       tuples
  optional:
      SIsNull: struct [1,1] - structure of fields with is-null
        information for the field content, it can be logical for plain
        real numbers of cell of logicals for cell strs or cell of cell of
        str for more complex types

      SIsValueNull: struct [1,1] - structure with logicals determining
        whether value corresponding to each field and each tuple is null
        or not

  properties:
      checkConsistency: logical[1,1], if true, a consistency between the
         input structures is not checked, true by default</pre>
</div>
<div class="highlight-python"><pre>APPLYGETFUNC - applies a function to the specified fields as columns, i.e.
               the function is applied to each field as whole, not to
               each cell separately

Input:
  regular:
      hFunc: function_handle[1,1] - function to apply to each of the
         field values
  optional:
      toFieldNameList: char/cell[1,] of char - a list of fields to which
         the function specified by hFunc is to be applied

    Note: hFunc can optionally be specified after toFieldNameList
          parameter

Notes: this function currently has a lots of limitations:
  1) it assumes that the output is uniform
  2) the function is applies to SData part of field value
  3) no additional arguments can be passed
  All this limitations will eventually go away though so stay tuned...</pre>
</div>
<div class="highlight-python"><pre>APPLYSETFUNC - applies some function to each cell of the specified fields
               of a given CubeStruct object

Usage: applySetFunc(self,toFieldNameList,hFunc)
       applySetFunc(self,hFunc,toFieldNameList)

Input:
  regular:
      self: CubeStruct [1,1] - class object

      hFunc: function handle [1,1] - handle of function to be
        applied to fields, the function is assumed to
          1) have the same number of input/output arguments
          2) the number of input arguments should be
             length(structNameList)*length(fieldNameList)
          3) the input arguments should be ordered according to the
          following rule
              (x_struct_1_field_1,x_struct_1_field_2,...,struct_n_field1,
              ...,struct_n_field_m)

  optional:

      toFieldNameList: char or char cell [1,nFields] - list of
        field names to which given function should be applied

        Note1: field lists of length&gt;1 are not currently supported !
        Note2: it is possible to specify toFieldNameList before hFunc in
           which case the parameters will be recognized automatically

  properties:
      uniformOutput: logical[1,1] - specifies if the result
         of the function is uniform to be stored in non-cell
         field, by default it is false for cell fileds and
         true for non-cell fields

      structNameList: char[1,]/cell[1,], name of data structure/list of
        data structure names to which the function is to
             be applied, can be composed from the following values

           SData - data itself

           SIsNull - contains is-null indicator information for data
             values

           SIsValueNull - contains is-null indicators for CubeStruct
              cells (not for cell values)

        structNameList={'SData'} by default

      inferIsNull: logical[1,2] - if the first(second) element is true,
          SIsNull(SIsValueNull) indicators are inferred from SData,
          i.e. with this indicator set to true it is sufficient to apply
          the function only to SData while the rest of the structures
          will be adjusted automatically.

      inputType: char[1,] - specifies a way in which the field value is
         partitioned into individual cells before being passed as an
         input parameter to hFunc. This parameter directly corresponds to
         outputType parameter of toArray method, see its documentation
         for a list of supported input types.</pre>
</div>
<div class="highlight-python"><pre>APPLYTUPLEGETFUNC - applies a function to the specified fields
                    separately to each tuple

Input:
  regular:
      hFunc: function_handle[1,1] - function to apply to the specified
         fields
  optional:
      toFieldNameList: char/cell[1,] of char - a list of fields to which
         the function specified by hFunc is to be applied

  properties:
      uniformOutput: logical[1,1] - if true, output is expected to be
          uniform as in cellfun with 'UniformOutput'=true, default
           value is true

Output:
  funcOut1Arr: &lt;type1&gt;[] - array corresponding to the first output of the
      applied function
          ....
  funcOutNArr: &lt;typeN&gt;[] - array corresponding to the last output of the
      applied function


Notes: this function currently has a lots of limitations:
  1) the function is applies to SData part of field value
  2) no additional arguments can be passed
  All this limitations will eventually go away though so stay tuned...</pre>
</div>
<div class="highlight-python"><pre>CLEARDATA - deletes all the data from the object

Usage: self.clearData(self)

Input:
  regular:
    self: CubeStruct [1,1] - class object</pre>
</div>
<div class="highlight-python"><pre>CLONE - creates a copy of a specified object via calling
        a copy constructor for the object class

Input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object</pre>
</div>
<div class="highlight-python"><pre>COPYFROM - reconstruct CubeStruct object within a current object using the
           input CubeStruct object as a prototype

Input:
  regular:
    self: CubeStruct [n_1,...,n_k]
    obj: any [] - internal representation of the object

  optional:
    fieldNameList: cell[1,nFields] - list of fields to copy</pre>
</div>
<div class="highlight-python"><pre>CREATEINSTANCE - returns an object of the same class by calling a default
                 constructor (with no parameters)

Usage: resObj=getInstance(self)

input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object</pre>
</div>
<div class="highlight-python"><pre>DISPONUI - displays a content of the given relation as a data grid UI
           component.

Input:
  regular:
      self:
  properties:
      tableType: char[1,] - type of table used for displaying the data,
          the following types are supported:
          'sciJavaGrid' - proprietary Java-based data grid component
              is used
          'uitable'  - Matlab built-in uitable component is used.
              if not specified, the method tries to use sciJavaGrid
              if it is available, if not - uitable is used.

Output:
  hFigure: double[1,1] - figure handle containing the component
  gridObj: smartdb.relations.disp.UIDataGrid[1,1] - data grid component
      instance used for displaying a content of the relation object</pre>
</div>
<div class="highlight-python"><pre>DISPLAY - puts some textual information about CubeStruct object in screen

Input:
 regular:
     self.</pre>
</div>
<div class="highlight-python"><pre>FROMSTRUCTLIST - creates a dynamic relation from a list of structures
                 interpreting each structure as the data for
                 several tuples.

Input:
  regular:
      className: name of object class which will be created,
          the class constructor should accept 2 properties:
          'fieldNameList' and 'fieldTypeSpecList'

      structList: cell[] of struct[1,1] - list of structures

Output:
  relDataObj: smartdb.relations.DynamicRelation[1,1] -
     constructed relation</pre>
</div>
<div class="highlight-python"><pre>GETCOPY - returns an object copy

Usage: resObj=getCopy(self)

Input:
  regular:
    self: CubeStruct [1,1] - current CubeStruct object
  optional:
    same as for getData</pre>
</div>
<div class="highlight-python"><pre>GETDATA - returns an indexed projection of CubeStruct object's content

Input:
  regular:
      self: CubeStruct [1,1] - the object

  optional:

      subIndCVec:
        Case#1: numeric[1,]/numeric[,1]

        Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
              for i=1,...,nDims

          -array of indices of field value slices that are selected
          to be returned; if not given (default),
          no indexation is performed

        Note!: numeric components of subIndVec are allowed to contain
           zeros which are be treated as they were references to null
           data slices

      dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
          numbers corresponding to subIndCVec

  properties:

      fieldNameList: char[1,]/cell[1,nFields] of char[1,]
          list of field names to return

      structNameList: char[1,]/cell[1,nStructs] of char[1,]
          list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}

      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the cells,
              default value is false

      nullReplacements: cell[1,nReplacedFields]  - list of null
          replacements for each of the fields

      nullReplacementFields: cell[1,nReplacedFields] - list of fields in
         which the nulls are to be replaced with the specified values,
         if not specified it is assumed that all fields are to be
         replaced

         NOTE!: all fields not listed in this parameter are replaced with
         the default values

      checkInputs: logical[1,1] - true by default (input arguments are
         checked for correctness

Output:
  regular:
    SData: struct [1,1] - structure containing values of
        fields at the selected slices, each field is an array
        containing values of the corresponding type

    SIsNull: struct [1,1] - structure containing a nested
        array with is-null indicators for each CubeStruct cell content

    SIsValueNull: struct [1,1] - structure containing a
       logical array [] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value</pre>
</div>
<div class="highlight-python"><pre>GETFIELDDESCRLIST - returns the list of CubeStruct field descriptions

Usage: value=getFieldDescrList(self)

Input:
  regular:
      self: CubeStruct [1,1]
  optional:
      fieldNameList: cell[1,nSpecFields] of char[1,] - field names for
         which descriptions should be returned

Output:
  regular:
    value: char cell [1,nFields] - list of CubeStruct object field
        descriptions</pre>
</div>
<div class="highlight-python"><pre>GETFIELDISNULL - returns for given field a nested logical/cell array
                 containing is-null indicators for cell content

Usage: fieldIsNullCVec=getFieldIsNull(self,fieldName)

Input:
  regular:
    self: CubeStruct [1,1]
    fieldName: char - field name
Output:
  regular:
    fieldIsCVec: logical/cell[] - nested cell/logical array containing
       is-null indicators for content of the field</pre>
</div>
<div class="highlight-python"><pre>GETFIELDISVALUENULL - returns for given field logical vector determining
                      whether value of this field in each cell is null
                      or not.

BEWARE OF confusing this with getFieldIsNull method which returns is-null
   indicators for a field content

Usage: isNullVec=getFieldValueIsNull(self,fieldName)

Input:
  regular:
    self: CubeStruct [1,1]
    fieldName: char - field name

Output:
  regular:
    isValueNullVec: logical[] - array of isValueNull indicators for the
       specified field</pre>
</div>
<div class="highlight-python"><pre>GETFIELDNAMELIST - returns the list of CubeStruct object field names

Usage: value=getFieldNameList(self)

Input:
  regular:
    self: CubeStruct [1,1]
Iutput:
  regular:
    value: char cell [1,nFields] - list of CubeStruct object field
        names</pre>
</div>
<div class="highlight-python"><pre>GETFIELDPROJECTION - project object with specified fields.

Input:
  regular:
      self: ARelation[1,1] - original object
      fieldNameList: cell[1,nFields] of char[1,] - field name list

Output:
  obj: DynamicRelation[1,1] - projected object</pre>
</div>
<div class="highlight-python"><pre>GETFIELDTYPELIST - returns list of field types in given CubeStruct object

Usage: fieldTypeList=getFieldTypeList(self)

Input:
  regular:
      self: CubeStruct [1,1]

  optional:
      fieldNameList: cell[1,nFields] - list of field names

Output:
 regular:
  fieldTypeList: cell [1,nFields] of smartdb.cubes.ACubeStructFieldType[1,1]
      - list of field types</pre>
</div>
<div class="highlight-python"><pre>GETFIELDTYPESPECLIST - returns a list of field type specifications. Field
                       type specification is a sequence of type names
                       corresponding to field value types starting with
                       the top level and going down into the nested
                       content of a field (for a field having a complex
                       type).

Input:
  regular:
      self:
  optional:
      fieldNameList: cell [1,nFields] of char[1,] - list of field names
  properties:
      uniformOutput: logical[1,1] - if true, the result is concatenated
         across all the specified fields

Output:
  typeSpecList:
       Case#1: uniformOutput=false
          cell[1,nFields] of cell[1,nNestedLevels_i] of char[1,.]
       Case#2: uniformOutput=true
          cell[1,nFields*prod(nNestedLevelsVec)] of char[1,.]
       - list of field type specifications</pre>
</div>
<div class="highlight-python"><pre>GETFIELDVALUESIZEMAT - returns a matrix composed from the size vectors
                       for the specified fields

Input:
  regular:
      self:

  optional:
      fieldNameList: cell[1,nFields] - a list of fileds for which the size
         matrix is to be generated

  properties:
      skipMinDimensions: logical[1,1] - if true, the dimensions from 1 up
          to minDimensionality are skipped

      minDimension: numeric[1,1] - minimum dimension which definies a
         minimum number of columns in the resulting matrix

Output:
  sizeMat: double[nFields,nMaxDims]</pre>
</div>
<div class="highlight-python"><pre>GETISFIELDVALUENULL - returns a vector indicating whether a particular
                      field is composed of null values completely

Usage: isValueNullVec=getIsFieldValueNull(self,fieldNameList)

Input:
  regular:
    self: CubeStruct [1,1]

  optional:
    fieldNameList: cell[1,nFields] of char[1,] - list of field names

Output:
  regular:
    isValueNullVec: logical[1,nFields]</pre>
</div>
<div class="highlight-python"><pre>GETJOINWITH - returns a result of INNER join of given relation with
              another relation by the specified key fields

LIMITATION: key fields by which the join is peformed are required to form
a unique key in the given relation

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT)
          'leftOuter'

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result</pre>
</div>
<div class="highlight-python"><pre>GETMINDIMENSIONSIZE - returns a size vector for the specified
                      dimensions. If no dimensions are specified, a size
                      vector for all dimensions up to minimum CubeStruct
                      dimension is returned

Input:
  regular:
      self:
  optional:
      dimNumVec: numeric[1,nDims] - a vector of dimension
          numbers

Output:
  minDimensionSizeVec: double [1,nDims] - a size vector for
     the requested dimensions</pre>
</div>
<div class="highlight-python"><pre>GETMINDIMENSIONALITY - returns a minimum dimensionality for a given
                       object

Input:
  regular:
      self

Output:
  minDimensionality: double[1,1] - minimum dimensionality of
     self object</pre>
</div>
<div class="highlight-python"><pre>GETNELEMS - returns a number of elements in a given object
Input:
  regular:
     self:

Output:
  nElems:double[1, 1] - number of elements in a given object</pre>
</div>
<div class="highlight-python"><pre>GETNFIELDS - returns number of fields in given object

Usage: nFields=getNFields(self)

Input:
  regular:
    self: CubeStruct [1,1]
Output:
  regular:
    nFields: double [1,1] - number of fields in given object</pre>
</div>
<div class="highlight-python"><pre>GETNTUPLES - returns number of tuples in given relation

Usage: nTuples=getNTuples(self)

input:
  regular:
    self: ARelation [1,1] - class object
output:
  regular:
    nTuples: double [1,1] - number of tuples in given  relation</pre>
</div>
<div class="highlight-python"><pre>GETSORTINDEX - gets sort index for all tuples of given relation with
               respect to some of its fields

Usage: sortInd=getSortIndex(self,sortFieldNameList,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
    sortFieldNameList: char or char cell [1,nFields] - list of field
       names with respect to which tuples are sorted

  properties:
    Direction: char or char cell [1,nFields] - direction of sorting for
        all fields (if one value is given) or for each field separately;
        each value may be 'asc' or 'desc'
output:
  regular:
   sortIndex: double [nTuples,1] - sort index for all tuples such that if
       fieldValueVec is a vector of values for some field of given
       relation, then fieldValueVec(sortIndex) is a vector of values for
       this field when tuples of the relation are sorted</pre>
</div>
<div class="highlight-python"><pre>GETTUPLES - selects tuples with given indices from given relation and
            returns the result as new relation

Usage: obj=getTuples(self,subIndVec)

input:
  regular:
    self: ARelation [1,1] - class object
    subIndVec: double [nSubTuples,1]/logical[nTuples,1] - array of
        indices for tuples that are selected
output:
  regular:
    obj: ARelation [1,1] - new class object containing only selected
        tuples</pre>
</div>
<div class="highlight-python"><pre>GETTUPLESFILTEREDBY - selects tuples from given relation such that a
                      fixed index field contains values from a given set
                      of value and returns the result as new relation

Input:
  regular:
    self: ARelation [1,1] - class object
    filterFieldName: char - name of index field
    filterValueVec: numeric/ cell of char [nValues,1] - vector of index
        values

  properties:
    keepNulls: logical[1,1] - if true, null values are not filteed out,
       and removed otherwise,
          default: false

Output:
  regular:
    obj: ARelation [1,1] - new class object containing only selected
        tuples
    isThereVec: logical[nTuples,1] - contains true for the kept tuples</pre>
</div>
<div class="highlight-python"><pre> GETTUPLESINDEXEDBY - selects tuples from given relation such that fixed
                      index field contains given in a specified order
                      values and returns the result as new relation.
                      It is required that the original relation
                      contains only one record for each field value

 input:
   regular:
     self: ARelation [1,1] - class object
     indexFieldName: char - name of index field
     indexValueVec: numeric or char cell [nValues,1] - vector of index
         values
 output:
   regular:
     obj: ARelation [1,1] - new class object containing only selected
         tuples

TODO add type check</pre>
</div>
<div class="highlight-python"><pre>GETTUPLESJOINEDWITH - returns the tuples of the given relation
                      INNER-joined with other relation by the specified
                      key fields

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT) - inner join
          'leftOuter' - left outer join
          'rightOuter' - right outer join
          'fullOuter' - full outer join

      fieldDescrSource: char[1,] - defines where the field descriptions
         are taken from, can be
          'useOriginal' - field descriptions are taken from the left hand
              side argument of the join operation
          'useOther' - field descriptions are taken from the right hand
              side of the join operation

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result</pre>
</div>
<div class="highlight-python"><pre>GETUNIQUEDATA - returns internal representation for a set of unique
                tuples for given relation

Usage: [SData,SIsNull,SIsValueNull]=getUniqueData(self,varargin)

Input:
  regular:
    self: ARelation [1,1] - class object
  properties
      fieldNameList: list of field names used for finding the unique
          elements; only the specified fields are returned in SData,
          SIsNull,SIsValueNull structures
      structNameList: list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the tuples
              default value is false

Output:
  regular:

    SData: struct [1,1] - structure containing values of fields in
        selected tuples, each field is an array containing values of the
        corresponding type

    SIsNull: struct [1,1] - structure containing info whether each value
        in selected tuples is null or not, each field is either logical
        array or cell array containing logical arrays

    SIsValueNull: struct [1,1] - structure containing a
       logical array [nTuples,1] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value

    indForward: double[1,nUniqueTuples] - indices of unique entries in
       the original tuple set

    indBackward: double[1,nTuples] - indices that map the unique tuple
       set back to the original tuple set</pre>
</div>
<div class="highlight-python"><pre>GETUNIQUEDATAALONGDIM - returns internal representation of CubeStruct

Input:
  regular:
    self:
    catDim: double[1,1] - dimension number along which uniqueness is
       checked

  properties
      fieldNameList: list of field names used for finding the unique
          elements; only the specified fields are returned in SData,
          SIsNull,SIsValueNull structures
      structNameList: list of internal structures to return (by default
          it is {SData, SIsNull, SIsValueNull}
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all CubeStruct cells
              default value is false
      checkInputs: logical[1,1] - if true, the input parameters are
         checked for consistency

Output:
  regular:
    SData: struct [1,1] - structure containing values of fields

    SIsNull: struct [1,1] - structure containing info whether each value
        in selected cells is null or not, each field is either logical
        array or cell array containing logical arrays

    SIsValueNull: struct [1,1] - structure containing a
       logical array [nSlices,1] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value

    indForwardVec: double[nUniqueSlices,1] - indices of unique entries in
       the original CubeStruct data set

    indBackwardVec: double[nSlices,1] - indices that map the unique data
       set back to the original data setdata set unique along a specified
       dimension</pre>
</div>
<div class="highlight-python"><pre>GETUNIQUETUPLES - returns a relation containing the unique tuples from
                  the original relation

Usage: [resRel,indForwardVec,indBackwardVec]=getUniqueTuples(self,varargin)

Input:
  regular:
    self: ARelation [1,1] - class object
  properties
      fieldNameList: list of field names used for finding the unique
         tuples
      structNameList: list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the tuples
              default value is false

Output:
  regular:

    resRel: ARelation[1,1] - resulting relation

    indForward: double[1,nUniqueTuples] - indices of unique entries in
       the original tuple set

    indBackward: double[1,nTuples] - indices that map the unique tuple
       set back to the original tuple set</pre>
</div>
<div class="highlight-python"><pre>INITBYEMPTYDATASET - initializes cube struct object with null value arrays
                     of specified size based on minDimVec specified.

For instance, if minDimVec=[2,3,4,5,6] and minDimensionality of cube
struct object cb is 2, then cb.initByEmptyDataSet(minDimVec) will create
a cube struct object with element array of [2,3] size where each element
has size of [4,5,6,0]

Input:
  regular:
      self:
  optional
      minDimVec: double[1,nDims] - size vector of null value arrays</pre>
</div>
<div class="highlight-python"><pre>INITBYDEFAULTDATASET - initializes cube struct object with null value
                       arrays of specified size based on minDimVec
                       specified.

For instance, if minDimVec=[2,3,4,5,6] and minDimensionality of cube
struct object cb is 2, then cb.initByEmptyDataSet(minDimVec) will create
a cube struct object with element array of [2,3] size where each element
has size of [4,5,6]

Input:
  regular:
      self:
  optional
      minDimVec: double[1,nDims] - size vector of null value arrays</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - compares current relation object with other relation object and
          returns true if they are equal, otherwise it returns false


Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: ARelation [1,1] - current relation object
    otherObj: ARelation [1,1] - other relation object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
        in compared relations must be in the same order, otherwise the
        order is not  important (false by default)
    checkTupleOrder: logical[1,1] -  if true, then the tuples in the
        compared relations are expected to be in the same order,
        otherwise the order is not important (false by default)

    maxTolerance: double [1,1] - maximum allowed tolerance

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

    maxRelativeTolerance: double [1,1] - maximum allowed
    relative tolerance

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - report of comparsion</pre>
</div>
<div class="highlight-python"><pre> ISFIELDS - returns whether all fields whose names are given in the input
            list are in the field list of given object or not

 Usage: isPositive=isFields(self,fieldList)

 Input:
   regular:
     self: CubeStruct [1,1]
     fieldList: char or char cell [1,nFields]/[nFields,1] - input list of
         given field names
 Output:
   isPositive: logical [1,1] - true if all gields whose
       names are given in the input list are in the field
       list of given object, false otherwise

   isUniqueNames: logical[1,1] - true if the specified names contain
      unique field values

   isThereVec: logical[1,nFields] - each element indicate whether the
       corresponding field is present in the cube

TODO allow for varargins</pre>
</div>
<div class="highlight-python"><pre>ISMEMBERALONGDIM - performs ismember operation of CubeStruct data slices
                   along the specified dimension
Input:
  regular:
    self: ARelation [1,1] - class object
    other: ARelation [1,1] - other class object
    dim: double[1,1] - dimension number for ismember operation

  properties:
    keyFieldNameList/fieldNameList: char or char cell [1,nKeyFields] -
        list  of fields to which ismember is applied; by default all
        fields of first (self) object are used


Output:
  regular:
    isThere: logical [nSlices,1] - determines for each data slice of the
        first (self) object whether combination of values for key fields
        is in the second (other) object or not
    indTheres: double [nSlices,1] - zero if the corresponding coordinate
        of isThere is false, otherwise the highest index of the
        corresponding data slice in the second (other) object</pre>
</div>
<div class="highlight-python"><pre>ISMEMBER - performs ismember operation for tuples of two relations by key
           fields given by special list

Usage: isTuple=isMemberTuples(self,otherRel,keyFieldNameList) or
       [isTuple indTuples]=isMemberTuples(self,otherRel,keyFieldNameList)

Input:
  regular:
    self: ARelation [1,1] - class object
    other: ARelation [1,1] - other class object
  optional:
    keyFieldNameList: char or char cell [1,nKeyFields] - list of fields
        to which ismember is applied; by default all fields of first
        (self) object are used
Output:
  regular:
    isTuple: logical [nTuples,1] - determines for each tuple of first
        (self) object whether combination of values for key fields is in
        the second (other) relation or not
    indTuples: double [nTuples,1] - zero if the corresponding coordinate
        of isTuple is false, otherwise the highest index of the
        corresponding tuple in the second (other) relation</pre>
</div>
<div class="highlight-python"><pre>ISUNIQUEKEY - checks if a specified set of fields forms a unique key

Usage: isPositive=self.isUniqueKey(fieldNameList)

Input:
  regular:
      self: ARelation [1,1] - class object
      fieldNameList: cell[1,nFields] - list of field names for a unique
          key candidate
Output:
  isPositive: logical[1,1] - true means that a specified set of fields is
     a unique key</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - compares current relation object with other relation object and
          returns true if they are equal, otherwise it returns false


Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: ARelation [1,1] - current relation object
    otherObj: ARelation [1,1] - other relation object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
        in compared relations must be in the same order, otherwise the
        order is not  important (false by default)
    checkTupleOrder: logical[1,1] -  if true, then the tuples in the
        compared relations are expected to be in the same order,
        otherwise the order is not important (false by default)

    maxTolerance: double [1,1] - maximum allowed tolerance

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

    maxRelativeTolerance: double [1,1] - maximum allowed
    relative tolerance

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - report of comparsion</pre>
</div>
<div class="highlight-python"><pre>REMOVEDUPLICATETUPLES - removes all duplicate tuples from the relation

Usage: [indForwardVec,indBackwardVec]=...
           removeDuplicateTuples(self,varargin)

Input:
  regular:
    self: ARelation [1,1] - class object

  properties:
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values for all fields uniformly across all
          relation tuples
              default value is false

Output:
  optional:
    indForwardVec: double[nUniqueSlices,1] - indices of unique tuples in
       the original relation

    indBackwardVec: double[nSlices,1] - indices that map the unique
       tuples back to the original tuples</pre>
</div>
<div class="highlight-python"><pre>REMOVETUPLES - removes tuples with given indices from given relation

Usage: self.removeTuples(subIndVec)

Input:
  regular:
    self: ARelation [1,1] - class object
    subIndVec: double [nSubTuples,1]/logical[nTuples,1] - array of
       indices for tuples that are selected to be removed</pre>
</div>
<div class="highlight-python"><pre>REORDERDATA - reorders cells of CubeStruct object along the specified
              dimensions according to the specified index vectors

Input:
  regular:
      self: CubeStruct [1,1] - the object
      subIndCVec: numeric[1,]/cell[1,nDims] of double [nSubElem_i,1]
          for i=1,...,nDims array of indices of field value slices that
          are selected to be returned;
          if not given (default), no indexation is performed

  optional:
      dimVec: numeric[1,nDims] - vector of dimension numbers
          corresponding to subIndCVec</pre>
</div>
<div class="highlight-python"><pre>SAVEOBJ- transforms given CubeStruct object into structure containing
         internal representation of object properties

Input:
  regular:
    self: CubeStruct [nDim1,...,nDim2]


Output:
  regular:
    SObjectData: struct [n1,...,n_k] - structure containing an internal
       representation of the specified object</pre>
</div>
<div class="highlight-python"><pre>SETDATA - sets values of all cells for all fields

Input:
  regular:
    self: CubeStruct[1,1]

  optional:
    SData: struct [1,1] - structure with values of all cells for
        all fields

    SIsNull: struct [1,1] - structure of fields with is-null
       information for the field content, it can be logical for
       plain real numbers of cell of logicals for cell strs or
       cell of cell of str for more complex types

    SIsValueNull: struct [1,1] - structure with logicals
        determining whether value corresponding to each field
        and field cell is null or not

  properties:
      fieldNameList: cell[1,] of char[1,] - list of fields for which data
          should be generated, if not specified, all fields from the
          relation are taken

      isConsistencyCheckedVec: logical [1,1]/[1,2]/[1,3] -
          the first element defines if a consistency between the value
              elements (data, isNull and isValueNull) is checked;
          the second element (if specified) defines if
              value's type is checked.
          the third element defines if consistency between of sizes
              between different fields is checked
            If isConsistencyCheckedVec
              if scalar, it is automatically replicated to form a
                  3-element vector
              if the third element is not specified it is assumed
                  to be true

      transactionSafe: logical[1,1], if true, the operation is performed
         in a transaction-safe manner

      checkStruct: logical[1,nStruct] - an array of indicators which when
         all true force checking of structure content (including presence
         of required fields). The first element correspod to SData, the
         second and the third (if specified) to SIsNull and SIsValueNull
         correspondingly

      structNameList: char[1,]/cell[1,], name of data structure/list of
        data structure names to which the function is to
             be applied, can be composed from the following values

           SData - data itself

           SIsNull - contains is-null indicator information for data
                values

           SIsValueNull - contains is-null indicators for CubeStruct cells
               (not for cell values)
        structNameList={'SData'} by default

      fieldMetaData: smartdb.cubes.CubeStructFieldInfo[1,] - field meta
         data array which is used for data validity checking and for
         replacing the existing meta-data

      mdFieldNameList: cell[1,] of char - list of names of fields for
         which meta data is specified

      dataChangeIsComplete: logical[1,1] - indicates whether a change
          performed by the function is complete

Note: call of setData with an empty list of arguments clears
   the data</pre>
</div>
<div class="highlight-python"><pre>SETFIELDINTERNAL - sets values of all cells for given field

Usage: setFieldInternal(self,fieldName,value)

Input:
  regular:
    self: CubeStruct [1,1]
    fieldName: char - name of field
    value: array [] of some type - field values

  optional:
    isNull: logical/cell[]
    isValueNull: logical[]

  properties:
    structNameList: list of internal structures to return (by default it
      is {SData, SIsNull, SIsValueNull}

    inferIsNull: logical[1,2] - the first (second) element = false
      means that IsNull (IsValueNull) indicator for a field in question
          is kept intact (default = [true,true])

      Note: if structNameList contains 'SIsValueNull' entry,
       inferIsValueNull parameter is overwritten by false</pre>
</div>
<div class="highlight-python"><pre>SORTBY - sorts all tuples of given relation with respect to some of its
         fields

Usage: sortBy(self,sortFieldNameList,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
    sortFieldNameList: char or char cell [1,nFields] - list of field
        names with respect to which tuples are sorted
  properties:
    direction: char or char cell [1,nFields] - direction of sorting for
        all fields (if one value is given) or for each field separately;
        each value may be 'asc' or 'desc'</pre>
</div>
<div class="highlight-python"><pre>SORTBYALONGDIM -  sorts data of given CubeStruct object along the
                  specified dimension using the specified fields

Usage: sortByInternal(self,sortFieldNameList,varargin)

input:
  regular:
    self: CubeStruct [1,1] - class object
    sortFieldNameList: char or char cell [1,nFields] - list of field
        names with respect to which field content is sorted
    sortDim: numeric[1,1] - dimension number along which the sorting is
       to be performed
    properties:
    direction: char or char cell [1,nFields] - direction of sorting for
        all fields (if one value is given) or for each field separately;
        each value may be 'asc' or 'desc'</pre>
</div>
<div class="highlight-python"><pre>TOARRAY - transforms values of all CubeStruct cells into a multi-
          dimentional array

Usage: resCArray=toArray(self,varargin)

Input:
  regular:
    self: CubeStruct [1,1]

  properties:
    checkInputs: logical[1,1] - if false, the method skips checking the
       input parameters for consistency

    fieldNameList: cell[1,] - list of filed names to return

    structNameList: cell[1,]/char[1,], data structure list
       for which the data is to be taken from, can consist of the
       following values

      SData - data itself
      SIsNull - contains is-null indicator information for data values
      SIsValueNull - contains is-null indicators for CubeStruct cells
         (not for cell values)

    groupByColumns: logical[1,1], if true, each column is returned in a
       separate cell

    outputType: char[1,] - method of formign an output array, the
       following methods are supported:
           'uniformMat' - the field values are concatenated without any
                   type/size transformations. As a result, this method
                   will fail if the specified fields have different types
                   or/and sizes along any dimension apart from catDim

           'uniformCell' - not-cell fields are converted to cells
                   element-wise but no size-transformations is performed.
                   This method will fail if the specified fields have
                   different sizes along any dimension apart from catDim

           'notUniform' - this method doesn't make any assumptions about
                   size or type of the fields. Each field value is wrapped
                   into cell in a such way that a size of resulting cell
                   is minDimensionSizeVec for each field. Thus if for
                   instance is size of cube object is [2,3,4] and a field
                   size is [2,4,5,10,30] its value is splitted into 2*4*5
                   pieces with each piece of size [1,1,1,10,30] put it
                   its separate cell
           'adaptiveCell' - functions similarly to 'nonUniform' except for
                   the cases when a field value size equals
                   minDimensionSizeVec exactly i.e. the field takes only
                   scalar values. In such cases no wrapping into cell is
                   performed which allows to get a more transparent
                   output.

    catDim: double[1,1] - dimension number for
       concatenating outputs when groupByColumns is false


    replaceNull: logical[1,1], if true, null values from SData are
       replaced by null replacement, = true by default

    nullTopReplacement: - can be of any type and currently only applicable
      when  UniformOutput=false and of
      the corresponding column type if UniformOutput=true.

      Note!: this parameter is disregarded for any dataStructure different
         from 'SData'.

      Note!: the main difference between this parameter and the following
         parameters is that nullTopReplacement can violate field type
         constraints thus allowing to replace doubles with strings for
         instance (for non-uniform output types only of course)


    nullReplacements: cell[1,nReplacedFields]  - list of null
       replacements for each of the fields

    nullReplacementFields: cell[1,nReplacedFields] - list of fields in
       which the nulls are to be replaced with the specified values,
       if not specified it is assumed that all fields are to be replaced

       NOTE!: all fields not listed in this parameter are replaced with
       the default values


Output:
  Case1 (one output is requested and length(structNameList)==1):

      resCMat: matrix/cell[]  with values of all fields (or
        fields selected by optional arguments) for all CubeStruct
        data cells

  Case2 (multiple outputs are requested and their number =
    length(structNameList) each output is assigned resCMat for the
    corresponding struct

  Case3 (2 outputs is requested or length(structNameList)+1 outputs is
  requested). In this case the last output argument is

       isConvertedToCell: logical[nFields,nStructs] -  matrix with true
          values on the positions which correspond to fields converted to
          cells</pre>
</div>
<div class="highlight-python"><pre>TOCELL - transforms values of all fields for all tuples into two
         dimensional cell array

Usage: resCMat=toCell(self,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
  optional:
    fieldName1: char - name of first field
    ...
    fieldNameN: char - name of N-th field
output:
  resCMat: cell [nTuples,nFields(N)] - cell with values of all fields (or
      fields selected by optional arguments) for all tuples

FIXME - order fields in setData method</pre>
</div>
<div class="highlight-python"><pre>TOCELLISNULL - transforms is-null indicators of all fields for all tuples
               into two dimensional cell array

Usage: resCMat=toCell(self,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
  optional:
    fieldName1: char - name of first field
    ...
    fieldNameN: char - name of N-th field
output:
  resCMat: cell [nTuples,nFields(N)] - cell with values of all fields (or
      fields selected by optional arguments) for all tuples

FIXME - order fields in setData method</pre>
</div>
<div class="highlight-python"><pre>TODISPCELL - transforms values of all fields into their character
             representation

Usage: resCMat=toDispCell(self)

Input:
  regular:
    self: ARelation [1,1] - class object

  properties:
      nullTopReplacement: any[1,1] - value used to replace null values
      fieldNameList: cell[1,] of char[1,] - field name list

Output:
  dataCell: cell[nRows,nCols] of char[1,] - cell array containing the
      character representation of field values</pre>
</div>
<div class="highlight-python"><pre>TOMAT - transforms values of all fields for all tuples into two
        dimensional array

Usage: resCMat=toMat(self,varargin)

input:
  regular:
    self: ARelation [1,1] - class object

  optional:
    fieldNameList: cell[1,] - list of filed names to return

    uniformOutput: logical[1,1], true - cell is returned, false - the
       functions tries to return a result as a matrix

    groupByColumns: logical[1,1], if true, each column is returned in a
       separate cell

    structNameList/dataStructure: char[1,], data structure for which the
       data is to be taken from, can have one of the following values

      SData - data itself
      SIsNull - contains is-null indicator information for data values
      SIsValueNull - contains is-null indicators for relation cells (not
         for cell values

    replaceNull: logical[1,1], if true, null values from SData are
       replaced by null replacement, = true by default

    nullTopReplacement: - can be of any type and currently only applicable
      when  UniformOutput=false and of
      the corresponding column type if UniformOutput=true.

      Note!: this parameter is disregarded for any dataStructure different
         from 'SData'.

      Note!: the main difference between this parameter and the following
         parameters is that nullTopReplacement can violate field type
         constraints thus allowing to replace doubles with strings for
         instance (for non-uniform output types only of course)


    nullReplacements: cell[1,nReplacedFields]  - list of null
       replacements for each of the fields

    nullReplacementFields: cell[1,nReplacedFields] - list of fields in
       which the nulls are to be replaced with the specified values,
       if not specified it is assumed that all fields are to be replaced

       NOTE!: all fields not listed in this parameter are replaced with
       the default values

output:
  resCMat:  [nTuples,nFields(N)] - matrix/cell with values of all fields
      (or fields selected by optional arguments) for all tuples</pre>
</div>
<div class="highlight-python"><pre>TOSTRUCT - transforms given CubeStruct object into structure

Input:
  regular:
    self: CubeStruct [nDim1,...,nDim2]


Output:
  regular:
    SObjectData: struct [n1,...,n_k] - structure containing an internal
       representation of the specified object</pre>
</div>
<div class="highlight-python"><pre>UNIONWITH - adds tuples of the input relation to the set of tuples of the
            original relation
Usage: self.unionWith(inpRel)

Input:
  regular:
    self: ARelation [1,1] - class object
    inpRel1: ARelation [1,1] - object to get the additional tuples from
      ...
    inpRelN: ARelation [1,1] - object to get the additional tuples from

  properties:
      checkType: logical[1,1] - if true, union is only performed when the
          types of relations is the same. Default value is false

      checkStruct: logical[1,nStruct] - an array of indicators which when
         true force checking of structure content (including presence
         of all required fields). The first element correspod to SData,
         the second and the third (if specified) to SIsNull and
         SIsValueNull correspondingly

      checkConsistency: logical [1,1]/[1,2] - the
          first element defines if a consistency between the value
          elements (data, isNull and isValueNull) is checked;
          the second element (if specified) defines if
          value's type is checked. If isConsistencyChecked
          is scalar, it is automatically replicated to form a
          two-element vector.
          Note: default value is true</pre>
</div>
<div class="highlight-python"><pre>UNIONWITHALONGDIM - adds data from the input CubeStructs

Usage: self.unionWithAlongDim(unionDim,inpCube)

Input:
  regular:
  self:
      inpCube1: CubeStruct [1,1] - object to get the additional data from
          ...
      inpCubeN: CubeStruct [1,1] - object to get the additional data from

  properties:
      checkType: logical[1,1] - if true, union is only performed when the
          types of relations is the same. Default value is false

      checkStruct: logical[1,nStruct] - an array of indicators which when
         true force checking of structure content (including presence of
all required fields). The first element correspod to SData, the
         second and the third (if specified) to SIsNull and SIsValueNull
         correspondingly

      checkConsistency: logical [1,1]/[1,2] - the
          first element defines if a consistency between the value
          elements (data, isNull and isValueNull) is checked;
          the second element (if specified) defines if
          value's type is checked. If isConsistencyChecked
          is scalar, it is automatically replicated to form a
          two-element vector.
          Note: default value is true</pre>
</div>
<div class="highlight-python"><pre>WRITETOCSV - writes a content of relation into Excel spreadsheet file
Input:
  regular:
      self:
      filePath: char[1,] - file path

Output:
  none</pre>
</div>
<div class="highlight-python"><pre>WRITETOXLS - writes a content of relation into Excel spreadsheet file
Input:
  regular:
      self:
      filePath: char[1,] - file path

Output:
  fileName: char[1,] - resulting file name, may not match with filePath
      when Excel is not available and csv format is used instead</pre>
</div>
</div>
<div class="section" id="gras-ellapx-smartdb-rels-elltube">
<h2>gras.ellapx.smartdb.rels.EllTube<a class="headerlink" href="#gras-ellapx-smartdb-rels-elltube" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>EllTube - class which keeps ellipsoidal tubes

Fields:
  QArray:cell[1, nElem] - Array of ellipsoid matrices
  aMat:cell[1, nElem] - Array of ellipsoid centers
  scaleFactor:double[1, 1] - Tube scale factor
  MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
  dim :double[1, 1] - Dimensionality
  sTime:double[1, 1] - Time s
  approxSchemaName:cell[1,] - Name
  approxSchemaDescr:cell[1,] - Description
  approxType:gras.ellapx.enums.EApproxType - Type of approximation
                (external, internal, not defined)
  timeVec:cell[1, m] - Time vector
  calcPrecision:double[1, 1] - Calculation precision
  indSTime:double[1, 1]  - index of sTime within timeVec
  ltGoodDirMat:cell[1, nElem] - Good direction curve
  lsGoodDirVec:cell[1, nElem] - Good direction at time s
  ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
  lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
  xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                  direction
  xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                    opposite to good direction
  xsTouchVec:cell[1, nElem]  - Touch point at time s
  xsTouchOpVec :cell[1, nElem] - Touch point at time s

  TODO: correct description of the fields in gras.ellapx.smartdb.rels.EllTube</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:</p>
<div class="highlight-python"><pre>CAT  - concatenates data from relation objects.

Input:
  regular:
      self.
      newEllTubeRel: smartdb.relation.StaticRelation[1, 1]/
          smartdb.relation.DynamicRelation[1, 1] - relation object
  properties:
      isReplacedByNew: logical[1,1] - if true, sTime and
          values of properties corresponding to sTime are taken
          from newEllTubeRel. Common times in self and
          newEllTubeRel are allowed, however the values for
          those times are taken either from self or from
          newEllTubeRel depending on value of isReplacedByNew
          property

      isCommonValuesChecked: logical[1,1] - if true, values
          at common times (if such are found) are checked for
          strong equality (with zero precision). If not equal
          - an exception is thrown. True by default.

      commonTimeAbsTol: double[1,1] - absolute tolerance used
          for comparing values at common times, =0 by default

      commonTimeRelTol: double[1,1] - absolute tolerance used
          for comparing values at common times, =0 by default

Output:
  catEllTubeRel:smartdb.relation.StaticRelation[1, 1]/
      smartdb.relation.DynamicRelation[1, 1] - relation object
      resulting from CAT operation</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>FROMELLARRAY  - creates a relation object using an array of ellipsoids</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd>qEllArray: ellipsoid[nDim1, nDim2, ..., nDimN] - array of ellipsoids</dd>
<dt>optional:</dt>
<dd><p class="first">timeVec:cell[1, m] - time vector
ltGoodDirArray:cell[1, nElem] - good direction at time s
sTime:double[1, 1] - time s
approxType:gras.ellapx.enums.EApproxType - type of approximation</p>
<blockquote>
<div>(external, internal, not defined)</div></blockquote>
<p class="last">approxSchemaName:cell[1,] - name of the schema
approxSchemaDescr:cell[1,] - description of the schema
calcPrecision:double[1, 1] - calculation precision</p>
</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd><dl class="first last docutils">
<dt>ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation</dt>
<dd>object</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>FROMELLMARRAY  - creates a relation object using an array of ellipsoids.
                 This method uses regularizer in the form of a matrix
                 function.

Input:
  regular:
    qEllArray: ellipsoid[nDim1, nDim2, ..., nDimN] - array of ellipsoids
    ellMArr: double[nDim1, nDim2, ..., nDimN] - regularization ellipsoid
        matrices

  optional:
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
         object</pre>
</div>
<div class="highlight-python"><pre>FROMQARRAYS  - creates a relation object using an array of ellipsoids,
               described by the array of ellipsoid matrices and
               array of ellipsoid centers.This method used default
               scale factor.

Input:
  regular:
    QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
        matrices
    aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers

Optional:
   MArrayList:cell[1, nElem] - array of regularization ellipsoid matrices
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
       object</pre>
</div>
<div class="highlight-python"><pre>FROMQMARRAYS  - creates a relation object using an array of ellipsoids,
                described by the array of ellipsoid matrices and
                array of ellipsoid centers. Also this method uses
                regularizer in the form of a matrix function. This method
                used default scale factor.

Input:
  regular:
  QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
        matrices
  aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers
  MArrayList: double[nDim1, nDim2, ..., nDimN] - ellipsoid  matrices of
        regularization

 optional:
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
         object</pre>
</div>
<div class="highlight-python"><pre>FROMQMSCALEDARRAYS  - creates a relation object using an array of ellipsoids,
                      described by the array of ellipsoid matrices and
                      array of ellipsoid centers. Also this method uses
                      regularizer in the form of a matrix function.


Input:
  regular:
    QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
        matrices
    aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers
    MArrayList: double[nDim1, nDim2, ..., nDimN] - ellipsoid matrices
              of regularization
    scaleFactor:double[1, 1] - tube scale factor

 optional:
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
         object</pre>
</div>
<div class="highlight-python"><pre>GETDATA - returns an indexed projection of CubeStruct object's content

Input:
  regular:
      self: CubeStruct [1,1] - the object

  optional:

      subIndCVec:
        Case#1: numeric[1,]/numeric[,1]

        Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
              for i=1,...,nDims

          -array of indices of field value slices that are selected
          to be returned; if not given (default),
          no indexation is performed

        Note!: numeric components of subIndVec are allowed to contain
           zeros which are be treated as they were references to null
           data slices

      dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
          numbers corresponding to subIndCVec

  properties:

      fieldNameList: char[1,]/cell[1,nFields] of char[1,]
          list of field names to return

      structNameList: char[1,]/cell[1,nStructs] of char[1,]
          list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}

      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the cells,
              default value is false

      nullReplacements: cell[1,nReplacedFields]  - list of null
          replacements for each of the fields

      nullReplacementFields: cell[1,nReplacedFields] - list of fields in
         which the nulls are to be replaced with the specified values,
         if not specified it is assumed that all fields are to be
         replaced

         NOTE!: all fields not listed in this parameter are replaced with
         the default values

      checkInputs: logical[1,1] - true by default (input arguments are
         checked for correctness

Output:
  regular:
    SData: struct [1,1] - structure containing values of
        fields at the selected slices, each field is an array
        containing values of the corresponding type

    SIsNull: struct [1,1] - structure containing a nested
        array with is-null indicators for each CubeStruct cell content

    SIsValueNull: struct [1,1] - structure containing a
       logical array [] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value</pre>
</div>
<div class="highlight-python"><pre>GETELLARRAY - returns array of matrix's ellipsoid according to
              approxType

Input:
 regular:
    self.
    approxType:char[1,] - type of approximation(internal/external)

Output:
  apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
           matrices</pre>
</div>
<div class="highlight-python"><pre>GETJOINWITH - returns a result of INNER join of given relation with
              another relation by the specified key fields

LIMITATION: key fields by which the join is peformed are required to form
a unique key in the given relation

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT)
          'leftOuter'

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - compares current relation object with other relation object and
          returns true if they are equal, otherwise it returns false


Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: ARelation [1,1] - current relation object
    otherObj: ARelation [1,1] - other relation object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
        in compared relations must be in the same order, otherwise the
        order is not  important (false by default)
    checkTupleOrder: logical[1,1] -  if true, then the tuples in the
        compared relations are expected to be in the same order,
        otherwise the order is not important (false by default)

    maxTolerance: double [1,1] - maximum allowed tolerance

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

    maxRelativeTolerance: double [1,1] - maximum allowed
    relative tolerance

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - report of comparsion</pre>
</div>
<div class="highlight-python"><pre>PLOT - displays ellipsoidal tubes using the specified RelationDataPlotter


Input:
  regular:
      self:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
          object used for displaying ellipsoidal tubes</pre>
</div>
<div class="highlight-python"><pre>PROJECT - computes projection of the relation object onto given time
          dependent subspase
Input:
  regular:
      self.
      projType: gras.ellapx.enums.EProjType[1,1] -
          type of the projection, can be
          'Static' and 'DynamicAlongGoodCurve'
      projMatList: cell[1,nProj] of double[nSpDim,nDim] - list of
          projection matrices, not necessarily orthogonal
   fGetProjMat: function_handle[1,1] - function which creates
      vector of the projection
            matrices
       Input:
        regular:
          projMat:double[nDim, mDim] - matrix of the projection at the
            instant of time
          timeVec:double[1, nDim] - time interval
        optional:
           sTime:double[1,1] - instant of time
       Output:
          projOrthMatArray:double[1, nSpDim] - vector of the projection
            matrices
          projOrthMatTransArray:double[nSpDim, 1] - transposed vector of
            the projection matrices
Output:
   ellTubeProjRel: gras.ellapx.smartdb.rels.EllTubeProj[1, 1]/
       gras.ellapx.smartdb.rels.EllTubeUnionProj[1, 1] -
          projected ellipsoidal tube

   indProj2OrigVec:cell[nDim, 1] - index of the line number from
            which is obtained the projection

Example:
  function example
   aMat = [0 1; 0 0]; bMat = eye(2);
   SUBounds = struct();
   SUBounds.center = {'sin(t)'; 'cos(t)'};
   SUBounds.shape = [9 0; 0 2];
   sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
   x0EllObj = ell_unitball(2);
   timeVec = [0 10];
   dirsMat = [1 0; 0 1]';
   rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
   ellTubeObj = rsObj.getEllTubeRel();
   unionEllTube = ...
    gras.ellapx.smartdb.rels.EllUnionTube.fromEllTubes(ellTubeObj);
   projMatList = {[1 0;0 1]};
   projType = gras.ellapx.enums.EProjType.Static;
   statEllTubeProj = unionEllTube.project(projType,projMatList,...
      @fGetProjMat);
   plObj=smartdb.disp.RelationDataPlotter();
   statEllTubeProj.plot(plObj);
end

function [projOrthMatArray,projOrthMatTransArray]=fGetProjMat(projMat,...
    timeVec,varargin)
  nTimePoints=length(timeVec);
  projOrthMatArray=repmat(projMat,[1,1,nTimePoints]);
  projOrthMatTransArray=repmat(projMat.',[1,1,nTimePoints]);
 end</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>PROJECTTOORTHS - project elltube onto subspace defined by
vectors of standart basis with indices specified in indVec</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd><dl class="first last docutils">
<dt>self: gras.ellapx.smartdb.rels.EllTube[1, 1] - elltube</dt>
<dd>object</dd>
<dt>indVec: double[1, nProjDims] - indices specifying a subset of</dt>
<dd>standart basis</dd>
</dl>
</dd>
<dt>optional:</dt>
<dd><dl class="first last docutils">
<dt>projType: gras.ellapx.enums.EProjType[1, 1] -  type of</dt>
<dd>projection</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd><dl class="first last docutils">
<dt>ellTubeProjRel: gras.ellapx.smartdb.rels.EllTubeProj[1, 1] -</dt>
<dd>elltube projection</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Example:</dt>
<dd>ellTubeProjRel = ellTubeRel.projectToOrths([1,2])
projType = gras.ellapx.enums.EProjType.DynamicAlongGoodCurve
ellTubeProjRel = ellTubeRel.projectToOrths([3,4,5], projType)</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>SCALE - scales relation object

 Input:
  regular:
     self.
     fCalcFactor - function which calculates factor for
                    fields in fieldNameList
       Input:
         regular:
           fieldNameList: char/cell[1,] of char - a list of fields
                  for which factor will be calculated
        Output:
            factor:double[1, 1] - calculated factor

      fieldNameList:cell[1,nElem]/char[1,] - names of the fields

 Output:
      none

Example:
  nPoints=5;
  calcPrecision=0.001;
  approxSchemaDescr=char.empty(1,0);
  approxSchemaName=char.empty(1,0);
  nDims=3;
  nTubes=1;
  lsGoodDirVec=[1;0;1];
  aMat=zeros(nDims,nPoints);
  timeVec=1:nPoints;
  sTime=nPoints;
  approxType=gras.ellapx.enums.EApproxType.Internal;
  qArrayList=repmat({repmat(diag([1 2 3]),[1,1,nPoints])},1,nTubes);
  ltGoodDirArray=repmat(lsGoodDirVec,[1,nTubes,nPoints]);
  fromMatEllTube=...
        gras.ellapx.smartdb.rels.EllTube.fromQArrays(qArrayList,...
        aMat, timeVec,ltGoodDirArray, sTime, approxType,...
        approxSchemaName, approxSchemaDescr, calcPrecision);
  fromMatEllTube.scale(@(varargin)2,{});</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
</div>
<div class="section" id="gras-ellapx-smartdb-rels-elltubeproj">
<h2>gras.ellapx.smartdb.rels.EllTubeProj<a class="headerlink" href="#gras-ellapx-smartdb-rels-elltubeproj" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>EllTubeProj - class which keeps ellipsoidal tube's projection

Fields:
  QArray:cell[1, nElem] - Array of ellipsoid matrices
  aMat:cell[1, nElem] - Array of ellipsoid centers
  scaleFactor:double[1, 1] - Tube scale factor
  MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
  dim :double[1, 1] - Dimensionality
  sTime:double[1, 1] - Time s
  approxSchemaName:cell[1,] - Name
  approxSchemaDescr:cell[1,] - Description
  approxType:gras.ellapx.enums.EApproxType - Type of approximation
                (external, internal, not defined)
  timeVec:cell[1, m] - Time vector
  calcPrecision:double[1, 1] - Calculation precision
  indSTime:double[1, 1]  - index of sTime within timeVec
  ltGoodDirMat:cell[1, nElem] - Good direction curve
  lsGoodDirVec:cell[1, nElem] - Good direction at time s
  ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
  lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
  xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                  direction
  xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                    opposite to good direction
  xsTouchVec:cell[1, nElem]  - Touch point at time s
  xsTouchOpVec:cell[1, nElem] - Touch point at time s
  projSTimeMat: cell[1, 1] - Projection matrix at time s
  projType:gras.ellapx.enums.EProjType - Projection type
  ltGoodDirNormOrigVec:cell[1, 1] - Norm of the original (not
                                    projected) good direction curve
  lsGoodDirNormOrig:double[1, 1] - Norm of the original (not
                                   projected)good direction at time s
  lsGoodDirOrigVec:cell[1, 1] - Original (not projected) good
                                direction at time s

TODO: correct description of the fields in
    gras.ellapx.smartdb.rels.EllTubeProj</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:</p>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>GETDATA - returns an indexed projection of CubeStruct object&#8217;s content</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first docutils">
<dt>regular:</dt>
<dd>self: CubeStruct [1,1] - the object</dd>
</dl>
<p>optional:</p>
<blockquote>
<div><dl class="docutils">
<dt>subIndCVec:</dt>
<dd><p class="first">Case#1: numeric[1,]/numeric[,1]</p>
<dl class="last docutils">
<dt>Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]</dt>
<dd><blockquote class="first">
<div>for i=1,...,nDims</div></blockquote>
<p class="last">-array of indices of field value slices that are selected
to be returned; if not given (default),
no indexation is performed</p>
</dd>
<dt>Note!: numeric components of subIndVec are allowed to contain</dt>
<dd>zeros which are be treated as they were references to null
data slices</dd>
</dl>
</dd>
<dt>dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension</dt>
<dd>numbers corresponding to subIndCVec</dd>
</dl>
</div></blockquote>
<p>properties:</p>
<blockquote class="last">
<div><dl class="docutils">
<dt>fieldNameList: char[1,]/cell[1,nFields] of char[1,]</dt>
<dd>list of field names to return</dd>
<dt>structNameList: char[1,]/cell[1,nStructs] of char[1,]</dt>
<dd>list of internal structures to return (by default it
is {SData, SIsNull, SIsValueNull}</dd>
<dt>replaceNull: logical[1,1] if true, null values are replaced with</dt>
<dd><dl class="first last docutils">
<dt>certain default values uniformly across all the cells,</dt>
<dd>default value is false</dd>
</dl>
</dd>
<dt>nullReplacements: cell[1,nReplacedFields]  - list of null</dt>
<dd>replacements for each of the fields</dd>
<dt>nullReplacementFields: cell[1,nReplacedFields] - list of fields in</dt>
<dd><p class="first">which the nulls are to be replaced with the specified values,
if not specified it is assumed that all fields are to be
replaced</p>
<p class="last">NOTE!: all fields not listed in this parameter are replaced with
the default values</p>
</dd>
<dt>checkInputs: logical[1,1] - true by default (input arguments are</dt>
<dd>checked for correctness</dd>
</dl>
</div></blockquote>
</dd>
<dt>Output:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd><dl class="first last docutils">
<dt>SData: struct [1,1] - structure containing values of</dt>
<dd>fields at the selected slices, each field is an array
containing values of the corresponding type</dd>
<dt>SIsNull: struct [1,1] - structure containing a nested</dt>
<dd>array with is-null indicators for each CubeStruct cell content</dd>
<dt>SIsValueNull: struct [1,1] - structure containing a</dt>
<dd><p class="first">logical array [] for each of the fields (true
means that a corresponding cell doesn&#8217;t not contain</p>
<blockquote class="last">
<div>any value</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>GETELLARRAY - returns array of matrix's ellipsoid according to
              approxType

Input:
 regular:
    self.
    approxType:char[1,] - type of approximation(internal/external)

Output:
  apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
           matrices</pre>
</div>
<div class="highlight-python"><pre>GETJOINWITH - returns a result of INNER join of given relation with
              another relation by the specified key fields

LIMITATION: key fields by which the join is peformed are required to form
a unique key in the given relation

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT)
          'leftOuter'

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>GETREACHTUBEANEPREFIX - return prefix of the reach tube</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd>self.</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>GETREGTUBEANEPREFIX - return prefix of the reg tube

Input:
  regular:
     self.</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><dl class="docutils">
<dt>ISEQUAL - compares current relation object with other relation object and</dt>
<dd>returns true if they are equal, otherwise it returns false</dd>
</dl>
<p>Usage: isEq=isEqual(self,otherObj)</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd>self: ARelation [1,1] - current relation object
otherObj: ARelation [1,1] - other relation object</dd>
<dt>properties:</dt>
<dd><dl class="first docutils">
<dt>checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields</dt>
<dd>in compared relations must be in the same order, otherwise the
order is not  important (false by default)</dd>
<dt>checkTupleOrder: logical[1,1] -  if true, then the tuples in the</dt>
<dd>compared relations are expected to be in the same order,
otherwise the order is not important (false by default)</dd>
</dl>
<p>maxTolerance: double [1,1] - maximum allowed tolerance</p>
<dl class="docutils">
<dt>compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct&#8217;s</dt>
<dd>referenced from the meta data objects are also compared</dd>
</dl>
<p class="last">maxRelativeTolerance: double [1,1] - maximum allowed
relative tolerance</p>
</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd>isEq: logical[1,1] - result of comparison
reportStr: char[1,] - report of comparsion</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>PLOT - displays ellipsoidal tubes using the specified
  RelationDataPlotter

Input:
  regular:
      self:
  optional:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
          object used for displaying ellipsoidal tubes
  properties:
      fGetColor: function_handle[1, 1] -
          function that specified colorVec for
          ellipsoidal tubes
      fGetAlpha: function_handle[1, 1] -
          function that specified transparency
          value for ellipsoidal tubes
      fGetLineWidth: function_handle[1, 1] -
          function that specified lineWidth for good curves
      fGetFill: function_handle[1, 1] - this
          property not used in this version
      colorFieldList: cell[nColorFields, ] of char[1, ] -
          list of parameters for color function
      alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
          list of parameters for transparency function
      lineWidthFieldList: cell[nLineWidthFields, ]
          of char[1, ] - list of parameters for lineWidth
          function
      fillFieldList: cell[nIsFillFields, ] of char[1, ] -
          list of parameters for fill function
      plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
          defaul list of parameters. If for any function in
          properties not specified list of parameters,
          this one will be used

Output:
  plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
          object used for displaying ellipsoidal tubes</pre>
</div>
<div class="highlight-python"><pre>PLOTEXT - plots external approximation of ellTube.


Usage:
      obj.plotExt() - plots external approximation of ellTube.
      obj.plotExt('Property',PropValue,...) - plots external approximation
                                              of ellTube with setting
                                              properties.

Input:
  regular:
      obj:  EllTubeProj: EllTubeProj object
  optional:
      relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
      colorSpec: char[1,1] - color specification code, can be 'r','g',
                   etc (any code supported by built-in Matlab function).

  properties:

      fGetColor: function_handle[1, 1] -
          function that specified colorVec for
          ellipsoidal tubes
      fGetAlpha: function_handle[1, 1] -
          function that specified transparency
          value for ellipsoidal tubes
      fGetLineWidth: function_handle[1, 1] -
          function that specified lineWidth for good curves
      fGetFill: function_handle[1, 1] - this
          property not used in this version
      colorFieldList: cell[nColorFields, ] of char[1, ] -
          list of parameters for color function
      alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
          list of parameters for transparency function
      lineWidthFieldList: cell[nLineWidthFields, ]
          of char[1, ] - list of parameters for lineWidth
          function
      fillFieldList: cell[nIsFillFields, ] of char[1, ] -
          list of parameters for fill function
      plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
          defaul list of parameters. If for any function in
          properties not specified list of parameters,
          this one will be used
      'showDiscrete':logical[1,1]  -
          if true, approximation in 3D will be filled in every time slice
      'nSpacePartPoins': double[1,1] -
          number of points in every time slice.
Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.</pre>
</div>
<div class="highlight-python"><pre>PLOTINT - plots internal approximation of ellTube.


Usage:
      obj.plotInt() - plots internal approximation of ellTube.
      obj.plotInt('Property',PropValue,...) - plots internal approximation
                                              of ellTube with setting
                                              properties.

Input:
  regular:
      obj:  EllTubeProj: EllTubeProj object
  optional:
      relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
      colorSpec: char[1,1] - color specification code, can be 'r','g',
                   etc (any code supported by built-in Matlab function).

  properties:

      fGetColor: function_handle[1, 1] -
          function that specified colorVec for
          ellipsoidal tubes
      fGetAlpha: function_handle[1, 1] -
          function that specified transparency
          value for ellipsoidal tubes
      fGetLineWidth: function_handle[1, 1] -
          function that specified lineWidth for good curves
      fGetFill: function_handle[1, 1] - this
          property not used in this version
      colorFieldList: cell[nColorFields, ] of char[1, ] -
          list of parameters for color function
      alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
          list of parameters for transparency function
      lineWidthFieldList: cell[nLineWidthFields, ]
          of char[1, ] - list of parameters for lineWidth
          function
      fillFieldList: cell[nIsFillFields, ] of char[1, ] -
          list of parameters for fill function
      plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
          defaul list of parameters. If for any function in
          properties not specified list of parameters,
          this one will be used
      'showDiscrete':logical[1,1]  -
          if true, approximation in 3D will be filled in every time slice
      'nSpacePartPoins': double[1,1] -
          number of points in every time slice.
Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
</div>
<div class="section" id="gras-ellapx-smartdb-rels-elluniontube">
<h2>gras.ellapx.smartdb.rels.EllUnionTube<a class="headerlink" href="#gras-ellapx-smartdb-rels-elluniontube" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>EllUionTube - class which keeps ellipsoidal tubes by the instant of
              time

Fields:
  QArray:cell[1, nElem] - Array of ellipsoid matrices
  aMat:cell[1, nElem] - Array of ellipsoid centers
  scaleFactor:double[1, 1] - Tube scale factor
  MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
  dim :double[1, 1] - Dimensionality
  sTime:double[1, 1] - Time s
  approxSchemaName:cell[1,] - Name
  approxSchemaDescr:cell[1,] - Description
  approxType:gras.ellapx.enums.EApproxType - Type of approximation
                (external, internal, not defined
  timeVec:cell[1, m] - Time vector
  calcPrecision:double[1, 1] - Calculation precision
  indSTime:double[1, 1]  - index of sTime within timeVec
  ltGoodDirMat:cell[1, nElem] - Good direction curve
  lsGoodDirVec:cell[1, nElem] - Good direction at time s
  ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
  lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
  xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                  direction
  xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                    opposite to good direction
  xsTouchVec:cell[1, nElem]  - Touch point at time s
  xsTouchOpVec :cell[1, nElem] - Touch point at time s
  ellUnionTimeDirection:gras.ellapx.enums.EEllUnionTimeDirection -
                     Direction in time along which union is performed
  isLsTouch:logical[1, 1] - Indicates whether a touch takes place
                            along LS
  isLsTouchOp:logical[1, 1] - Indicates whether a touch takes place
                              along LS opposite
  isLtTouchVec:cell[1, nElem] - Indicates whether a touch takes place
                                along LT
  isLtTouchOpVec:cell[1, nElem] - Indicates whether a touch takes
                                  place along LT opposite
  timeTouchEndVec:cell[1, nElem] - Touch point curve for good
                                   direction
  timeTouchOpEndVec:cell[1, nElem] - Touch point curve for good
                                     direction

TODO: correct description of the fields in
    gras.ellapx.smartdb.rels.EllUnionTube</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:</p>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>FROMELLTUBES - returns union of the ellipsoidal tubes on time</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>ellTubeRel: smartdb.relation.StaticRelation[1, 1]/</dt>
<dd>smartdb.relation.DynamicRelation[1, 1] - relation
object</dd>
</dl>
</dd>
</dl>
<p>Output:
ellUnionTubeRel: ellapx.smartdb.rel.EllUnionTube - union of the</p>
<blockquote>
<div>ellipsoidal tubes</div></blockquote>
</div></blockquote>
<div class="highlight-python"><pre>GETDATA - returns an indexed projection of CubeStruct object's content

Input:
  regular:
      self: CubeStruct [1,1] - the object

  optional:

      subIndCVec:
        Case#1: numeric[1,]/numeric[,1]

        Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
              for i=1,...,nDims

          -array of indices of field value slices that are selected
          to be returned; if not given (default),
          no indexation is performed

        Note!: numeric components of subIndVec are allowed to contain
           zeros which are be treated as they were references to null
           data slices

      dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
          numbers corresponding to subIndCVec

  properties:

      fieldNameList: char[1,]/cell[1,nFields] of char[1,]
          list of field names to return

      structNameList: char[1,]/cell[1,nStructs] of char[1,]
          list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}

      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the cells,
              default value is false

      nullReplacements: cell[1,nReplacedFields]  - list of null
          replacements for each of the fields

      nullReplacementFields: cell[1,nReplacedFields] - list of fields in
         which the nulls are to be replaced with the specified values,
         if not specified it is assumed that all fields are to be
         replaced

         NOTE!: all fields not listed in this parameter are replaced with
         the default values

      checkInputs: logical[1,1] - true by default (input arguments are
         checked for correctness

Output:
  regular:
    SData: struct [1,1] - structure containing values of
        fields at the selected slices, each field is an array
        containing values of the corresponding type

    SIsNull: struct [1,1] - structure containing a nested
        array with is-null indicators for each CubeStruct cell content

    SIsValueNull: struct [1,1] - structure containing a
       logical array [] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value</pre>
</div>
<div class="highlight-python"><pre>GETELLARRAY - returns array of matrix's ellipsoid according to
              approxType

Input:
 regular:
    self.
    approxType:char[1,] - type of approximation(internal/external)

Output:
  apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
           matrices</pre>
</div>
<div class="highlight-python"><pre>GETJOINWITH - returns a result of INNER join of given relation with
              another relation by the specified key fields

LIMITATION: key fields by which the join is peformed are required to form
a unique key in the given relation

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT)
          'leftOuter'

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - compares current relation object with other relation object and
          returns true if they are equal, otherwise it returns false


Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: ARelation [1,1] - current relation object
    otherObj: ARelation [1,1] - other relation object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
        in compared relations must be in the same order, otherwise the
        order is not  important (false by default)
    checkTupleOrder: logical[1,1] -  if true, then the tuples in the
        compared relations are expected to be in the same order,
        otherwise the order is not important (false by default)

    maxTolerance: double [1,1] - maximum allowed tolerance

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

    maxRelativeTolerance: double [1,1] - maximum allowed
    relative tolerance

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - report of comparsion</pre>
</div>
<div class="highlight-python"><pre>PROJECT - computes projection of the relation object onto given time
          dependent subspase
Input:
  regular:
      self.
      projType: gras.ellapx.enums.EProjType[1,1] -
          type of the projection, can be
          'Static' and 'DynamicAlongGoodCurve'
      projMatList: cell[1,nProj] of double[nSpDim,nDim] - list of
          projection matrices, not necessarily orthogonal
   fGetProjMat: function_handle[1,1] - function which creates
      vector of the projection
            matrices
       Input:
        regular:
          projMat:double[nDim, mDim] - matrix of the projection at the
            instant of time
          timeVec:double[1, nDim] - time interval
        optional:
           sTime:double[1,1] - instant of time
       Output:
          projOrthMatArray:double[1, nSpDim] - vector of the projection
            matrices
          projOrthMatTransArray:double[nSpDim, 1] - transposed vector of
            the projection matrices
Output:
   ellTubeProjRel: gras.ellapx.smartdb.rels.EllTubeProj[1, 1]/
       gras.ellapx.smartdb.rels.EllTubeUnionProj[1, 1] -
          projected ellipsoidal tube

   indProj2OrigVec:cell[nDim, 1] - index of the line number from
            which is obtained the projection

Example:
  function example
   aMat = [0 1; 0 0]; bMat = eye(2);
   SUBounds = struct();
   SUBounds.center = {'sin(t)'; 'cos(t)'};
   SUBounds.shape = [9 0; 0 2];
   sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
   x0EllObj = ell_unitball(2);
   timeVec = [0 10];
   dirsMat = [1 0; 0 1]';
   rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
   ellTubeObj = rsObj.getEllTubeRel();
   unionEllTube = ...
    gras.ellapx.smartdb.rels.EllUnionTube.fromEllTubes(ellTubeObj);
   projMatList = {[1 0;0 1]};
   projType = gras.ellapx.enums.EProjType.Static;
   statEllTubeProj = unionEllTube.project(projType,projMatList,...
      @fGetProjMat);
   plObj=smartdb.disp.RelationDataPlotter();
   statEllTubeProj.plot(plObj);
end

function [projOrthMatArray,projOrthMatTransArray]=fGetProjMat(projMat,...
    timeVec,varargin)
  nTimePoints=length(timeVec);
  projOrthMatArray=repmat(projMat,[1,1,nTimePoints]);
  projOrthMatTransArray=repmat(projMat.',[1,1,nTimePoints]);
 end</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
</div>
<div class="section" id="gras-ellapx-smartdb-rels-elluniontubestaticproj">
<h2>gras.ellapx.smartdb.rels.EllUnionTubeStaticProj<a class="headerlink" href="#gras-ellapx-smartdb-rels-elluniontubestaticproj" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>EllUnionTubeStaticProj - class which keeps projection on static plane
                         union of ellipsoid tubes

Fields:
  QArray:cell[1, nElem] - Array of ellipsoid matrices
  aMat:cell[1, nElem] - Array of ellipsoid centers
  scaleFactor:double[1, 1] - Tube scale factor
  MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
  dim :double[1, 1] - Dimensionality
  sTime:double[1, 1] - Time s
  approxSchemaName:cell[1,] - Name
  approxSchemaDescr:cell[1,] - Description
  approxType:gras.ellapx.enums.EApproxType - Type of approximation
                (external, internal, not defined
  timeVec:cell[1, m] - Time vector
  calcPrecision:double[1, 1] - Calculation precision
  indSTime:double[1, 1]  - index of sTime within timeVec
  ltGoodDirMat:cell[1, nElem] - Good direction curve
  lsGoodDirVec:cell[1, nElem] - Good direction at time s
  ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
  lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
  xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                  direction
  xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                    opposite to good direction
  xsTouchVec:cell[1, nElem]  - Touch point at time s
  xsTouchOpVec :cell[1, nElem] - Touch point at time s
  projSTimeMat: cell[1, 1] - Projection matrix at time s
  projType:gras.ellapx.enums.EProjType - Projection type
  ltGoodDirNormOrigVec:cell[1, 1] - Norm of the original (not
                                    projected) good direction curve
  lsGoodDirNormOrig:double[1, 1] - Norm of the original (not
                                   projected)good direction at time s
  lsGoodDirOrigVec:cell[1, 1] - Original (not projected) good
                                direction at time s
  ellUnionTimeDirection:gras.ellapx.enums.EEllUnionTimeDirection -
                     Direction in time along which union is performed
  isLsTouch:logical[1, 1] - Indicates whether a touch takes place
                            along LS
  isLsTouchOp:logical[1, 1] - Indicates whether a touch takes place
                              along LS opposite
  isLtTouchVec:cell[1, nElem] - Indicates whether a touch takes place
                                along LT
  isLtTouchOpVec:cell[1, nElem] - Indicates whether a touch takes
                                  place along LT opposite
  timeTouchEndVec:cell[1, nElem] - Touch point curve for good
                                   direction
  timeTouchOpEndVec:cell[1, nElem] - Touch point curve for good
                                     direction

  TODO: correct description of the fields in
    gras.ellapx.smartdb.rels.EllUnionTubeStaticProj</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:smartdb.relations.ATypifiedStaticRelation] for
smartdb.relations.ATypifiedStaticRelation:</p>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>FROMELLTUBES - returns union of the ellipsoidal tubes on time</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>ellTubeRel: smartdb.relation.StaticRelation[1, 1]/</dt>
<dd>smartdb.relation.DynamicRelation[1, 1] - relation
object</dd>
</dl>
</dd>
</dl>
<p>Output:
ellUnionTubeRel: ellapx.smartdb.rel.EllUnionTube - union of the</p>
<blockquote>
<div>ellipsoidal tubes</div></blockquote>
</div></blockquote>
<div class="highlight-python"><pre>GETDATA - returns an indexed projection of CubeStruct object's content

Input:
  regular:
      self: CubeStruct [1,1] - the object

  optional:

      subIndCVec:
        Case#1: numeric[1,]/numeric[,1]

        Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
              for i=1,...,nDims

          -array of indices of field value slices that are selected
          to be returned; if not given (default),
          no indexation is performed

        Note!: numeric components of subIndVec are allowed to contain
           zeros which are be treated as they were references to null
           data slices

      dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
          numbers corresponding to subIndCVec

  properties:

      fieldNameList: char[1,]/cell[1,nFields] of char[1,]
          list of field names to return

      structNameList: char[1,]/cell[1,nStructs] of char[1,]
          list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}

      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the cells,
              default value is false

      nullReplacements: cell[1,nReplacedFields]  - list of null
          replacements for each of the fields

      nullReplacementFields: cell[1,nReplacedFields] - list of fields in
         which the nulls are to be replaced with the specified values,
         if not specified it is assumed that all fields are to be
         replaced

         NOTE!: all fields not listed in this parameter are replaced with
         the default values

      checkInputs: logical[1,1] - true by default (input arguments are
         checked for correctness

Output:
  regular:
    SData: struct [1,1] - structure containing values of
        fields at the selected slices, each field is an array
        containing values of the corresponding type

    SIsNull: struct [1,1] - structure containing a nested
        array with is-null indicators for each CubeStruct cell content

    SIsValueNull: struct [1,1] - structure containing a
       logical array [] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value</pre>
</div>
<div class="highlight-python"><pre>GETELLARRAY - returns array of matrix's ellipsoid according to
              approxType

Input:
 regular:
    self.
    approxType:char[1,] - type of approximation(internal/external)

Output:
  apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
           matrices</pre>
</div>
<div class="highlight-python"><pre>GETJOINWITH - returns a result of INNER join of given relation with
              another relation by the specified key fields

LIMITATION: key fields by which the join is peformed are required to form
a unique key in the given relation

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT)
          'leftOuter'

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>GETREACHTUBEANEPREFIX - return prefix of the reach tube</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd>self.</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>GETREGTUBEANEPREFIX - return prefix of the reg tube

Input:
  regular:
     self.</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><dl class="docutils">
<dt>ISEQUAL - compares current relation object with other relation object and</dt>
<dd>returns true if they are equal, otherwise it returns false</dd>
</dl>
<p>Usage: isEq=isEqual(self,otherObj)</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd>self: ARelation [1,1] - current relation object
otherObj: ARelation [1,1] - other relation object</dd>
<dt>properties:</dt>
<dd><dl class="first docutils">
<dt>checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields</dt>
<dd>in compared relations must be in the same order, otherwise the
order is not  important (false by default)</dd>
<dt>checkTupleOrder: logical[1,1] -  if true, then the tuples in the</dt>
<dd>compared relations are expected to be in the same order,
otherwise the order is not important (false by default)</dd>
</dl>
<p>maxTolerance: double [1,1] - maximum allowed tolerance</p>
<dl class="docutils">
<dt>compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct&#8217;s</dt>
<dd>referenced from the meta data objects are also compared</dd>
</dl>
<p class="last">maxRelativeTolerance: double [1,1] - maximum allowed
relative tolerance</p>
</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd>isEq: logical[1,1] - result of comparison
reportStr: char[1,] - report of comparsion</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>PLOT - displays ellipsoidal tubes using the specified
  RelationDataPlotter

Input:
  regular:
      self:
  optional:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
          object used for displaying ellipsoidal tubes
  properties:
      fGetColor: function_handle[1, 1] -
          function that specified colorVec for
          ellipsoidal tubes
      fGetAlpha: function_handle[1, 1] -
          function that specified transparency
          value for ellipsoidal tubes
      fGetLineWidth: function_handle[1, 1] -
          function that specified lineWidth for good curves
      fGetFill: function_handle[1, 1] - this
          property not used in this version
      colorFieldList: cell[nColorFields, ] of char[1, ] -
          list of parameters for color function
      alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
          list of parameters for transparency function
      lineWidthFieldList: cell[nLineWidthFields, ]
          of char[1, ] - list of parameters for lineWidth
          function
      fillFieldList: cell[nIsFillFields, ] of char[1, ] -
          list of parameters for fill function
      plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
          defaul list of parameters. If for any function in
          properties not specified list of parameters,
          this one will be used

Output:
  plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
          object used for displaying ellipsoidal tubes</pre>
</div>
<div class="highlight-python"><pre>PLOTEXT - plots external approximation of ellTube.


Usage:
      obj.plotExt() - plots external approximation of ellTube.
      obj.plotExt('Property',PropValue,...) - plots external approximation
                                              of ellTube with setting
                                              properties.

Input:
  regular:
      obj:  EllTubeProj: EllTubeProj object
  optional:
      relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
      colorSpec: char[1,1] - color specification code, can be 'r','g',
                   etc (any code supported by built-in Matlab function).

  properties:

      fGetColor: function_handle[1, 1] -
          function that specified colorVec for
          ellipsoidal tubes
      fGetAlpha: function_handle[1, 1] -
          function that specified transparency
          value for ellipsoidal tubes
      fGetLineWidth: function_handle[1, 1] -
          function that specified lineWidth for good curves
      fGetFill: function_handle[1, 1] - this
          property not used in this version
      colorFieldList: cell[nColorFields, ] of char[1, ] -
          list of parameters for color function
      alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
          list of parameters for transparency function
      lineWidthFieldList: cell[nLineWidthFields, ]
          of char[1, ] - list of parameters for lineWidth
          function
      fillFieldList: cell[nIsFillFields, ] of char[1, ] -
          list of parameters for fill function
      plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
          defaul list of parameters. If for any function in
          properties not specified list of parameters,
          this one will be used
      'showDiscrete':logical[1,1]  -
          if true, approximation in 3D will be filled in every time slice
      'nSpacePartPoins': double[1,1] -
          number of points in every time slice.
Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.</pre>
</div>
<div class="highlight-python"><pre>PLOTINT - plots internal approximation of ellTube.


Usage:
      obj.plotInt() - plots internal approximation of ellTube.
      obj.plotInt('Property',PropValue,...) - plots internal approximation
                                              of ellTube with setting
                                              properties.

Input:
  regular:
      obj:  EllTubeProj: EllTubeProj object
  optional:
      relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
      colorSpec: char[1,1] - color specification code, can be 'r','g',
                   etc (any code supported by built-in Matlab function).

  properties:

      fGetColor: function_handle[1, 1] -
          function that specified colorVec for
          ellipsoidal tubes
      fGetAlpha: function_handle[1, 1] -
          function that specified transparency
          value for ellipsoidal tubes
      fGetLineWidth: function_handle[1, 1] -
          function that specified lineWidth for good curves
      fGetFill: function_handle[1, 1] - this
          property not used in this version
      colorFieldList: cell[nColorFields, ] of char[1, ] -
          list of parameters for color function
      alphaFieldList: cell[nAlphaFields, ] of char[1, ] -
          list of parameters for transparency function
      lineWidthFieldList: cell[nLineWidthFields, ]
          of char[1, ] - list of parameters for lineWidth
          function
      fillFieldList: cell[nIsFillFields, ] of char[1, ] -
          list of parameters for fill function
      plotSpecFieldList: cell[nPlotFields, ] of char[1, ] -
          defaul list of parameters. If for any function in
          properties not specified list of parameters,
          this one will be used
      'showDiscrete':logical[1,1]  -
          if true, approximation in 3D will be filled in every time slice
      'nSpacePartPoins': double[1,1] -
          number of points in every time slice.
Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
</div>
<div class="section" id="elltool-reach-areach">
<h2>elltool.reach.AReach<a class="headerlink" href="#elltool-reach-areach" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><dl class="docutils">
<dt>CUT - extracts the piece of reach tube from given start time to given</dt>
<dd>end time. Given reach set self, find states that are reachable
within time interval specified by cutTimeVec. If cutTimeVec
is a scalar, then reach set at given time is returned.</dd>
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd><blockquote class="first">
<div>self.</div></blockquote>
<p class="last">cutTimeVec: double[1, 2]/double[1, 1] - time interval to cut.</p>
</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd><dl class="first last docutils">
<dt>cutObj: elltool.reach.IReach[1, 1] - reach set resulting from the CUT</dt>
<dd>operation.</dd>
</dl>
</dd>
<dt>Example:</dt>
<dd>aMat = [0 1; 0 0]; bMat = eye(2);
SUBounds = struct();
SUBounds.center = {&#8216;sin(t)&#8217;; &#8216;cos(t)&#8217;};
SUBounds.shape = [9 0; 0 2];
sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
x0EllObj = ell_unitball(2);
timeVec = [0 10];
dirsMat = [1 0; 0 1]&#8217;;
rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
cutObj = rsObj.cut([3 5]);
dRsObj = elltool.reach.ReachDiscrete(dtsys, x0EllObj, dirsMat, timeVec);
dCutObj = dRsObj.cut([3 5]);</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>DIMENSION - returns array of dimensions of given reach set array.

Input:
  regular:
      self - multidimensional array of
             ReachContinuous/ReachDiscrete objects

Output:
  rSdimArr: double[nDim1, nDim2,...] - array of reach set dimensions.
  sSdimArr: double[nDim1, nDim2,...] - array of state space dimensions.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObjArr = rsObj.repMat(1,2);
  [rSdim sSdim] = rsObj.dimension()

  rSdim =

           2


  sSdim =

           2

  [rSdim sSdim] = rsObjArr.dimension()

  rSdim =
          [ 2  2 ]

  sSdim =
          [ 2  2 ]</pre>
</div>
<div class="highlight-python"><pre>DISPLAY - displays the reach set object.

Input:
  regular:
      self.

Output:
  None.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObj.display()

  rsObj =
  Reach set of the continuous-time linear system in R^2 in the time...
       interval [0, 10].

  Initial set at time t0 = 0:
  Ellipsoid with parameters
  Center:
       0
       0

  Shape Matrix:
       1     0
       0     1

  Number of external approximations: 2
  Number of internal approximations: 2</pre>
</div>
<div class="highlight-python"><pre>EVOLVE - computes further evolution in time of the
         already existing reach set.

Input:
  regular:
      self.

      newEndTime: double[1, 1] - new end time.

  optional:
      linSys: elltool.linsys.LinSys[1, 1] - new linear system.

Output:
  newReachObj: reach[1, 1] - reach set on time  interval
        [oldT0 newEndTime].

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  dRsObj = elltool.reach.ReachDiscrete(dsys, x0EllObj, dirsMat, timeVec);
  newRsObj = rsObj.evolve(12);
  newDRsObj = dRsObj.evolve(11);</pre>
</div>
<div class="highlight-python"><pre>GETABSTOL - gives the array of absTol for all elements
  in rsArr

Input:
  regular:
      rsArr: elltool.reach.AReach[nDim1, nDim2, ...] -
          multidimension array of reach sets
  optional:
      fAbsTolFun: function_handle[1,1] - function that is
          applied to the absTolArr. The default is @min.

Output:
  regular:
      absTolArr: double [absTol1, absTol2, ...] - return
          absTol for each element in rsArr
  optional:
      absTol: double[1,1] - return result of work fAbsTolFun
          with the absTolArr

Usage:
  use [~,absTol] = rsArr.getAbsTol() if you want get only
      absTol,
  use [absTolArr,absTol] = rsArr.getAbsTol() if you want
      get absTolArr and absTol,
  use absTolArr = rsArr.getAbsTol() if you want get only
      absTolArr</pre>
</div>
<div class="highlight-python"><pre>Input:
  regular:
      self:
  properties:
      l0Mat: double[nDims,nDirs] - matrix of good
          directions at time s
      isIntExtApxVec: logical[1,2] - two element vector with the
         first element corresponding to internal approximations
        and second - to external ones. An element equal to
         false means that the corresponding approximation type
         is filtered out. Default value is [true,true]
Example:
    aMat = [0 1; 0 0]; bMat = eye(2);
    SUBounds = struct();
    SUBounds.center = {'sin(t)'; 'cos(t)'};
    SUBounds.shape = [9 0; 0 2];
    sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
    x0EllObj = ell_unitball(2);
    timeVec = [0 10];
    dirsMat = [1 0; 0 1; 1 1;1 2]';
    rsObj = elltool.reach.ReachContinuous(sys, x0EllObj,...
      dirsMat, timeVec);

    copyRsObj = rsObj.getCopy()

    Reach set of the continuous-time linear system in R^2 in
      the time interval [0, 10].

    Initial set at time k0 = 0:
    Ellipsoid with parameters
    Center:
         0
         0

    Shape Matrix:
         1     0
         0     1

    Number of external approximations: 4
    Number of internal approximations: 4

    copyRsObj = rsObj.getCopy('l0Mat',[0;1],'approxType',...
      [true,false])

    Reach set of the continuous-time linear system in R^2 in
      the time interval [0, 10].

    Initial set at time k0 = 0:
    Ellipsoid with parameters
    Center:
         0
         0

    Shape Matrix:
         1     0
         0     1

    Number of external approximations: 1
    Number of internal approximations: 1</pre>
</div>
<div class="highlight-python"><pre>GET_EASCALEFACTOR - return the scale factor for external approximation
                    of reach tube

Input:
  regular:
      self.

Output:
  regular:
      eaScaleFactor: double[1, 1] - scale factor.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [10 0];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObj.getEaScaleFactor()

  ans =

      1.0200</pre>
</div>
<div class="highlight-python"><pre>Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObj.getEllTubeRel();</pre>
</div>
<div class="highlight-python"><pre>Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  getEllTubeUnionRel(rsObj);</pre>
</div>
<div class="highlight-python"><pre>GET_IASCALEFACTOR - return the scale factor for internal approximation
                    of reach tube

Input:
  regular:
      self.

Output:
  regular:
      iaScaleFactor: double[1, 1] - scale factor.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [10 0];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObj.getIaScaleFactor()

  ans =

      1.0200</pre>
</div>
<div class="highlight-python"><pre>GETINITIALSET - return the initial set for linear system, which is solved
                for building reach tube.

Input:
  regular:
      self.

Output:
  regular:
      x0Ell: ellipsoid[1, 1] - ellipsoid x0, which was initial set for
          linear system.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [10 0];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  x0Ell = rsObj.getInitialSet()

  x0Ell =

  Center:
       0
       0

  Shape Matrix:
       1     0
       0     1

  Nondegenerate ellipsoid in R^2.</pre>
</div>
<div class="highlight-python"><pre>GETNPLOT2DPOINTS - gives array  the same size as rsArr of
  value of nPlot2dPoints property for each element in rsArr -
  array of reach sets

Input:
  regular:
    rsArr:elltool.reach.AReach[nDims1,nDims2,...] - reach
      set array

Output:
  nPlot2dPointsArr:double[nDims1,nDims2,...] - array of
      values of nTimeGridPoints property for each reach set
      in rsArr</pre>
</div>
<div class="highlight-python"><pre>GETNPLOT3DPOINTS - gives array  the same size as rsArr of
  value of nPlot3dPoints property for each element in rsArr
  array of reach sets

Input:
  regular:
      rsArr:reach[nDims1,nDims2,...] - reach set array

Output:
  nPlot3dPointsArr:double[nDims1,nDims2,...]- array of values
      of nPlot3dPoints property for each reach set in rsArr</pre>
</div>
<div class="highlight-python"><pre>GETNTIMEGRIDPOINTS - gives array  the same size as rsArr of
  value of nTimeGridPoints property for each element in rsArr
  array of reach sets

Input:
  regular:
      rsArr: elltool.reach.AReach [nDims1,nDims2,...] - reach
          set array

Output:
  nTimeGridPointsArr: double[nDims1,nDims2,...]- array of
      values of nTimeGridPoints property for each reach set
      in rsArr</pre>
</div>
<div class="highlight-python"><pre>GETRELTOL - gives the array of relTol for all elements in
ellArr

Input:
  regular:
      rsArr: elltool.reach.AReach[nDim1,nDim2, ...] -
          multidimension array of reach sets.
  optional
      fRelTolFun: function_handle[1,1] - function that is
          applied to the relTolArr. The default is @min.

Output:
  regular:
      relTolArr: double [relTol1, relTol2, ...] - return
          relTol for each element in rsArr.
  optional:
      relTol: double[1,1] - return result of work fRelTolFun
          with the relTolArr

Usage:
  use [~,relTol] = rsArr.getRelTol() if you want get only
      relTol,
  use [relTolArr,relTol] = rsArr.getRelTol() if you want get
      relTolArr and relTol,
  use relTolArr = rsArr.getRelTol() if you want get only
      relTolArr</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><p>GET_CENTER - returns the trajectory of the center of the reach set.</p>
<dl class="docutils">
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd>self.</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd><dl class="first docutils">
<dt>trCenterMat: double[nDim, nPoints] - array of points that form the</dt>
<dd>trajectory of the reach set center, where nDim is reach set
dimentsion, nPoints - number of points in time grid.</dd>
</dl>
<p class="last">timeVec: double[1, nPoints] - array of time values.</p>
</dd>
<dt>Example:</dt>
<dd>aMat = [0 1; 0 0]; bMat = eye(2);
SUBounds = struct();
SUBounds.center = {&#8216;sin(t)&#8217;; &#8216;cos(t)&#8217;};
SUBounds.shape = [9 0; 0 2];
sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
x0EllObj = ell_unitball(2);
timeVec = [0 10];
dirsMat = [1 0; 0 1]&#8217;;
rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
[trCenterMat timeVec] = rsObj.get_center();</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>GET_DIRECTIONS - returns the values of direction vectors for time grid
                 values.

Input:
  regular:
      self.

Output:
  directionsCVec: cell[1, nPoints] of double [nDim, nDir] - array of
      cells, where each cell is a sequence of direction vector values
      that correspond to the time values of the grid, where nPoints is
      number of points in time grid.

  timeVec: double[1, nPoints] - array of time values.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  [directionsCVec timeVec] = rsObj.get_directions();</pre>
</div>
<div class="highlight-python"><pre>GET_EA - returns array of ellipsoid objects representing external
         approximation of the reach  tube.

Input:
  regular:
      self.

Output:
  eaEllMat: ellipsoid[nAppr, nPoints] - array of ellipsoids, where nAppr
      is the number of approximations, nPoints is number of points in time
      grid.

   timeVec: double[1, nPoints] - array of time values.
   l0Mat: double[nDirs,nDims] - matrix of good directions at t0

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  [eaEllMat timeVec] = rsObj.get_ea();

  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
  [eaEllMat timeVec] = dRsObj.get_ea();</pre>
</div>
<div class="highlight-python"><pre>GET_GOODCURVES - returns the 'good curve' trajectories of the reach set.

Input:
  regular:
      self.

Output:
  goodCurvesCVec: cell[1, nPoints] of double [x, y] - array of cells,
      where each cell is array of points that form a 'good curve'.

  timeVec: double[1, nPoints] - array of time values.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  [goodCurvesCVec timeVec] = rsObj.get_goodcurves();

  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
  [goodCurvesCVec timeVec] = dRsObj.get_goodcurves();</pre>
</div>
<div class="highlight-python"><pre>GET_IA - returns array of ellipsoid objects representing internal
         approximation of the  reach tube.

Input:
  regular:
      self.

Output:
  iaEllMat: ellipsoid[nAppr, nPoints] - array of ellipsoids, where nAppr
      is the number of approximations, nPoints is number of points in time
      grid.

  timeVec: double[1, nPoints] - array of time values.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  [iaEllMat timeVec] = rsObj.get_ia();</pre>
</div>
<div class="highlight-python"><pre>GET_SYSTEM - returns the linear system for which the reach set is
             computed.

Input:
  regular:
      self.

Output:
  linSys: elltool.linsys.LinSys[1, 1] - linear system object.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  linSys = rsObj.get_system()

  self =
  A:
       0     1
       0     0


  B:
       1     0
       0     1


  Control bounds:
     2-dimensional ellipsoid with center
      'sin(t)'
      'cos(t)'

     and shape matrix
       9     0
       0     2


  C:
       1     0
       0     1

  2-input, 2-output continuous-time linear time-invariant system of
          dimension 2:
  dx/dt  =  A x(t)  +  B u(t)
   y(t)  =  C x(t)

  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
  dRsObj.get_system();</pre>
</div>
<div class="highlight-python"><pre>INTERSECT - checks if its external (s = 'e'), or internal (s = 'i')
            approximation intersects with given ellipsoid, hyperplane
            or polytop.

Input:
  regular:
      self.

      intersectObj: ellipsoid[1, 1]/hyperplane[1,1]/polytop[1, 1].

      approxTypeChar: char[1, 1] - 'e' (default) - external approximation,
                                   'i' - internal approximation.

Output:
  isEmptyIntersect: logical[1, 1] -  true - if intersection is nonempty,
                                     false - otherwise.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  ellObj = ellipsoid([0; 0], 2*eye(2));
  isEmptyIntersect = intersect(rsObj, ellObj)

  isEmptyIntersect =

                  1</pre>
</div>
<div class="highlight-python"><pre>ISEMPTY - checks if given reach set array is an array of empty objects.

Input:
  regular:
      self - multidimensional array of
             ReachContinuous/ReachDiscrete objects

Output:
  isEmptyArr: logical[nDim1, nDim2, nDim3,...] -
              isEmpty(iDim1, iDim2, iDim3,...) = true - if self(iDim1, iDim2, iDim3,...) is empty,
                                               = false - otherwise.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  dRsObj = elltool.reach.ReachRiscrete(dsys, x0EllObj, dirsMat, timeVec);
  rsObjArr = rsObj.repMat(1,2);
  dRsObjArr = dRsObj.repMat(1,2);
  dRsObj.isEmpty();
  rsObj.isEmpty()

  ans =

       0

  dRsObjArr.isEmpty();
  rsObjArr.isEmpty()

  ans =
      [ 0  0 ]</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - checks for equality given reach set objects

Input:
  regular:
      self.
      reachObj:
          elltool.reach.AReach[1, 1] - each set object, which
           compare with self.
  optional:
      indTupleVec: double[1,] - tube numbers that are
          compared
      approxType: gras.ellapx.enums.EApproxType[1, 1] -  type of
          approximation, which will be compared.
  properties:
      notComparedFieldList: cell[1,k] - fields not to compare
          in tubes. Default: LT_GOOD_DIR_*, LS_GOOD_DIR_*,
          IND_S_TIME, S_TIME, TIME_VEC
      areTimeBoundsCompared: logical[1,1] - treat tubes with
          different timebounds as inequal if 'true'.
          Default: false

Output:
  regular:
      ISEQUAL: logical[1, 1] - true - if reach set objects are equal.
          false - otherwise.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  copyRsObj = rsObj.getCopy();
  isEqual = isEqual(rsObj, copyRsObj)

  isEqual =

          1</pre>
</div>
<div class="highlight-python"><pre>ISBACKWARD - checks if given reach set object was obtained by solving
             the system in reverse time.

Input:
  regular:
      self.

Output:
  regular:
      isBackward: logical[1, 1] - true - if self was obtained by solving
          in reverse time, false - otherwise.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [10 0];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObj.isbackward()

  ans =

       1</pre>
</div>
<div class="highlight-python"><pre>ISCUT - checks if given array of reach set objects is a cut of
        another reach set object's array.

Input:
  regular:
      self - multidimensional array of
             ReachContinuous/ReachDiscrete objects

Output:
  isCutArr: logical[nDim1, nDim2, nDim3 ...] -
            isCut(iDim1, iDim2, iDim3,..) = true - if self(iDim1, iDim2, iDim3,...) is a cut of the reach set,
                                          = false - otherwise.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  dRsObj = elltool.reach.ReachRiscrete(dsys, x0EllObj, dirsMat, timeVec);
  cutObj = rsObj.cut([3 5]);
  cutObjArr = cutObj.repMat(2,3,4);
  iscut(cutObj);
  iscut(cutObjArr);
  cutObj = dRsObj.cut([4 8]);
  cutObjArr = cutObj.repMat(1,2);
  iscut(cutObjArr);
  iscut(cutObj);</pre>
</div>
<div class="highlight-python"><pre>ISPROJECTION - checks if given array of reach set objects is projections.

Input:
  regular:
      self - multidimensional array of
             ReachContinuous/ReachDiscrete objects

Output:
  isProjArr: logical[nDim1, nDim2, nDim3, ...] -
             isProj(iDim1, iDim2, iDim3,...) = true - if self(iDim1, iDim2, iDim3,...) is projection,
                                             = false - otherwise.


Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  dRsObj = elltool.reach.ReachRiscrete(dsys, x0EllObj, dirsMat, timeVec);
  projMat = eye(2);
  projObj = rsObj.projection(projMat);
  projObjArr = projObj.repMat(3,2,2);
  isprojection(projObj);
  isprojection(projObjArr);
  projObj = dRsObj.projection(projMat);
  projObjArr = projObj.repMat(1,2);
  isprojection(projObj);
  isprojection(projObjArr);</pre>
</div>
<div class="highlight-python"><pre>plotByEa - plots external approximation of reach tube.


Usage:
      plotByEa(self,'Property',PropValue,...)
      - plots external approximation of reach tube
           with  setting properties

Input:
  regular:
      self: - reach tube

  optional:
      relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
      charColor: char[1,1]  - color specification code, can be 'r','g',
                     etc (any code supported by built-in Matlab function).
  properties:

      'fill': logical[1,1]  -
              if 1, tube in 2D will be filled with color.
              Default value is true.
      'lineWidth': double[1,1]  -
                   line width for 2D plots. Default value is 2.
      'color': double[1,3] -
               sets default colors in the form [x y z].
                  Default value is [0 0 1].
      'shade': double[1,1]  -
     level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
               Default value is 0.3.

Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.</pre>
</div>
<div class="highlight-python"><pre>plotByIa - plots internal approximation of reach tube.


Usage:
      plotByIa(self,'Property',PropValue,...)
      - plots internal approximation of reach tube
           with  setting properties

Input:
  regular:
      self: - reach tube

  optional:
      relDataPlotter:smartdb.disp.RelationDataPlotter[1,1] - relation data plotter object.
      charColor: char[1,1]  - color specification code, can be 'r','g',
                     etc (any code supported by built-in Matlab function).
  properties:

      'fill': logical[1,1]  -
              if 1, tube in 2D will be filled with color.
              Default value is true.
      'lineWidth': double[1,1]  -
                   line width for 2D plots. Default value is 2.
      'color': double[1,3] -
               sets default colors in the form [x y z].
                  Default value is [0 1 0].
      'shade': double[1,1]  -
     level of transparency between 0 and 1 (0 - transparent, 1 - opaque).
               Default value is 0.1.

Output:
  regular:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - returns the relation
      data plotter object.</pre>
</div>
<div class="highlight-python"><pre>PLOT_EA - plots external approximations of 2D and 3D reach sets.

Input:
  regular:
      self.

  optional:
      colorSpec: char[1, 1] - set color to plot in following way:
                             'r' - red color,
                             'g' - green color,
                             'b' - blue color,
                             'y' - yellow color,
                             'c' - cyan color,
                             'm' - magenta color,
                             'w' - white color.

      OptStruct: struct[1, 1] with fields:
          color: double[1, 3] - sets color of the picture in the form
                [x y z].
          width: double[1, 1] - sets line width for 2D plots.
          shade: double[1, 1] in [0; 1] interval - sets transparency level
                (0 - transparent, 1 - opaque).
           fill: double[1, 1] - if set to 1, reach set will be filled with
                 color.

Output:
  None.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObj.plotEa();
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);

  dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
  dRsObj.plotEa();</pre>
</div>
<div class="highlight-python"><pre>PLOTIA - plots internal approximations of 2D and 3D reach sets.

Input:
  regular:
      self.

  optional:
      colorSpec: char[1, 1] - set color to plot in following way:
                             'r' - red color,
                             'g' - green color,
                             'b' - blue color,
                             'y' - yellow color,
                             'c' - cyan color,
                             'm' - magenta color,
                             'w' - white color.

      OptStruct: struct[1, 1] with fields:
          color: double[1, 3] - sets color of the picture in the form
                [x y z].
          width: double[1, 1] - sets line width for 2D plots.
          shade: double[1, 1] in [0; 1] interval - sets transparency level
                (0 - transparent, 1 - opaque).
           fill: double[1, 1] - if set to 1, reach set will be filled with
                color.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
  rsObj.plotIa();
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dRsObj = elltool.reach.ReachDiscrete(sys, x0EllObj, dirsMat, timeVec);
  dRsObj.plotIa();</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><dl class="docutils">
<dt>REFINE - adds new approximations computed for the specified directions</dt>
<dd>to the given reach set or to the projection of reach set.</dd>
<dt>Input:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd><p class="first">self.
l0Mat: double[nDim, nDir] - matrix of directions for new</p>
<blockquote class="last">
<div>approximation</div></blockquote>
</dd>
</dl>
</dd>
<dt>Output:</dt>
<dd><dl class="first last docutils">
<dt>regular:</dt>
<dd><dl class="first last docutils">
<dt>reachObj: reach[1,1] - refine reach set for the directions</dt>
<dd>specified in l0Mat</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Example:</dt>
<dd>aMat = [0 1; 0 0]; bMat = eye(2);
SUBounds = struct();
SUBounds.center = {&#8216;sin(t)&#8217;; &#8216;cos(t)&#8217;};
SUBounds.shape = [9 0; 0 2];
sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
x0EllObj = ell_unitball(2);
timeVec = [0 10];
dirsMat = [1 0; 0 1]&#8217;;
newDirsMat = [1; -1];
rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
rsObj = rsObj.refine(newDirsMat);</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>REPMAT - is analogous to built-in repmat function with one exception - it
         copies the objects, not just the handles

Input:
  regular:
      self.

Output:
  Array of given ReachContinuous/ReachDiscrete object's copies.

 Example:
   aMat = [0 1; 0 0]; bMat = eye(2);
   SUBounds = struct();
   SUBounds.center = {'sin(t)'; 'cos(t)'};
   SUBounds.shape = [9 0; 0 2];
   sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
   x0EllObj = ell_unitball(2);
   timeVec = [0 10];
   dirsMat = [1 0; 0 1]';
   reachObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
   reachObjArr = reachObj.repMat(1,2);

   reachObjArr = 1x2 array of ReachContinuous objects</pre>
</div>
</div>
<div class="section" id="elltool-reach-reachcontinuous">
<h2>elltool.reach.ReachContinuous<a class="headerlink" href="#elltool-reach-reachcontinuous" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>ReachContinuous - computes reach set approximation of the continuous
    linear system for the given time interval.
Input:
    regular:
      linSys: elltool.linsys.LinSys object -
          given linear system .
      x0Ell: ellipsoid[1, 1] - ellipsoidal set of
          initial conditions.
      l0Mat: double[nRows, nColumns] - initial good directions
          matrix.
      timeVec: double[1, 2] - time interval.

    properties:
      isRegEnabled: logical[1, 1] - if it is 'true' constructor
          is allowed to use regularization.
      isJustCheck: logical[1, 1] - if it is 'true' constructor
          just check if square matrices are degenerate, if it is
          'false' all degenerate matrices will be regularized.
      regTol: double[1, 1] - regularization precision.

Output:
  regular:
    self - reach set object.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:elltool.reach.AReach] for elltool.reach.AReach:</p>
</div>
<div class="section" id="elltool-reach-reachdiscrete">
<h2>elltool.reach.ReachDiscrete<a class="headerlink" href="#elltool-reach-reachdiscrete" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>ReachDiscrete - computes reach set approximation of the discrete linear
                system for the given time interval.


Input:
    linSys: elltool.linsys.LinSys object - given linear system
    x0Ell: ellipsoid[1, 1] - ellipsoidal set of initial conditions
    l0Mat: double[nRows, nColumns] - initial good directions
          matrix.
    timeVec: double[1, 2] - time interval
    properties:
      isRegEnabled: logical[1, 1] - if it is 'true' constructor
          is allowed to use regularization.
      isJustCheck: logical[1, 1] - if it is 'true' constructor
          just check if square matrices are degenerate, if it is
          'false' all degenerate matrices will be regularized.
      regTol: double[1, 1] - regularization precision.
      minmax: logical[1, 1] - field, which:
          = 1 compute minmax reach set,
          = 0 (default) compute maxmin reach set.

Output:
  regular:
    self - reach set object.
Example:
  adMat = [0 1; -1 -0.5];
  bdMat = [0; 1];
  udBoundsEllObj  = ellipsoid(1);
  dtsys = elltool.linsys.LinSysDiscrete(adMat, bdMat, udBoundsEllObj);
  x0EllObj = ell_unitball(2);
  timeVec = [0 10];
  dirsMat = [1 0; 0 1]';
  dRsObj = elltool.reach.ReachDiscrete(dtsys, x0EllObj, dirsMat, timeVec);</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:elltool.reach.AReach] for elltool.reach.AReach:</p>
</div>
<div class="section" id="elltool-reach-reachfactory">
<h2>elltool.reach.ReachFactory<a class="headerlink" href="#elltool-reach-reachfactory" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>Example:
  import elltool.reach.ReachFactory;
  crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
  crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
  rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);</pre>
</div>
<div class="highlight-python"><pre>Example:
  import elltool.reach.ReachFactory;
  crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
  crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
  rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
  reachObj = rsObj.createInstance();</pre>
</div>
<div class="highlight-python"><pre>::</pre>
</div>
<blockquote>
<div><dl class="docutils">
<dt>Example:</dt>
<dd>import elltool.reach.ReachFactory;
crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
rsObj =  ReachFactory(&#8216;demo3firstTest&#8217;, crm, crmSys, false, false);
dim = rsObj.getDim();</dd>
</dl>
</div></blockquote>
<div class="highlight-python"><pre>Example:
  import elltool.reach.ReachFactory;
  crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
  crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
  rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
  l0Mat = rsObj.getL0Mat()

  l0Mat =

       1     0
       0     1</pre>
</div>
<div class="highlight-python"><pre>Example:
  import elltool.reach.ReachFactory;
  crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
  crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
  rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
  linSys = rsObj.getLinSys();</pre>
</div>
<div class="highlight-python"><pre>Example:
  import elltool.reach.ReachFactory;
  crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
  crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
  rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
  tVec = rsObj.getTVec()

  tVec =

       0    10</pre>
</div>
<div class="highlight-python"><pre>Example:
  import elltool.reach.ReachFactory;
  crm=gras.ellapx.uncertcalc.test.regr.conf.ConfRepoMgr();
  crmSys=gras.ellapx.uncertcalc.test.regr.conf.sysdef.ConfRepoMgr();
  rsObj =  ReachFactory('demo3firstTest', crm, crmSys, false, false);
  X0Ell = rsObj.getX0Ell()

  X0Ell =

  Center:
       0
       0

  Shape Matrix:
      0.0100         0
           0    0.0100

  Nondegenerate ellipsoid in R^2.</pre>
</div>
</div>
<div class="section" id="elltool-linsys-alinsys">
<h2>elltool.linsys.ALinSys<a class="headerlink" href="#elltool-linsys-alinsys" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>ALinSys - constructor abstract class of linear system.

Continuous-time linear system:
          dx/dt  =  A(t) x(t)  +  B(t) u(t)  +  C(t) v(t)

Discrete-time linear system:
          x[k+1]  =  A[k] x[k]  +  B[k] u[k]  +  C[k] v[k]

Input:
  regular:
      atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

      btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.

      uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
          ellipsoid.

      ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

      vBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds
          ellipsoid.
      discrFlag: char[1, 1] - if discrFlag set:
          'd' - to discrete-time linSys
          not 'd' - to continuous-time linSys.

Output:
  self: elltool.linsys.ALinSys[1, 1] -
      linear system.</pre>
</div>
<div class="highlight-python"><pre>DIMENSION - returns dimensions of state, input, output and disturbance
            spaces.
Input:
  regular:
      self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of
            linear systems.

Output:
  stateDimArr: double[nDims1, nDims2,...] - array of state space
      dimensions.

  inpDimArr: double[nDims1, nDims2,...] - array of input dimensions.

  distDimArr: double[nDims1, nDims2,...] - array of disturbance
        dimensions.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  [stateDimArr, inpDimArr, outDimArr, distDimArr] = sys.dimension()

  stateDimArr =

       2


  inpDimArr =

       2



  distDimArr =

       0

  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dsys.dimension();</pre>
</div>
<div class="highlight-python"><pre>DISPLAY - displays the details of linear system object.

Input:
  regular:
      self: elltool.linsys.ALinSys[1, 1] - linear system.

Output:
  None.</pre>
</div>
<div class="highlight-python"><pre>GETABSTOL - gives array the same size as linsysArr with values of absTol
            properties for each hyperplane in hplaneArr.


Input:
  regular:
      self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of linear
            systems.

Output:
  absTolArr: double[nDims1, nDims2,...] - array of absTol properties for
      linear systems in self.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  sys.getAbsTol();
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dsys.getAbsTol();</pre>
</div>
<div class="highlight-python"><pre>Input:
  regular:
      self: elltool.linsys.ILinSys[1, 1] - linear system.

Output:
  aMat: double[aMatDim, aMatDim]/cell[nDim, nDim] - matrix A.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  aMat = dsys.getAtMat();</pre>
</div>
<div class="highlight-python"><pre>Input:
  regular:
      self: elltool.linsys.ILinSys[1, 1] - linear system.

Output:
  bMat: double[bMatDim, bMatDim]/cell[bMatDim, bMatDim] - matrix B.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  bMat = dsys.getBtMat();</pre>
</div>
<div class="highlight-python"><pre>GETCOPY - gives array the same size as linsysArr with with copies of
          elements of self.

Input:
  regular:
      self: elltool.linsys.ALinSys[nDims1, nDims2,...] - an array of
            linear systems.

Output:
  copyLinSysArr: elltool.linsys.LinSys[nDims1, nDims2,...] -  an array of
     copies of elements of self.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  newSys = sys.getCopy();
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  newDSys = dsys.getCopy();</pre>
</div>
<div class="highlight-python"><pre>Input:
  regular:
      self: elltool.linsys.ILinSys[1, 1] - linear system.

Output:
  cMat: double[cMatDim, cMatDim]/cell[cMatDim, cMatDim] - matrix C.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  gMat = sys.getCtMat();</pre>
</div>
<div class="highlight-python"><pre>Input:
  regular:
      self: elltool.linsys.ILinSys[1, 1] - linear system.

Output:
  distEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds ellipsoid.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  distEll = sys.getDistBoundsEll();</pre>
</div>
<div class="highlight-python"><pre>Input:
  regular:
      self: elltool.linsys.ILinSys[1, 1] - linear system.

Output:
  uEll: ellipsoid[1, 1]/struct[1, 1] - control bounds ellipsoid.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  uEll = dsys.getUBoundsEll();</pre>
</div>
<div class="highlight-python"><pre>HASDISTURBANCE - returns true if system has disturbance

Input:
  regular:
      self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of
            linear systems.
  optional:
      isMeaningful: logical[1,1] - if true(default), treat constant
                    disturbance vector as absence of disturbance

Output:
  isDisturbanceArr: logical[nDims1, nDims2,...] - array such that it's
      element at each position is true if corresponding linear system
      has disturbance, and false otherwise.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  sys.hasDisturbance()

  ans =

       0
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dsys.hasDisturbance();</pre>
</div>
<div class="highlight-python"><pre>ISEMPTY - checks if linear system is empty.

Input:
  regular:
      self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of linear
            systems.

Output:
  isEmptyMat: logical[nDims1, nDims2,...] - array such that it's element at
      each position is true if corresponding linear system is empty, and
      false otherwise.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  sys.isEmpty()

  ans =

       0
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  dsys.isEmpty();</pre>
</div>
<div class="highlight-python"><pre>ISEQUAL - produces produces logical array the same size as
          self/compLinSysArr (if they have the same).
          isEqualArr[iDim1, iDim2,...] is true if corresponding
          linear systems are equal and false otherwise.

Input:
  regular:
      self: elltool.linsys.ILinSys[nDims1, nDims2,...] -  an array of
           linear systems.
      compLinSysArr: elltool.linsys.ILinSys[nDims1,...nDims2,...] - an
           array of linear systems.

Output:
  isEqualArr: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of
      logical values.
      isEqualArr[iDim1, iDim2,...] is true if corresponding linear systems
      are equal and false otherwise.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  newSys = sys.getCopy();
  isEqual = sys.isEqual(newSys)

  isEqual =

       1
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  newDSys = sys.getCopy();
  isEqual = dsys.isEqual(newDSys)

  isEqual =

       1</pre>
</div>
<div class="highlight-python"><pre>ISLTI - checks if linear system is time-invariant.

Input:
  regular:
      self: elltool.linsys.LinSys[nDims1, nDims2,...] - an array of linear
            systems.

Output:
  isLtiMat: logical[nDims1, nDims2,...] -array such that it's element at
      each position is true if corresponding linear system is
      time-invariant, and false otherwise.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
  isLtiArr = sys.isLti();
  dsys = elltool.linsys.LinSysDiscrete(aMat, bMat, SUBounds);
  isLtiArr = dsys.isLti();</pre>
</div>
</div>
<div class="section" id="elltool-linsys-linsyscontinuous">
<h2>elltool.linsys.LinSysContinuous<a class="headerlink" href="#elltool-linsys-linsyscontinuous" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>LINSYSCONTINUOUS - Constructor of continuous linear system object.

Continuous-time linear system:
          dx/dt  =  A(t) x(t)  +  B(t) u(t)  +  C(t) v(t)

Input:
  regular:
      atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

      btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.

  optional:
      uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
            ellipsoid.

      ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

      distBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance
            bounds ellipsoid.

      discrFlag: char[1, 1] - if discrFlag set:
             'd' - to discrete-time linSys,
             not 'd' - to continuous-time linSys.


Output:
  self: elltool.linsys.LinSysContinuous[1, 1] - continuous linear
            system.

Example:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:elltool.linsys.ALinSys] for elltool.linsys.ALinSys:</p>
</div>
<div class="section" id="elltool-linsys-linsysdiscrete">
<h2>elltool.linsys.LinSysDiscrete<a class="headerlink" href="#elltool-linsys-linsysdiscrete" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>LINSYSDISCRETE - constructor of discrete linear system object.

Discrete-time linear system:
          x[k+1]  =  A[k] x[k]  +  B[k] u[k]  +  C[k] v[k]

Input:
  regular:
      atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

      btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.
  optional:
      uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
          ellipsoid.

      ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

      distBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds
          ellipsoid.

      discrFlag: char[1, 1] - if discrFlag set:
           'd' - to discrete-time linSys
           not 'd' - to continuous-time linSys.

Output:
  self: elltool.linsys.LinSysDiscrete[1, 1] - discrete linear system.

Example:
  for k = 1:20
     atMat = {'0' '1 + cos(pi*k/2)'; '-2' '0'};
     btMat =  [0; 1];
     uBoundsEllObj = ellipsoid(4);
     ctMat = [1; 0];
     distBounds = 1/(k+1);
     lsys = elltool.linsys.LinSysDiscrete(atMat, btMat,...
         uBoundsEllObj, ctMat,distBounds);
  end</pre>
</div>
<p>See the description of the following methods in section
[secClassDescr:elltool.linsys.ALinSys] for elltool.linsys.ALinSys:</p>
</div>
<div class="section" id="elltool-linsys-linsysfactory">
<h2>elltool.linsys.LinSysFactory<a class="headerlink" href="#elltool-linsys-linsysfactory" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><pre>Factory class of linear system objects of the Ellipsoidal Toolbox.</pre>
</div>
<div class="highlight-python"><pre>CREATE - returns linear system object.

Continuous-time linear system:
          dx/dt  =  A(t) x(t)  +  B(t) u(t)  +  C(t) v(t)

Discrete-time linear system:
          x[k+1]  =  A[k] x[k]  +  B[k] u[k]  +  C[k] v[k]

Input:
  regular:
      atInpMat: double[nDim, nDim]/cell[nDim, nDim] - matrix A.

      btInpMat: double[nDim, kDim]/cell[nDim, kDim] - matrix B.

      uBoundsEll: ellipsoid[1, 1]/struct[1, 1] - control bounds
          ellipsoid.

      ctInpMat: double[nDim, lDim]/cell[nDim, lDim] - matrix G.

      distBoundsEll: ellipsoid[1, 1]/struct[1, 1] - disturbance bounds
          ellipsoid.

      discrFlag: char[1, 1] - if discrFlag set:
          'd' - to discrete-time linSys
          not 'd' - to continuous-time linSys.

Output:
  linSys: elltool.linsys.LinSysContinuous[1, 1]/
      elltool.linsys.LinSysDiscrete[1, 1] - linear system.

Examples:
  aMat = [0 1; 0 0]; bMat = eye(2);
  SUBounds = struct();
  SUBounds.center = {'sin(t)'; 'cos(t)'};
  SUBounds.shape = [9 0; 0 2];
  sys = elltool.linsys.LinSysFactory.create(aMat, bMat,SUBounds);</pre>
</div>
<div class="references"><p>“$d/dt$ Homepage.” www-verimag.imag.fr/\~tdang/ddt.html.</p>
<p>“CDD/CDD+ Homepage.” www.cs.mcgill.ca/\~fukuda/soft/cdd_home/cdd.html.</p>
<p>“CheckMate Homepage.” www.ece.cmu.edu/\~webk/checkmate.</p>
<p>“CVX Homepage.” cvxr.com/cvx.</p>
<p>“Geometric Bounding Toolbox Homepage.” www.sysbrain.com/gbt.</p>
<p>“Level Set Toolbox Homepage.” www.cs.ubc.ca/\~mitchell/ToolboxLS.</p>
<p>“MATISSE Homepage.” www.seas.upenn.edu/ãgirard/Software/MATISSE.</p>
<p>“Multi-Parametric Toolbox Homepage.” control.ee.ethz.ch/\~mpt.</p>
<p>“Requiem Homepage.” www.seas.upenn.edu/\~hybrid/requiem/requiem.html.</p>
<p>“SDPT3 Homepage.” <a class="reference external" href="http://www.math.nus.edu.sg/">http://www.math.nus.edu.sg/</a>\~mattohkc/sdpt3.html.</p>
<p>“SeDuMi Homepage.” sedumi.mcmaster.ca.</p>
<p>“Stanley Chan Article Homepage.”
<a class="reference external" href="http://videoprocessing.ucsd.edu/~stanleychan/publication/unpublished/Ellipse.pdf">http://videoprocessing.ucsd.edu/~stanleychan/publication/unpublished/Ellipse.pdf</a>.</p>
<p>“Zonotope Methods on Wolfgang Kühn Homepage.” www.decatur.de.</p>
<p>A. A. Kurzhanskiy, P. Varaiya. 2007. “Ellipsoidal Techniques for
Reachability Analysis of Discrete-time Linear Systems.” <em>IEEE
Transactions on Automatic Control</em> 52 (1): 26–38.</p>
<p>A.B.Kurzhanski, and P.Varaiya. 2001. “Reachability Analysis for
Uncertain Systems - the Ellipsoidal Technique.” <em>Dynamics of Continuous,
Discrete and Impulsive Systems Series B: Applications and Algorithms</em> 9:
347–367.</p>
<p>A.Girard, C.Le Guernic, and O.Maler. 2006. “Computation of Reachable
Sets of Linear Time-invariant Systems with Inputs.” In <em>Hybrid Systems:
Computation and Control</em>, edited by J.Hespanha and A.Tiwari,
3927:257–271. Springer.</p>
<p>Avis, D., D. Bremner, and R. Seidel. 1997. “How Good Are Convex Hull
Algorithms?” <em>Computational Geometry: Theory and Applications</em> 7:
265–301.</p>
<p>Boyd, S., and L. Vandenberghe. 2004. <em>Convex Optimization</em>. Cambridge
University Press.</p>
<p>Dariyn, A. N., and A. B. Kurzhanski. 2012. “Method of Invariant Sets for
Linear Systems of High Dimensionality Under Uncertain Disturbances.”
<em>Doklady Akademii Nauk</em> 446 (6): 607–611.</p>
<p>E.Asarin, O.Bournez, T.Dang, and O.Maler. 2000. “Approximate
Reachability Analysis of Piecewise Linear Dynamical Systems.” In <em>Hybrid
Systems: Computation and Control</em>, edited by N.Lynch and B.H.Krogh,
1790:482–497. Springer.</p>
<p>Gantmacher, F. R. 1960. <em>Matrix Theory, I-II</em>. Chelsea.</p>
<p>Girard, A. 2005. “Reachability of Uncertain Linear Systems Using
Zonotopes.” In <em>Hybrid Systems: Computation and Control</em>, edited by M.
Morari, L. Thiele, and F. Rossi, 3414:291–305. Springer.</p>
<p>Kostousova, E. K. 2001. “Control Synthesis via Parallelotopes:
Optimization and Parallel Computations.” <em>Optimization Methods and
Software</em> 14 (4): 267–310.</p>
<p>Kurzhanski, A. B., and P. Varaiya. 2000. “On Ellipsoidal Techniques for
Reachability Analysis.” <em>Optimization Methods and Software</em> 17: 177–237.</p>
<p>Kurzhanski, A. B., and I. Vályi. 1997. <em>Ellipsoidal Calculus for
Estimation and Control</em>. <em>Ser. SCFA</em>. Birkhäuser.</p>
<p>Kvasnica, M., P. Grieder, M. Baotić, and M. Morari. 2004.
“Multi-Parametric Toolbox (MPT).” In <em>Hybrid Systems: Computation and
Control</em>, edited by R. Alur and G. J. Pappas, 2993:448–462. Springer.</p>
<p>L. Ros, A. Sabater, F. Thomas. 2002. “An Ellipsoidal Calculus Based on
Propagation and Fusion.” <em>IEEE Transactions on Systems, Man and
Cybernetics, Part B: Cybernetics</em> 32 (4).</p>
<p>L.Muñoz, X.Sun, R.Horowitz, and L.Alvarez. 2003. “Traffic Density
Estimation with the Cell Transmission Model.” In <em>Proceedings of the
American Control Conference</em>, 3750–3755. Denver, Colorado, USA.</p>
<p>Lafferriere, G., G. J. Pappas, and S. Yovine. 2001. “Symbolic
Reachability Computation for Families of Linear Vector Fields.” <em>Journal
of Symbolic Computation</em> 32: 231–253.</p>
<p>Lin, A., and S. Han. 2002. “On the Distance Between Two Ellipsoids.”
<em>SIAM Journal on Optimization</em> 13 (1): 298–308.</p>
<p>Mitchell, I., and C. Tomlin. 2000. “Level Set Methods for Computation in
Hybrid Systems.” In <em>Hybrid Systems: Computation and Control</em>, edited by
N. Lynch and B. H. Krogh, 1790:21–31. Springer.</p>
<p>Motzkin, T. S., H. Raiffa, G. L. Thompson, and R. M. Thrall. 1953. “The
Double Description Method.” In <em>Conttributions to Theory of Games</em>,
edited by H. W. Kuhn and A. W. Tucker. Vol. 2. Princeton University
Press.</p>
<p>Sturm, J. F. 1999. “Using SeDuMi 1.02, A MATLAB Toolbox for Optimization
over Symmetric Cones.” <em>Optimization Methods and Software</em> 11-12:
625–653.</p>
<p>Stursberg, O., and B. H. Krogh. 2003. “Efficient Representation and
Computation of Reachable Sets for Hybrid Systems.” In <em>Hybrid Systems:
Computation and Control</em>, edited by O. Maler and A. Pnueli,
2623:482–497. Springer.</p>
<p>Varaiya, P. 1998. “Reach Set Computation Using Optimal Control.” Proc.
of KIT Workshop on Verification on Hybrid Systems. Verimag, Grenoble.</p>
<p>Vazhentsev, A. Yu. 1999. “On Internal Ellipsoidal Approximations for
Problems of Control and Synthesis with Bounded Coordinates.” <em>Izvestiya
Rossiiskoi Akademii Nauk. Teoriya I Systemi Upravleniya.</em></p>
<p>Veres, S. M., A. V. Kuntsevich, I. V. Vályi, S. Hermsmeyer, and D. S.
Wall. 2001. “Geometric Bounding Toolbox for MATLAB.” <em>MATLAB/Simulink
Connections Catalogue</em>.</p>
</div><table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>In discrete-time case <span class="math">t</span> assumes integer values.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>We are being general when giving the basic definitions. However, it
is important to understand that for any specific <em>continuous-time</em>
dynamical system it must be determined whether the solution exists
and is unique, and in which class of solutions these conditions are
met. Here we shall assume that function <span class="math">f</span> is such that the
solution of the differential equation ([ctds1]) exists and is unique
in Fillipov sense. This allows the right-hand side to be
discontinuous. For discrete-time systems this problem does not exist.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Minkowski sum of sets
<span class="math">{\mathcal W}, {\mathcal Z}\subseteq {\bf R}^n</span> is defined as
<span class="math">{\mathcal W}\oplus {\mathcal Z}= \{w+z ~|~ w\in{\mathcal W}, ~ z\in{\mathcal Z}\}</span>.
Set <span class="math">{\mathcal W}\oplus{\mathcal Z}</span> is nonempty if and only if
both, <span class="math">{\mathcal W}</span> and <span class="math">{\mathcal Z}</span> are nonempty. If
<span class="math">{\mathcal W}</span> and <span class="math">{\mathcal Z}</span> are convex, set
<span class="math">{\mathcal W}\oplus{\mathcal Z}</span> is convex.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><span class="math">{\mathcal M}</span> is weakly invariant with respect to the target
set <span class="math">{\mathcal Y}_1</span> and times <span class="math">t_0</span> and <span class="math">t</span>, if
for every state <span class="math">x_0\in{\mathcal M}</span> there exists a control
<span class="math">u(\tau, x(\tau))\in{\mathcal U}(\tau)</span>,
<span class="math">t_0\leqslant\tau< t</span>, that steers the system from <span class="math">x_0</span>
at time <span class="math">t_0</span> to some state in <span class="math">{\mathcal Y}_1</span> at time
<span class="math">t</span>. If <em>all</em> controls in <span class="math">{\mathcal U}(\tau)</span>,
<span class="math">t_0\leqslant\tau<t</span> steer the system from every
<span class="math">x_0\in{\mathcal M}</span> at time <span class="math">t_0</span> to
<span class="math">{\mathcal Y}_1</span> at time <span class="math">t</span>, set <span class="math">{\mathcal M}</span> is
said to be <em>strongly</em> invariant with respect to
<span class="math">{\mathcal Y}_1</span>, <span class="math">t_0</span> and <span class="math">t</span>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>There exists <span class="math">f^{-1}(t,x,u)</span> such that
<span class="math">x(t)=f^{-1}(t, x(t+1), u, v)</span>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><p class="first">Hausdorff semidistance between compact sets
<span class="math">{\mathcal W}, {\mathcal Z}\subseteq {\bf R}^n</span> is defined as</p>
<div class="last math">
\[  {\bf dist}({\mathcal W}, {\mathcal Z}) = \min\{\langle w-z, w-z\rangle^{1/2}
  ~|~ w\in{\mathcal W}, \; z\in{\mathcal Z}\},\]\[where :math:`\langle\cdot, \cdot\rangle` denotes inner product.\]</div>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>The Minkowski difference of sets
<span class="math">{\mathcal W}, {\mathcal Z}\in{\bf R}^n</span> is defined as
<span class="math">{\mathcal W}\dot{-}{\mathcal Z}= \left\{\xi\in{\bf R}^n ~|~
\xi \oplus {\mathcal Z}\subseteq {\mathcal W}\right\}</span>. If
<span class="math">{\mathcal W}</span> and <span class="math">{\mathcal Z}</span> are convex,
<span class="math">{\mathcal W}\dot{-}{\mathcal Z}</span> is convex if it is nonempty.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>So-called verification problems often consist in ensuring that the
system is unable to reach an ‘unsafe’ target set within a given time
interval.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td><p class="first">The case when <span class="math">A(t)</span> is singular is described in A. A.
Kurzhanskiy (2007). The idea is to substitute <span class="math">A(t)</span> with the
nonsingular <span class="math">A_\delta(t) = A(t) + \delta U(t)W(t)</span>, in which
<span class="math">U(t)</span> and <span class="math">W(t)</span> are obtained from the singular value
decomposition</p>
<div class="math">
\[A(t) = U(t)\Sigma(t)V(t) .\]\[The parameter :math:`\delta` can be chosen based on the number of\]</div>
<p class="last">time steps for which the reach set must be computed and the required
accuracy. The issue of inverting ill-conditioned matrices is also
addressed in A. A. Kurzhanskiy (2007).</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[10]</a></td><td>Note that for ([adjointdt]) <span class="math">A(t)</span> must be invertible.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="main_manual.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction</a></li>
<li><a class="reference internal" href="#ellipsoidal-calculus">Ellipsoidal Calculus</a><ul>
<li><a class="reference internal" href="#basic-notions">Basic Notions</a></li>
<li><a class="reference internal" href="#operations-with-ellipsoids">Operations with Ellipsoids</a><ul>
<li><a class="reference internal" href="#affine-transformation">Affine Transformation</a></li>
<li><a class="reference internal" href="#geometric-sum">Geometric Sum</a></li>
<li><a class="reference internal" href="#geometric-difference">Geometric Difference</a></li>
<li><a class="reference internal" href="#geometric-difference-sum">Geometric Difference-Sum</a></li>
<li><a class="reference internal" href="#geometric-sum-difference">Geometric Sum-Difference</a></li>
<li><a class="reference internal" href="#intersection-of-ellipsoid-and-hyperplane">Intersection of Ellipsoid and Hyperplane</a></li>
<li><a class="reference internal" href="#intersection-of-ellipsoid-and-ellipsoid">Intersection of Ellipsoid and Ellipsoid</a></li>
<li><a class="reference internal" href="#intersection-of-ellipsoid-and-halfspace">Intersection of Ellipsoid and Halfspace</a></li>
<li><a class="reference internal" href="#checking-if">Checking if</a></li>
<li><a class="reference internal" href="#minimum-volume-ellipsoids">Minimum Volume Ellipsoids</a></li>
<li><a class="reference internal" href="#maximum-volume-ellipsoids">Maximum Volume Ellipsoids</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reachability">Reachability</a><ul>
<li><a class="reference internal" href="#basics-of-reachability-analysis">Basics of Reachability Analysis</a><ul>
<li><a class="reference internal" href="#systems-without-disturbances">Systems without disturbances</a></li>
<li><a class="reference internal" href="#systems-with-disturbances">Systems with disturbances</a></li>
<li><a class="reference internal" href="#reachability-problem">Reachability problem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ellipsoidal-method">Ellipsoidal Method</a><ul>
<li><a class="reference internal" href="#continuous-time-systems">Continuous-time systems</a></li>
<li><a class="reference internal" href="#discrete-time-systems">Discrete-time systems</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#additional-software">Additional Software</a><ul>
<li><a class="reference internal" href="#cvx">CVX</a></li>
<li><a class="reference internal" href="#mpt">MPT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installation-and-quick-start">Installation and Quick Start</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation">Implementation</a><ul>
<li><a class="reference internal" href="#id11">Operations with ellipsoids</a></li>
<li><a class="reference internal" href="#operations-with-hyperplanes">Operations with hyperplanes</a></li>
<li><a class="reference internal" href="#operations-with-ellipsoidal-tubes">Operations with ellipsoidal tubes</a></li>
<li><a class="reference internal" href="#id12">Reachability</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#ellipsoids-vs-polytopes">Ellipsoids vs. Polytopes</a></li>
<li><a class="reference internal" href="#system-with-disturbance">System with Disturbance</a></li>
<li><a class="reference internal" href="#switched-system">Switched System</a></li>
<li><a class="reference internal" href="#hybrid-system">Hybrid System</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary-and-outlook">Summary and Outlook</a></li>
<li><a class="reference internal" href="#acknowledgement">Acknowledgement</a></li>
<li><a class="reference internal" href="#function-reference">Function Reference</a><ul>
<li><a class="reference internal" href="#ellipsoid">ellipsoid</a></li>
<li><a class="reference internal" href="#hyperplane">hyperplane</a></li>
<li><a class="reference internal" href="#elltool-conf-properties">elltool.conf.Properties</a></li>
<li><a class="reference internal" href="#elltool-core-genellipsoid">elltool.core.GenEllipsoid</a></li>
<li><a class="reference internal" href="#smartdb-relations-atypifiedstaticrelation">smartdb.relations.ATypifiedStaticRelation</a></li>
<li><a class="reference internal" href="#gras-ellapx-smartdb-rels-elltube">gras.ellapx.smartdb.rels.EllTube</a></li>
<li><a class="reference internal" href="#gras-ellapx-smartdb-rels-elltubeproj">gras.ellapx.smartdb.rels.EllTubeProj</a></li>
<li><a class="reference internal" href="#gras-ellapx-smartdb-rels-elluniontube">gras.ellapx.smartdb.rels.EllUnionTube</a></li>
<li><a class="reference internal" href="#gras-ellapx-smartdb-rels-elluniontubestaticproj">gras.ellapx.smartdb.rels.EllUnionTubeStaticProj</a></li>
<li><a class="reference internal" href="#elltool-reach-areach">elltool.reach.AReach</a></li>
<li><a class="reference internal" href="#elltool-reach-reachcontinuous">elltool.reach.ReachContinuous</a></li>
<li><a class="reference internal" href="#elltool-reach-reachdiscrete">elltool.reach.ReachDiscrete</a></li>
<li><a class="reference internal" href="#elltool-reach-reachfactory">elltool.reach.ReachFactory</a></li>
<li><a class="reference internal" href="#elltool-linsys-alinsys">elltool.linsys.ALinSys</a></li>
<li><a class="reference internal" href="#elltool-linsys-linsyscontinuous">elltool.linsys.LinSysContinuous</a></li>
<li><a class="reference internal" href="#elltool-linsys-linsysdiscrete">elltool.linsys.LinSysDiscrete</a></li>
<li><a class="reference internal" href="#elltool-linsys-linsysfactory">elltool.linsys.LinSysFactory</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/result.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="main_manual.html">elltool_manual 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Lukashevichus K..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b2.
    </div>
  </body>
</html>