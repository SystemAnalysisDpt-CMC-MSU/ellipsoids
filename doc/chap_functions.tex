\section{smartdb.cubes.CubeStruct}\label{secClassDescr:smartdb.cubes.CubeStruct}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.CubeStruct}{CubeStruct}}\label{method:smartdb.cubes.CubeStruct.CubeStruct}
\begin{verbatim}
CUBESTRUCT - constructor for CubeStruct class

Input:
  Case1 (copy constructor):
      regular:
         cubeObj: CubeStruct: [1,1]

  Case2 (building from structures):
      regular:
          SData: struct[1,1]
      optional:

          SIsNull: struct[1,1]
          SIsValueNull: struct[1,1]

      properties:
          SubCase1:
              fieldMetaData: CubeStructFieldInfo[1,nFields] - an
                  array of field meta data objects,
          SubCase2:

              fieldNameList: char cell [1,nFields] - list of
                  names for fields of given object

              fieldDescrList: char cell [1,nFields] - list of
                  descriptions for fields of given object

              fieldTypeSpecList: cell[1,nFields] of cell of
                  char - field type specification

          minDimensionality: numeric[1,1] - minimum
              dimensionality of CubeStruct field values.
              Use minDimensionality=1 for relations and
              minDimensionality=# of keys for cubes

          checkConsistency: logical[1,1] - determines if
              consistency of input data structures is checked

          structNameList: cell[] of char - determines which
              structures are specified on input

          checkstruct: logical[1,1] - determines if presence of
              all relation fields in the input structures is checked

Output:
  self: CubeStruct[1,1] - created object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.applyGetFunc}{applyGetFunc}}\label{method:smartdb.cubes.CubeStruct.applyGetFunc}
\begin{verbatim}
APPLYGETFUNC - applies a function to the specified fields as columns, i.e.
               the function is applied to each field as whole, not to
               each cell separately

Input:
  regular:
      hFunc: function_handle[1,1] - function to apply to each of the
         field values
  optional:
      toFieldNameList: char/cell[1,] of char - a list of fields to which
         the function specified by hFunc is to be applied

    Note: hFunc can optionally be specified after toFieldNameList
          parameter

Notes: this function currently has a lots of limitations:
  1) it assumes that the output is uniform
  2) the function is applies to SData part of field value
  3) no additional arguments can be passed
  All this limitations will eventually go away though so stay tuned...
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.applySetFunc}{applySetFunc}}\label{method:smartdb.cubes.CubeStruct.applySetFunc}
\begin{verbatim}
APPLYSETFUNC - applies some function to each cell of the specified fields
               of a given CubeStruct object

Usage: applySetFunc(self,toFieldNameList,hFunc)
       applySetFunc(self,hFunc,toFieldNameList)

Input:
  regular:
      self: CubeStruct [1,1] - class object

      hFunc: function handle [1,1] - handle of function to be
        applied to fields, the function is assumed to
          1) have the same number of input/output arguments
          2) the number of input arguments should be
             length(structNameList)*length(fieldNameList)
          3) the input arguments should be ordered according to the
          following rule
              (x_struct_1_field_1,x_struct_1_field_2,...,struct_n_field1,
              ...,struct_n_field_m)

  optional:

      toFieldNameList: char or char cell [1,nFields] - list of
        field names to which given function should be applied

        Note1: field lists of length>1 are not currently supported !
        Note2: it is possible to specify toFieldNameList before hFunc in
           which case the parameters will be recognized automatically

  properties:
      uniformOutput: logical[1,1] - specifies if the result
         of the function is uniform to be stored in non-cell
         field, by default it is false for cell fileds and
         true for non-cell fields

      structNameList: char[1,]/cell[1,], name of data structure/list of
        data structure names to which the function is to
             be applied, can be composed from the following values

           SData - data itself

           SIsNull - contains is-null indicator information for data
             values

           SIsValueNull - contains is-null indicators for CubeStruct
              cells (not for cell values)

        structNameList={'SData'} by default

      inferIsNull: logical[1,2] - if the first(second) element is true,
          SIsNull(SIsValueNull) indicators are inferred from SData,
          i.e. with this indicator set to true it is sufficient to apply
          the function only to SData while the rest of the structures
          will be adjusted automatically.

      inputType: char[1,] - specifies a way in which the field value is
         partitioned into individual cells before being passed as an
         input parameter to hFunc. This parameter directly corresponds to
         outputType parameter of toArray method, see its documentation
         for a list of supported input types.
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.applyTupleGetFunc}{applyTupleGetFunc}}\label{method:smartdb.cubes.CubeStruct.applyTupleGetFunc}
\begin{verbatim}
APPLYTUPLEGETFUNC - applies a function to the specified fields
                    separately to each tuple

Input:
  regular:
      hFunc: function_handle[1,1] - function to apply to the specified
         fields
  optional:
      toFieldNameList: char/cell[1,] of char - a list of fields to which
         the function specified by hFunc is to be applied

  properties:
      uniformOutput: logical[1,1] - if true, output is expected to be
          uniform as in cellfun with 'UniformOutput'=true, default
           value is true

Output:
  funcOut1Arr: <type1>[] - array corresponding to the first output of the
      applied function
          ....
  funcOutNArr: <typeN>[] - array corresponding to the last output of the
      applied function


Notes: this function currently has a lots of limitations:
  1) the function is applies to SData part of field value
  2) no additional arguments can be passed
  All this limitations will eventually go away though so stay tuned...
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.clone}{clone}}\label{method:smartdb.cubes.CubeStruct.clone}
\begin{verbatim}
CLONE - creates a copy of a specified object via calling
        a copy constructor for the object class

Input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.copyFrom}{copyFrom}}\label{method:smartdb.cubes.CubeStruct.copyFrom}
\begin{verbatim}
COPYFROM - reconstruct CubeStruct object within a current object using the
           input CubeStruct object as a prototype

Input:
  regular:
    self: CubeStruct [n_1,...,n_k]
    obj: any [] - internal representation of the object

  optional:
    fieldNameList: cell[1,nFields] - list of fields to copy
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.createInstance}{createInstance}}\label{method:smartdb.cubes.CubeStruct.createInstance}
\begin{verbatim}
CREATEINSTANCE - returns an object of the same class by calling a default
                 constructor (with no parameters)

Usage: resObj=getInstance(self)

input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.display}{display}}\label{method:smartdb.cubes.CubeStruct.display}
\begin{verbatim}
DISPLAY - puts some textual information about CubeStruct object in screen

Input:
 regular:
     self.
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.fromStructList}{fromStructList}}\label{method:smartdb.cubes.CubeStruct.fromStructList}
\begin{verbatim}
FROMSTRUCTLIST creates an object of specified type
from a list of structures interpreting each structure
as the data for several CubeStruct data slices

Input:
  regular:
      catDim: double[1,1] - dimension along which the input structures
         are to be concatenated
      className: name of object class which will be created,
          the class constructor should accept 2 properties:
          'fieldNameList' and 'fieldTypeSpecList'
      structList: cell[] of struct[1,1] - list of structures

Output:
  relDataObj: className[1,1] -  constructed object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getCopy}{getCopy}}\label{method:smartdb.cubes.CubeStruct.getCopy}
\begin{verbatim}
GETCOPY - returns an object copy

Usage: resObj=getCopy(self)

Input:
  regular:
    self: CubeStruct [1,1] - current CubeStruct object
  optional:
    same as for getData
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getData}{getData}}\label{method:smartdb.cubes.CubeStruct.getData}
\begin{verbatim}
GETDATA - returns an indexed projection of CubeStruct object's content

Input:
  regular:
      self: CubeStruct [1,1] - the object

  optional:

      subIndCVec:
        Case#1: numeric[1,]/numeric[,1]

        Case#2: cell[1,nDims]/cell[nDims,1] of double [nSubElem_i,1]
              for i=1,...,nDims

          -array of indices of field value slices that are selected
          to be returned; if not given (default),
          no indexation is performed

        Note!: numeric components of subIndVec are allowed to contain
           zeros which are be treated as they were references to null
           data slices

      dimVec: numeric[1,nDims]/numeric[nDims,1] - vector of dimension
          numbers corresponding to subIndCVec

  properties:

      fieldNameList: char[1,]/cell[1,nFields] of char[1,]
          list of field names to return

      structNameList: char[1,]/cell[1,nStructs] of char[1,]
          list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}

      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the cells,
              default value is false

      nullReplacements: cell[1,nReplacedFields]  - list of null
          replacements for each of the fields

      nullReplacementFields: cell[1,nReplacedFields] - list of fields in
         which the nulls are to be replaced with the specified values,
         if not specified it is assumed that all fields are to be
         replaced

         NOTE!: all fields not listed in this parameter are replaced with
         the default values

      checkInputs: logical[1,1] - true by default (input arguments are
         checked for correctness

Output:
  regular:
    SData: struct [1,1] - structure containing values of
        fields at the selected slices, each field is an array
        containing values of the corresponding type

    SIsNull: struct [1,1] - structure containing a nested
        array with is-null indicators for each CubeStruct cell content

    SIsValueNull: struct [1,1] - structure containing a
       logical array [] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldDescrList}{getFieldDescrList}}\label{method:smartdb.cubes.CubeStruct.getFieldDescrList}
\begin{verbatim}
GETFIELDDESCRLIST - returns the list of CubeStruct field descriptions

Usage: value=getFieldDescrList(self)

Input:
  regular:
      self: CubeStruct [1,1]
  optional:
      fieldNameList: cell[1,nSpecFields] of char[1,] - field names for
         which descriptions should be returned

Output:
  regular:
    value: char cell [1,nFields] - list of CubeStruct object field
        descriptions
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldIsNull}{getFieldIsNull}}\label{method:smartdb.cubes.CubeStruct.getFieldIsNull}
\begin{verbatim}
GETFIELDISNULL - returns for given field a nested logical/cell array
                 containing is-null indicators for cell content

Usage: fieldIsNullCVec=getFieldIsNull(self,fieldName)

Input:
  regular:
    self: CubeStruct [1,1]
    fieldName: char - field name
Output:
  regular:
    fieldIsCVec: logical/cell[] - nested cell/logical array containing
       is-null indicators for content of the field
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldIsValueNull}{getFieldIsValueNull}}\label{method:smartdb.cubes.CubeStruct.getFieldIsValueNull}
\begin{verbatim}
GETFIELDISVALUENULL - returns for given field logical vector determining
                      whether value of this field in each cell is null
                      or not.

BEWARE OF confusing this with getFieldIsNull method which returns is-null
   indicators for a field content

Usage: isNullVec=getFieldValueIsNull(self,fieldName)

Input:
  regular:
    self: CubeStruct [1,1]
    fieldName: char - field name

Output:
  regular:
    isValueNullVec: logical[] - array of isValueNull indicators for the
       specified field
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldNameList}{getFieldNameList}}\label{method:smartdb.cubes.CubeStruct.getFieldNameList}
\begin{verbatim}
GETFIELDNAMELIST - returns the list of CubeStruct object field names

Usage: value=getFieldNameList(self)

Input:
  regular:
    self: CubeStruct [1,1]
Iutput:
  regular:
    value: char cell [1,nFields] - list of CubeStruct object field
        names
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldProjection}{getFieldProjection}}\label{method:smartdb.cubes.CubeStruct.getFieldProjection}
\begin{verbatim}
GETFIELDPROJECTION - create object with specified fields using existing
                     table

Input:
  regular:
      self: CubeStruct[1,1] - original object
      fieldNameList: cell[1,nFields] of char[1,] - field name list

Output:
  obj: DynamicCubeStruct[1,1] - projected object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldTypeList}{getFieldTypeList}}\label{method:smartdb.cubes.CubeStruct.getFieldTypeList}
\begin{verbatim}
GETFIELDTYPELIST - returns list of field types in given CubeStruct object

Usage: fieldTypeList=getFieldTypeList(self)

Input:
  regular:
      self: CubeStruct [1,1]

  optional:
      fieldNameList: cell[1,nFields] - list of field names

Output:
 regular:
  fieldTypeList: cell [1,nFields] of smartdb.cubes.ACubeStructFieldType[1,1]
      - list of field types
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldTypeSpecList}{getFieldTypeSpecList}}\label{method:smartdb.cubes.CubeStruct.getFieldTypeSpecList}
\begin{verbatim}
GETFIELDTYPESPECLIST - returns a list of field type specifications. Field
                       type specification is a sequence of type names
                       corresponding to field value types starting with
                       the top level and going down into the nested
                       content of a field (for a field having a complex
                       type).

Input:
  regular:
      self:
  optional:
      fieldNameList: cell [1,nFields] of char[1,] - list of field names
  properties:
      uniformOutput: logical[1,1] - if true, the result is concatenated
         across all the specified fields

Output:
  typeSpecList:
       Case#1: uniformOutput=false
          cell[1,nFields] of cell[1,nNestedLevels_i] of char[1,.]
       Case#2: uniformOutput=true
          cell[1,nFields*prod(nNestedLevelsVec)] of char[1,.]
       - list of field type specifications
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getFieldValueSizeMat}{getFieldValueSizeMat}}\label{method:smartdb.cubes.CubeStruct.getFieldValueSizeMat}
\begin{verbatim}
GETFIELDVALUESIZEMAT - returns a matrix composed from the size vectors
                       for the specified fields

Input:
  regular:
      self:

  optional:
      fieldNameList: cell[1,nFields] - a list of fileds for which the size
         matrix is to be generated

  properties:
      skipMinDimensions: logical[1,1] - if true, the dimensions from 1 up
          to minDimensionality are skipped

      minDimension: numeric[1,1] - minimum dimension which definies a
         minimum number of columns in the resulting matrix

Output:
  sizeMat: double[nFields,nMaxDims]
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getIsFieldValueNull}{getIsFieldValueNull}}\label{method:smartdb.cubes.CubeStruct.getIsFieldValueNull}
\begin{verbatim}
GETISFIELDVALUENULL - returns a vector indicating whether a particular
                      field is composed of null values completely

Usage: isValueNullVec=getIsFieldValueNull(self,fieldNameList)

Input:
  regular:
    self: CubeStruct [1,1]

  optional:
    fieldNameList: cell[1,nFields] of char[1,] - list of field names

Output:
  regular:
    isValueNullVec: logical[1,nFields]
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getMinDimensionSize}{getMinDimensionSize}}\label{method:smartdb.cubes.CubeStruct.getMinDimensionSize}
\begin{verbatim}
GETMINDIMENSIONSIZE - returns a size vector for the specified
                      dimensions. If no dimensions are specified, a size
                      vector for all dimensions up to minimum CubeStruct
                      dimension is returned

Input:
  regular:
      self:
  optional:
      dimNumVec: numeric[1,nDims] - a vector of dimension
          numbers

Output:
  minDimensionSizeVec: double [1,nDims] - a size vector for
     the requested dimensions
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getMinDimensionality}{getMinDimensionality}}\label{method:smartdb.cubes.CubeStruct.getMinDimensionality}
\begin{verbatim}
GETMINDIMENSIONALITY - returns a minimum dimensionality for a given
                       object

Input:
  regular:
      self

Output:
  minDimensionality: double[1,1] - minimum dimensionality of
     self object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getNElems}{getNElems}}\label{method:smartdb.cubes.CubeStruct.getNElems}
\begin{verbatim}
GETNELEMS - returns a number of elements in a given object
Input:
  regular:
     self:

Output:
  nElems:double[1, 1] - number of elements in a given object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.getNFields}{getNFields}}\label{method:smartdb.cubes.CubeStruct.getNFields}
\begin{verbatim}
GETNFIELDS - returns number of fields in given object

Usage: nFields=getNFields(self)

Input:
  regular:
    self: CubeStruct [1,1]
Output:
  regular:
    nFields: double [1,1] - number of fields in given object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.initByEmptyDataSet}{initByEmptyDataSet}}\label{method:smartdb.cubes.CubeStruct.initByEmptyDataSet}
\begin{verbatim}
INITBYEMPTYDATASET - initializes cube struct object with null value arrays
                     of specified size based on minDimVec specified.

For instance, if minDimVec=[2,3,4,5,6] and minDimensionality of cube
struct object cb is 2, then cb.initByEmptyDataSet(minDimVec) will create
a cube struct object with element array of [2,3] size where each element
has size of [4,5,6,0]

Input:
  regular:
      self:
  optional
      minDimVec: double[1,nDims] - size vector of null value arrays
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.initByNullDataSet}{initByNullDataSet}}\label{method:smartdb.cubes.CubeStruct.initByNullDataSet}
\begin{verbatim}
INITBYDEFAULTDATASET - initializes cube struct object with null value
                       arrays of specified size based on minDimVec
                       specified.

For instance, if minDimVec=[2,3,4,5,6] and minDimensionality of cube
struct object cb is 2, then cb.initByEmptyDataSet(minDimVec) will create
a cube struct object with element array of [2,3] size where each element
has size of [4,5,6]

Input:
  regular:
      self:
  optional
      minDimVec: double[1,nDims] - size vector of null value arrays
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.isEqual}{isEqual}}\label{method:smartdb.cubes.CubeStruct.isEqual}
\begin{verbatim}
ISEQUAL compares the specified CubeStruct object with other CubeStruct
object and returns true if they are equal, otherwise it
returns false

Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: CubeStruct [1,1]
    otherObj: CubeStruct [1,1] - the other object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] -
        if true, then fields in compared objects must
        be in the same order, otherwise the order is not
        important (false by default)

    sortDim: numeric[1,1] - dimension along which the CubeStruct slices
       order is considered irrelevant with regard to equality

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

    compareMetaDataParamList: cell[1,nParam] - list of additional
       parameters passed to isEqual method of CubeStruct from isEqual method
       of CubeStructFieldInfo. This list is used particularly to
       elimitate an infinite loop when comparing the reverse
       references from CubeStructFieldInfo to CubeStruct

    maxTolerance: double [1,1] - maximum allowed tolerance

    leftIndCVec: cell[1,nLeftIndDims] - list of indices to be applied to
      the dimensions of left-hand side CubeStruct object

    leftDimVec: numeric[1,nLeftIndDims] - vector of index dimensions for
       which leftIndCVec is specified

    rightIndCVec: cell[1,nRightIndDims] - same as leftIndCVec but for the
       right-hand side CubeStruct object

    rightDimVec: numeric[1,nRightIndDims] - same as leftDimVec but for
    the right-hand side CubeStruct object

      Note: sortDim property cannot be specified along with
          any of leftIndCVec, leftDimVec, rightIndCVec, rightDimVec
          properties

    compareFuncHandle: function_handle[1,1] - function handle used to
       compare data structures

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - contains an additional information about the
     differences (if any)
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.isFields}{isFields}}\label{method:smartdb.cubes.CubeStruct.isFields}
\begin{verbatim}
 ISFIELDS - returns whether all fields whose names are given in the input
            list are in the field list of given object or not

 Usage: isPositive=isFields(self,fieldList)

 Input:
   regular:
     self: CubeStruct [1,1]
     fieldList: char or char cell [1,nFields]/[nFields,1] - input list of
         given field names
 Output:
   isPositive: logical [1,1] - true if all gields whose
       names are given in the input list are in the field
       list of given object, false otherwise

   isUniqueNames: logical[1,1] - true if the specified names contain
      unique field values

   isThereVec: logical[1,nFields] - each element indicate whether the
       corresponding field is present in the cube

TODO allow for varargins
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.isequal}{isequal}}\label{method:smartdb.cubes.CubeStruct.isequal}
\begin{verbatim}
ISEQUAL compares the specified CubeStruct object with other CubeStruct
object and returns true if they are equal, otherwise it
returns false

Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: CubeStruct [1,1]
    otherObj: CubeStruct [1,1] - the other object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] -
        if true, then fields in compared objects must
        be in the same order, otherwise the order is not
        important (false by default)

    sortDim: numeric[1,1] - dimension along which the CubeStruct slices
       order is considered irrelevant with regard to equality

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

    compareMetaDataParamList: cell[1,nParam] - list of additional
       parameters passed to isEqual method of CubeStruct from isEqual method
       of CubeStructFieldInfo. This list is used particularly to
       elimitate an infinite loop when comparing the reverse
       references from CubeStructFieldInfo to CubeStruct

    maxTolerance: double [1,1] - maximum allowed tolerance

    leftIndCVec: cell[1,nLeftIndDims] - list of indices to be applied to
      the dimensions of left-hand side CubeStruct object

    leftDimVec: numeric[1,nLeftIndDims] - vector of index dimensions for
       which leftIndCVec is specified

    rightIndCVec: cell[1,nRightIndDims] - same as leftIndCVec but for the
       right-hand side CubeStruct object

    rightDimVec: numeric[1,nRightIndDims] - same as leftDimVec but for
    the right-hand side CubeStruct object

      Note: sortDim property cannot be specified along with
          any of leftIndCVec, leftDimVec, rightIndCVec, rightDimVec
          properties

    compareFuncHandle: function_handle[1,1] - function handle used to
       compare data structures

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - contains an additional information about the
     differences (if any)
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.saveObj}{saveObj}}\label{method:smartdb.cubes.CubeStruct.saveObj}
\begin{verbatim}
SAVEOBJ- transforms given CubeStruct object into structure containing
         internal representation of object properties

Input:
  regular:
    self: CubeStruct [nDim1,...,nDim2]


Output:
  regular:
    SObjectData: struct [n1,...,n_k] - structure containing an internal
       representation of the specified object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.setField}{setField}}\label{method:smartdb.cubes.CubeStruct.setField}
\begin{verbatim}
SETFIELDINTERNAL - sets values of all cells for given field

Usage: setFieldInternal(self,fieldName,value)

Input:
  regular:
    self: CubeStruct [1,1]
    fieldName: char - name of field
    value: array [] of some type - field values

  optional:
    isNull: logical/cell[]
    isValueNull: logical[]

  properties:
    structNameList: list of internal structures to return (by default it
      is {SData, SIsNull, SIsValueNull}

    inferIsNull: logical[1,2] - the first (second) element = false
      means that IsNull (IsValueNull) indicator for a field in question
          is kept intact (default = [true,true])

      Note: if structNameList contains 'SIsValueNull' entry,
       inferIsValueNull parameter is overwritten by false
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.toArray}{toArray}}\label{method:smartdb.cubes.CubeStruct.toArray}
\begin{verbatim}
TOARRAY - transforms values of all CubeStruct cells into a multi-
          dimentional array

Usage: resCArray=toArray(self,varargin)

Input:
  regular:
    self: CubeStruct [1,1]

  properties:
    checkInputs: logical[1,1] - if false, the method skips checking the
       input parameters for consistency

    fieldNameList: cell[1,] - list of filed names to return

    structNameList: cell[1,]/char[1,], data structure list
       for which the data is to be taken from, can consist of the
       following values

      SData - data itself
      SIsNull - contains is-null indicator information for data values
      SIsValueNull - contains is-null indicators for CubeStruct cells
         (not for cell values)

    groupByColumns: logical[1,1], if true, each column is returned in a
       separate cell

    outputType: char[1,] - method of formign an output array, the
       following methods are supported:
           'uniformMat' - the field values are concatenated without any
                   type/size transformations. As a result, this method
                   will fail if the specified fields have different types
                   or/and sizes along any dimension apart from catDim

           'uniformCell' - not-cell fields are converted to cells
                   element-wise but no size-transformations is performed.
                   This method will fail if the specified fields have
                   different sizes along any dimension apart from catDim

           'notUniform' - this method doesn't make any assumptions about
                   size or type of the fields. Each field value is wrapped
                   into cell in a such way that a size of resulting cell
                   is minDimensionSizeVec for each field. Thus if for
                   instance is size of cube object is [2,3,4] and a field
                   size is [2,4,5,10,30] its value is splitted into 2*4*5
                   pieces with each piece of size [1,1,1,10,30] put it
                   its separate cell
           'adaptiveCell' - functions similarly to 'nonUniform' except for
                   the cases when a field value size equals
                   minDimensionSizeVec exactly i.e. the field takes only
                   scalar values. In such cases no wrapping into cell is
                   performed which allows to get a more transparent
                   output.

    catDim: double[1,1] - dimension number for
       concatenating outputs when groupByColumns is false


    replaceNull: logical[1,1], if true, null values from SData are
       replaced by null replacement, = true by default

    nullTopReplacement: - can be of any type and currently only applicable
      when  UniformOutput=false and of
      the corresponding column type if UniformOutput=true.

      Note!: this parameter is disregarded for any dataStructure different
         from 'SData'.

      Note!: the main difference between this parameter and the following
         parameters is that nullTopReplacement can violate field type
         constraints thus allowing to replace doubles with strings for
         instance (for non-uniform output types only of course)


    nullReplacements: cell[1,nReplacedFields]  - list of null
       replacements for each of the fields

    nullReplacementFields: cell[1,nReplacedFields] - list of fields in
       which the nulls are to be replaced with the specified values,
       if not specified it is assumed that all fields are to be replaced

       NOTE!: all fields not listed in this parameter are replaced with
       the default values


Output:
  Case1 (one output is requested and length(structNameList)==1):

      resCMat: matrix/cell[]  with values of all fields (or
        fields selected by optional arguments) for all CubeStruct
        data cells

  Case2 (multiple outputs are requested and their number =
    length(structNameList) each output is assigned resCMat for the
    corresponding struct

  Case3 (2 outputs is requested or length(structNameList)+1 outputs is
  requested). In this case the last output argument is

       isConvertedToCell: logical[nFields,nStructs] -  matrix with true
          values on the positions which correspond to fields converted to
          cells
\end{verbatim}
\subsection{\texorpdfstring{smartdb.cubes.CubeStruct.toStruct}{toStruct}}\label{method:smartdb.cubes.CubeStruct.toStruct}
\begin{verbatim}
TOSTRUCT - transforms given CubeStruct object into structure

Input:
  regular:
    self: CubeStruct [nDim1,...,nDim2]


Output:
  regular:
    SObjectData: struct [n1,...,n_k] - structure containing an internal
       representation of the specified object
\end{verbatim}
\section{smartdb.relations.ARelation}\label{secClassDescr:smartdb.relations.ARelation}
\subsection{\texorpdfstring{smartdb.relations.ARelation.ARelation}{ARelation}}\label{method:smartdb.relations.ARelation.ARelation}
\begin{verbatim}
ARELATION is a constructor of relation class object

Usage: self=ARelation(varargin)

Input:
  optional:
    inpObj: ARelation[1,1]/SData: struct[1,1]
        structure with values of all fields
        for all tuples

    SIsNull: struct [1,1] - structure of fields with is-null
       information for the field content, it can be logical for
       plain real numbers of cell of logicals for cell strs or
       cell of cell of str for more complex types

    SIsValueNull: struct [1,1] - structure with logicals
        determining whether value corresponding to each field
        and each tuple is null or not

Output:
  regular:
    self: ARelation [1,1] - constructed class object

  Subclasses probably do have an overriden version of this
  method which defines either dynamic or static set of fields

(tweaked to use CubeStuct as a base class)
\end{verbatim}


See the description of the following methods in section \ref{secClassDescr:smartdb.cubes.CubeStruct}
 for smartdb.cubes.CubeStruct:

\begin{list}{}{}
 \item \hyperref[method:smartdb.cubes.CubeStruct.applyGetFunc]{applyGetFunc}
 \item \hyperref[method:smartdb.cubes.CubeStruct.applySetFunc]{applySetFunc}
 \item \hyperref[method:smartdb.cubes.CubeStruct.applyTupleGetFunc]{applyTupleGetFunc}
 \item \hyperref[method:smartdb.cubes.CubeStruct.copyFrom]{copyFrom}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getCopy]{getCopy}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getData]{getData}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldDescrList]{getFieldDescrList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldIsNull]{getFieldIsNull}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldIsValueNull]{getFieldIsValueNull}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldNameList]{getFieldNameList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldTypeList]{getFieldTypeList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldTypeSpecList]{getFieldTypeSpecList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldValueSizeMat]{getFieldValueSizeMat}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getIsFieldValueNull]{getIsFieldValueNull}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getMinDimensionSize]{getMinDimensionSize}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getMinDimensionality]{getMinDimensionality}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getNElems]{getNElems}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getNFields]{getNFields}
 \item \hyperref[method:smartdb.cubes.CubeStruct.initByEmptyDataSet]{initByEmptyDataSet}
 \item \hyperref[method:smartdb.cubes.CubeStruct.initByNullDataSet]{initByNullDataSet}
 \item \hyperref[method:smartdb.cubes.CubeStruct.isFields]{isFields}
 \item \hyperref[method:smartdb.cubes.CubeStruct.saveObj]{saveObj}
 \item \hyperref[method:smartdb.cubes.CubeStruct.setField]{setField}
 \item \hyperref[method:smartdb.cubes.CubeStruct.toArray]{toArray}
 \item \hyperref[method:smartdb.cubes.CubeStruct.toStruct]{toStruct}
\end{list}
\subsection{\texorpdfstring{smartdb.relations.ARelation.addData}{addData}}\label{method:smartdb.relations.ARelation.addData}
\begin{verbatim}
ADDDATA - adds a set of field values to existing data in a form of new
          tuples

Input:
  regular:
     self:ARelation [1,1] - class object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.addTuples}{addTuples}}\label{method:smartdb.relations.ARelation.addTuples}
\begin{verbatim}
ADDTUPLES - adds a set of new tuples to the relation

Usage: addTuplesInternal(self,varargin)

input:
  regular:
      self: ARelation [1,1] - class object
      SData: struct [1,1] - structure with values of all fields  for all
       tuples
  optional:
      SIsNull: struct [1,1] - structure of fields with is-null
        information for the field content, it can be logical for plain
        real numbers of cell of logicals for cell strs or cell of cell of
        str for more complex types

      SIsValueNull: struct [1,1] - structure with logicals determining
        whether value corresponding to each field and each tuple is null
        or not

  properties:
      checkConsistency: logical[1,1], if true, a consistency between the
         input structures is not checked, true by default
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.clone}{clone}}\label{method:smartdb.relations.ARelation.clone}
\begin{verbatim}
CLONE - creates a copy of a specified object via calling
        a copy constructor for the object class

Input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.createInstance}{createInstance}}\label{method:smartdb.relations.ARelation.createInstance}
\begin{verbatim}
CREATEINSTANCE - returns an object of the same class by calling a default
                 constructor (with no parameters)

Usage: resObj=getInstance(self)

input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.dispOnUI}{dispOnUI}}\label{method:smartdb.relations.ARelation.dispOnUI}
\begin{verbatim}
DISPONUI - displays a content of the given relation as a data grid UI
           component.

Input:
  regular:
      self:
  properties:
      tableType: char[1,] - type of table used for displaying the data,
          the following types are supported:
          'sciJavaGrid' - proprietary Java-based data grid component
              is used
          'uitable'  - Matlab built-in uitable component is used.
              if not specified, the method tries to use sciJavaGrid
              if it is available, if not - uitable is used.

Output:
  hFigure: double[1,1] - figure handle containing the component
  gridObj: smartdb.relations.disp.UIDataGrid[1,1] - data grid component
      instance used for displaying a content of the relation object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.display}{display}}\label{method:smartdb.relations.ARelation.display}
\begin{verbatim}
DISPLAY - puts some textual information about CubeStruct object in screen

Input:
 regular:
     self.
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.fromStructList}{fromStructList}}\label{method:smartdb.relations.ARelation.fromStructList}
\begin{verbatim}
FROMSTRUCTLIST - creates a dynamic relation from a list of structures
                 interpreting each structure as the data for
                 several tuples.

Input:
  regular:
      className: name of object class which will be created,
          the class constructor should accept 2 properties:
          'fieldNameList' and 'fieldTypeSpecList'

      structList: cell[] of struct[1,1] - list of structures

Output:
  relDataObj: smartdb.relations.DynamicRelation[1,1] -
     constructed relation
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getFieldProjection}{getFieldProjection}}\label{method:smartdb.relations.ARelation.getFieldProjection}
\begin{verbatim}
GETFIELDPROJECTION - project object with specified fields.

Input:
  regular:
      self: ARelation[1,1] - original object
      fieldNameList: cell[1,nFields] of char[1,] - field name list

Output:
  obj: DynamicRelation[1,1] - projected object
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getJoinWith}{getJoinWith}}\label{method:smartdb.relations.ARelation.getJoinWith}
\begin{verbatim}
GETJOINWITH returns a result of join of given relation with another
relation by the specified key fields

LIMITATION: key fields by which the join is peformed are required to form
a unique key in the given relation

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT) - inner join
          'leftOuter' - left outer join
          'rightOuter' - right outer join
          'fullOuter' - full outer join

      fieldDescrSource: char[1,] - defines where the field descriptions
         are taken from, can be
          'useOriginal' - field descriptions are taken from the left hand
              side argument of the join operation
          'useOther' - field descriptions are taken from the right hand
              side of the join operation

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getNTuples}{getNTuples}}\label{method:smartdb.relations.ARelation.getNTuples}
\begin{verbatim}
GETNTUPLES - returns number of tuples in given relation

Usage: nTuples=getNTuples(self)

input:
  regular:
    self: ARelation [1,1] - class object
output:
  regular:
    nTuples: double [1,1] - number of tuples in given  relation
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getSortIndex}{getSortIndex}}\label{method:smartdb.relations.ARelation.getSortIndex}
\begin{verbatim}
GETSORTINDEX - gets sort index for all tuples of given relation with
               respect to some of its fields

Usage: sortInd=getSortIndex(self,sortFieldNameList,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
    sortFieldNameList: char or char cell [1,nFields] - list of field
       names with respect to which tuples are sorted

  properties:
    Direction: char or char cell [1,nFields] - direction of sorting for
        all fields (if one value is given) or for each field separately;
        each value may be 'asc' or 'desc'
output:
  regular:
   sortIndex: double [nTuples,1] - sort index for all tuples such that if
       fieldValueVec is a vector of values for some field of given
       relation, then fieldValueVec(sortIndex) is a vector of values for
       this field when tuples of the relation are sorted
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getTuples}{getTuples}}\label{method:smartdb.relations.ARelation.getTuples}
\begin{verbatim}
GETTUPLES - selects tuples with given indices from given relation and
            returns the result as new relation

Usage: obj=getTuples(self,subIndVec)

input:
  regular:
    self: ARelation [1,1] - class object
    subIndVec: double [nSubTuples,1]/logical[nTuples,1] - array of
        indices for tuples that are selected
output:
  regular:
    obj: ARelation [1,1] - new class object containing only selected
        tuples
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getTuplesFilteredBy}{getTuplesFilteredBy}}\label{method:smartdb.relations.ARelation.getTuplesFilteredBy}
\begin{verbatim}
GETTUPLESFILTEREDBY - selects tuples from given relation such that a
                      fixed index field contains values from a given set
                      of value and returns the result as new relation

Input:
  regular:
    self: ARelation [1,1] - class object
    filterFieldName: char - name of index field
    filterValueVec: numeric/ cell of char [nValues,1] - vector of index
        values

  properties:
    keepNulls: logical[1,1] - if true, null values are not filteed out,
       and removed otherwise,
          default: false

Output:
  regular:
    obj: ARelation [1,1] - new class object containing only selected
        tuples
    isThereVec: logical[nTuples,1] - contains true for the kept tuples
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getTuplesIndexedBy}{getTuplesIndexedBy}}\label{method:smartdb.relations.ARelation.getTuplesIndexedBy}
\begin{verbatim}
 GETTUPLESINDEXEDBY - selects tuples from given relation such that fixed
                      index field contains given in a specified order
                      values and returns the result as new relation.
                      It is required that the original relation
                      contains only one record for each field value

 input:
   regular:
     self: ARelation [1,1] - class object
     indexFieldName: char - name of index field
     indexValueVec: numeric or char cell [nValues,1] - vector of index
         values
 output:
   regular:
     obj: ARelation [1,1] - new class object containing only selected
         tuples

TODO add type check
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getTuplesJoinedWith}{getTuplesJoinedWith}}\label{method:smartdb.relations.ARelation.getTuplesJoinedWith}
\begin{verbatim}
GETTUPLESJOINEDWITH - returns the tuples of the given relation
                      INNER-joined with other relation by the specified
                      key fields

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT) - inner join
          'leftOuter' - left outer join
          'rightOuter' - right outer join
          'fullOuter' - full outer join

      fieldDescrSource: char[1,] - defines where the field descriptions
         are taken from, can be
          'useOriginal' - field descriptions are taken from the left hand
              side argument of the join operation
          'useOther' - field descriptions are taken from the right hand
              side of the join operation

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getUniqueData}{getUniqueData}}\label{method:smartdb.relations.ARelation.getUniqueData}
\begin{verbatim}
GETUNIQUEDATA - returns internal representation for a set of unique
                tuples for given relation

Usage: [SData,SIsNull,SIsValueNull]=getUniqueData(self,varargin)

Input:
  regular:
    self: ARelation [1,1] - class object
  properties
      fieldNameList: list of field names used for finding the unique
          elements; only the specified fields are returned in SData,
          SIsNull,SIsValueNull structures
      structNameList: list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the tuples
              default value is false

Output:
  regular:

    SData: struct [1,1] - structure containing values of fields in
        selected tuples, each field is an array containing values of the
        corresponding type

    SIsNull: struct [1,1] - structure containing info whether each value
        in selected tuples is null or not, each field is either logical
        array or cell array containing logical arrays

    SIsValueNull: struct [1,1] - structure containing a
       logical array [nTuples,1] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value

    indForward: double[1,nUniqueTuples] - indices of unique entries in
       the original tuple set

    indBackward: double[1,nTuples] - indices that map the unique tuple
       set back to the original tuple set
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.getUniqueTuples}{getUniqueTuples}}\label{method:smartdb.relations.ARelation.getUniqueTuples}
\begin{verbatim}
GETUNIQUETUPLES - returns a relation containing the unique tuples from
                  the original relation

Usage: [resRel,indForwardVec,indBackwardVec]=getUniqueTuples(self,varargin)

Input:
  regular:
    self: ARelation [1,1] - class object
  properties
      fieldNameList: list of field names used for finding the unique
         tuples
      structNameList: list of internal structures to return (by default it
          is {SData, SIsNull, SIsValueNull}
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all the tuples
              default value is false

Output:
  regular:

    resRel: ARelation[1,1] - resulting relation

    indForward: double[1,nUniqueTuples] - indices of unique entries in
       the original tuple set

    indBackward: double[1,nTuples] - indices that map the unique tuple
       set back to the original tuple set
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.isEqual}{isEqual}}\label{method:smartdb.relations.ARelation.isEqual}
\begin{verbatim}
ISEQUAL - compares current relation object with other relation object and
          returns true if they are equal, otherwise it returns false


Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: ARelation [1,1] - current relation object
    otherObj: ARelation [1,1] - other relation object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
        in compared relations must be in the same order, otherwise the
        order is not  important (false by default)
    checkTupleOrder: logical[1,1] -  if true, then the tuples in the
        compared relations are expected to be in the same order,
        otherwise the order is not important (false by default)

    maxTolerance: double [1,1] - maximum allowed tolerance

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - report of comparsion
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.isMemberTuples}{isMemberTuples}}\label{method:smartdb.relations.ARelation.isMemberTuples}
\begin{verbatim}
ISMEMBER - performs ismember operation for tuples of two relations by key
           fields given by special list

Usage: isTuple=isMemberTuples(self,otherRel,keyFieldNameList) or
       [isTuple indTuples]=isMemberTuples(self,otherRel,keyFieldNameList)

input:
  regular:
    self: ARelation [1,1] - class object
    other: ARelation [1,1] - other class object
  optional:
    keyFieldNameList: char or char cell [1,nKeyFields] - list of fields
        to which ismember is applied; by default all fields of first
        (self) object are used
output:
  regular:
    isTuple: logical [nTuples,1] - determines for each tuple of first
        (self) object whether combination of values for key fields is in
        the second (other) relation or not
    indTuples: double [nTuples,1] - zero if the corresponding coordinate
        of isTuple is false, otherwise the highest index of the
        corresponding tuple in the second (other) relation
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.isUniqueKey}{isUniqueKey}}\label{method:smartdb.relations.ARelation.isUniqueKey}
\begin{verbatim}
ISUNIQUEKEY - checks if a specified set of fields forms a unique key

Usage: isPositive=self.isUniqueKey(fieldNameList)

Input:
  regular:
      self: ARelation [1,1] - class object
      fieldNameList: cell[1,nFields] - list of field names for a unique
          key candidate
Output:
  isPositive: logical[1,1] - true means that a specified set of fields is
     a unique key
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.isequal}{isequal}}\label{method:smartdb.relations.ARelation.isequal}
\begin{verbatim}
ISEQUAL - compares current relation object with other relation object and
          returns true if they are equal, otherwise it returns false


Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: ARelation [1,1] - current relation object
    otherObj: ARelation [1,1] - other relation object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
        in compared relations must be in the same order, otherwise the
        order is not  important (false by default)
    checkTupleOrder: logical[1,1] -  if true, then the tuples in the
        compared relations are expected to be in the same order,
        otherwise the order is not important (false by default)

    maxTolerance: double [1,1] - maximum allowed tolerance

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - report of comparsion
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.removeDuplicateTuples}{removeDuplicateTuples}}\label{method:smartdb.relations.ARelation.removeDuplicateTuples}
\begin{verbatim}
REMOVEDUPLICATETUPLES - removes all duplicate tuples from the relation

Usage: [indForwardVec,indBackwardVec]=...
           removeDuplicateTuples(self,varargin)

Input:
  regular:
    self: ARelation [1,1] - class object

  properties:
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values for all fields uniformly across all
          relation tuples
              default value is false

Output:
  optional:
    indForwardVec: double[nUniqueSlices,1] - indices of unique tuples in
       the original relation

    indBackwardVec: double[nSlices,1] - indices that map the unique
       tuples back to the original tuples
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.removeTuples}{removeTuples}}\label{method:smartdb.relations.ARelation.removeTuples}
\begin{verbatim}
REMOVETUPLES - removes tuples with given indices from given relation

Usage: self.removeTuples(subIndVec)

Input:
  regular:
    self: ARelation [1,1] - class object
    subIndVec: double [nSubTuples,1]/logical[nTuples,1] - array of
       indices for tuples that are selected to be removed
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.sortBy}{sortBy}}\label{method:smartdb.relations.ARelation.sortBy}
\begin{verbatim}
SORTBY - sorts all tuples of given relation with respect to some of its
         fields

Usage: sortBy(self,sortFieldNameList,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
    sortFieldNameList: char or char cell [1,nFields] - list of field
        names with respect to which tuples are sorted
  properties:
    direction: char or char cell [1,nFields] - direction of sorting for
        all fields (if one value is given) or for each field separately;
        each value may be 'asc' or 'desc'
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.toCell}{toCell}}\label{method:smartdb.relations.ARelation.toCell}
\begin{verbatim}
TOCELL - transforms values of all fields for all tuples into two
         dimensional cell array

Usage: resCMat=toCell(self,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
  optional:
    fieldName1: char - name of first field
    ...
    fieldNameN: char - name of N-th field
output:
  resCMat: cell [nTuples,nFields(N)] - cell with values of all fields (or
      fields selected by optional arguments) for all tuples

FIXME - order fields in setData method
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.toCellIsNull}{toCellIsNull}}\label{method:smartdb.relations.ARelation.toCellIsNull}
\begin{verbatim}
TOCELLISNULL - transforms is-null indicators of all fields for all tuples
               into two dimensional cell array

Usage: resCMat=toCell(self,varargin)

input:
  regular:
    self: ARelation [1,1] - class object
  optional:
    fieldName1: char - name of first field
    ...
    fieldNameN: char - name of N-th field
output:
  resCMat: cell [nTuples,nFields(N)] - cell with values of all fields (or
      fields selected by optional arguments) for all tuples

FIXME - order fields in setData method
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.toDispCell}{toDispCell}}\label{method:smartdb.relations.ARelation.toDispCell}
\begin{verbatim}
TODISPCELL - transforms values of all fields into their character
             representation

Usage: resCMat=toDispCell(self)

Input:
  regular:
    self: ARelation [1,1] - class object

  properties:
      nullTopReplacement: any[1,1] - value used to replace null values
      fieldNameList: cell[1,] of char[1,] - field name list

Output:
  dataCell: cell[nRows,nCols] of char[1,] - cell array containing the
      character representation of field values
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.toMat}{toMat}}\label{method:smartdb.relations.ARelation.toMat}
\begin{verbatim}
TOMAT - transforms values of all fields for all tuples into two
        dimensional array

Usage: resCMat=toMat(self,varargin)

input:
  regular:
    self: ARelation [1,1] - class object

  optional:
    fieldNameList: cell[1,] - list of filed names to return

    uniformOutput: logical[1,1], true - cell is returned, false - the
       functions tries to return a result as a matrix

    groupByColumns: logical[1,1], if true, each column is returned in a
       separate cell

    structNameList/dataStructure: char[1,], data structure for which the
       data is to be taken from, can have one of the following values

      SData - data itself
      SIsNull - contains is-null indicator information for data values
      SIsValueNull - contains is-null indicators for relation cells (not
         for cell values

    replaceNull: logical[1,1], if true, null values from SData are
       replaced by null replacement, = true by default

    nullTopReplacement: - can be of any type and currently only applicable
      when  UniformOutput=false and of
      the corresponding column type if UniformOutput=true.

      Note!: this parameter is disregarded for any dataStructure different
         from 'SData'.

      Note!: the main difference between this parameter and the following
         parameters is that nullTopReplacement can violate field type
         constraints thus allowing to replace doubles with strings for
         instance (for non-uniform output types only of course)


    nullReplacements: cell[1,nReplacedFields]  - list of null
       replacements for each of the fields

    nullReplacementFields: cell[1,nReplacedFields] - list of fields in
       which the nulls are to be replaced with the specified values,
       if not specified it is assumed that all fields are to be replaced

       NOTE!: all fields not listed in this parameter are replaced with
       the default values

output:
  resCMat:  [nTuples,nFields(N)] - matrix/cell with values of all fields
      (or fields selected by optional arguments) for all tuples
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.unionWith}{unionWith}}\label{method:smartdb.relations.ARelation.unionWith}
\begin{verbatim}
UNIONWITH - adds tuples of the input relation to the set of tuples of the
            original relation
Usage: self.unionWith(inpRel)

Input:
  regular:
    self: ARelation [1,1] - class object
    inpRel1: ARelation [1,1] - object to get the additional tuples from
      ...
    inpRelN: ARelation [1,1] - object to get the additional tuples from

  properties:
      checkType: logical[1,1] - if true, union is only performed when the
          types of relations is the same. Default value is false

      checkStruct: logical[1,nStruct] - an array of indicators which when
         true force checking of structure content (including presence
         of all required fields). The first element correspod to SData,
         the second and the third (if specified) to SIsNull and
         SIsValueNull correspondingly

      checkConsistency: logical [1,1]/[1,2] - the
          first element defines if a consistency between the value
          elements (data, isNull and isValueNull) is checked;
          the second element (if specified) defines if
          value's type is checked. If isConsistencyChecked
          is scalar, it is automatically replicated to form a
          two-element vector.
          Note: default value is true
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.writeToCSV}{writeToCSV}}\label{method:smartdb.relations.ARelation.writeToCSV}
\begin{verbatim}
WRITETOCSV - writes a content of relation into Excel spreadsheet file
Input:
  regular:
      self:
      filePath: char[1,] - file path

Output:
  none
\end{verbatim}
\subsection{\texorpdfstring{smartdb.relations.ARelation.writeToXLS}{writeToXLS}}\label{method:smartdb.relations.ARelation.writeToXLS}
\begin{verbatim}
WRITETOXLS - writes a content of relation into Excel spreadsheet file
Input:
  regular:
      self:
      filePath: char[1,] - file path

Output:
  fileName: char[1,] - resulting file name, may not match with filePath
      when Excel is not available and csv format is used instead
\end{verbatim}
\section{gras.ellapx.smartdb.rels.EllTube}\label{secClassDescr:gras.ellapx.smartdb.rels.EllTube}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.EllTube}{EllTube}}\label{method:gras.ellapx.smartdb.rels.EllTube.EllTube}
\begin{verbatim}
EllTube - class which keeps ellipsoidal tubes

Fields:
  QArray:cell[1, nElem] - Array of ellipsoid matrices
  aMat:cell[1, nElem] - Array of ellipsoid centers
  scaleFactor:double[1, 1] - Tube scale factor
  MArray:cell[1, nElem] - Array of regularization ellipsoid matrices
  dim :double[1, 1] - Dimensionality
  sTime:double[1, 1] - Time s
  approxSchemaName:cell[1,] - Name
  approxSchemaDescr:cell[1,] - Description
  approxType:gras.ellapx.enums.EApproxType - Type of approximation
                (external, internal, not defined)
  timeVec:cell[1, m] - Time vector
  calcPrecision:double[1, 1] - Calculation precision
  indSTime:double[1, 1]  - index of sTime within timeVec
  ltGoodDirMat:cell[1, nElem] - Good direction curve
  lsGoodDirVec:cell[1, nElem] - Good direction at time s
  ltGoodDirNormVec:cell[1, nElem] - Norm of good direction curve
  lsGoodDirNorm:double[1, 1] - Norm of good direction at time s
  xTouchCurveMat:cell[1, nElem] - Touch point curve for good
                                  direction
  xTouchOpCurveMat:cell[1, nElem] - Touch point curve for direction
                                    opposite to good direction
  xsTouchVec:cell[1, nElem]  - Touch point at time s
  xsTouchOpVec :cell[1, nElem] - Touch point at time s

  TODO: correct description of the fields in gras.ellapx.smartdb.rels.EllTube
\end{verbatim}


See the description of the following methods in section \ref{secClassDescr:smartdb.cubes.CubeStruct}
 for smartdb.cubes.CubeStruct:

\begin{list}{}{}
 \item \hyperref[method:smartdb.cubes.CubeStruct.applyGetFunc]{applyGetFunc}
 \item \hyperref[method:smartdb.cubes.CubeStruct.applySetFunc]{applySetFunc}
 \item \hyperref[method:smartdb.cubes.CubeStruct.applyTupleGetFunc]{applyTupleGetFunc}
 \item \hyperref[method:smartdb.cubes.CubeStruct.copyFrom]{copyFrom}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getCopy]{getCopy}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getData]{getData}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldDescrList]{getFieldDescrList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldIsNull]{getFieldIsNull}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldIsValueNull]{getFieldIsValueNull}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldNameList]{getFieldNameList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldTypeList]{getFieldTypeList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldTypeSpecList]{getFieldTypeSpecList}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getFieldValueSizeMat]{getFieldValueSizeMat}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getIsFieldValueNull]{getIsFieldValueNull}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getMinDimensionSize]{getMinDimensionSize}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getMinDimensionality]{getMinDimensionality}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getNElems]{getNElems}
 \item \hyperref[method:smartdb.cubes.CubeStruct.getNFields]{getNFields}
 \item \hyperref[method:smartdb.cubes.CubeStruct.initByEmptyDataSet]{initByEmptyDataSet}
 \item \hyperref[method:smartdb.cubes.CubeStruct.initByNullDataSet]{initByNullDataSet}
 \item \hyperref[method:smartdb.cubes.CubeStruct.isFields]{isFields}
 \item \hyperref[method:smartdb.cubes.CubeStruct.saveObj]{saveObj}
 \item \hyperref[method:smartdb.cubes.CubeStruct.setField]{setField}
 \item \hyperref[method:smartdb.cubes.CubeStruct.toArray]{toArray}
 \item \hyperref[method:smartdb.cubes.CubeStruct.toStruct]{toStruct}
\end{list}


See the description of the following methods in section \ref{secClassDescr:smartdb.relations.ARelation}
 for smartdb.relations.ARelation:

\begin{list}{}{}
 \item \hyperref[method:smartdb.relations.ARelation.addData]{addData}
 \item \hyperref[method:smartdb.relations.ARelation.addTuples]{addTuples}
 \item \hyperref[method:smartdb.relations.ARelation.dispOnUI]{dispOnUI}
 \item \hyperref[method:smartdb.relations.ARelation.fromStructList]{fromStructList}
 \item \hyperref[method:smartdb.relations.ARelation.getFieldProjection]{getFieldProjection}
 \item \hyperref[method:smartdb.relations.ARelation.getNTuples]{getNTuples}
 \item \hyperref[method:smartdb.relations.ARelation.getSortIndex]{getSortIndex}
 \item \hyperref[method:smartdb.relations.ARelation.getTuples]{getTuples}
 \item \hyperref[method:smartdb.relations.ARelation.getTuplesFilteredBy]{getTuplesFilteredBy}
 \item \hyperref[method:smartdb.relations.ARelation.getTuplesIndexedBy]{getTuplesIndexedBy}
 \item \hyperref[method:smartdb.relations.ARelation.getTuplesJoinedWith]{getTuplesJoinedWith}
 \item \hyperref[method:smartdb.relations.ARelation.getUniqueData]{getUniqueData}
 \item \hyperref[method:smartdb.relations.ARelation.getUniqueTuples]{getUniqueTuples}
 \item \hyperref[method:smartdb.relations.ARelation.isEqual]{isEqual}
 \item \hyperref[method:smartdb.relations.ARelation.isMemberTuples]{isMemberTuples}
 \item \hyperref[method:smartdb.relations.ARelation.isUniqueKey]{isUniqueKey}
 \item \hyperref[method:smartdb.relations.ARelation.removeDuplicateTuples]{removeDuplicateTuples}
 \item \hyperref[method:smartdb.relations.ARelation.removeTuples]{removeTuples}
 \item \hyperref[method:smartdb.relations.ARelation.sortBy]{sortBy}
 \item \hyperref[method:smartdb.relations.ARelation.toCell]{toCell}
 \item \hyperref[method:smartdb.relations.ARelation.toCellIsNull]{toCellIsNull}
 \item \hyperref[method:smartdb.relations.ARelation.toDispCell]{toDispCell}
 \item \hyperref[method:smartdb.relations.ARelation.toMat]{toMat}
 \item \hyperref[method:smartdb.relations.ARelation.unionWith]{unionWith}
 \item \hyperref[method:smartdb.relations.ARelation.writeToCSV]{writeToCSV}
 \item \hyperref[method:smartdb.relations.ARelation.writeToXLS]{writeToXLS}
\end{list}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.addDataAlongDim}{addDataAlongDim}}\label{method:gras.ellapx.smartdb.rels.EllTube.addDataAlongDim}
\begin{verbatim}
ADDDATAALONGDIM - adds a set of field values to existing data using
                  a concatenation along a specified dimension

Input:
  regular:
      self: CubeStruct [1,1] - the object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.cat}{cat}}\label{method:gras.ellapx.smartdb.rels.EllTube.cat}
\begin{verbatim}
CAT  - concatenates data from relation objects.

Input:
 regular:
   self.
   newEllTubeRel: smartdb.relation.StaticRelation[1, 1]/
     smartdb.relation.DynamicRelation[1, 1] - relation object

Output:
   catEllTubeRel:smartdb.relation.StaticRelation[1, 1]/
     smartdb.relation.DynamicRelation[1, 1] - relation object resulting
     from CAT operation
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.clearData}{clearData}}\label{method:gras.ellapx.smartdb.rels.EllTube.clearData}
\begin{verbatim}
CLEARDATA - deletes all the data from the object

Usage: self.clearData(self)

Input:
  regular:
    self: CubeStruct [1,1] - class object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.clone}{clone}}\label{method:gras.ellapx.smartdb.rels.EllTube.clone}
\begin{verbatim}
CLONE - creates a copy of a specified object via calling
        a copy constructor for the object class

Input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.createInstance}{createInstance}}\label{method:gras.ellapx.smartdb.rels.EllTube.createInstance}
\begin{verbatim}
CREATEINSTANCE - returns an object of the same class by calling a default
                 constructor (with no parameters)

Usage: resObj=getInstance(self)

input:
  regular:
    self: any [] - current object
  optional
    any parameters applicable for relation constructor

Ouput:
  self: any [] - constructed object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.cut}{cut}}\label{method:gras.ellapx.smartdb.rels.EllTube.cut}
\begin{verbatim}
CUT - extracts the piece of the relation object from given start time to
      given end time.
Input:
 regular:
    self.
    cutTimeVec: double[1, 2]/ double[1, 1] - time interval to cut

Output:
cutEllTubeRel: smartdb.relation.StaticRelation[1, 1]/
     smartdb.relation.DynamicRelation[1, 1] - relation object resulting
     from CUT operation
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.display}{display}}\label{method:gras.ellapx.smartdb.rels.EllTube.display}
\begin{verbatim}
DISPLAY - puts some textual information about CubeStruct object in screen

Input:
 regular:
     self.
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.fromEllArray}{fromEllArray}}\label{method:gras.ellapx.smartdb.rels.EllTube.fromEllArray}
\begin{verbatim}
FROMELLARRAY  - creates a relation object using an array of ellipsoids

Input:
  regular:
    qEllArray: ellipsoid[nDim1, nDim2, ..., nDimN] - array of ellipsoids

  optional:
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
       object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.fromEllMArray}{fromEllMArray}}\label{method:gras.ellapx.smartdb.rels.EllTube.fromEllMArray}
\begin{verbatim}
FROMELLMARRAY  - creates a relation object using an array of ellipsoids.
                 This method uses regularizer in the form of a matrix
                 function.

Input:
  regular:
    qEllArray: ellipsoid[nDim1, nDim2, ..., nDimN] - array of ellipsoids
    ellMArr: double[nDim1, nDim2, ..., nDimN] - regularization ellipsoid
        matrices

  optional:
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
         object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.fromQArrays}{fromQArrays}}\label{method:gras.ellapx.smartdb.rels.EllTube.fromQArrays}
\begin{verbatim}
FROMQARRAYS  - creates a relation object using an array of ellipsoids,
               described by the array of ellipsoid matrices and
               array of ellipsoid centers.This method used default
               scale factor.

Input:
  regular:
    QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
        matrices
    aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers

Optional:
   MArrayList:cell[1, nElem] - array of regularization ellipsoid matrices
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
       object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.fromQMArrays}{fromQMArrays}}\label{method:gras.ellapx.smartdb.rels.EllTube.fromQMArrays}
\begin{verbatim}
FROMQMARRAYS  - creates a relation object using an array of ellipsoids,
                described by the array of ellipsoid matrices and
                array of ellipsoid centers. Also this method uses
                regularizer in the form of a matrix function. This method
                used default scale factor.

Input:
  regular:
  QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
        matrices
  aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers
  MArrayList: double[nDim1, nDim2, ..., nDimN] - ellipsoid  matrices of
        regularization

 optional:
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
         object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.fromQMScaledArrays}{fromQMScaledArrays}}\label{method:gras.ellapx.smartdb.rels.EllTube.fromQMScaledArrays}
\begin{verbatim}
FROMQMSCALEDARRAYS  - creates a relation object using an array of ellipsoids,
                      described by the array of ellipsoid matrices and
                      array of ellipsoid centers. Also this method uses
                      regularizer in the form of a matrix function.


Input:
  regular:
    QArrayList: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid
        matrices
    aMat: double[nDim1, nDim2, ..., nDimN] - array of ellipsoid centers
    MArrayList: double[nDim1, nDim2, ..., nDimN] - ellipsoid matrices
              of regularization
    scaleFactor:double[1, 1] - tube scale factor

 optional:
   timeVec:cell[1, m] - time vector
   ltGoodDirArray:cell[1, nElem] - good direction at time s
   sTime:double[1, 1] - time s
   approxType:gras.ellapx.enums.EApproxType - type of approximation
                (external, internal, not defined)
   approxSchemaName:cell[1,] - name of the schema
   approxSchemaDescr:cell[1,] - description of the schema
   calcPrecision:double[1, 1] - calculation precision

Output:
   ellTubeRel: smartdb.relation.StaticRelation[1, 1] - constructed relation
         object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.getEllArray}{getEllArray}}\label{method:gras.ellapx.smartdb.rels.EllTube.getEllArray}
\begin{verbatim}
GETELLARRAY - returns array of matrix's ellipsoid according to
              approxType

Input:
 regular:
    self.
    approxType:char[1,] - type of approximation(internal/external)

Output:
  apprEllMat:double[nDim1,..., nDimN] - array of array of ellipsoid's
           matrices
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.getJoinWith}{getJoinWith}}\label{method:gras.ellapx.smartdb.rels.EllTube.getJoinWith}
\begin{verbatim}
GETJOINWITH - returns a result of INNER join of given relation with
              another relation by the specified key fields

LIMITATION: key fields by which the join is peformed are required to form
a unique key in the given relation

Input:
  regular:
      self:
      otherRel: smartdb.relations.ARelation[1,1]
      keyFieldNameList: char[1,]/cell[1,nFields] of char[1,]

  properties:
      joinType: char[1,] - type of join, can be
          'inner' (DEFAULT)
          'leftOuter'

Output:
  resRel: smartdb.relations.ARelation[1,1] - join result
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.getUniqueDataAlongDim}{getUniqueDataAlongDim}}\label{method:gras.ellapx.smartdb.rels.EllTube.getUniqueDataAlongDim}
\begin{verbatim}
GETUNIQUEDATAALONGDIM - returns internal representation of CubeStruct

Input:
  regular:
    self:
    catDim: double[1,1] - dimension number along which uniqueness is
       checked

  properties
      fieldNameList: list of field names used for finding the unique
          elements; only the specified fields are returned in SData,
          SIsNull,SIsValueNull structures
      structNameList: list of internal structures to return (by default
          it is {SData, SIsNull, SIsValueNull}
      replaceNull: logical[1,1] if true, null values are replaced with
          certain default values uniformly across all CubeStruct cells
              default value is false
      checkInputs: logical[1,1] - if true, the input parameters are
         checked for consistency

Output:
  regular:
    SData: struct [1,1] - structure containing values of fields

    SIsNull: struct [1,1] - structure containing info whether each value
        in selected cells is null or not, each field is either logical
        array or cell array containing logical arrays

    SIsValueNull: struct [1,1] - structure containing a
       logical array [nSlices,1] for each of the fields (true
       means that a corresponding cell doesn't not contain
          any value

    indForwardVec: double[nUniqueSlices,1] - indices of unique entries in
       the original CubeStruct data set

    indBackwardVec: double[nSlices,1] - indices that map the unique data
       set back to the original data setdata set unique along a specified
       dimension
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.isMemberAlongDim}{isMemberAlongDim}}\label{method:gras.ellapx.smartdb.rels.EllTube.isMemberAlongDim}
\begin{verbatim}
ISMEMBERALONGDIM - performs ismember operation of CubeStruct data slices
                   along the specified dimension
Input:
  regular:
    self: ARelation [1,1] - class object
    other: ARelation [1,1] - other class object
    dim: double[1,1] - dimension number for ismember operation

  properties:
    keyFieldNameList/fieldNameList: char or char cell [1,nKeyFields] -
        list  of fields to which ismember is applied; by default all
        fields of first (self) object are used


Output:
  regular:
    isThere: logical [nSlices,1] - determines for each data slice of the
        first (self) object whether combination of values for key fields
        is in the second (other) object or not
    indTheres: double [nSlices,1] - zero if the corresponding coordinate
        of isThere is false, otherwise the highest index of the
        corresponding data slice in the second (other) object
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.isequal}{isequal}}\label{method:gras.ellapx.smartdb.rels.EllTube.isequal}
\begin{verbatim}
ISEQUAL - compares current relation object with other relation object and
          returns true if they are equal, otherwise it returns false


Usage: isEq=isEqual(self,otherObj)

Input:
  regular:
    self: ARelation [1,1] - current relation object
    otherObj: ARelation [1,1] - other relation object

  properties:
    checkFieldOrder/isFieldOrderCheck: logical [1,1] - if true, then fields
        in compared relations must be in the same order, otherwise the
        order is not  important (false by default)
    checkTupleOrder: logical[1,1] -  if true, then the tuples in the
        compared relations are expected to be in the same order,
        otherwise the order is not important (false by default)

    maxTolerance: double [1,1] - maximum allowed tolerance

    compareMetaDataBackwardRef: logical[1,1] if true, the CubeStruct's
        referenced from the meta data objects are also compared

Output:
  isEq: logical[1,1] - result of comparison
  reportStr: char[1,] - report of comparsion
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.plot}{plot}}\label{method:gras.ellapx.smartdb.rels.EllTube.plot}
\begin{verbatim}
PLOT - displays ellipsoidal tubes using the specified RelationDataPlotter


Input:
  regular:
      self:
      plObj: smartdb.disp.RelationDataPlotter[1,1] - plotter
          object used for displaying ellipsoidal tubes
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.project}{project}}\label{method:gras.ellapx.smartdb.rels.EllTube.project}
\begin{verbatim}
PROJECT - computes projection of the relation object onto given time
          dependent subspase


Input:
 regular:
   self.
   projType - type of the projection.
       Takes the following values: 'Static'
                                   'DynamicAlongGoodCurve'
   projMatList:double[nDim, nSpDim] - matrices' array of the orthoganal
            basis vectors
   fGetProjMat - function which creates vector of the projection
            matrices
       Input:
        regular:
          projMat:double[nDim, mDim] - matrix of the projection at the
            instant of time
          timeVec:double[1, nDim] - time interval
        optional:
           sTime:double[1,1] - instant of time
       Output:
          projOrthMatArray:double[1, nSpDim] - vector of the projection
            matrices
          projOrthMatTransArray:double[nSpDim, 1] - transposed vector of
            the projection matrices
Output:
   ellTubeProjRel:smartdb.relation.StaticRelation[1, 1]/
       smartdb.relation.DynamicRelation[1, 1]- projected relation
   indProj2OrigVec:cell[nDim, 1] - index of the line number from
            which is obtained the projection

Example:
  function example
   aMat = [0 1; 0 0]; bMat = eye(2);
   SUBounds = struct();
   SUBounds.center = {'sin(t)'; 'cos(t)'};
   SUBounds.shape = [9 0; 0 2];
   sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
   x0EllObj = ell_unitball(2);
   timeVec = [0 10];
   dirsMat = [1 0; 0 1]';
   rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
   ellTubeObj = rsObj.getEllTubeRel();
   unionEllTube = ...
    gras.ellapx.smartdb.rels.EllUnionTube.fromEllTubes(ellTubeObj);
   projSpaceList = {[1 0;0 1]};
   projType = gras.ellapx.enums.EProjType.Static;
   statEllTubeProj = unionEllTube.project(projType,projSpaceList,...
      @fGetProjMat);
   plObj=smartdb.disp.RelationDataPlotter();
   statEllTubeProj.plot(plObj);
end

function [projOrthMatArray,projOrthMatTransArray]=fGetProjMat(projMat,...
    timeVec,varargin)
  nTimePoints=length(timeVec);
  projOrthMatArray=repmat(projMat,[1,1,nTimePoints]);
  projOrthMatTransArray=repmat(projMat.',[1,1,nTimePoints]);
 end
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.reorderData}{reorderData}}\label{method:gras.ellapx.smartdb.rels.EllTube.reorderData}
\begin{verbatim}
REORDERDATA - reorders cells of CubeStruct object along the specified
              dimensions according to the specified index vectors

Input:
  regular:
      self: CubeStruct [1,1] - the object
      subIndCVec: numeric[1,]/cell[1,nDims] of double [nSubElem_i,1]
          for i=1,...,nDims array of indices of field value slices that
          are selected to be returned;
          if not given (default), no indexation is performed

  optional:
      dimVec: numeric[1,nDims] - vector of dimension numbers
          corresponding to subIndCVec
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.scale}{scale}}\label{method:gras.ellapx.smartdb.rels.EllTube.scale}
\begin{verbatim}
SCALE - scales relation object

 Input:
  regular:
     self.
     fCalcFactor - function which calculates factor for
                    fields in fieldNameList
       Input:
         regular:
           fieldNameList: char/cell[1,] of char - a list of fields
                  for which factor will be calculated
        Output:
            factor:double[1, 1] - calculated factor

      fieldNameList:cell[1,nElem]/char[1,] - names of the fields

 Output:
      none

Example:
  nPoints=5;
  calcPrecision=0.001;
  approxSchemaDescr=char.empty(1,0);
  approxSchemaName=char.empty(1,0);
  nDims=3;
  nTubes=1;
  lsGoodDirVec=[1;0;1];
  aMat=zeros(nDims,nPoints);
  timeVec=1:nPoints;
  sTime=nPoints;
  approxType=gras.ellapx.enums.EApproxType.Internal;
  qArrayList=repmat({repmat(diag([1 2 3]),[1,1,nPoints])},1,nTubes);
  ltGoodDirArray=repmat(lsGoodDirVec,[1,nTubes,nPoints]);
  fromMatEllTube=...
        gras.ellapx.smartdb.rels.EllTube.fromQArrays(qArrayList,...
        aMat, timeVec,ltGoodDirArray, sTime, approxType,...
        approxSchemaName, approxSchemaDescr, calcPrecision);
  fromMatEllTube.scale(@(varargin)2,{});
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.setData}{setData}}\label{method:gras.ellapx.smartdb.rels.EllTube.setData}
\begin{verbatim}
SETDATA - sets values of all cells for all fields

Input:
  regular:
    self: CubeStruct[1,1]

  optional:
    SData: struct [1,1] - structure with values of all cells for
        all fields

    SIsNull: struct [1,1] - structure of fields with is-null
       information for the field content, it can be logical for
       plain real numbers of cell of logicals for cell strs or
       cell of cell of str for more complex types

    SIsValueNull: struct [1,1] - structure with logicals
        determining whether value corresponding to each field
        and field cell is null or not

  properties:
      fieldNameList: cell[1,] of char[1,] - list of fields for which data
          should be generated, if not specified, all fields from the
          relation are taken

      isConsistencyCheckedVec: logical [1,1]/[1,2]/[1,3] -
          the first element defines if a consistency between the value
              elements (data, isNull and isValueNull) is checked;
          the second element (if specified) defines if
              value's type is checked.
          the third element defines if consistency between of sizes
              between different fields is checked
            If isConsistencyCheckedVec
              if scalar, it is automatically replicated to form a
                  3-element vector
              if the third element is not specified it is assumed
                  to be true

      transactionSafe: logical[1,1], if true, the operation is performed
         in a transaction-safe manner

      checkStruct: logical[1,nStruct] - an array of indicators which when
         all true force checking of structure content (including presence
         of required fields). The first element correspod to SData, the
         second and the third (if specified) to SIsNull and SIsValueNull
         correspondingly

      structNameList: char[1,]/cell[1,], name of data structure/list of
        data structure names to which the function is to
             be applied, can be composed from the following values

           SData - data itself

           SIsNull - contains is-null indicator information for data
                values

           SIsValueNull - contains is-null indicators for CubeStruct cells
               (not for cell values)
        structNameList={'SData'} by default

      fieldMetaData: smartdb.cubes.CubeStructFieldInfo[1,] - field meta
         data array which is used for data validity checking and for
         replacing the existing meta-data

      mdFieldNameList: cell[1,] of char - list of names of fields for
         which meta data is specified

      dataChangeIsComplete: logical[1,1] - indicates whether a change
          performed by the function is complete

Note: call of setData with an empty list of arguments clears
   the data
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.sortByAlongDim}{sortByAlongDim}}\label{method:gras.ellapx.smartdb.rels.EllTube.sortByAlongDim}
\begin{verbatim}
SORTBYALONGDIM -  sorts data of given CubeStruct object along the
                  specified dimension using the specified fields

Usage: sortByInternal(self,sortFieldNameList,varargin)

input:
  regular:
    self: CubeStruct [1,1] - class object
    sortFieldNameList: char or char cell [1,nFields] - list of field
        names with respect to which field content is sorted
    sortDim: numeric[1,1] - dimension number along which the sorting is
       to be performed
    properties:
    direction: char or char cell [1,nFields] - direction of sorting for
        all fields (if one value is given) or for each field separately;
        each value may be 'asc' or 'desc'
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.thinOutTuples}{thinOutTuples}}\label{method:gras.ellapx.smartdb.rels.EllTube.thinOutTuples}
\begin{verbatim}
THINOUTTUPLES  - delete tuples from relation object

Input:
  regular:
    self.
    indVec:logical[1, nDim]/double[1, nDim] - indexes of tuples which
            we must remove

Output:
  thinnedEllTubeRel: smartdb.relation.StaticRelation[1, 1]/
      smartdb.relation.DynamicRelation[1, 1] - relation object without
      tuples
\end{verbatim}
\subsection{\texorpdfstring{gras.ellapx.smartdb.rels.EllTube.unionWithAlongDim}{unionWithAlongDim}}\label{method:gras.ellapx.smartdb.rels.EllTube.unionWithAlongDim}
\begin{verbatim}
UNIONWITHALONGDIM - adds data from the input CubeStructs

Usage: self.unionWithAlongDim(unionDim,inpCube)

Input:
  regular:
  self:
      inpCube1: CubeStruct [1,1] - object to get the additional data from
          ...
      inpCubeN: CubeStruct [1,1] - object to get the additional data from

  properties:
      checkType: logical[1,1] - if true, union is only performed when the
          types of relations is the same. Default value is false

      checkStruct: logical[1,nStruct] - an array of indicators which when
         true force checking of structure content (including presence of
all required fields). The first element correspod to SData, the
         second and the third (if specified) to SIsNull and SIsValueNull
         correspondingly

      checkConsistency: logical [1,1]/[1,2] - the
          first element defines if a consistency between the value
          elements (data, isNull and isValueNull) is checked;
          the second element (if specified) defines if
          value's type is checked. If isConsistencyChecked
          is scalar, it is automatically replicated to form a
          two-element vector.
          Note: default value is true
\end{verbatim}
