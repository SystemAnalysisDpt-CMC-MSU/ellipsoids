\section{Operations with Ellipsoids}
In the {\it Ellipsoidal Toolbox} we define a new class {\tt ellipsoid} inside
the MATLAB programming environment. The following three commands
define the same ellipsoid $\EE(q,Q)$, with $q\in{\bf R}^n$ and
$Q\in{\bf R}^{n\times n}$ being symmetric positive semidefinite:

{\tt >> E = ellipsoid(q, Q);}
\newline
{\tt >> E = ellipsoid(Q) + q;}
\newline
{\tt >> E = sqrtm(Q)*ell\_unitball(size(Q, 1)) + q;}

For the {\tt ellipsoid} class we overload the following functions and operators:
\begin{itemize}
\item {\tt isempty(E)} - checks if {\tt E} is an empty ellipsoid.
\item {\tt display(E)} - displays the details of ellipsoid $\EE(q,Q)$, namely,
its center $q$ and the shape matrix $Q$.
\item {\tt plot(E)} - plots ellipsoid $\EE(q,Q)$ if its dimension is not greater
than 3.
\item {\tt E1 == E2} - checks if ellipsoids $\EE(q_1,Q_1)$ and
$\EE(q_2,Q_2)$ are equal.
\item {\tt E1 \~{ }= E2} - checks if ellipsoids $\EE(q_1,Q_1)$ and
$\EE(q_2,Q_2)$ are not equal.
\item {\tt [ , ]} - concatenates the ellipsoids into the horizontal array, e.g.
{\tt EE = [E1 E2 E3]}.
\item {\tt [ ; ]} - concatenates the ellipsoids into the vertical array, e.g.
{\tt EE = [E1 E2; E3 E4]} defines $2\times 2$ array of ellipsoids.
\item {\tt E1 >= E2} - checks if the ellipsoid $\EE(q_1,Q_1)$ is bigger than
the ellipsoid $\EE(q_2,Q_2)$, or equivalently $\EE(0,Q_1)\subseteq\EE(0,Q_2)$.
\item {\tt E1 <= E2} - checks if $\EE(0,Q_2)\subseteq\EE(0,Q_1)$.
\item {\tt -E} - defines ellipsoid $\EE(-q,Q)$.
\item {\tt E + b} - defines ellipsoid $\EE(q+b,Q)$.
\item {\tt E - b} - defines ellipsoid $\EE(q-b,Q)$.
\item {\tt A * E} - defines ellipsoid $\EE(q,AQA^T)$.
\item {\tt inv(E)} - inverts the shape matrix of the ellipsoid: $\EE(q,Q^{-1})$.
\end{itemize}
All the listed operations can be applied to a single ellipsoid as well as to
a two-dimensional array of ellipsoids.
For example,
{\tt \begin{verbatim}
>> E1 = ellipsoid([2; -1], [9 -5; -5 4]);  % nondegenerate ellipsoid in R^2
>> E2 = polar(E1);  % E2 is polar ellipsoid for E1
>> E3 = inv(E2);  % E3 is generated from E2 by inverting its shape matrix
>> EE = [E1 E2; E3 ellipsoid([1; 1], eye(2))];  % 2x2 array of ellipsoids
>> EE <= E1  % check if E1 is bigger than each of the ellipsoids in EE

ans =

     1     0
     1     0
\end{verbatim} }
To access individual elements of the array, the usual MATLAB subindexing
is used:
{\tt \begin{verbatim}
>> A = [0 1; -2 0]; b = [3; 0];  % A - 2x2 real matrix, b - vector in R^2
>> AT = A * EE(:, 2) + b;  % affine transformation of ellipsoids in the second column of EE
\end{verbatim} }
Sometimes it may be useful to modify the shape of the ellipsoid without
affecting its center. Say, we would like to bloat or squeeze the ellipsoid:
{\tt \begin{verbatim}
>> BLT = shape(E1, 2);  % bloats ellipsoid E1
>> SQZ = shape(E1, 0.5);  % squeezes ellipsoid E1
\end{verbatim} }
Since function {\tt shape} does not change the center of the ellipsoid,
it only accepts scalars or square matrices as its second input parameter.

Several functions  access the internal data of
the ellipsoid object:
{\tt \begin{verbatim}
>> [q, Q] = double(E2)  % get the center and the shape matrix of E2

q =

   -0.5000
   -0.1667

Q =

   0.9167     0.9167
   0.9167     1.5278

>> D = ellipsoid([42 -7 -2 4; -7 10 3 1; -2 3 5 -2; 4 1 -2 2]);  % define new ellipsoid
>> isdegenerate([EE(1, :) D])  % check if given ellipsoids are degenerate

ans =

     0     0     1

>> [n, r] = dimension([EE(1, :) D])  % get space dimensions and ranks of the shape matrices

n =

   2     2     4

r =

   2     2     3
\end{verbatim} }
One way to check if two ellipsoids intersect, is to compute
the distance between them:
{\tt \begin{verbatim}
>> distance(EE, E3)  % distance between E3 and each of the ellipsoids in EE

ans =
     0         0
     0    0.1683
\end{verbatim} }
This result indicates that the ellipsoid {\tt E3} does not intersect with
the ellipsoid {\tt EE(2, 2)}, with all the other ellipsoids in {\tt EE}
it has nonempty intersection. If the intersection of the two ellipsoids is
nonempty, it can be approximated by ellipsoids from the outside as well as
from the inside:
{\tt \begin{verbatim}
>> EA = intersection_ea(E1, E3);  % external approximation of intersection of E1 and E3
>> IA = intersection_ia(E1, E3);  % internal approximation of intersection of E1 and E3
\end{verbatim} }
It can be checked that resulting ellipsoid {\tt EA} contains the given
intersection, whereas {\tt IA} is contained in this intersection:
{\tt \begin{verbatim}
>> isinside(EA, [E1 E3], 'i')  % array [E1 E3] should be treated as intersection

ans =

     1

>> isinside([E1 E3], IA)  % check if IA belongs to the intersection of E1 and E3

ans =

     1
\end{verbatim} }
Function {\tt isinside} in general checks if the intersection of ellipsoids
in the given array contains the union or intersection of ellipsoids or
polytopes.

It is also possible to solve the feasibility problem, that is, to check
if the intersection of more than two ellipsoids is empty:
{\tt \begin{verbatim}
>> intersect(EE, EE(1, 1), 'i')  % check if the intersection of ellipsoids in EE is empty

ans =

     -1
\end{verbatim} }
In this particular example the result $-1$ indicates that the intersection
of ellipsoids in {\tt EE} is empty.
Function {\tt intersect} in general checks if an ellipsoid,
hyperplane or polytope intersects the union or the intersection
of ellipsoids in the given array:
{\tt \begin{verbatim}
>> % check if EE(2, 2) intersects the intersection of E1, E2 and E3:
>> intersect([E1 E2 E3], EE(2, 2), 'i')

ans =

     0

>> % check if E(2, 2) intersects the union of E1, E2 and E3:
>> intersect([E1 E2 E3], EE(2, 2), 'u')

ans =

     1
\end{verbatim} }
For the ellipsoids in ${\bf R}$, ${\bf R}^2$ and ${\bf R}^3$ the geometric
sum can be computed explicitely and plotted:
{\tt \begin{verbatim}
>> minksum(EE);  % compute and plot the geometric sum of ellipsoids in EE
\end{verbatim} }
If the dimension of the space in which the ellipsoids are defined exceeds $3$,
an error is returned. The result of the geometric sum operation is
not generally an ellipsoid, but it can be approximated by families
of external and internal ellipsoids parametrized by the direction vector:
{\tt \begin{verbatim}
>> % define the set of directions:
>> L = [1 0; 1 1; 0 1; -1 1; 1 3]';  % columns of matrix L are vectors in R^2
>>
>> EA = minksum_ea(EE, L)  % compute external ellipsoids for the directions in L

EA =
1x5 array of ellipsoids.

>> IA = minksum_ia(EE, L)  % compute internal ellipsoids for the directions in L

IA =
1x5 array of ellipsoids.

>> % intersection of external ellipsoids should always contain
>> % the union of internal ellipsoids:
>> isinside(EA, IA, 'u')

ans =

     1
\end{verbatim} }
Functions {\tt minksum\_ea} and {\tt minksum\_ia} work for ellipsoids of
arbitrary dimension. They should be used for general computations
whereas {\tt minksum} is there merely for visualization purposes.

If the geometric difference of two ellipsoids is not an empty set, it can
be computed explicitely and plotted for ellipsoids in ${\bf R}$,
${\bf R}^2$ and ${\bf R}^3$:
{\tt \begin{verbatim}
>> E4 = shape(EE(2, 2), 0.4);  % ellipsoid defined by squeezing the ellipsoid EE(2, 2)
>> E1 >= E4  % check if the geometric difference E1 - E4 is nonempty

ans =

     1

>> minkdiff(E1, E4);  % compute and plot this geometric difference
\end{verbatim} }
Similar to {\tt minksum}, {\tt minkdiff} is there for visualization
purpose. It works only for dimensions $1$, $2$ and $3$, and for higher
dimensions it returns an error. For arbitrary dimensions, the geometric
difference can be approximated by  families of external and internal
ellipsoids parametrized by the direction vector, provided this direction
is not bad:
{\tt \begin{verbatim}
>> isbaddirection(E1, E4, L)  % find out which of the directions in L are bad

ans =

     1     0     0     1     0

>> % two of five directions specified by L are bad,
>> % so, only three ellipsoidal approximations can be produced for this L:
>> EA = minkdiff_ea(E1, E4, L)

EA =
1x3 array of ellipsoids.

>> IA = minkdiff_ia(E1, E4, L)

IA =
1x3 array of ellipsoids.
\end{verbatim} }
Operation 'difference-sum' described in section 2.2.4 is implemented in
functions {\tt minkmp}, {\tt minkmp\_ea}, {\tt minkmp\_ia}, the first one of
which is used for visualization and works for dimensions not higher than $3$,
whereas the last two can deal with ellipsoids of arbitrary dimension.
{\tt \begin{verbatim}
>> % ellipsoidal approximations for (E1 - E3 + E2)
>> EA = minkmp_ea(E1, E3, E2, L)  % external

EA =
1x5 array of ellipsoids.

>> IA = minkmp_ia(E1, E3, E2, L)  % internal

IA =
1x5 array of ellipsoids.

>> minkmp(E1, E3, E2);  % plot the set (E1 - E3 + E2)
\end{verbatim} }
Similarly, operation 'sum-difference' described in section 2.2.5
is implemented in
functions {\tt minkpm}, {\tt minkpm\_ea}, {\tt minkpm\_ia}, the first one of
which is used for visualization and works for dimensions not higher than $3$,
whereas the last two can deal with ellipsoids of arbitrary dimension.
{\tt \begin{verbatim}
>> % ellipsoidal approximations for (E1 + E2 - E3)
>> EA = minkpm_ea([E1 E2], E3, L)  % external

EA =
1x5 array of ellipsoids.

>> IA = minkpm_ia([E1 E2], E3, L)  % internal

IA =
1x4 array of ellipsoids.

>> minkpm(E1, E2, E3);  % plot the set (E1 + E2 - E3)
\end{verbatim} }
Function {\tt ellunion\_ea} computes the minimum volume ellipsoid
containing the union of given ellipsoids.
Function {\tt ellintersection\_ia} computes the maximum volume ellipsoid
contained in the intersection of given ellipsoids.
If the intersection is empty, an empty ellipsoid object is returned.
{\tt \begin{verbatim}
>> % compute minimum volume external ellipsoid for union
>> U = ellunion_ea([E1 E2 E3]);
>> % compute maximum volume internal ellipsoid for intersection
>> I = ellintersection_ia([E1 E2 E3]);
\end{verbatim} }

The class {\tt hyperplane} of the {\it Ellipsoidal Toolbox} is used
to describe hyperplanes and halfspaces. The following two commands
define one and the same hyperplane but two different halfspaces:
{\tt \begin{verbatim}
>> H = hyperplane([1; 1], 1);  % defines halfspace x1 + x2 <= 1
>> H = hyperplane([-1; -1], -1);  % defines halfspace x1 + x2 >= 1
\end{verbatim} }
The following functions and operators are overloaded for the
{\tt hyperplane} class:
\begin{itemize}
\item {\tt isempty(H)} - checks if {\tt H} is an empty hyperplane.
\item {\tt display(H)} - displays the details of hyperplane $H(c,\gamma)$,
namely, its normal $c$ and the scalar $\gamma$.
\item {\tt plot(H)} - plots hyperplane $H(c,\gamma)$ if the dimension of the
space in which it is defined  is not greater than 3.
\item {\tt H1 == H2} - checks if hyperplanes $H(c_1,\gamma_1)$ and
$H(c_2,\gamma_2)$ are equal.
\item {\tt H1 \~{ }= H2} - checks if hyperplanes $H(c_1,\gamma_1)$ and
$H(c_2,\gamma_2)$ are not equal.
\item {\tt [ , ]} - concatenates the hyperplanes into the horizontal array, e.g.
{\tt HH = [H1 H2 H3]}.
\item {\tt [ ; ]} - concatenates the hyperplanes into the vertical array, e.g.
{\tt HH = [H1 H2; H3 H4]} - defines $2\times 2$ array of hyperplanes.
\item {\tt -H} - defines hyperplane $H(-c,-\gamma)$, which is the same
as $H(c,\gamma)$ but specifies different halfspace.
\end{itemize}
There are several ways to access the internal data of the {\tt hyperplane}
object:
{\tt \begin{verbatim}
>> [c, g] = double(H)  % get the normal and the scalar that define hyperplane H

c =

   -1
   -1

g =

   -1

>> dimension(H)  % get the dimension of the space where H is defined

ans =

     2

>> H0 = hyperplane([1 -1; 1 1]);  % define two hyperplanes passing through the origin
>> isparallel(H, H0)  % check which of two hyperplanes in array H0 is parallel to H

ans =

     1     0
\end{verbatim} }
All the functions of {\it Ellipsoidal Toolbox} that accept {\tt hyperplane}
object as parameter, work with single hyperplanes as well as with hyperplane
arrays. One exception is the function {\tt parameters} that allows only
single {\tt hyperplane} object.

An array of hyperplanes can be converted to the {\tt polytope} object of the
Multi-Parametric Toolbox (\cite{morari04, mpt}), and back:
{\tt \begin{verbatim}
>> define array of four hyperplanes:
>> HH = hyperplane([1 1; -1 -1; 1 -1; -1 1]', [2 2 2 2]);

HH =
1x4 array of hyperplanes.

>> P  = hyperplane2polytope(HH);  % convert array of hyperplanes to polytope
>> HP = polytope2hyperplane(P);  % covert polytope to array of hyperplanes
>> HP == HH

ans =

     1     1     1     1
\end{verbatim} }
Functions {\tt hyperplane2polytope} and {\tt polytope2hyperplane} require
the Multi-Parametric Toolbox to be installed.

We can compute distance from ellipsoids to hyperplanes and polytopes:
{\tt \begin{verbatim}
>> distance(E1, HH)  % distance from ellipsoid E1 to each of the hyperplanes in HH

ans =

     -0.5176    0.8966   -2.6841    0.1444

>> distance(EE, P)  % distance from each of the ellipsoids in EE to the polytope P

ans =

     0     0
     0     0
\end{verbatim} }
A negative distance value in the case of ellipsoid and hyperplane means that
the ellipsoid intersects the hyperplane. As we see in this example, ellipsoid
{\tt E1} intersects  hyperplanes {\tt H(1)} and {\tt H(3)} and has
no common points with {\tt H(2)} and {\tt H(4)}. When {\tt distance} function
has a polytope as a parameter, it always returns nonnegative values to be
consistent with {\tt distance} function of the Multi-Parametric Toolbox.
Here, the zero distance values mean that each ellipsoid in {\tt EE} has
nonempty intersection with polytope {\tt P}.

It can be checked if the union or intersection of given ellipsoids intersects
given hyperplanes or polytopes:
{\tt \begin{verbatim}
>> % check if the union of ellipsoids in EE intersects  hyperplanes in HH:
>> intersect(EE, HH)

ans =

     1     1     1     1

>> % check if the intersection of ellipsoids in the first column of EE
>> % intersects with hyperplanes in HH:
>> intersect(EE(:, 1), HH, 'i')

ans =

     0     0     1     0

>> % check if the intersection of ellipsoids E1, E2 and E3
>> % intersects with polytope P:
>> intersect([E1 E2 E3], P, 'i')

ans =

     1
\end{verbatim} }
The intersection of ellipsoid and hyperplane can be computed exactly:
{\tt \begin{verbatim}
>> % compute the intersections of ellipsoids in the first column of EE
>> % with hyperplane H(3):
>> I = hpintersection(EE(:, 1), H(3))

I =
2x1 array of ellipsoids.

>> isdegenerate(I)  % resulting ellipsoids should lose rank

ans =

     1
     1
\end{verbatim} }
Functions {\tt intersection\_ea} and {\tt intersection\_ia} can be used
with {\tt hyperplane} objects, which in this case define halfspaces and
{\tt polytope} objects:
{\tt \begin{verbatim}
>> % compute external and internal ellipsoidal approximations
>> % of the intersections of ellipsoids in the first column of EE
>> % with the halfspace x1 - x2 <= 2:
>> EA1 = intersection_ea(EE(:, 1), H(3))  % get external ellipsoids

EA1 =
2x1 array of ellipsoids.
>> IA1 = intersection_ia(EE(:, 1), H(3))  % get internal ellipsoids

IA1 =
2x1 array of ellipsoids.

>> % compute external and internal ellipsoidal approximations
>> % of the intersections of ellipsoids in the first column of EE
>> % with the halfspace x1 - x2 >= 2:
>> EA2 = intersection_ea(EE(:, 1), -H(3));  % get external ellipsoids
>> IA2 = intersection_ia(EE(:, 1), -H(3));  % get internal ellipsoids

>> % compute ellipsoidal approximations of the intersection
>> % of ellipsoid E1 and polytope P:
>> EA = intersection_ea(E1, P);  % get external ellipsoid
>> IA = intersection_ia(E1, P);  % get internal ellipsoid
\end{verbatim} }
Function {\tt isinside} can be used to check if a polytope or union of
polytopes is contained in the intersection of given ellipsoids:
{\tt \begin{verbatim}
>> Q = 0.5*P + [1; 1];  % polytope Q is obtained by affine transformation of P
>>
>> % check if the intersection of ellipsoids in the first column of EE
>> % contains the union of polytopes P and Q:
>> isinside(EE(:, 1), [P Q])  % equivalent to: isinside(EE(:, 1), P | Q)

ans =

     0

>> % check if ellipsoid EE(2, 2) contains the intersection of P and Q:
>> isinside(EE(2, 2), [P Q], 'i')  % equivalent to: isinside(EE(2, 2), P & Q)

ans =

     1
\end{verbatim} }
Functions {\tt distance}, {\tt intersect}, {\tt intersection\_ia} and
{\tt isinside} use the YALMIP interface (\cite{yalmip, yalmiphp}) to the
external optimization package. The default optimization package included
in the distribution of the {\it Ellipsoidal Toolbox} is SeDuMi
(\cite{sedumi, sedumihp}). The user, however, is free to choose
any other optimization tool that solves second order cone programming (SOCP)
problems, as long as this tool is supported by YALMIP. QCQP is a special case
of SOCP.



\section{Reachability}
To compute the reach sets of the systems described
in Chapter \ref{ch_reachability}, we define
two new classes in the {\it Ellipsoidal Toolbox}: class {\tt linsys} for the
system description, and class {\tt reach} for the reach set data.
We start by explaining how to define a system using {\tt linsys} object.
For example, description of the system
\[ \left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 & 1\\
0 & 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right], ~~~ u(t)\in\EE(p(t), P) \]
with
\[ p(t) = \left[\begin{array}{c}
\sin(t)\\
\cos(t)\end{array}\right], ~~~ P = \left[\begin{array}{cc}
9 & 0\\
0 & 2\end{array}\right], \]
is done by the following sequence of commands:
{\tt \begin{verbatim}
>> A = [0 1; 0 0]; B = eye(2);  % matrices A and B, B is identity
>> U.center = {'sin(t)'; 'cos(t)'};  % center of the ellipsoid depends on t
>> U.shape = [9 0; 0 2];  % shape matrix of the ellipsoid is static
>> sys = linsys(A, B, U);  % create linear system object
\end{verbatim} }
If matrices $A$ or $B$ depend on time, say $A(t)=\left[\begin{array}{cc}
0 & 1-\cos(2t)\\
-\frac{1}{t} & 0\end{array}\right]$, then matrix {\tt A} should be symbolic:
{\tt \begin{verbatim}
>> At = {'0' '1 - cos(2*t)'; '-1/t' '0'};  % A(t) - time-variant
>> sys_t = linsys(At, B, U);
\end{verbatim} }
To describe the system with disturbance
\[ \left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 & 1\\
0 & 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]v(t), \]
with bounds on control as before, and disturbance being $-1\leq v(t)\leq1$,
we type:
{\tt \begin{verbatim}
>> G = [0; 1];  % matrix G
>> V = ellipsoid(1);  % disturbance bounds: unit ball in R
>> sys_d = linsys(A, B, U, G, V);
\end{verbatim} }
Control and disturbance bounds {\tt U} and {\tt V} can have different types.
If the bound is constant, it should be described by {\tt ellipsoid} object.
If the bound depends on time, then it is represented by a structure with
fields {\tt center} and {\tt shape}, one or both of which are symbolic.
In system {\tt sys}, the control bound {\tt U} is defined as such a structure.
Finally, if the control or disturbance is known and fixed, it should be
defined as a vector, of type {\tt double} if constant, or symbolic, if
it depends on time.

To declare a discrete-time system
\[ \left[\begin{array}{c}
x_1[k+1]\\
x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
0 & 1\\
-1 & -0.5\end{array}\right]\left[\begin{array}{c}
x_1[k]\\
x_2[k]\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]u[k], ~~~ -1\leq u[k]\leq 1,\]
we use the same {\tt linsys} constructor:
{\tt \begin{verbatim}
>> Ad = [0 1; -1 -0.5]; Bd = [0; 1];  % matrices A and B
>> Ud  = ellipsoid(1);  % control bounds: unit ball in R
>> dtsys = linsys(Ad, Bd, Ud, [], [], [], [], 'd');  % discrete-time system
\end{verbatim} }
Once the {\tt linsys} object is created, we need to specify the set
of initial conditions, the time interval and values of the direction vector,
for which the reach set approximations must be computed:
{\tt \begin{verbatim}
>> X0 = ell_unitball(2)  % set of initial conditions
>> T = [0 10]  % time interval
>> L = [1 0; 0 1]';  % columns of L specify the directions
\end{verbatim} }
The reach set approximation is computed by calling the constructor
of the {\tt reach} object:
{\tt \begin{verbatim}
>> options.save_all = 1  % turn on save_all option (its default value is 0)
>> rs = reach(sys, X0, L, T, options);  % reach set of continuos-time system
\end{verbatim} }
The {\tt options} parameter in the {\tt reach()} call is optional.
We shall soon explain why we used it here.
At this point, variable {\tt rs} contains the reach set approximations for the
specified continuous-time system, time interval and set of initial conditions
computed for given directions. By default, both external and internal
approximations are computed. To compute only external or only internal
approximations, {\tt options} structure must contain
another field - {\tt approximation}.
For only external approximations, this field
must be set to $0$, for only internal approximations, it must be set to $1$.
The reach set approximation data can be
extracted in the form of arrays of ellipsoids:
{\tt \begin{verbatim}
>> EA = get_ea(rs)  % external approximating ellipsoids

EA =
4x200 array of ellipsoids.

>> [IA, tt] = get_ia(rs);  % internal approximating ellipsoids
\end{verbatim} }
Ellipsoidal arrays {\tt EA} and {\tt IA} have $4$ rows because we computed
the reach set approximations for $4$ directions. Each row of ellipsoids
corresponds to one direction. The number of columns in {\tt EA} and {\tt IA}
is defined by the {\tt time\_grid} parameter of the global {\tt ellOptions}
structure (see Chapter \ref{ch_objects} for details).
It represents the number of time values
in our time interval, at which the approximations are evaluated. These
time values are returned in the optinal output parameter, array {\tt tt},
whose length is the same as the number of columns in {\tt EA} and {\tt IA}.
Intersection of ellipsoids in a particular column of {\tt EA} gives
external ellipsoidal approximation of the reach set at corresponding time.
Internal ellipsoidal approximation of this set at this time is given by the
union of ellipsoids in the same column of {\tt IA}.

We may be interested in the reachability data of our system in some
particular time interval, smaller than the one for which the reach set was
computed, say $3\leq t\leq5$.
This data can be extracted and returned in the form of {\tt reach}
object by the {\tt cut} function:
{\tt \begin{verbatim}
>> ct = cut(rs, [3 5]);  % reach set for the time interval [3, 5]
\end{verbatim} }
To obtain a snap shot of the reach set at given time, the same function
{\tt cut} is used:
{\tt \begin{verbatim}
>> ct = cut(rs, 5);  % reach set at time t = 5
\end{verbatim} }
It can be checked if the external or internal reach set approximation
intersects with given ellipsoids, hyperplanes or polytopes:
{\tt \begin{verbatim}
>> E = ellipsoid([-17; 0], [4 -1; -1 1]);  % define ellipsoid
>> HH = hyperplane([1 1; -1 -1; 1 -1; -1 1]', [2 2 2 2]);  % define 4 hyperplanes
>> P = hyperplane2polytope(HH) + [2; 10];  % define polytope
>> % check if ellipsoid E intersects with external approximation:
>> intersect(ct, E, 'e')

ans =

     1

>> % check if ellipsoid E intersects with internal approximation:
>> intersect(ct, E, 'i')

ans =

     0

>> % check if hyperplanes in HH intersect with internal approximation:
>> intersect(ct, HH, 'i')

ans =

     1     1     1     1

>> % check if polytope P intersects with external approximation:
>> intersect(ct, P)

ans =

     0
\end{verbatim} }
If a given set intersects with the internal approximation of the reach set,
then this set intersects with the actual reach set.
If the given set does not
intersect with external approximation, this set does not
intersect the actual reach set. There are situations, however, when the
given set intersects with the external approximation but does not intersect
with the internal one. In our example above, ellipsoid {\tt E} is such a case:
the quality of the approximation does not allow us to determine whether or not
{\tt E} intersects with the actual reach set. To improve the quality
of approximation, {\tt refine} function should be used:
{\tt \begin{verbatim}
>> L1 = [1; -1];  % define new directions, in this case one, but could be more
>> rs = refine(rs, L1);  % compute approximations for the new directions
>> ct = cut(rs, 5);  % snap shot of the reach set at time t = 5
>> intersect(ct, E, 'i')  % check if E intersects the internal approximation

ans =

     1
\end{verbatim} }
Now we are sure that ellipsoid {\tt E} intersects with the actual reach set.
Recall that when we computed reach set {\tt rs} the first time, we did it
with the option {\tt save\_all} set to $1$. This option indicated to the
{\tt reach} constructor that it should save all intermediate calculations of
data in the {\tt reach} object {\tt rs}. These data include evaluations
of matrices $A$, $B$, $G$ at specific time values (in case these
matrices depend on time) together with the control and disturbance
bounds, the state transition matrix and its inverse evaluated at
these time values.
By default, {\tt save\_all} option is set to $0$, and all these intermediate
data are not retained, which significantly reduces the memory used
by the {\tt reach} object {\tt rs}. However, to use the {\tt refine} function,
the reach set object must contain all calculated data, otherwise, an
error is returned.

Having a reach set object resulting from the {\tt reach}, {\tt cut} or
{\tt refine} operations, we can obtain the trajectory of the center
of the reach set and the good curves along which the actual reach set
is touched by its ellipsoidal approximations:
{\tt \begin{verbatim}
>> [ctr, tt] = get_center(rs);  % trajectory of the center
>> gc = get_goodcurves(rs)  % get good curves

gc =
    [2x200 double]   [2x200 double]   [2x200 double]   [2x200 double]   [2x200 double]
\end{verbatim} }
Variable {\tt ctr} here is a matrix whose columns are the points ofthe
reach set center trajectory evaluated at time values returned in the
array {\tt tt}. Variable {\tt gc} contains $4$ matrices each of which
corresponds to a good curve (columns of such matrix are points of the
good curve evaluated at time values in {\tt tt}).
The analytic expression for the control driving the system along a good
curve is given by formula (\ref{uct}).

We computed the reach set up to time $10$. It is possible to continue
the reach set computation for a longer time horizon using the reach set
data at time $10$ as initial condition.
It is also possible that the dynamics and inputs of the system change at
certain time, and from that point on the system evolves according to the new
system of differential equations. For example, starting at time $10$, our
reach set may evolve in time according to the time-variant system {\tt sys\_t}
defined above. Switched systems are a special case of this situation.
To compute the further evolution in time of the existing reach set,
function {\tt evolve} should be used:
{\tt \begin{verbatim}
>> rs2 = evolve(rs, 15);  % reach set from time 10 to 15 with the same dynamics
>> rs2 = evolve(rs, 15, sys_t);  % reach set from time 10 to 15 with new dynamics
>>
>> % not only the dynamics, but the inputs can change as well,
>> % from time 15 to 20 disturbance is added to the system:
>> rs3 = evolve(rs2, 20 sys_d);  % sys_d - system with disturbance defined above
\end{verbatim} }
Function {\tt evolve} can be viewed as an implementation of the semigroup
property.

To compute the backward reach set for some specified target set,
we declare the time interval so that the terminating time comes first:
{\tt \begin{verbatim}
>> Y = ellipsoid([8; 2], [4 1; 1 2]);  % target set in the form of ellipsoid
>> Tb = [10 5];  % backward time interval
>> brs = reach(sys, Y, L, Tb, options);  % backward reach set
>> brs = refine(brs, L1);  % refine the approximation
>> brs2 = evolve(brs, 0);  % further evolution in backward time from 5 to 0
\end{verbatim} }
Reach set and backward reach set computation for discrete-time systems and
manipulations with the resulting reach set object are performed using
the same functions as for continuous-time systems:
{\tt \begin{verbatim}
>> T = [0 100];  % represents 100 time steps from 1 to 100
>> dtrs = reach(dtsys, X0, L, T);  % reach set for 100 time steps
>> dtrs2 = evolve(dtrs, 200);  % compute next 100 time steps
>>
>> Tb = [50 0];  % backward time interval
>> dtbrs = reach(dtsys, Y, L, Tb, options)  % backward reach set
>> dtbrs = refine(dtbrs, L1);  % refine the approximation
>> [EA, tt] = get_ea(dtbrs);  % get external approximating ellipsoids and time values
>> IA = get_ia(dtbrs)  % get internal approximating ellipsoids

IA =
5x51 array of ellipsoids.
\end{verbatim} }
Number of columns in the ellipsoidal arrays {\tt EA} and {\tt IA} is $51$
because the backward reach set is computed for $50$ time steps, and the first
column of these arrays contains $5$ ellipsoids {\tt Y} - the terminating
condition.

When dealing with discrete-time systems, all functions that accept time or
time interval as an input parameter, round the time values and treat them as
integers.



\section{Visualization}
{\it Ellipsoidal Toolbox} has several plotting routines:
\begin{itemize}
\item {\tt ellipsoid/plot} - plots one or more ellipsoids, or arrays of
ellipsoids, defined in ${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minksum} - plots geometric sum of finite number of
ellipsoids defined in ${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minkdiff} - plots geometric difference
(if it is not an empty set) of two ellipsoids defined in
${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minkmp} - plots geometric (Minkowski) sum
of the geometric difference of two ellipsoids and the geometric sum of $n$
ellipsoids defined in ${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minkpm} - plots geometric (Minkowski) difference of the
geometric sum of ellipsoids and a single ellipsoid defined in
${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt hyperplane/plot} - plots one or more hyperplanes, or arrays of
hyperplanes, defined in ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt reach/plot\_ea} - plots external approximation of the reach set
whose dimension is $2$ or $3$.
\item {\tt reach/plot\_ia} - plots internal approximation of the reach set
whose dimension is $2$ or $3$.
\end{itemize}
All these functions allow the user to specify the color of the plotted objects,
line width for 1D and 2D plots, and transparency level of the 3D objects.
Hyperplanes are displayed as line segments in 2D and square facets in 3D.
In the {\tt hyperplane/plot} method it is possible to specify the center
of the line segment or facet and its size.

Ellipsoids of dimensions higher than three must be
projected onto a two- or three-dimensional subspace before being plotted.
This is done by means of {\tt projection} function:
{\tt \begin{verbatim}
>> % create two 4-dimensional ellipsoids:
>> E1 = ellipsoid([14 -4 2 -5; -4 6 0 1; 2 0 6 -1; -5 1 -1 2]);
>> E2 = inv(E1);
>>
>> % specify 3-dimensional subspace by its basis:
>> BB = [1 0 0 0; 0 0 1 0; 0 1 0 1]';  % columns of BB must be orthogonal
>>
>> % get 3-dimensional projections of E1 and E2:
>> PP = projection([E1 E2], B)  % array PP contains projections of E1 and E2

PP =
1x2 array of ellipsoids.

>> plot(PP);  % plot ellipsoids in PP
\end{verbatim} }
Since the operation of projection is linear, the projection of the geometric
sum of ellipsoids equals the geometric sum of the projected ellipsoids.
The same is true for the geometric difference of two ellipsoids.

Function {\tt projection} exists also for the {\tt reach} objects:
{\tt \begin{verbatim}
>> A = [0 1 0 0; -1 0 1 0; 0 0 0 1; 0 0 -1 0];
>> B = [0; 0; 0; 1];
>> U = ellipsoid(1);
>> sys = linsys(A, B, U);  % 4-dimensional system
>> L  = [1 1 0 1; 0 -1 1 0; -1 1 1 1; 0 0 -1 1]'; % matrix of directions
>> rs = reach(sys, ell_unitball(4), L, 5);  % reach set from time 0 to 5
>> BB = [1 0 0 1; 0 1 1 0]';  % basis of 2-dimensional subspace
>> ps = projection(rs, BB);  % project reach set rs onto basis BB
>> plot_ea(ps);  % plot external approximation
>> hold on;
>> plot_ia(ps);  % plot internal approximation
\end{verbatim} }
The quality of the ellipsoid and reach set plots is controlled by the
parameters {\tt plot2d\_grid} and {\tt plot3d\_grid} of the global
{\tt ellOptions} structure (see Chapter \ref{ch_objects}).





