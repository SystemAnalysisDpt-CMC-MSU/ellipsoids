\documentclass{report}
%\usepackage{psfrag}
\usepackage[dvips]{epsfig}
\usepackage{epsfig}
\oddsidemargin 0.25in
\evensidemargin 0.25in
\textheight 8.5in
\textwidth 6.0in
\parskip 0.0675in
\parindent 0.0in


\makeatletter
% \@addtoreset{equation}{section}
\makeatother
\tolerance = 5000
\hbadness = 5000
\newtheorem{theo}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{df}{Definition}[section]
\newtheorem{cor}{Corollary}[section]
\newtheorem{assump}{Assumption}[section]
\newtheorem{assert}{Assertion}[section]
\newtheorem{remark}{Remark}[section]
\setlength{\parindent}{0pt}
\setlength{\parskip}{\bigskipamount}
\newcommand{\bl}{\begin{lemma}}
\newcommand{\el}{\end{lemma}}
\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\beqn}{\begin{eqnarray}}
\newcommand{\eeqn}{\end{eqnarray}}
\newcommand{\bt}{\begin{theo}}
\newcommand{\et}{\end{theo}}
\newcommand{\bd}{\begin{df}}
\newcommand{\ed}{\end{df}}
\newcommand{\ba}{\begin{assump}}
\newcommand{\ea}{\end{assump}}
\newcommand{\bass}{\begin{assert}}
\newcommand{\eass}{\end{assert}}
\newcommand{\brem}{\begin{remark}}
\newcommand{\erem}{\end{remark}}
\newcommand{\bc}{\begin{cor}}
\newcommand{\ec}{\end{cor}}
\newcommand{\dR}{\mbox{\rm I\hspace*{-.2em}R}}
\newcommand{\DR}{\mbox{\rm I\hspace*{-.2em}R}}
\newcommand{\EE}{{\cal E}}
\newcommand{\FF}{{\cal F}}
\newcommand{\HH}{{\cal H}}
\newcommand{\II}{{\cal I}}
\newcommand{\MM}{{\cal M}}
\newcommand{\PP}{{\cal P}}
\newcommand{\QQ}{{\cal Q}}
\newcommand{\RR}{{\cal R}}
\newcommand{\UU}{{\cal U}}
\newcommand{\VV}{{\cal V}}
\newcommand{\WW}{{\cal W}}
\newcommand{\XX}{{\cal X}}
\newcommand{\YY}{{\cal Y}}
\newcommand{\ZZ}{{\cal Z}}
\newcommand{\dm}{\dot{-}}

\title{
\begin{figure}[htbp]
\centerline{
\includegraphics[height=5 cm]{logo.eps}}
\end{figure}
ELLIPSOIDAL TOOLBOX\thanks{Research supported by NSF Grant CCR-00225610.}\\
Manual
\author{Alex A. Kurzhanskiy and Pravin Varaiya}
\date{2006-2007}
}

\begin{document}
\maketitle
\tableofcontents



\chapter{Introduction}
Research on dynamical and hybrid systems has produced several methods
for verification and controller synthesis.
A common step in these methods is the reachability analysis of the system.
Reachability analysis is concerned with the  computation of the reach set
in  a way that can effectively meet requests like the following:
\begin{enumerate}
\item For a given target set and time, determine whether
the reach set and the target set have nonempty intersection.
\item For specified reachable state and time,
find a feasible initial condition and control that steers the system
from this initial condition to the given reachable state in given time.
\item Graphically display the projection of the reach set onto
any specified two- or three-dimensional subspace.
\end{enumerate}
Except for very specific classes of systems, exact computation of reach sets is
not possible, and approximation techniques are needed.
For controlled linear systems with convex bounds on the control
and initial conditions, the efficiency and accuracy of these techniques depend
on how they represent convex sets and how well they perform the operations
of unions, intersections, geometric (Minkowski) sums and differences
of convex sets.
Two basic objects are used as convex approximations:
polytopes of various types, including general polytopes, zonotopes,
parallelotopes, rectangular polytopes; and ellipsoids.

Reachability analysis for general polytopes is implemented in the
Multi Parametric Toolbox (MPT) for Matlab \cite{morari, mpt}.
The reach set at every time step is computed as the geometric sum
of two polytopes. The procedure consists in finding the vertices
of the resulting polytope and calculating their convex hull.
MPT's convex hull algorithm is based on the Double Description
method \cite{motzkin} and implemented in the CDD/CDD+ package \cite{cdd}.
Its complexity is $V^n$, where $V$ is the number of vertices and $n$ is the
state space dimension. Hence the use of MPT is practicable for low dimensional
systems. But even in low dimensional systems the number of vertices in
the reach set polytope can grow very large with the number
of time steps. For example, consider the  system,
\[ x_{k+1} = Ax_k + u_k ,\]
with $A=\left[\begin{array}{cc}
\cos 1 & -\sin 1\\
\sin 1 & \cos 1\end{array}\right]$,
$u_k \in \{u\in {\bf R}^2 ~|~ \|u\|_{\infty}\leq 1\}$, and
$x_0 \in \{x\in {\bf R}^2 ~|~ \|x\|_{\infty}\leq 1\}$. Starting with a
rectangular initial set, the number of vertices of the reach set polytope
is $4k + 4$ at the $k$th step.

In $d/dt$ \cite{ddt},
the reach set is approximated by unions of rectangular polytopes \cite{maler}.
\begin{figure}[htbp]
\centerline{
\includegraphics[width=6.5 cm, height=8 cm]{ddt.eps}}
\caption{Reach set approximation by union of rectangles.
Source: adapted from \cite{maler}.}
\label{ddtfig}
\end{figure}
The algorithm works as follows. First, given the set of initial conditions
defined as a polytope, the evolution in time of the polytope's extreme points
is computed (figure \ref{ddtfig}(a)).
$R(t_1)$ in figure \ref{ddtfig}(a) is the
reach set of the system at time $t_1$, and $R[t_0, t_1]$ is the set of all
points that can be reached during $[t_0, t_1]$. Second, the
algorithm computes the convex hull of vertices of both, the initial polytope
and $R(t_1)$ (figure \ref{ddtfig}(b)).
The resulting polytope is then bloated to include
all the reachable states in $[t_0,t_1]$
(figure \ref{ddtfig}(c)). Finally, this overapproximating polytope is in its
turn overapproximated by the union of rectangles (figure \ref{ddtfig}(d)).
The same procedure is repeated for the next time interval $[t_1,t_2]$, and
the union of both rectangular approximations is taken
(figure \ref{ddtfig}(e,f)), and so on.
Rectangular polytopes are easy to represent and the number
of facets grows linearly with dimension, but a large number of rectangles
must be used to assure the approximation is not overly conservative.
Besides, the important part of this method is again the convex hull
calculation whose implementation relies on the same CDD/CDD+
library. This limits the dimension of the system and time interval
for which it is feasible to calculate the reach set.

Polytopes can give arbitrarily close approximations to any convex set,
but the number of vertices can grow prohibitively large and,
as shown in \cite{avis}, the computation of a polytope by its convex hull
becomes intractable for large number of vertices in high dimensions.

The method of zonotopes for approximation of reach sets
\cite{girard, leguernic, matisse} uses a special class of polytopes
(see \cite{zonotool}) of the form,
\[ Z=\{x \in {\bf R}^n ~|~
x=c+\sum_{i=1}^p\alpha_ig_i,~ -1\leq\alpha_i\leq1\}, \]
wherein $c$ and $g_1, ..., g_p$ are vectors in ${\bf R}^n$. Thus, a
zonotope $Z$ is  represented by its center $c$ and `generator' vectors
$g_1, ..., g_p$. The value $p/n$ is called the order of the zonotope.
The main benefit of zonotopes over general polytopes is that a symmetric
polytope can be represented more compactly than a general polytope.
The geometric sum of two zonotopes is a zonotope:
\[ Z(c_1, G_1)\oplus Z(c_2, G_2) = Z(c_1+c_2, [G_1 ~ G_2]), \]
wherein $G_1$ and $G_2$ are matrices whose columns are generator vectors,
and $[G_1 ~ G_2]$ is their concatenation. Thus, in the reach set computation,
the order of the zonotope increases by $p/n$ with every time step.
This difficulty can be averted by limiting the number of generator vectors,
and overapproximating zonotopes whose number of generator vectors exceeds
the limit by lower order zonotopes.
The benefits of the compact zonotype representation, however, appear
to diminish because in order to plot them or check if they
intersect with given objects and compute those intersections,
these operations are performed after converting zonotopes to polytopes.

CheckMate \cite{checkmate} is a Matlab toolbox that can evaluate specifications
for trajectories starting from the set of initial (continuous) states
corresponding to the parameter values at the vertices of the parameter set.
This provides preliminary insight into whether the specifications will be true
for all parameter values.
The method of oriented rectangluar polytopes for external approximation
of reach sets is introduced in \cite{krogh}.
The basic idea is to construct an oriented
rectangular hull of the reach set for every time step, whose orientation is
determined by the singular value decomposition of the sample covariance matrix
for the states reachable from the vertices of the initial polytope.
The limitation of CheckMate and the method of oriented rectangles is
that only autonomous (i.e. uncontrolled) systems, or  systems with fixed
input are allowed, and only an external approximation of the reach set
is provided.

All the methods described so far employ the notion of time step,
and calculate the reach set or its approximation at each time step.
This approach can be used only with discrete-time systems.
By contrast, the analytic methods which we are about to discuss,
provide a formula or differential equation describing the (continuous)
time evolution of the reach set or its approximation.

The level set method \cite{mitchell,levelset} deals with general
nonlinear controlled systems and gives exact representation of
their reach sets, but requires solving the HJB equation and finding
the set of states that belong to sub-zero level set of the value function.
The method \cite{levelset} is impractical for systems of dimension higher
than three.

Requiem \cite{requiem} is a Mathematica notebook which, given a linear system,
the set of initial conditions and control bounds, symbolically computes
the exact reach set, using the experimental quantifier elimination package.
Quantifier elimination is the removal of all quantifiers (the universal
quantifier $\forall$ and the existential quantifier $\exists$) from a quantified
system. Each quantified formula is substituted with quantifier-free expression
with operations $+$, $\times$, $=$ and $<$. For example, consider the
discrete-time system
\[ x_{k+1} = Ax_k + Bu_k \]
with $A=\left[\begin{array}{cc}
0 & 1\\
0 & 0\end{array}\right]$ and $B=\left[\begin{array}{c}
0\\
1\end{array}\right]$.  For initial conditions
$x_0\in\{x\in {\bf R}^2 ~|~ \|x\|_{\infty} \leq 1\}$ and controls
$u_k\in\{u\in {\bf R} ~|~ -1\leq u\leq1\}$, the reach set for  $k\geq0$
is given by the quantified formula
\[\{ x\in{\bf R}^2 ~|~ \exists x_0, ~~ \exists k\geq 0, ~~
\exists u_i, ~ 0\leq i\leq k: ~~
x = A^kx_0+\sum_{i=0}^{k-1}A^{k-i-1}Bu_i \}, \]
which is equivalent to the quantifier-free expression
\[ -1\leq[1 ~~ 0]x\leq1 ~ \wedge ~ -1\leq[0 ~~ 1]x\leq1. \]
It is proved in \cite{yovine} that for continuous-time systems,
$\dot{x}(t) = Ax(t) + Bu(t)$, if $A$ is constant and nilpotent or
is diagonalizable with rational real or purely imaginary eigenvalues,
and with suitable restrictions on the control and initial conditions,
the quantifier elimination package returns a quantifier free formula
describing the reach set. Quantifier elimination has limited applicability.

The reach set approximation via parallelotopes \cite{kostousova} employs
the idea of parametrization described in \cite{kurvar} for ellipsoids.
The reach set is represented as the intersection of tight external,
and the union of tight internal, parallelotopes.
The evolution equations for the centers and
orientation matrices of both external and internal parallelotopes are
provided. This method also finds controls that can drive the system to
the boundary points of the reach set, similarly to \cite{varaiya}
and \cite{kurvar}. It works for general linear systems.  The
computation to solve the evolution equation for tight approximating
parallelotopes, however, is more involved than that for ellipsoids,
and for discrete-time systems this method does not deal with singular state
transition matrices.

{\it Ellipsoidal Toolbox} (ET) implements in MATLAB
the ellipsoidal calculus \cite{kurvalyi}
and its application to the reachability analysis of continuous-time
\cite{kurvar}, discrete-time \cite{pvak}, possibly time-varying linear systems,
and linear systems with disturbances \cite{kurvar2},
for which ET calculates both open-loop and close-loop reach sets.
The ellipsoidal calculus provides the following benefits:
\begin{itemize}
\item The complexity of the
ellipsoidal representation is quadratic in the dimension of
the state space, and linear in the number of time steps.
\item It is possible to exactly represent the reach set of
linear system through both external and internal ellipsoids.
\item It is possible to single out individual external and internal
approximating ellipsoids that are optimal to some given criterion
(e.g. trace, volume, diameter), or combination of such criteria.
\item We obtain simple analytical expressions for the control
that steers the state to a desired target.
\end{itemize}
The report is organized as follows.
\newline
Chapter 2 describes the operations of the
ellipsoidal calculus: affine transformation, geometric sum,
geometric difference, intersections with
hyperplane, ellipsoid, halfspace and polytope.
\newline
Chapter 3 presents the reachability problem and ellipsoidal methods for
the reach set approximation.
\newline
Chapter 4 contains {\it Ellipsoidal Toolbox} installation and quick start
instructions, and lists the software packages used by the toolbox.
\newline
Chapter 5 describes the implementation of methods from chapters 2 and 3
and visualization routines.
\newline
Chapter 6 describes structures and objects implemented and
used in the toolbox.
\newline
Chapter 7 gives examples of how to use the toolbox.
\newline
Chapter 8 collects some conclusions and plans for future toolbox development.
\newline
The functions provided by the toolbox together with their descriptions
are listed in appendix A.





\chapter{Ellipsoidal Calculus}
\section{Basic Notions}
We start with basic definitions.
\bd
Ellipsoid $\EE(q,Q)$ in ${\bf R}^n$ with  center $q$
and  shape matrix $Q$ is the set
\begin{equation}
\EE(q,Q) = \{ x \in {\bf R}^n ~|~ \langle (x-q), Q^{-1}(x-q)\rangle\leq1 \},
\label{ellipsoid}
\end{equation}
wherein  $Q$ is positive definite ($Q=Q^T$ and $\langle x, Qx\rangle>0$
for all nonzero $x\in{\bf R}^n$).
\label{ellipsoiddef0}
\ed
Here $\langle\cdot,\cdot\rangle$ denotes inner product.
\bd
The support function of a set $\XX\subseteq{\bf R}^n$ is
\[ \rho(l~|~\XX) = \sup_{x\in\XX} \langle l,x\rangle. \]
\ed
In particular, the support function of the ellipsoid (\ref{ellipsoid}) is
\begin{equation}
\rho(l~|~\EE(q,Q)) = \langle l, q\rangle + \langle l, Ql\rangle^{1/2}.
\label{ellsupp}
\end{equation}
Although in (\ref{ellipsoid})    $Q$ is assumed to be
positive definite, in practice we may deal with situations when $Q$ is
singular, that is, with degenerate ellipsoids flat in those directions
for which the corresponding eigenvalues are zero. Therefore, it is
useful to give an alternative definition of an ellipsoid using the
expression (\ref{ellsupp}).
\bd
Ellipsoid $\EE(q,Q)$ in ${\bf R}^n$ with  center $q$
and  shape matrix $Q$ is the set
\begin{equation}
\EE(q,Q) = \{ x \in {\bf R}^n ~|~
\langle l,x\rangle\leq\langle l,q\rangle + \langle l,Ql\rangle^{1/2}
\mbox{ for all } l\in{\bf R}^n \},
\label{ellipsoid2}
\end{equation}
wherein matrix $Q$ is positive semidefinite
($Q=Q^T$ and $\langle x, Qx\rangle\geq0$ for all $x\in{\bf R}^n$).
\label{ellipsoiddef}
\ed
The distance from $\EE(q,Q)$ to the fixed point $a$ is
\begin{equation}
{\bf dist}(\EE(q,Q),a) = \max_{\langle l,l\rangle=1}\left(\langle l,a\rangle -
\rho(l ~|~ \EE(q,Q)) \right) =
\max_{\langle l,l\rangle=1}\left(\langle l,a\rangle - \langle l,q\rangle -
\langle l,Ql\rangle^{1/2}\right). \label{dist_point}
\end{equation}
If ${\bf dist}(\EE(q,Q),a) > 0$, $a$ lies outside  $\EE(q,Q)$;
if ${\bf dist}(\EE(q,Q),a) = 0$, $a$ is a boundary point of $\EE(q,Q)$;
if ${\bf dist}(\EE(q,Q),a) < 0$, $a$ is an internal point of $\EE(q,Q)$.

Given two ellipsoids, $\EE(q_1,Q_1)$ and $\EE(q_2,Q_2)$, the distance between
them is
\begin{eqnarray}
{\bf dist}(\EE(q_1,Q_1),\EE(q_2,Q_2)) & = & \max_{\langle l,l\rangle=1}
\left(-\rho(-l ~|~ \EE(q_1,Q_1)) - \rho(l ~|~ \EE(q_2,Q_2))\right) \\
& = & \max_{\langle l,l\rangle=1}\left(\langle l,q_1\rangle -
\langle l,Q_1l\rangle^{1/2} - \langle l,q_2\rangle -
\langle l,Q_2l\rangle^{1/2}\right). \label{dist_ell}
\end{eqnarray}
If ${\bf dist}(\EE(q_1,Q_1),\EE(q_2,Q_2)) > 0$,  the ellipsoids have no
common points;
if ${\bf dist}(\EE(q_1,Q_1),\EE(q_2,Q_2)) = 0$,  the ellipsoids have one
common point - they touch;
if ${\bf dist}(\EE(q_1,Q_1),\EE(q_2,Q_2)) < 0$,  the ellipsoids intersect.

Checking if $k$ nondegenerate ellipsoids $\EE(q_1,Q_1),\cdots,\EE(q_k,Q_k)$
have nonempty intersection, can be cast as a quadratically constrained
quadratic programming (QCQP) problem:
\[ \min 0 \]
subject to:
\[ \langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leq 0, ~~~ i=1,\cdots,k. \]
If this problem is feasible,  the intersection is nonempty.
\bd
Given compact convex set $\XX\subseteq{\bf R}^n$, its polar set, denoted
$\XX^\circ$, is
\[ \XX^\circ = \{x\in{\bf R}^n ~|~ \langle x,y\rangle\leq 1, ~ y\in\XX\}, \]
or, equivalently,
\[ \XX^\circ = \{l\in{\bf R}^n ~|~ \rho(l ~|~ \XX)\leq 1\}. \]
\ed
The properties of the polar set are
\begin{itemize}
\item If  $\XX$ contains the origin,  $(\XX^\circ)^\circ = \XX$;
\item If $\XX_1\subseteq\XX_2$,  $\XX_2^\circ\subseteq\XX_1^\circ$;
\item For any nonsingular matrix $A\in{\bf R}^{n\times n}$,
$(A\XX)^\circ = (A^T)^{-1}\XX^\circ$.
\end{itemize}
If a nondegenerate ellipsoid $\EE(q,Q)$ contains the origin,
 its polar set is also an ellipsoid:
\begin{eqnarray*}
\EE^\circ(q,Q) & = & \{l\in{\bf R}^n ~|~ \langle l,q\rangle +
\langle l,Ql\rangle^{1/2}\leq1 \}\\
& = & \{l\in{\bf R}^n ~|~ \langle l,(Q-qq^T)^{-1}l\rangle +
2\langle l,q\rangle\leq1 \}\\ 
& = & \{l\in{\bf R}^n ~|~ \langle(l+(Q-qq^T)^{-1}q),
(Q-qq^T)(l+(Q-qq^T)^{-1}q)\rangle\leq1+\langle q,(Q-qq^T)^{-1}q\rangle \}.
\end{eqnarray*}
The special case is
\[ \EE^\circ(0,Q) = \EE(0,Q^{-1}). \]
\bd
Given $k$ compact sets $\XX_1, \cdots, \XX_k\subseteq{\bf R}^n$,
their geometric (Minkowski) sum is
\begin{equation}
\XX_1\oplus\cdots\oplus\XX_k=\bigcup_{x_1\in\XX_1}\cdots\bigcup_{x_k\in\XX_k}
\{x_1 + \cdots + x_k\} .  \label{minksum}
\end{equation}
\ed
\bd
Given two compact sets $\XX_1, \XX_2 \subseteq{\bf R}^n$, their geometric
(Minkowski) difference is
\begin{equation}
\XX_1\dot{-}\XX_2 = \{x\in{\bf R}^n ~|~ x + \XX_2 \subseteq \XX_1 \}.
\label{minkdiff}
\end{equation}
\ed
Ellipsoidal calculus concerns the following set of operations:
\begin{itemize}
\item affine transformation of ellipsoid;
\item geometric sum of finite number of ellipsoids;
\item geometric difference of two ellipsoids;
\item intersection of finite number of ellipsoids.
\end{itemize}
These operations occur in reachability calculation and verification
of piecewise affine dynamical systems. The result of all of these operations,
except for the affine transformation, is \emph{not} generally an ellipsoid
but some convex set, for which we can compute external and internal ellipsoidal
approximations.

Additional operations implemented in the {\it Ellipsoidal Toolbox} include
external and internal approximations of intersections of ellipsoids with
hyperplanes, halfspaces and polytopes.
\bd
Hyperplane $H(c,\gamma)$ in ${\bf R}^n$ is the set
\begin{equation}
H = \{x\in{\bf R}^n ~|~ \langle c, x\rangle = \gamma\}
\label{hyperplane}
\end{equation}
with $c\in{\bf R}^n$ and $\gamma\in{\bf R}$ fixed.
\label{hyperplanedef}
\ed
The distance from ellipsoid $\EE(q,Q)$ to hyperplane $H(c,\gamma)$ is
\begin{equation}
{\bf dist}(\EE(q,Q),H(c,\gamma)) =
\frac{\left|\gamma-\langle c,q\rangle\right| -
\langle c,Qc\rangle^{1/2}}{\langle c,c\rangle^{1/2}}. \label{dist_hp}
\end{equation}
If ${\bf dist}(\EE(q,Q),H(c,\gamma))>0$, the ellipsoid and the hyperplane
do not intersect;
if ${\bf dist}(\EE(q,Q),H(c,\gamma))=0$, the hyperplane is a supporting
hyperplane for the ellipsoid;
if ${\bf dist}(\EE(q,Q),H(c,\gamma))<0$, the ellipsoid intersects the
hyperplane.
The intersection of an ellipsoid with a hyperplane is always an ellipsoid
and can be computed directly.

Checking if the intersection of $k$ nondegenerate ellipsoids
$E(q_1,Q_1),\cdots,\EE(q_k,Q_k)$ intersects  hyperplane $H(c,\gamma)$,
is equivalent to the feasibility check of the QCQP problem:
\[ \min 0 \]
subject to:
\begin{eqnarray*}
\langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leq 0, & & i=1,\cdots,k,\\
\langle c, x\rangle - \gamma = 0. & &
\end{eqnarray*}
A hyperplane defines two (closed) {\it halfspaces}:
\begin{equation}
{\bf S}_1 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \leq \gamma\}
\label{halfspace1}
\end{equation}
and
\begin{equation}
{\bf S}_2 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \geq \gamma\}.
\label{halfspace2}
\end{equation}
To avoid confusion, however, we shall further assume that a
 hyperplane $H(c,\gamma)$ specifies the halfspace in the sense
(\ref{halfspace1}). In order to refer to the
other halfspace, the same hyperplane should be defined as $H(-c,-\gamma)$.

The idea behind the calculation of intersection of an ellipsoid with a
halfspace is to treat the halfspace as an unbounded ellipsoid, that is, as the
ellipsoid with the shape matrix  all but one of whose eigenvalues are $\infty$.
\bd
Polytope $P(C,g)$ is the  intersection of a finite number
of closed halfspaces:
\[ P = \{x\in{\bf R}^n ~|~ Cx\leq g\}, \]
wherein $C=[c_1 ~ \cdots ~ c_m]^T\in{\bf R}^{m\times n}$ and
$g=[\gamma_1 ~ \cdots ~ \gamma_m]^T\in{\bf R}^m$.
\ed
The distance from ellipsoid $\EE(q,Q)$ to the polytope $P(C,g)$ is
\begin{equation}
{\bf dist}(\EE(q,Q),P(C,g))=\min_{y\in P(C,g)}{\bf dist}(\EE(q,Q),y),
\label{dist_poly}
\end{equation}
where ${\bf dist}(\EE(q,Q),y)$ comes from (\ref{dist_point}).
If ${\bf dist}(\EE(q,Q),P(C,g))>0$, the ellipsoid and the polytope
do not intersect;
if ${\bf dist}(\EE(q,Q),P(C,g))=0$, the ellipsoid touches the polytope;
if ${\bf dist}(\EE(q,Q),P(C,g))<0$, the ellipsoid intersects the
polytope.

Checking if the intersection of $k$ nondegenerate ellipsoids
$E(q_1,Q_1),\cdots,\EE(q_k,Q_k)$ intersects  polytope $P(C,g)$
is equivalent to the feasibility check of the QCQP problem:
\[ \min 0 \]
subject to:
\begin{eqnarray*}
\langle (x-q_i),Q_i^{-1}(x-q_i)\rangle - 1 \leq 0, & & i=1,\cdots,k,\\
\langle c_j, x\rangle - \gamma_j \leq 0, & & j=1,\cdots,m.
\end{eqnarray*}



\section{Operations with Ellipsoids}
\subsection{Affine Transformation}
The simplest operation with ellipsoids is an affine transformation.
Let ellipsoid $\EE(q,Q)\subseteq{\bf R}^n$, matrix $A\in{\bf R}^{m\times n}$
and vector $b\in{\bf R}^m$. Then
\begin{equation}
A\EE(q,Q) + b = \EE(Aq+b, AQA^T) .\label{affinetrans}
\end{equation}
Thus, ellipsoids are preserved under affine transformation.
If the rows of $A$ are linearly independent (which implies  $m\leq n$), and
$b=0$, the affine transformation is called {\it projection}.


\subsection{Geometric Sum}
Consider the geometric sum (\ref{minksum}) in which $\XX_1,\cdots$,$\XX_k$
are  nondegenerate ellipsoids
$\EE(q_1,Q_1),\cdots$, $\EE(q_k,Q_k)\subseteq{\bf R}^n$.
The resulting set is not generally  an ellipsoid.
However, it can be tightly approximated by the parametrized families
of external and internal ellipsoids.

Let parameter $l$ be some nonzero vector in ${\bf R}^n$. Then the external
approximation $\EE(q,Q_l^+)$ and the internal approximation $\EE(q,Q_l^-)$
of the sum $\EE(q_1,Q_1)\oplus\cdots\oplus\EE(q_k,Q_k)$ are \emph{tight} along
direction $l$, i.e.,
\[ \EE(q,Q_l^-)\subseteq\EE(q_1,Q_1)\oplus\cdots\oplus\EE(q_k,Q_k)
\subseteq\EE(q,Q_l^+) \]
and
\[ \rho(\pm l ~|~ \EE(q,Q_l^-)) =
\rho(\pm l ~|~ \EE(q_1,Q_1)\oplus\cdots\oplus\EE(q_k,Q_k)) =
\rho(\pm l ~|~ \EE(q,Q_l^+)).\]
Here the center $q$ is
\begin{equation}
q = q_1 + \cdots + q_k , \label{minksum_c}
\end{equation}
the shape matrix of the external ellipsoid $Q_l^+$ is
\begin{equation}
Q_l^+ = \left(\langle l,Q_1l\rangle^{1/2} + \cdots
+ \langle l,Q_kl\rangle^{1/2}\right)
\left(\frac{1}{\langle l,Q_1l\rangle^{1/2}}Q_1 + \cdots +
\frac{1}{\langle l,Q_kl\rangle^{1/2}}Q_k\right), \label{minksum_ea}
\end{equation}
and the shape matrix of the internal ellipsoid $Q_l^-$ is
\begin{equation}
Q_l^- = \left(Q_1^{1/2} + S_2Q_2^{1/2} + \cdots + S_kQ_k^{1/2}\right)^T
\left(Q_1^{1/2} + S_2Q_2^{1/2} + \cdots + S_kQ_k^{1/2}\right),\label{minksum_ia}
\end{equation}
with matrices $S_i$, $i=2,\cdots,k$, being orthogonal ($S_iS_i^T=I$) and such
that vectors $Q_1^{1/2}l, S_2Q_2^{1/2}l, \cdots, S_kQ_k^{1/2}l$ are parallel.

Varying vector $l$ we get exact external and internal approximations,
\[ \bigcup_{\langle l,l\rangle=1} \EE(q,Q_l^-) =
\EE(q_1,Q_1)\oplus\cdots\oplus\EE(q_k,Q_k) =
\bigcap_{\langle l,l\rangle=1} \EE(q,Q_l^+) .\]
For proofs of formulas given in this section, see \cite{kurvalyi},
\cite{kurvar}.

One last comment is about how to find orthogonal matrices $S_2,\cdots,S_k$
that align vectors $Q_2^{1/2}l, \cdots, Q_k^{1/2}l$ with $Q_1^{1/2}l$.
Let $v$ and $w$ be some unit vectors in ${\bf R}^n$.
We have to find matrix $S$ such that $Sv=w$. For that,
we perform singular value decomposition (SVD) of vectors $v$ and $w$:
\begin{equation}
v = U_v\Sigma_vV_v^T, ~~~~ w = U_w\Sigma_wV_w^T . \label{valign1}
\end{equation}
Notice that $V_v$ and $V_w$ are $\pm1$ scalars.
The matrix $S$ is now easily determined:
\begin{equation}
S U_vV_v = U_wV_w ~~~ \Rightarrow ~~~ S = U_wV_wV_vU_v^T. \label{valign2}
\end{equation}


\subsection{Geometric Difference}
Consider the geometric difference (\ref{minkdiff}) in which the sets $\XX_1$ and
$\XX_2$ are nondegenerate ellipsoids $\EE(q_1,Q_1)$ and $\EE(q_2,Q_2)$.
We say that ellipsoid $\EE(q_1,Q_1)$ is {\it bigger} than ellipsoid
$\EE(q_2,Q_2)$ if
\[ \EE(0,Q_2) \subseteq \EE(0,Q_1). \]
If this condition is not fulfilled,  the geometric difference
$\EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)$ is an empty set:
\[ \EE(0,Q_2) \not\subseteq \EE(0,Q_1) ~~~ \Rightarrow ~~~
\EE(q_1,Q_1) \dot{-}\EE(q_2,Q_2) = \emptyset. \]
If $\EE(q_1,Q_1)$ is bigger than $\EE(q_2,Q_2)$ and
$\EE(q_2,Q_2)$ is bigger than $\EE(q_1,Q_1)$, in other words, if $Q_1=Q_2$,
\[ \EE(q_1,Q_1) \dot{-}\EE(q_2,Q_2) = \{q_1-q_2\} ~~~ \mbox{and} ~~~
\EE(q_2,Q_2) \dot{-}\EE(q_1,Q_1) = \{q_2-q_1\}. \]
To check if ellipsoid $\EE(q_1,Q_1)$ is bigger than ellipsoid $\EE(q_2,Q_2)$,
we perform simultaneous diagonalization of matrices $Q_1$ and $Q_2$, that is,
we find matrix $T$ such that
\[ TQ_1T^T = I ~~~ \mbox{and} ~~~ TQ_2T^T=D, \]
where $D$ is some diagonal matrix.
Simultaneous diagonalization of $Q_1$ and $Q_2$ is possible
because both are symmetric positive definite (see \cite{gant}).
To find such matrix $T$, we first do the SVD of $Q_1$:
\begin{equation}
Q_1 = U_1\Sigma_1V_1^T . \label{simdiag1}
\end{equation}
Then the SVD of matrix $\Sigma_1^{-1/2}U_1^TQ_2U_1\Sigma_1^{-1/2}$:
\begin{equation}
\Sigma_1^{-1/2}U_1^TQ_2U_1\Sigma_1^{-1/2} = U_2\Sigma_2V_2^T. \label{simdiag2}
\end{equation}
Now, $T$ is defined as
\begin{equation}
T = U_2^T \Sigma_1^{-1/2}U_1^T.  \label{simdiag3}
\end{equation}
If the biggest diagonal element (eigenvalue) of matrix $D=TQ_2T^T$ is less than
or equal to $1$,  $\EE(0,Q_2)\subseteq\EE(0,Q_1)$.

Once it is established that ellipsoid $\EE(q_1,Q_1)$ is bigger than
ellipsoid $\EE(q_2,Q_2)$, we know that their geometric difference
$\EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)$ is a nonempty convex compact set.
Although  it is not generally an ellipsoid, we can find tight external
and internal approximations of this set parametrized by vector $l\in{\bf R}^n$.
Unlike geometric sum, however, ellipsoidal approximations for the geometric
difference do not exist  for every direction $l$.
Vectors for which the approximations do not exist are called
{\it bad directions}.

Given two ellipsoids $\EE(q_1,Q_1)$ and $\EE(q_2,Q_2)$ with
$\EE(0,Q_2)\subseteq\EE(0,Q_1)$, $l$ is a bad direction if
\[ \frac{\langle l,Q_1l\rangle^{1/2}}{\langle l,Q_2l\rangle^{1/2}}>r, \]
in which $r$ is a minimal root of the equation
\[ {\bf det}(Q_1-rQ_2) = 0. \]
To find $r$, compute matrix $T$ by (\ref{simdiag1}-\ref{simdiag3}) and define
\[ r = \frac{1}{\max({\bf diag}(TQ_2T^T))}. \]
If $l$ is {\it not} a bad direction, we can find tight external
and internal ellipsoidal approximations $\EE(q,Q^+_l)$ and
$\EE(q,Q^-_l)$ such that
\[ \EE(q,Q^-_l)\subseteq\EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)\subseteq\EE(q,Q^+_l) \]
and
\[ \rho(\pm l ~|~ \EE(q,Q_l^-)) =
\rho(\pm l ~|~ \EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)) =
\rho(\pm l ~|~ \EE(q,Q_l^+)).\]
The center $q$ is
\begin{equation}
q = q_1 - q_2;  \label{minkdiff_c}
\end{equation}
the shape matrix of the internal ellipsoid $Q^-_l$ is
\begin{equation}
Q^-_l = \left(1-\frac{\langle l,Q_1l\rangle^{1/2}}{\langle l,
Q_2l\rangle^{1/2}}\right)Q_1 +
\left(1 - \frac{\langle l, Q_2l\rangle^{1/2}}{\langle l,
Q_1l\rangle^{1/2}}\right)Q_2; \label{minkdiff_ia}
\end{equation}
and the shape matrix of the external ellipsoid $Q^+_l$ is
\begin{equation}
Q^+_l = \left(Q_1^{1/2} + SQ_2^{1/2}\right)^T
\left(Q_1^{1/2} + SQ_2^{1/2}\right).  \label{minkdiff_ea}
\end{equation}
Here $S$ is an orthogonal matrix such that vectors $Q_1^{1/2}l$
and $SQ_2^{1/2}l$ are parallel.
 $S$ is found from (\ref{valign1}-\ref{valign2}), with
$v=Q_2^{1/2}l$ and $w=Q_1^{1/2}l$.

Running $l$ over all unit directions that are not bad, we get
\[ \bigcup_{\langle l,l\rangle=1} \EE(q,Q_l^-) =
\EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2) =
\bigcap_{\langle l,l\rangle=1} \EE(q,Q_l^+) .\]
For proofs of formulas given in this section, see \cite{kurvalyi}.


\subsection{Geometric Difference-Sum}
Given ellipsoids $\EE(q_1,Q_1)$, $\EE(q_2,Q_2)$ and $\EE(q_3,Q_3)$, it is
possible to compute families of external and internal approximating
ellipsoids for 
\begin{equation}
\EE(q_1,Q_1) \dot{-} \EE(q_2,Q_2) \oplus \EE(q_3,Q_3) \label{minkmp}
\end{equation}
parametrized by direction $l$, if this set is nonempty
($\EE(0,Q_2)\subseteq\EE(0,Q_1)$).

First, using the result of the previous section, for any direction $l$ that
is not bad, we obtain tight external $\EE(q_1-q_2, Q_l^{0+})$ and internal
$\EE(q_1-q_2, Q_l^{0-})$ approximations of the set
$\EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)$.

The second and last step is, using the result of section 2.2.2, to find
tight external ellipsoidal approximation $\EE(q_1-q_2+q_3,Q_l^+)$ of the sum
$\EE(q_1-q_2,Q_l^{0+})\oplus\EE(q_3,Q_3)$, and tight internal ellipsoidal
approximation $\EE(q_1-q_2+q_3,Q_l^-)$ for the sum
$\EE(q_1-q_2,Q_l^{0-})\oplus\EE(q_3,Q_3)$.

As a result, we get
\[ \EE(q_1-q_2+q_3,Q_l^-) \subseteq
\EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)\oplus\EE(q_3,Q_3) \subseteq
\EE(q_1-q_2+q_3,Q_l^+) \]
and
\[ \rho(\pm l ~|~\EE(q_1-q_2+q_3,Q_l^-)) =
\rho(\pm l ~|~ \EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)\oplus\EE(q_3,Q_3)) =
\rho(\pm l ~|~ \EE(q_1-q_2+q_3,Q_l^+)). \]
Running $l$ over all unit vectors that are not bad, this translates to
\[ \bigcup_{\langle l,l\rangle=1} \EE(q_1-q_2+q_3,Q_l^-) =
\EE(q_1,Q_1)\dot{-}\EE(q_2,Q_2)\oplus\EE(q_3,Q_3) =
\bigcap_{\langle l,l\rangle=1} \EE(q_1-q_2+q_3,Q_l^+) .\]


\subsection{Geometric Sum-Difference}
Given ellipsoids $\EE(q_1,Q1)$, $\EE(q_2,Q_2)$ and $\EE(q_3,Q_3)$, it is
possible to compute families of external and internal approximating
ellipsoids for 
\begin{equation}
\EE(q_1,Q_1) \oplus \EE(q_2,Q_2) \dot{-} \EE(q_3,Q_3) \label{minkpm}
\end{equation}
parametrized by direction $l$, if this set is nonempty
($\EE(0,Q_3)\subseteq\EE(0,Q_1)\oplus\EE(0,Q_2)$).

First, using the result of section 2.2.2, we obtain tight external
$\EE(q_1+q_2,Q_l^{0+})$ and internal $\EE(q_1+q_2,Q_l^{0-})$ ellipsoidal
approximations of the set $\EE(q_1,Q_1)\oplus\EE(q_2,Q_2)$.
In order for the set (\ref{minkpm}) to be nonempty, inclusion
$\EE(0,Q_3)\subseteq\EE(0,Q_l^{0+})$ must be true for any $l$.
Note, however, that even if (\ref{minkpm}) is nonempty, it may be that
$\EE(0,Q_3)\not\subseteq\EE(0,Q_l^{0-})$, then internal approximation for this
direction does not exist.

Assuming that (\ref{minkpm}) is nonempty and
$\EE(0,Q_3)\subseteq\EE(0,Q_l^{0-})$, the second step would be, using the
results of section 2.2.3, to compute tight external ellipsoidal approximation
$\EE(q_1+q_2-q_3,Q_l^+)$ of the difference
$\EE(q_1+q_2,Q_l^{0+})\dot{-}\EE(q_3,Q_3)$, which exists only if $l$ is not
bad, and tight internal ellipsoidal approximation
$\EE(q_1+q_2-q_3,Q_l^-)$ of the difference
$\EE(q_1+q_2,Q_l^{0-})\dot{-}\EE(q_3,Q_3)$, which exists only if $l$ is not
bad for this difference.

If approximation $\EE(q_1+q_2-q_3,Q_l^+)$ exists, then
\[ \EE(q_1,Q_1)\oplus\EE(q_2,Q_2)\dot{-}\EE(q_3,Q_3) \subseteq
\EE(q_1+q_2-q_3,Q_l^+) \]
and
\[ \rho(\pm l ~|~ \EE(q_1,Q_1)\oplus\EE(q_2,Q_2)\dot{-}\EE(q_3,Q_3)) =
\rho(\pm l ~|~ \EE(q_1+q_2-q_3,Q_l^+)). \]
If approximation $\EE(q_1+q_2-q_3,Q_l^-)$ exists, then
\[ \EE(q_1+q_2-q_3,Q_l^-) \subseteq
\EE(q_1,Q_1)\oplus\EE(q_2,Q_2)\dot{-}\EE(q_3,Q_3) \]
and
\[ \rho(\pm l ~|~\EE(q_1+q_2-q_3,Q_l^-)) =
\rho(\pm l ~|~ \EE(q_1,Q_1)\oplus\EE(q_2,Q_2)\dot{-}\EE(q_3,Q_3)) . \]
For any fixed direction $l$ it may be the case that neither external nor
internal tight ellipsoidal approximations exist.


\subsection{Intersection of Ellipsoid and Hyperplane}
Let nondegenerate ellipsoid $\EE(q,Q)$ and hyperplane $H(c,\gamma)$ be such that
${\bf dist}(\EE(q,Q),H(c,\gamma))<0$. In other words,
\[ \EE_H(w,W) = \EE(q,Q)\cap H(c,\gamma) \neq \emptyset .\]
The intersection of ellipsoid with hyperplane, if nonempty, is always an
ellipsoid. Here we show how to find it.

First of all, we transform the hyperplane $H(c,\gamma)$
into $H([1~0~\cdots~0]^T, 0)$ by the affine transformation
\[ y = Sx - \frac{\gamma}{\langle c,c\rangle^{1/2}}Sc, \]
where $S$ is an orthogonal matrix found by (\ref{valign1}-\ref{valign2}) with
$v=c$ and $w=[1~0~\cdots~0]^T$.
The ellipsoid in the new coordinates becomes $\EE(q',Q')$ with
\begin{eqnarray*}
q' & = & q-\frac{\gamma}{\langle c,c\rangle^{1/2}}Sc, \\
Q' & = & SQS^T.
\end{eqnarray*}
Define matrix $M=Q'^{-1}$; $m_{11}$ is its element in position $(1,1)$,
$\bar{m}$ is the first column of  $M$ without the first element,
and $\bar{M}$ is the submatrix of $M$ obtained by stripping $M$ of its
first row and first column:
\[ M = \left[\begin{array}{c|cl}
m_{11} & & \bar{m}^T\\
 & \\
\hline
 & \\
\bar{m} & & \bar{M}\end{array}\right]. \]
The ellipsoid resulting from the intersection is $\EE_H(w',W')$ with
\begin{eqnarray*}
w' & = & q' + q_1'\left[\begin{array}{c}
-1\\
\bar{M}^{-1}\bar{m}\end{array}\right],\\
W' & = & \left(1-q_1'^2(m_{11}-
\langle\bar{m},\bar{M}^{-1}\bar{m}\rangle)\right)\left[\begin{array}{c|cl}
0 & & {\bf 0}\\
 & \\
\hline
 & \\
{\bf 0} & & \bar{M}^{-1}\end{array}\right],
\end{eqnarray*}
in which $q_1'$ represents the first element of vector $q'$.

Finally, it remains to do the inverse transform of the coordinates
to obtain ellipsoid $\EE_H(w,W)$:
\begin{eqnarray*}
w & = & S^Tw' + \frac{\gamma}{\langle c,c\rangle^{1/2}}c, \\
W & = & S^TW'S.
\end{eqnarray*}


\subsection{Intersection of Ellipsoid and Ellipsoid}
Given two nondegenerate ellipsoids $\EE(q_1,Q_1)$ and $\EE(q_2,Q_2)$,
${\bf dist}(\EE(q_1,Q_1),\EE(q_2,Q_2))<0$ implies that
\[ \EE(q_1,Q_1)\cap\EE(q_2,Q_2)\neq\emptyset .\]
This intersection can be approximated by ellipsoids from the outside and
from the inside.
Trivially, both  $\EE(q_1,Q_1)$ and $\EE(q_2,Q_2)$ are external approximations
of this intersection.
Here, however, we show how to find the external ellipsoidal approximation
of minimal volume.

Define matrices
\begin{equation}
W_1 = Q_1^{-1}, ~~~~ W_2 = Q_2^{-1} .\label{wmatrices}
\end{equation}
Minimal volume external ellipsoidal approximation $\EE(q+,Q^+)$ of
the intersection $\EE(q_1,Q_1)\cap\EE(q_2,Q_2)$ is determined from the set
of equations:
\begin{eqnarray}
Q^+ & = & \alpha X^{-1} \label{fusion1} \\
X & = & \pi W_1 + (1-\pi)W_2 \label{fusion2} \\
\alpha & = & 1-\pi(1-\pi)\langle(q_2-q_1), W_2X^{-1}W_1(q_2-q_1)\rangle
\label{fusion3} \\
q^+ & = & X^{-1}(\pi W_1q_1 + (1-\pi)W_2q_2) \label{fusion4} \\
0 & = & \alpha({\bf det}(X))^2{\bf trace}(X^{-1}(W_1-W_2)) \nonumber \\
& - & n({\bf det}(X))^2
\big{(}2\langle q^+,W_1q_1-W_2q_2\rangle +
\langle q^+,(W_2-W_1)q^+\rangle \nonumber\\
&  & - \langle q_1,W_1q_1\rangle +
\langle q_2,W_2q_2\rangle\big{)}, \label{fusion5}
\end{eqnarray}
with $0\leq\pi\leq1$. We substitute $X$, $\alpha$, $q^+$ defined in
(\ref{fusion2}-\ref{fusion4}) into (\ref{fusion5}) and get a polynomial of
degree $2n-1$ with respect to $\pi$, which has only one root in the
interval $[0,1]$, $\pi_0$. Then, substituting $\pi=\pi_0$ into
(\ref{fusion1}-\ref{fusion4}), we obtain $q^+$ and $Q^+$.
Special cases are $\pi_0=1$, whence $\EE(q^+,Q^+)=\EE(q_1,Q_1)$, and
$\pi_0=0$, whence $\EE(q^+,Q^+)=\EE(q_2,Q_2)$. These situations may occur
if, for example, one ellipsoid is contained in the other:
\begin{eqnarray*}
\EE(q_1,Q_1)\subseteq\EE(q_2,Q_2) & \Rightarrow & \pi_0 = 1,\\
\EE(q_2,Q_2)\subseteq\EE(q_1,Q_1) & \Rightarrow & \pi_0 = 0.\\
\end{eqnarray*}
The proof that the system of equations (\ref{fusion1}-\ref{fusion5})
correctly defines the minimal volume external ellipsoidal approximationi
of the intersection $\EE(q_1,Q_1)\cap\EE(q_2,Q_2)$ is given in \cite{fusion}.

To find the internal approximating ellipsoid
$\EE(q^-,Q^-)\subseteq\EE(q_1,Q_1)\cap\EE(q_2,Q_2)$, define
\begin{eqnarray}
\beta_1 & = &
\min_{\langle x,W_2x\rangle=1}\langle x,W_1x\rangle, \label{beta1}\\
\beta_2 & = & \min_{\langle x,W_1x\rangle=1}\langle x,W_2x\rangle, \label{beta2}
\end{eqnarray}
Notice that (\ref{beta1}) and (\ref{beta2}) are QCQP problems.
Parameters $\beta_1$ and $\beta_2$ are invariant with respect to affine
coordinate transformation and describe the position of ellipsoids
$\EE(q_1,Q_1)$, $\EE(q_2,Q_2)$ with respect to each other:
\begin{eqnarray*}
\beta_1\geq1,~\beta_2\geq1 & \Rightarrow &
{\bf int}(\EE(q_1,Q_1)\cap\EE(q_2,Q_2))=\emptyset, \\
\beta_1\geq1,~\beta_2\leq1 & \Rightarrow & \EE(q_1,Q_1)\subseteq\EE(q_2,Q_2), \\
\beta_1\leq1,~\beta_2\geq1 & \Rightarrow & \EE(q_2,Q_2)\subseteq\EE(q_1,Q_1), \\
\beta_1<1,~\beta_2<1 & \Rightarrow &
{\bf int}(\EE(q_1,Q_1)\cap\EE(q_2,Q_2))\neq\emptyset \\
& & \mbox{and} ~ \EE(q_1,Q_1)\not\subseteq\EE(q_2,Q_2) \\
& & \mbox{and} ~ \EE(q_2,Q_2)\not\subseteq\EE(q_1,Q_1).
\end{eqnarray*}
Define parametrized family of internal ellipsoids
$\EE(q^-_{\theta_1\theta_2},Q^-_{\theta_1\theta_2})$ with
\begin{eqnarray}
q^-_{\theta_1\theta_2} & = & (\theta_1W_1 +
\theta_2W_2)^{-1}(\theta_1W_1q_1 + \theta_2W_2q_2), \label{paramell1} \\
Q^-_{\theta_1\theta_2} & = & (1 - \theta_1\langle q_1,W_1q_1\rangle -
\theta_2\langle q_2,W_2q_2\rangle +
\langle q^-_{\theta_1\theta_2},(Q^-)^{-1}q^-_{\theta_1\theta_2}\rangle)
(\theta_1W_1 + \theta_2W_2)^{-1} .\label{paramell2}
\end{eqnarray}
The best internal ellipsoid
$\EE(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})$
in the class (\ref{paramell1}-\ref{paramell2}), namely, such that
\[ \EE(q^-_{{\theta}_1{\theta}_2},Q^-_{{\theta}_1{\theta}_2})\subseteq
\EE(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})
\subseteq \EE(q_1,Q_1)\cap\EE(q_2,Q_2) \]
for all $0\leq\theta_1,\theta_2\leq1$, is specified by the parameters
\begin{equation}
\hat{\theta}_1 = \frac{1-\hat{\beta}_2}{1-\hat{\beta}_1\hat{\beta}_2}, ~~~~
\hat{\theta}_2 = \frac{1-\hat{\beta}_1}{1-\hat{\beta}_1\hat{\beta}_2},
\label{thetapar}
\end{equation}
with
\[ \hat{\beta}_1=\min(1,\beta_1), ~~~~ \hat{\beta}_2=\min(1,\beta_2). \]
It is the ellipsoid that we look for:
$\EE(q^-,Q^-)=\EE(q^-_{\hat{\theta}_1\hat{\theta}_2},Q^-_{\hat{\theta}_1\hat{\theta}_2})$.
Two special cases are
\[ \hat{\theta}_1=1, ~ \hat{\theta}_2=0 ~~~ \Rightarrow ~~~
\EE(q_1,Q_1)\subseteq\EE(q_2,Q_2) ~~~ \Rightarrow ~~~
\EE(q^-,Q^-)=\EE(q_1,Q_1), \]
and
\[ \hat{\theta}_1=0, ~ \hat{\theta}_2=1 ~~~ \Rightarrow ~~~
\EE(q_2,Q_2)\subseteq\EE(q_1,Q_1) ~~~ \Rightarrow ~~~
\EE(q^-,Q^-)=\EE(q_2,Q_2). \]
The method of finding the internal ellipsoidal approximation of the
intersection of two ellipsoids is described in \cite{vazhen}.


\subsection{Intersection of Ellipsoid and Halfspace}
Finding the intersection of ellipsoid and halfspace can be reduced to
finding the intersection of two ellipsoids, one of which is unbounded.
Let $\EE(q_1,Q_1)$ be a nondegenerate ellipsoid and let  $H(c,\gamma)$
define the halfspace
\[ {\bf S}(c,\gamma) = \{x\in{\bf R}^n ~|~ \langle c,x\rangle\leq\gamma\}. \]
We have to determine if the intersection $\EE(q_1,Q_1)\cap{\bf S}(c,\gamma)$
is empty, and if not, find its external and internal ellipsoidal approximations,
$\EE(q^+,Q^+)$ and $\EE(q^-,Q^-)$.
Two trivial situations are:
\begin{itemize}
\item ${\bf dist}(\EE(q_1,Q_1),H(c,\gamma))>0$ and $\langle c, q_1\rangle>0$,
which implies that $\EE(q_1,Q_1)\cap{\bf S}(c,\gamma)=\emptyset$;
\item ${\bf dist}(\EE(q_1,Q_1),H(c,\gamma))>0$ and $\langle c, q_1\rangle<0$,
so that $\EE(q_1,Q_1)\subseteq{\bf S}(c,\gamma)$, and then
$\EE(q^+,Q^+)=\EE(q^-,Q^-)=\EE(q_1,Q_1)$.
\end{itemize}
In case ${\bf dist}(\EE(q_1,Q_1),H(c,\gamma)<0$, i.e. the ellipsoid
intersects the hyperplane,
\[ \EE(q_1,Q_1)\cap{\bf S}(c,\gamma) =
\EE(q_1,Q_1)\cap\{x ~|~ \langle (x-q_2),W_2(x-q_2)\rangle\leq1\}, \]
with
\begin{eqnarray}
q_2 & = & (\gamma + 2\sqrt{\overline{\lambda}})c,\label{hsell1} \\
W_2 & = & \frac{1}{4\overline{\lambda}}cc^T,\label{hsell2}
\end{eqnarray}
 $\overline{\lambda}$ being the biggest eigenvalue of matrix $Q_1$.
After defining $W_1=Q_1^{-1}$, we obtain $\EE(q^+,Q^+)$ from  equations
(\ref{fusion1}-\ref{fusion5}), and $\EE(q^-,Q^-)$ from
(\ref{paramell1}-\ref{paramell2}), (\ref{thetapar}).

{\bf Remark.} Notice that matrix $W_2$ has rank $1$, which makes it singular
for $n>1$. Nevertheless, expressions (\ref{fusion1}-\ref{fusion2}),
(\ref{paramell1}-\ref{paramell2}) make sense because $W_1$ is nonsingular,
$\pi_0\neq0$ and $\hat{\theta}_1\neq0$.

To find the ellipsoidal approximations $\EE(q^+,Q^+)$ and $\EE(q^-,Q^-)$ of
the intersection of ellipsoid $\EE(q,Q)$ and polytope $P(C,g)$,
$C\in{\bf R}^{m\times n}$, $b\in{\bf R}^m$, such that
\[ \EE(q^-,Q^-)\subseteq\EE(q,Q)\cap P(C,g)\subseteq\EE(q^+,Q^+), \]
we first compute
\[ \EE(q^-_1,Q^-_1)\subseteq\EE(q,Q)\cap{\bf S}(c_1,\gamma_1)\subseteq
\EE(q^+_1,Q^+_1), \]
wherein ${\bf S}(c_1,\gamma_1)$ is the halfspace defined by the first row of matrix $C$,
$c_1$, and the first element of vector $g$, $\gamma_1$. Then, one by one, we get
\begin{eqnarray*}
& & \EE(q^-_2,Q^-_2)\subseteq\EE(q^-_1,Q^-_1)\cap{\bf S}(c_2,\gamma_2), ~~~
\EE(q^+_1,Q^+_1)\cap{\bf S}(c_2,\gamma_2)\subseteq\EE(q^+_2,Q^+_2), \\
& & \EE(q^-_3,Q^-_3)\subseteq\EE(q^-_2,Q^-_2)\cap{\bf S}(c_3,\gamma_3), ~~~
\EE(q^+_2,Q^+_2)\cap{\bf S}(c_3,\gamma_3)\subseteq\EE(q^+_3,Q^+_3), \\
& & \cdots \\
& & \EE(q^-_m,Q^-_m)\subseteq\EE(q^-_{m-1},Q^-_{m-1})\cap{\bf S}(c_m,\gamma_m), ~~~
\EE(q^+_{m-1},Q^+_{m-1})\cap{\bf S}(c_m,\gamma_m)\subseteq\EE(q^+_m,Q^+_m), \\
\end{eqnarray*}
The resulting ellipsoidal approximations are
\[ \EE(q^+,Q^+)=\EE(q^+_m,Q^+_m), ~~~~ \EE(q^-,Q^-)=\EE(q^-_m,Q^-_m) .\]





\chapter{Reachability}
\section{Continuous-Time Systems}
Consider the system
\begin{equation}
\dot{x}(t) = A(t)x(t) + B(t)u(t,x(t)) + G(t)v(t), \label{ctsystem}
\end{equation}
in which $x\in{\bf R}^n$ is the state, $u\in{\bf R}^m$ is the control and
$v\in{\bf R}^d$ is the disturbance. $A(t)$, $B(t)$ and $G(t)$
are continuous and take their values in ${\bf R}^{n\times n}$,
${\bf R}^{n\times m}$ and ${\bf R}^{n\times d}$ respectively.
Control $u(t,x(t))$ and disturbance $v(t)$ are measurable functions
restricted by ellipsoidal constraints:
$u(t,x(t)) \in \EE(p(t), P(t))$ and $v(t) \in \EE(q(t), Q(t))$.
The set of initial conditions is assumed to be the ellipsoid $\EE(x_0,X_0)$.

The state transition matrix of system (\ref{ctsystem}) is
\[ \dot{\Phi}(t, t_0) = A(t)\Phi(t, t_0), ~~~ \Phi(t,t)=I, \]
which for constant matrix $A$ simplifies as
\[ \Phi(t,t_0) = e^{A(t-t_0)} .\]
Although (\ref{ctsystem}) indicates that control $u(t,x(t))$ depends on the
state, hence is closed-loop, the system may also be controlled by open-loop
control $u(t,x(t))=u(t)$, $t\geq t_0$.
The reachable set of system (\ref{ctsystem}) under open-loop control (OLRS)
is different from the closed-loop reach set (CLRS).

We distinguish two types of OLRS.  We are
given the set of initial conditions $\EE(x_0,X_0)$, initial time $t_0$ and
time $t>t_0$.
\bd[OLRS of maxmin type] The
maxmin open-loop reach set $\overline{\XX}(t,t_0,\EE(x_0,X_0))$
is the set of all states $x$, such
that for any disturbance $v(\tau)\in\EE(q(\tau),Q(\tau))$ there exist
initial state $x^0\in\EE(x_0,X_0)$ and control $u(\tau)\in\EE(p(\tau),P(\tau))$,
$t_0\leq\tau<t$,
which steers the system from $x(t_0)=x^0$ to $x(t)=x$.
\ed
\bd[OLRS of minmax type] The
minmax open-loop reach set $\underline{\XX}(t,t_0,\EE(x_0,X_0))$
is the set of all states $x$, such
that there exists control $u(\tau)\in\EE(p(\tau),P(\tau))$ that for all
disturbances $v(\tau)\in\EE(q(\tau),Q(\tau))$,
$t_0\leq\tau<t$, assigns initial state
$x^0\in\EE(x_0,X_0)$ and steers the system from $x(t_0)=x^0$ to $x(t)=x$.
\ed


{\bf Remark.} The terms `maxmin' and `minmax' come from the fact that
$\overline{\XX}(t,t_0,\EE(x_0,X_0))$ is a subzero level set of the value
function
\[ \underline{V}(t,x) =
\max_v\min_u\{{\bf dist}(x(t_0),\EE(x_0,X_0)) ~|~ x(t)=x)\}, \]
and $\underline{\XX}(t,t_0,\EE(x_0,X_0))$ is a subzero level set of the value
function
\[ \overline{V}(t,x) =
\min_u\max_v\{{\bf dist}(x(t_0),\EE(x_0,X_0)) ~|~ x(t)=x)\}. \]

In maxmin case, the control is chosen for the \emph{known} disturbance
in the time interval $[t_0,t]$, and the reach set is
\begin{eqnarray}
&& \overline{\XX}(t,t_0,\EE(x_0,X_0)) = \nonumber\\
&& \Big{(}\Phi(t,t_0)\EE(x_0,X_0)\oplus
\int_{t_0}^t\Phi(t,\tau)B(\tau)\EE(p(\tau),P(\tau))d\tau\Big{)} \nonumber\\
&& \dot{-}\int_{t_0}^t\Phi(t,\tau)(-G(\tau))\EE(q(\tau),Q(\tau))d\tau.
\label{maxminrs}
\end{eqnarray}
In minmax case, the control in the time interval $[t_0,t]$ is chosen with \emph{no}
knowledge of the disturbance and the reach set is
\begin{eqnarray}
&& \underline{\XX}(t,t_0,\EE(x_0,X_0)) = \nonumber\\
&& \Big{(}\Phi(t,t_0)\EE(x_0,X_0)\dot{-}
\int_{t_0}^t\Phi(t,\tau)(-G(\tau))\EE(q(\tau),Q(\tau))d\tau\Big{)} \nonumber\\
&& \oplus\int_{t_0}^t\Phi(t,\tau)B(\tau)\EE(p(\tau),P(\tau))d\tau.
\label{minmaxrs}
\end{eqnarray}
Since for any $\WW_1,\WW_2,\WW_3\subseteq{\bf R}^n$ it is true that
\begin{equation}
(\WW_1\dot{-}\WW_2)\oplus\WW_3 =
(\WW_1\oplus\WW_3)\dot{-}(\WW_2\oplus\WW_3) \subseteq
(\WW_1\oplus\WW_3)\dot{-}\WW_2, \label{gdiffinc}
\end{equation}
the following inclusion holds,
\[ \underline{\XX}(t,t_0,\EE(x_0,X_0)) \subseteq
\overline{\XX}(t,t_0,\EE(x_0,X_0)) .\]
Fixing a time instant $\tau_1$, $t_0<\tau_1<t$, define
{\it sequential} maxmin OLRS with {\it one correction}:
\[ \overline{\XX}_1(t,t_0,\EE(x_0,X_0)) =
\overline{\XX}(t,\tau_1,\overline{\XX}(\tau_1,t_0,\EE(x_0,X_0))), \]
and {\it sequential} minmax OLRS with {\it one correction}:
\[ \underline{\XX}_1(t,t_0,\EE(x_0,X_0)) =
\underline{\XX}(t,\tau_1,\underline{\XX}(\tau_1,t_0,\EE(x_0,X_0))). \]
Following (\ref{maxminrs}) and (\ref{minmaxrs}), we obtain integral
formulas for $\overline{\XX}_1(t,t_0,\EE(x_0,X_0))$,
\begin{eqnarray*}
&& \overline{\XX}_1(t,t_0,\EE(x_0,X_0)) = \\
&& \Big{(}\Phi(t,\tau_1)\Big{(}\Big{(}\Phi(\tau_1,t_0)\EE(x_0,X_0)\oplus
\int_{t_0}^{\tau_1}\Phi(\tau_1,\tau)B(\tau)\EE(p(\tau),P(\tau))d\tau\Big{)}\\
&& \dot{-}\int_{t_0}^{\tau_1}
\Phi(\tau_1,\tau)(-G(\tau))\EE(q(\tau),Q(\tau))d\tau\Big{)}
\oplus \int_{\tau_1}^t\Phi(t,\tau)B(\tau)\EE(p(\tau),P(\tau))d\tau\Big{)} \\
&& \dot{-}\int_{\tau_1}^{t}\Phi(t,\tau)(-G(\tau))\EE(q(\tau),Q(\tau))d\tau,
\end{eqnarray*}
and for $\underline{\XX}_1(t,t_0,\EE(x_0,X_0))$,
\begin{eqnarray*}
&& \underline{\XX}_1(t,t_0,\EE(x_0,X_0)) = \\
&& \Big{(}\Phi(t,\tau_1)\Big{(}\Big{(}\Phi(\tau_1,t_0)\EE(x_0,X_0)\dot{-}
\int_{t_0}^{\tau_1}\Phi(\tau_1,\tau)(-G(\tau))\EE(q(\tau),Q(\tau))d\tau\Big{)}\\
&& \oplus\int_{t_0}^{\tau_1}
\Phi(\tau_1,\tau)B(\tau)\EE(p(\tau),P(\tau))d\tau\Big{)}
\dot{-} \int_{\tau_1}^t\Phi(t,\tau)(-G(\tau))\EE(q(\tau),Q(\tau))d\tau\Big{)} \\
&& \oplus\int_{\tau_1}^{t}\Phi(t,\tau)B(\tau)\EE(p(\tau),P(\tau))d\tau .
\end{eqnarray*}
Recursively, sequential maxmin and minmax OLRS with {\it $k$ corrections}
for $t_0<\tau_1<\cdots<\tau_k<t$ can be defined,
\[ \overline{\XX}_k(t,t_0,\EE(x_0,X_0)) =
\overline{\XX}(t,\tau_k,\overline{\XX}_{k-1}(\tau_k,t_0,\EE(x_0,X_0))), \]
and
\[ \underline{\XX}_k(t,t_0,\EE(x_0,X_0)) =
\underline{\XX}(t,\tau_k,\underline{\XX}_{k-1}(\tau_k,t_0,\EE(x_0,X_0))). \]
By (\ref{gdiffinc}) the following inclusion holds,
\begin{eqnarray}
&& \underline{\XX}(t,t_0,\EE(x_0,X_0)) \subseteq
\underline{\XX}_1(t,t_0,\EE(x_0,X_0)) \subseteq
\cdots\subseteq\underline{\XX}_k(t,t_0,\EE(x_0,X_0)) \subseteq \nonumber \\
&& \overline{\XX}_k(t,t_0,\EE(x_0,X_0)) \subseteq \cdots \subseteq
\overline{\XX}_1(t,t_0,\EE(x_0,X_0)) \subseteq
\overline{\XX}(t,t_0,\EE(x_0,X_0)) .
\label{olrsinc}
\end{eqnarray}
As $k\rightarrow\infty$, we arrive at (see \cite{kurvar1})
\[ \overline{\XX}_\infty(t,t_0,\EE(x_0,X_0)) =
\underline{\XX}_\infty(t,t_0,\EE(x_0,X_0))
= \XX(t,t_0,\EE(x_0,X_0)) ,\]
in which $\XX(t,t_0,\EE(x_0,X_0))$ is CLRS.
\bd[CLRS]
Given initial time $t_0$ and the set of initial conditions $\EE(x_0,X_0)$,
the closed-loop reach set $\XX(t,t_0,\EE(x_0,X_0))$ of system (\ref{ctsystem})
at time $t>t_0$ is the set of all states $x$ for each of which
there exist initial condition $x^0\in\EE(x_0,X_0)$ and control $u(\tau,x(\tau))$
that for every disturbance $v(\tau)\in\EE(q(\tau),Q(\tau))$ assigns trajectory
$x(\tau)$ satisfying
\[ \dot{x}(\tau)\in A(\tau)x(\tau) + B(\tau)u(\tau,x(\tau)) + G(\tau)v(\tau),\]
with $t_0\leq\tau\leq t$, such that $x(t_0) = x_0$ and $x(t) = x$.
\ed
It follows from (\ref{olrsinc}) that maxmin OLRS is an external bound
and minmax OLRS is an internal bound for CLRS:
\[ \underline{\XX}(t,t_0,\EE(x_0,X_0)) \subseteq \XX(t,t_0,\EE(x_0,X_0))
\subseteq \overline{\XX}(t,t_0,\EE(x_0,X_0)) .\]
CLRS can be empty.
This happens for example, if the set of initial conditions is reduced
to a single state $x_0$ and control $u(t)$ is fixed,
but the disturbance bound $\EE(q(t),Q(t))$ is a nondegenerate ellipsoid
for all $t$.
A sufficient condition for $\XX(t,t_0,\EE(x_0,X_0)\neq\emptyset$ is
\begin{equation}
\EE(0,G(\tau)Q(\tau)G^T(\tau))\subseteq\EE(0,B(\tau)P(\tau)B^T(\tau))
\label{suffnonempty}
\end{equation}
for $t_0\leq\tau\leq t$.
To ensure $\XX(t,t_0,\EE(x_0,X_0))\neq\emptyset$ when (\ref{suffnonempty})
does not hold, the initial set $\EE(x_0,X_0)$ must be sufficiently large.

{\bf Remark.} If matrix $Q(\cdot)=0$, the system (\ref{ctsystem})
becomes an ordinary affine system with known $v(\cdot)=q(\cdot)$.
If matrix $G(\cdot)=0$, (\ref{ctsystem}) reduces to a linear controlled system.
In the absence of disturbance ($Q(\cdot)=0$ or $G(\cdot)=0$), reach set
$\XX(t,t_0,\EE(x_0,X_0))$ is the set of all states $x$
to which system (\ref{ctsystem}) can be steered at time $t$ through all
admissible controls $u(\tau,x(\tau))\in\EE(p(\tau),P(\tau))$
($u(\tau)\in\EE(p(\tau),P(\tau))$) starting at any $x^0\in\EE(x_0,X_0)$ at time
$t_0$, $t_0\leq\tau<t$.
In this case, the reach set is always nonempty and
is the same for open-loop and closed-loop controls.

The reach sets for systems with disturbances computed by {\it Ellipsoidal
Toolbox} are CLRS.
Hence, from now on, and further when describing backward reachability,
by reach set we refer to CLRS.

The reach set $\XX(t,t_0,\EE(x_0,X_0))$ is a symmetric compact convex set.
It satisfies the semigroup property:
\[ \XX(t,t_0,\EE(x_0,X_0)) = \XX(t, \tau, \XX(\tau, t_0, \EE(x_0, X_0))),
~~~ t_0\leq\tau\leq t. \]
The reach set can be approximated by the parametrized families of external
and internal ellipsoids, $\EE(x_c(t),X^+_l(t))$ and $\EE(x_c(t),X^-_l(t))$
respectively:
\[ \EE(x_c(t), X^-_l(t))\subseteq\XX(t,t_0,\EE(x_0,X_0))
\subseteq \EE(x_c(t), X^+_l(t)). \]
The trajectory of the center is governed by the equation
\begin{equation}
\dot{x}_c(t) = A(t)x_c(t) + B(t)p(t) + G(t)q(t), ~~~
x_c(t_0)=x_0. \label{fwdcenter}
\end{equation}
The equation for the shape matrix of the external ellipsoid is
\begin{eqnarray}
\dot{X}^+_l(t) & = & A(t)X^+_l(t) + X^+_l(t)A^T(t) \label{fwdext1} \\
& + & \pi_l(t)X^+_l(t) + \frac{1}{\pi_l(t)}B(t)P(t)B^T(t) \label{fwdext2} \\
& - & X_l^{+1/2}(t)S_l(t)(G(t)Q(t)G^T(t))^{1/2} -
(G(t)Q(t)G^T(t))^{1/2}S_l^T(t)X_l^{+1/2}(t), \label{fwdext3} \\
& & X^+_l(t_0) = X_0, \label{fwdext4}
\end{eqnarray}
in which
\[ \pi_l(t) = \frac{\langle l,
\Phi(t_0,t)B(t)P(t)B^T(t)\Phi^T(t_0,t)l\rangle^{1/2}}{\langle l,
\Phi(t_0,t)X^+_l(t)\Phi^T(t_0,t)l\rangle^{1/2}}, \]
and matrix $S_l(t)$ is orthogonal ($S_l(t)S_l^T(t) = I$), determined
from the equation
\[ S_l(t)(G(t)Q(t)G^T(t))^{1/2}\Phi^T(t_0,t)l = \frac{\langle l,
\Phi(t_0,t)G(t)Q(t)G^T(t)\Phi^T(t_0,t)l\rangle^{1/2}}{\langle l,
\Phi(t_0,t)X_l^+(t)\Phi^T(t_0,t)l\rangle^{1/2}}X_l^{+1/2}(t)\Phi^T(t_0,t)l. \]
In the presence of disturbance if the reach set is empty, the
matrix $X^+_l(t)$ becomes sign indefinite.
For a system without disturbance, the part indicated by (\ref{fwdext3}) naturally vanishes
from the equation (\ref{fwdext1}-\ref{fwdext4}).

The equation for the shape matrix of the internal ellipsoid is
\begin{eqnarray}
\dot{X}^-_l(t) & = & A(t)X^-_l(t) + X^-_l(t)A^T(t) \label{fwdint1} \\
& + & X_l^{-1/2}(t)T_l(t)(B(t)P(t)B^T(t))^{1/2} +
(B(t)P(t)B^T(t))^{1/2}T_l^T(t)X_l^{-1/2}(t) \label{fwdint2} \\
& - & \eta_l(t)X^-_l(t) - \frac{1}{\eta_l(t)}G(t)Q(t)G^T(t), \label{fwdint3} \\
& & X^-_l(t_0) = X_0, \label{fwdint4}
\end{eqnarray}
in which
\[ \eta_l(t) = \frac{\langle l,
\Phi(t_0,t)G(t)Q(t)G^T(t)\Phi^T(t_0,t)l\rangle^{1/2}}{\langle l,
\Phi(t_0,t)X^+_l(t)\Phi^T(t_0,t)l\rangle^{1/2}}, \]
and matrix $T_l(t)$ is orthogonal, determined from the equation
\[ T_l(t)(B(t)P(t)B^T(t))^{1/2}\Phi^T(t_0,t)l = \frac{\langle l,
\Phi(t_0,t)B(t)P(t)B^T(t)\Phi^T(t_0,t)l\rangle^{1/2}}{\langle l,
\Phi(t_0,t)X_l^-(t)\Phi^T(t_0,t)l\rangle^{1/2}}X_l^{-1/2}(t)\Phi^T(t_0,t)l. \]
Similarly to the external case, the part indicated by (\ref{fwdint3}) vanishes from
the equation (\ref{fwdint1}-\ref{fwdint4}) for a system without disturbance.
Here vector $l\in{\bf R}^n$ is a parameter, and approximations
$\EE(x_c(t),X^+_l(t))$, $\EE(x_c(t),X^-_l(t))$ are tight - they touch
the boundary of the reach set $\XX(t,t_0,\EE(x_0,X_0))$ at the point
determined by the direction $\Phi(t_0,t)l$:
\begin{equation}
\rho(\Phi(t_0,t)l ~|~ \EE(x_c(t),X^-_l(t))) =
\rho(\Phi(t_0,t)l ~|~ \XX(t,t_0,\EE(x_0,X_0))) =
\rho(\Phi(t_0,t)l ~|~ \EE(x_c(t),X^+_l(t))). \label{fwdtight}
\end{equation}
The boundary point where the external and internal ellipsoids touch the
boundary of the reach set is given by
\[ x_l^*(t) = x_c(t) + \frac{X^+_l(t)\Phi^T(t_0,t)l}{\langle l,
\Phi(t_0,t)X^+_l(t)\Phi^T(t_0,t)l\rangle^{1/2}} =
x_c(t) + \frac{X^-_l(t)\Phi^T(t_0,t)l}{\langle l,
\Phi(t_0,t)X^-_l(t)\Phi^T(t_0,t)l\rangle^{1/2}}. \]
Points $x^*_l(t)$ form trajectories, to which we refer as {\it good
curves}.
Due to the nonsingular nature of matrix $\Phi(t_0,t)$,
for every boundary point of the reach set there exists a good curve
to which it belongs.
To follow a good curve specified by parameter $l$, the
system has to start at time $t_0$ at initial state
\begin{equation}
x^0_l = x_0 + \frac{X_0l}{\langle l,X_0l\rangle^{1/2}}, \label{x0lct}
\end{equation}
and the control must be chosen as
\begin{equation}
u_l(t) = p(t) + \frac{P(t)B^T(t)\Phi(t_0,t)l}{\langle l,
\Phi(t_0,t)B(t)P(t)B^T(t)\Phi(t_0,t)l\rangle^{1/2}}. \label{uct}
\end{equation}
This is an open-loop control.
If there is no disturbance, it steers the system along the good curve defined by
vector $l$.
In the presence of disturbance, this control keeps the system on a good curve
if and only if the disturbance plays against the control
always taking its extreme values.

Expression (\ref{fwdtight}) leads to the following fact:
\begin{equation}
\bigcup_{\langle l,l\rangle=1}\EE(x_c(t),X^-_l(t)) = \XX(t,t_0,\EE(x_0,X_0)) =
\bigcap_{\langle l,l\rangle=1}\EE(x_c(t),X^+_l(t)).
\end{equation}
In practice this means that the more values of $l$ we use to compute $X^+_l(t)$ and
$X^-_l(t)$, the better will be our approximation.

Analogous results hold for the backward reach set.
\bd
Given the terminating time $t_1$ and target set $\EE(y_1,Y_1)$,
the backward reach set (closed-loop) $\YY(t_1,t,\EE(y_1,Y_1))$
of system (\ref{ctsystem}) at time $t<t_1$ is the set of all states $y$,
for each of which there exists terminating state $y^1\in\EE(y_1,Y_1)$
and control $u(\tau,y(\tau))$ that for every disturbance
$v(\tau)\in\EE(q(\tau),Q(\tau))$ assigns trajectory $y(\tau)$ satisfying
\[ \dot{y}(\tau)\in A(\tau)y(\tau)+B(\tau)u(\tau,y(\tau)) + G(\tau)v(\tau), \]
where $t\leq\tau<t_1$, $y(t)=y$ and $y(t_1)=y^1$.
\ed
The backward reach set satisfies the semigroup property:
\[ \YY(t_1,t,\EE(y_1,Y_1)) = \YY(\tau,t,\YY(t_1,\tau,\EE(y_1,Y_1))),
~~~ t\leq\tau\leq t_1. \]
Being convex and compact, the backward reach set $\YY(t_1,t,\EE(y_1,Y_1))$
can be tightly approximated by external ellipsoids $\EE(y_c(t),Y^+_l(t))$
and internal ellipsoids $\EE(y_c(t),Y^-_l(t))$ parametrized by the
direction vector $l\in{\bf R}^n$. The equation for the center is given by
\begin{equation}
y_c(t) = Ay_c(t) + B(t)p(t) + G(t)q(t), ~~~ y_c(t_1) = y_1.\label{bckcenter}
\end{equation}
The equation for the shape matrix of the external ellipsoid is
\begin{eqnarray}
\dot{Y}^+_l(t) & = & A(t)Y^+_l(t) + Y^+_l(t)A^T(t) \label{bckext1} \\
& - & \pi_l(t)Y^+_l(t) - \frac{1}{\pi_l(t)}B(t)P(t)B^T(t) \label{bckext2} \\
& + & Y_l^{+1/2}(t)S_l(t)(G(t)Q(t)G^T(t))^{1/2} +
(G(t)Q(t)G^T(t))^{1/2}S_l^T(t)Y_l^{+1/2}(t), \label{bckext3} \\
& & Y^+_l(t_1) = Y_1, \label{bckext4}
\end{eqnarray}
in which
\[ \pi_l(t) = \frac{\langle l,
\Phi(t_1,t)B(t)P(t)B^T(t)\Phi^T(t_1,t)l\rangle^{1/2}}{\langle l,
\Phi(t_1,t)Y^+_l(t)\Phi^T(t_1,t)l\rangle^{1/2}}, \]
and matrix $S_l(t)$ is orthogonal and satisfies the equation
\[ S_l(t)(G(t)Q(t)G^T(t))^{1/2}\Phi^T(t_1,t)l = \frac{\langle l,
\Phi(t_1,t)G(t)Q(t)G^T(t)\Phi^T(t_1,t)l\rangle^{1/2}}{\langle l,
\Phi(t_1,t)Y_l^+(t)\Phi^T(t_1,t)l\rangle^{1/2}}Y_l^{+1/2}(t)\Phi^T(t_1,t)l. \]
The equation for the shape matrix of the internal ellipsoid is
\begin{eqnarray}
\dot{Y}^-_l(t) & = & A(t)Y^-_l(t) + Y^-_l(t)A^T(t) \label{bckint1} \\
& - & Y_l^{-1/2}(t)T_l(t)(B(t)P(t)B^T(t))^{1/2} -
(B(t)P(t)B^T(t))^{1/2}T_l^T(t)Y_l^{-1/2}(t) \label{bckint2} \\
& + & \eta_l(t)Y^-_l(t) + \frac{1}{\eta_l(t)}G(t)Q(t)G^T(t), \label{bckint3} \\
& & Y^-_l(t_1) = Y_1, \label{bckint4}
\end{eqnarray}
in which
\[ \eta_l(t) = \frac{\langle l,
\Phi(t_1,t)G(t)Q(t)G^T(t)\Phi^T(t_1,t)l\rangle^{1/2}}{\langle l,
\Phi(t_1,t)Y^+_l(t)\Phi^T(t_1,t)l\rangle^{1/2}}, \]
and matrix $T_l(t)$ is orthogonal and determined from the equation
\[ T_l(t)(B(t)P(t)B^T(t))^{1/2}\Phi^T(t_1,t)l = \frac{\langle l,
\Phi(t_1,t)B(t)P(t)B^T(t)\Phi^T(t_1,t)l\rangle^{1/2}}{\langle l,
\Phi(t_1,t)Y_l^-(t)\Phi^T(t_1,t)l\rangle^{1/2}}Y_l^{-1/2}(t)\Phi^T(t_1,t)l. \]
Just as in the forward reachability case, the parts (\ref{bckext3}) and
(\ref{bckint3}) vanish from  equations (\ref{bckext1}-\ref{bckext4}) and
(\ref{bckint1}-\ref{bckint4}) in the absence of disturbance.
Boundary value problems (\ref{bckcenter}), (\ref{bckext1}-\ref{bckext4})
and (\ref{bckint1}-\ref{bckint4}) are converted to the initial value
problems by the change of variables $s = -t$.

{\bf Remark.} In expressions (\ref{fwdext2}), (\ref{fwdint3}),
(\ref{bckext2}) and (\ref{bckint3}) the terms $\frac{1}{\pi_l(t)}$
and $\frac{1}{\eta_l(t)}$ may not be well defined for some vectors $l$,
because matrices $B(t)P(t)B^T(t)$ and $G(t)Q(t)G^T(t)$ may be singular.
In such cases, we take these entire expressions to equal zero.

For more detail on reach set calculation and good curves, and proofs, see
\cite{kurvar, varaiya}. For more information on systems
with disturbances, see \cite{kurvar1,kurvar2}.



\section{Discrete-Time Systems}
Consider the discrete-time affine system:
\begin{equation}
x[k+1] = A[k]x[k] + B[k]u[k,x[k]] + G[k]v[k], \label{dtsystem}
\end{equation}
where $x[k]\in{\bf R}^n$ is the state, $u[k,x[k]]\in{\bf R}^m$ is the control
bounded by the ellipsoid $\EE(p[k],P[k])$,
$v[k]\in{\bf R}^d$ is disturbance bounded by ellipsoid $\EE(q[k],Q[k])$,
and matrices $A[k]$, $B[k]$, $G[k]$ are in ${\bf R}^{n\times n}$,
${\bf R}^{n\times m}$, ${\bf R}^{n\times d}$ respectively.
The set of initial conditions is ellipsoid $\EE(x_0,X_0)$.

The state transition matrix is
\[ \Phi(k+1,k_{0})=A[k]\Phi(k,k_{0}), ~~~ k\geq k_0, ~~~ \Phi(k,k)=I, \]
which for time-invariant systems simplifies as
\[ \Phi(k,k_{0})=A^{k-k_0}. \]
Just as in continuous-time systems, control $u[k, x[k]]$ in (\ref{dtsystem})
may be open- (if $u[k,x[k]] = u[k]$, $k\geq k_0$) or closed-loop.
Hence, just as in continuous-time case, the reach set can be classified as
OLRS or CLRS.
\bd[OLRS of maxmin type]
The maxmin open-loop reach set $\overline{\XX}_{OL}(k,k_0,\EE(x_0,X_0))$ is the set
of all states $x$, such that for any disturbance $v[i]\in\EE(q[i],Q[i])$ there
exist initial state $x^0\in\EE(x_0,X_0)$ and control $u[i]\in\EE(p[i],P[i])$,
$k_0\leq i<k$, which steers the system from $x[k_0]=x^0$ to $x[k]=x$.
\ed
In this case, the control is chosen for the \emph{known} disturbance in the
time step interval $[k_0, k)$, and the reach set is
\begin{eqnarray}
& & \overline{\XX}_{OL}(k,k_0,\EE(x_0,X_0)) = \nonumber \\
& & \Big{(}\Phi(k,k_0)\EE(x_0,X_0)\oplus
\sum_{i=k_0}^{k-1}\Phi(k,i+1)B[i]\EE(p[i],P[i])\Big{)} \nonumber \\
& & \dot{-} \sum_{i=k_0}^{k-1}\Phi(k,i+1)(-G[i])\EE(q[i],Q[i]).
\end{eqnarray}
\bd[OLRS of minmax type]
The minmax open-loop reach set $\underline{\XX}_{OL}(k,k_0,\EE(x_0,X_0))$ is the set
of all states $x$, such that there exists control $u[i]\in\EE(p[i],P[i])$ that
for all disturbances $v[i]\in\EE(q[i],Q[i])$, $k_0\leq i<k$, assigns initial
state $x^0\in\EE(x_0,X_0)$ and steers the system from $x[k_0]=x^0$ to
$x[k]=x$. 
\ed
Here, the control in the time step interval $[k_0,k)$ is chosen with \emph{no}
knowledge of the disturbance and the reach set is
\begin{eqnarray}
& & \underline{\XX}_{OL}(k,k_0,\EE(x_0,X_0)) = \nonumber \\
& & \Big{(}\Phi(k,k_0)\EE(x_0,X_0)\dot{-}
\sum_{i=k_0}^{k-1}\Phi(k,i+1)(-G[i])\EE(q[i],Q[i])\Big{)} \nonumber \\
& & \oplus
\sum_{i=k_0}^{k-1}\Phi(k,i+1)B[i]\EE(p[i],P[i]).
\end{eqnarray}
For the same reason as in continuous-time case the following inclusion is true:
\[ \underline{\XX}_{OL}(k,k_0,\EE(x_0,X_0)) \subseteq
\overline{\XX}_{OL}(k,k_0,\EE(x_0,X_0)) . \]
Analogously to continuous-time case, we can introduce the notion of OLRS
(maxmin or minmax) with one correction. Maxmin OLRS with one correction is
\[ \overline{\XX}_1(k,k_0,\EE(x_0,X_0) =
\overline{\XX}_{OL}(k,k_0+1,\overline{\XX}_{OL}(k_0+1,k_0,\EE(x_0,X_0))), \]
and minmax OLRS with one correction is
\[ \underline{\XX}_1(k,k_0,\EE(x_0,X_0) =
\underline{\XX}_{OL}(k,k_0+1,\underline{\XX}_{OL}(k_0+1,k_0,\EE(x_0,X_0))). \]
Recursively, sequential maxmin and minmax OLRS with $i>1$ corrections
can be defined,
\begin{equation}
\overline{\XX}_i(k,k_0,\EE(x_0,X_0) =
\overline{\XX}_{OL}(k,k_0+i,\overline{\XX}_{i-1}(k_0+i,k_0,\EE(x_0,X_0))),
\label{mxmnicorr}
\end{equation}
and
\begin{equation}
\underline{\XX}_i(k,k_0,\EE(x_0,X_0) =
\underline{\XX}_{OL}(k,k_0+i,\underline{\XX}_{i-1}(k_0+i,k_0,\EE(x_0,X_0))). 
\label{mnmxicorr}
\end{equation}
\bd[CLRS of maxmin type]
The maxmin closed-loop reach set is
\[ \overline{\XX}(k,k_0,\EE(x_0,X_0)) =
\overline{\XX}_{k-k_0-1}(k,k_0,\EE(x_0,X_0)) , \]
where $\overline{\XX}_{k-k_0-1}$ is defined in (\ref{mxmnicorr}).
\ed
\bd[CLRS of minmax type]
The minmax closed-loop reach set is
\[ \underline{\XX}(k,k_0,\EE(x_0,X_0)) =
\underline{\XX}_{k-k_0-1}(k,k_0,\EE(x_0,X_0)) , \]
where $\underline{\XX}_{k-k_0-1}$ is defined in (\ref{mnmxicorr}).
\ed

{\bf Remark.} Notice the difference between continuous-time case, in which
sequential maxmin and minmax OLRS converge to single CLRS as number of
corrections tends to infinity, and discrete-time case where the number of
corrections stays finite creating two types of CLRS - maxmin and minmax.

Similarly to the continuous-time case, we can write 
\[ \underline{\XX}_{OL}(k,k_0,\EE(x_0,X_0)) \subseteq
\underline{\XX}(k,k_0,\EE(x_0,X_0)) \subseteq
\overline{\XX}(k,k_0,\EE(x_0,X_0)) \subseteq 
\overline{\XX}_{OL}(k,k_0,\EE(x_0,X_0)) .  \]
Both, maxmin and minmax CLRS can be empty. Necessary and sufficient condition
for maxmin CLRS $\overline{\XX}(k,k_0,\EE(x_0,X_0))$ to be nonempty is
\[ A[i]\overline{\XX}(i,k_0,\EE(x_0,X_0)) \oplus B[i]\EE(p[i],P[i])
\dot{-} G[i]\EE(q[i],Q[i]) \neq \emptyset \]
for all $i$, $k_0\leq i<k$. Necessary and sufficient condition 
for minmax CLRS $\underline{\XX}(k,k_0,\EE(x_0,X_0))$ to be nonempty is
\[ A[i]\underline{\XX}(i,k_0,\EE(x_0,X_0)) 
\dot{-} G[i]\EE(q[i],Q[i]) \neq \emptyset \]
for all $i$, $k_0\leq i<k$. This last condition is especially restricting -
it requires the set of initial conditions to be sufficiently large.

The reach sets $\overline{\XX}(k,k_0,\EE(x_0,X_0))$ and
$\underline{\XX}(k,k_0,\EE(x_0,X_0))$, if nonempty,
are symmetric compact convex sets.
Both satisfy semigroup property:
\[ \overline{\XX}(k,k_0,\EE(x_0,X_0)) =
 \overline{\XX}(k,i,\overline{\XX}(i,k_0,\EE(x_0,X_0))) ,
~~~ k_0\leq i<k,\]
and
\[ \underline{\XX}(k,k_0,\EE(x_0,X_0)) =
 \underline{\XX}(k,i,\underline{\XX}(i,k_0,\EE(x_0,X_0))) ,
~~~ k_0\leq i<k.\]
The reach sets for systems with disturbances computed by
{\it Ellipsoidal Toolbox} are maxmin and minmax CLRS.
Hence, from now on, and further when describing backward reachability,
by maxmin or minmax reach set we refer to maxmin or minmax CLRS.

If matrix $Q[\cdot]=0$, then the system (\ref{dtsystem}) becomes
ordinary affine system with known $v[\cdot]=q[\cdot]$.
If matrix $G[\cdot]=0$, then the system reduces to a linear controlled
system. In the absence of disturbance ($Q[\cdot]=0$ or $G[\cdot]=0$),
definitions of minmax OLRS and CLRS do not make sense, and the reach set
$\XX(k,k_0,\EE(x_0,X_0)) = \overline{\XX}_{OL}(k,k_0,\EE(x_0,X_0)) =
\overline{\XX}(k,k_0,\EE(x_0,X_0))$ is the set of all states $x$ to which
system (\ref{dtsystem}) can be steered in $k-k_0$ time steps through all
admissible controls $u[i,x[i]]\in\EE(p[i],P[i])$ ($u[i]\in\EE(p[i],P[i])$)
starting at any $x^0\in\EE(x_0,X_0)$ at time $k_0$, $k_0,\leq i<k$.

In the absence of disturbance, if matrices $A[k]$ are nonsingular
and the set of initial conditions $\EE(x_0,X_0)$ is a nondegenerate ellipsoid,
the reach set $\XX(k,k_0,\EE(x_0,X_0))$, $k>k_0$, is convex and compact,
has nonempty interior, and can be approximated by the families of
external and internal ellipsoids $\EE(x_c[k],X^+_l[k])$,
$\EE(x_c[k],X^-_l[k])$, parametrized by vector $l\in{\bf R}^n$:
\[ \EE(x_c[k], X^-_l[k]) \subseteq \XX(k,k_0,\EE(x_0,X_0)) \subseteq
\EE(x_c[k], X^+_l[k]), \]
and at the same time
\[ \rho(\Phi(k_0,k)l ~|~ \EE(x_c[k], X^-_l[k])) =
\rho(\Phi(k_0,k)l ~|~ \XX(k,k_0,\EE(x_0,X_0))) =
\rho(\Phi(k_0,k)l ~|~ \EE(x_c[k], X^+_l[k])). \]
The recurrence relation for the center is given by
\begin{equation}
x_c[k+1] = A[k]x_c[k] + B[k]p[k] + G[k]v[k], ~~~ x_c[k_0]=x_0.
\label{dfwdcenter}
\end{equation}
The shape matrix of the external ellipsoid is determined from
\begin{equation}
X^+_l[k+1] = (1+\pi_l[k])A[k]X^+_l[k]A^T[k] +
(1+\frac{1}{\pi_l[k]})B[k]P[k]B^T[k], ~~ X^+_l[k_0] = X_0, \label{dfwdext}
\end{equation}
in which
\begin{equation}
\pi_l[k] = \frac{\langle l,
\Phi(k_0,k+1)B[k]P[k]B^T[k]\Phi^T(k_0,k+1)l\rangle^{1/2}}{\langle l,
\Phi(k_0,k)X^+_l[k]\Phi^T(k_0,k)l\rangle^{1/2}}, ~~~ k\geq k_0.
\label{pidscrt}
\end{equation}
The shape matrix of the internal ellipsoid is
\begin{eqnarray}
X^-_l[k+1] & = & A[k]X^-_l[k]A^T[k] + B[k]P[k]B^T[k] \nonumber \\
& + & A[k]X^{-1/2}_l[k]S_l[k](B[k]P[k]B^T[k])^{1/2} \nonumber \\
& + & (B[k]P[k]B^T[k])^{1/2}S^T_l[k]X^{-1/2}_l[k]A^T[k], ~~~
X^-_l[k_0]=X_0, \label{dfwdint}
\end{eqnarray}
in which matrix $S_l[k]$ is orthogonal and determined from the equation
\[ S_l[k](B[k]P[k]B^T[k])^{1/2}\Phi(k_0,k+1)l = \frac{\langle l,
\Phi(k_0,k+1)B[k]P[k]B^T[k]\Phi^T(k_0,k+1)l\rangle^{1/2}}{\langle l,
X_0l\rangle^{1/2}}X_0^{1/2}l. \]
The point where  the external and the internal ellipsoids both touch
the boundary of the reach set is given by
\[ x_l^*[k] = x_c[k] + \frac{X^+_l[k]\Phi^T(k_0,k)l}{\langle l,
\Phi(k_0,k)X^+_l[k]\Phi^T(k_0,k)l\rangle^{1/2}} =
x_c[k] + \frac{X^-_l[k]\Phi^T(k_0,k)l}{\langle l,
\Phi(k_0,k)X^-_l[k]\Phi^T(k_0,k)l\rangle^{1/2}}. \]
Points $x^*_l[k]$, $k\geq k_0$, form a good curve. In order for the system
to follow the good curve specified by some vector $l$, the initial
state must be
\begin{equation}
x_l^0 = x_0 + \frac{X_0l}{\langle l, X_0l\rangle^{1/2}}, \label{dx0l}
\end{equation}
and the control must be
\begin{equation}
u_l[k] = p[k] + \frac{P[k]B^T[k]\Phi^T(k_0,k+1)l}{\langle l,
\Phi(k_0,k+1)B[k]P[k]B^T[k]\Phi(k_0,k+1)l\rangle^{1/2}}. \label{udt}
\end{equation}

{\bf Remark.} There are cases when $\pi_l[k]$ in (\ref{pidscrt}) and
$u_l[k]$ in (\ref{udt}) are not well defined due to singularity of the matrix
$B[k]P[k]B^T[k]$. The way to handle these situations, as well as systems
with singular $A[k]$, is described in detail in \cite{pvak}.

It can be seen that
$\EE(x_c[k+1],X_l^+[k+1])$ is external approximating ellipsoid of the sum
\[ A[k]\EE(x_c[k],X_l^+[k]) \oplus B[k]\EE(p[k],P[k]) \]
in the direction
\begin{equation}
l[k] = \Phi(k_0,k)^Tl, \label{fwdlk}
\end{equation}
and $\EE(x_c[k+1],X_l^-[k+1])$ is internal approximating ellipsoid of the sum
\[ A[k]\EE(x_c[k],X_l^-[k]) \oplus B[k]\EE(p[k],P[k]), \]
with initial conditions
\[ x_c[k_0] = x_0, ~~~ X_l^+[k_0] = X_l^-[k_0] = X_0 .\]
In the presence of disturbance we can compute families of tight external
$\EE(x_c[k],\overline{X}_l^+[k])$ and internal
$\EE(x_c[k],\overline{X}_l^-[k])$ ellipsoidal approximations for
$\overline{\XX}(k,k_0,\EE(x_0,X_0))$, and tight external
$\EE(x_c[k],\underline{X}_l^+[k])$ and internal
$\EE(x_c[k],\underline{X}_l^-[k])$ ellipsoidal approximations for
$\underline{\XX}(k,k_0,\EE(x_0,X_0))$ for those directions $l$ for which
such approximations exist.

With initial conditions
\[ x_c[k_0]=x_0, ~~~ \overline{X}_l^+[k_0] = \overline{X}_l^-[k_0] = X_0, \]
at time step $k+1$
$\EE(x_c[k+1],\overline{X}_l^+[k+1])$ and $\EE(x_c[k+1],\overline{X}_l^-[k+1])$
are computed as external and internal ellipsoidal approximations of
\[ A[k]\EE(x_c[k],\overline{X}_l^+[k]) \oplus
B[k]\EE(p[k],P[k]) \dot{-} G[k]\EE(q[k],Q[k]) \]
and
\[ A[k]\EE(x_c[k],\overline{X}_l^-[k]) \oplus
B[k]\EE(p[k],P[k]) \dot{-} G[k]\EE(q[k],Q[k]) \]
for direction $l[k]$ from (\ref{fwdlk}) as described in section 2.2.5.

Similarly, with initial conditions
\[ x_c[k_0]=x_0, ~~~ \underline{X}_l^+[k_0] = \underline{X}_l^-[k_0] = X_0, \]
$\EE(x_c[k+1],\underline{X}_l^+[k+1])$ and
$\EE(x_c[k+1],\underline{X}_l^-[k+1])$ are computed as external and internal
ellipsoidal approximations of
\[ A[k]\EE(x_c[k],\underline{X}_l^+[k]) \dot{-} G[k]\EE(q[k],Q[k])
\oplus B[k]\EE(p[k],P[k]) \]
and
\[ A[k]\EE(x_c[k],\underline{X}_l^-[k]) \dot{-} G[k]\EE(q[k],Q[k])
\oplus B[k]\EE(p[k],P[k]) \]
for direction $l[k]$ from (\ref{fwdlk}) as described in section 2.2.4.

Backward reach sets for discrete-time systems can be computed only
if matrices $A[k]$ are nonsingular for all $k$.
\bd[CLBRS of maxmin type]
Given the terminating time step $k_1$ and target set $\EE(y_1,Y_1)$, the
closed-loop backward reach set (CLBRS) of maxmin type
$\overline{\YY}(y_1,k,\EE(y_1,Y_1))$ of system
(\ref{dtsystem}) at time step $k<k_1$ is the set of all states $y$, for each of
which there exists terminating state $y^1\in\EE(y_1,Y_1)$ and for every
disturbance value $v[i]\in\EE(q[i],Q[i])$ at time step $i$, $k\leq i<k_1$,
there exists control value $u[i,y[i]]$ such that trajectory $y[\cdot]$ satisfies
\[ y[i+1]\in A[i]y[i] + B[i]u[i,y[i]] + G[i]v[i], \]
where $k\leq i<k_1$, $y[k]=y$ and $y[k_1]=y^1$.
\ed
\bd[CLBRS of minmax type]
Given the terminating time step $k_1$ and target set $\EE(y_1,Y_1)$, the
closed-loop backward reach set of minmax type
$\underline{\YY}(y_1,k,\EE(y_1,Y_1))$ of system
(\ref{dtsystem}) at time step $k<k_1$ is the set of all states $y$, for each of
which there exists terminating state $y^1\in\EE(y_1,Y_1)$ and control value
$u[i,y[i]]$ at time step $i$, $k\leq i<k_1$, that for every disturbance
value $v[i]\in\EE(q[i],Q[i])$ assigns trajectory $y[i]$ satisfying
\[ y[i+1]\in A[i]y[i] + B[i]u[i,y[i]] + G[i]v[i], \]
where $k\leq i<k_1$, $y[k]=y$ and $y[k_1]=y^1$.
\ed
Both, maxmin and minmax CLBRS, satisfy semigroup property:
\[ \overline{\YY}(k_1,k,\EE(y_1,Y_1)) =
\overline{\YY}(i,k,\overline{\YY}(k_1,i,\EE(y_1,Y_1))), ~~~ k\leq i< k_1, \]
and
\[ \underline{\YY}(k_1,k,\EE(y_1,Y_1)) =
\underline{\YY}(i,k,\underline{\YY}(k_1,i,\EE(y_1,Y_1))), ~~~ k\leq i< k_1. \]
In the absence of disturbance ($Q[\cdot]=0$ or $G[\cdot]=0$),
system (\ref{dtsystem}) becomes affine or linear, definition of minmax CLBRS
does not make sense, and maxmin CLBRS is reduced to
\bd
Given the terminating time step $k_1$ and target set $\EE(y_1,Y_1)$, the
backward reach set $\YY(y_1,k,\EE(y_1,Y_1))$ of system (\ref{dtsystem})
at time step $k<k_1$ is the set of all states $y$, from which it is possible
to reach $\EE(y_1,Y_1)$ in $k_1-k$ steps using all admissible controls
$u[i,y[i]]\in\EE(p[i],P[i])$ (or $u[i]\in\EE(p[i],P[i])$), $k\leq i<k_1$.
\ed
Backward reach sets of systems with no disturbance can be tightly
approximated by external and internal ellipsoids,
$\EE(y_c[k],Y^+_l[k])$ and $\EE(y_c[k],Y^-_l[k])$.
The equation for the center $y_c[k]$ is
\begin{equation}
y_c[k] = A^{-1}[k](y_c[k+1] - B[k]p[k] - G[k]v[k]), ~~~ y_c[k_1] = y_1.
\label{dbckcenter}
\end{equation}
The equation for the shape matrix for the external ellipsoid is
\begin{eqnarray}
Y^+_l[k] & = & (1+\pi_l[k])A^{-1}[k]Y^+_l[k+1]A^{-1T}[k] \nonumber \\
& + & (1+\frac{1}{\pi_l[k]})A^{-1}[k]B[k]P[k]B^T[k]A^{-1T}[k], ~~~
Y^+_l[k_1] = Y_1, \label{dbckext}
\end{eqnarray}
in which
\[ \pi_l[k] = \frac{\langle l,
\Phi(k_1,k+1)B[k]P[k]B^T[k]\Phi^T(k_1,k+1)l\rangle^{1/2}}{\langle l,
\Phi(k_1,k+1)Y^+_l[k+1]\Phi^T(k_1,k+1)l\rangle^{1/2}}, ~~~ k<k_1. \]
The expression for the shape matrix of the internal ellipsoid is
\begin{eqnarray}
Y^-_l[k] & = & A^{-1}[k]Y^-_l[k+1]A^{-1T}[k]
+ A^{-1}[k]B[k]P[k]B^T[k]A^{-1T}[k] \nonumber \\
& + & A^{-1}[k]Y^{-1/2}_l[k+1]S_l[k]
(A^{-1}[k]B[k]P[k]B^T[k]A^{-1T}[k])^{1/2} \nonumber \\
& + & (A^{-1}[k]B[k]P[k]B^T[k]A^{-1T}[k])^{1/2}
S^T_l[k]Y^{-1/2}_l[k+1]A^{-1T}[k], ~~~ Y^-_l[k_1]=Y_1, \label{dbckint}
\end{eqnarray}
in which matrix $S_l[k]$ is orthogonal and determined from the equation
\[ S_l[k](A^{-1}[k]B[k]P[k]B^T[k]A^{-1T}[k])^{1/2}\Phi(k_1,k)l=
\frac{\langle l, \Phi(k_1,k)A^{-1}[k]B[k]P[k]B^T[k]A^{-1T}[k]
\Phi^T(k_1,k)l\rangle^{1/2}}{\langle l,Y_1l\rangle^{1/2}}Y_1^{1/2}l. \]
Ellipsoid $\EE(y_c[k],Y_l^+[k])$ is tight external approximation of the sum
\[ A^{-1}[k]\left(\EE(y_c[k+1],Y_l^+[k+1]) \oplus B[k]\EE(-p[k],P[k])\right) \]
for direction $l[k]$ defined by
\begin{equation}
l[k] = \Phi^T(k1,k)l, \label{bcklk}
\end{equation}
and ellipsoid $\EE(y_c[k],Y_l^-[k])$ is tight internal approximation of the sum
\[ A^{-1}[k]\left(\EE(y_c[k+1],Y_l^-[k+1]) \oplus B[k]\EE(-p[k],P[k])\right) \]
for direction (\ref{bcklk}), where the boundary conditions are
\[ y_c[k_1] = y_1, ~~~ Y_l^+[k_1]=Y_l^-[k_1]=Y_1 .\]
In the presence of disturbance we can compute families of tight external
$\EE(y_c[k],\overline{Y}_l^+[k])$ and internal
$\EE(y_c[k],\overline{Y}_l^-[k])$ ellipsoidal approximations for
$\overline{\YY}(k,k_0,\EE(y_1,Y_1))$, and tight external
$\EE(y_c[k],\underline{Y}_l^+[k])$ and internal
$\EE(y_c[k],\underline{Y}_l^-[k])$ ellipsoidal approximations for
$\underline{\YY}(k,k_0,\EE(y_1,Y_1))$ for those directions $l$ for which
such approximations exist.

With boundary conditions
\[ y_c[k_1]=y_1, ~~~ \overline{Y}_l^+[k_1] = \overline{Y}_l^-[k_1] = Y_1, \]
at time step $k$
$\EE(y_c[k],\overline{Y}_l^+[k])$ and $\EE(y_c[k],\overline{Y}_l^-[k])$
are computed as external and internal ellipsoidal approximations of
\[ A^{-1}[k]\left(\EE(y_c[k+1],\overline{Y}_l^+[k+1]) \oplus
B[k]\EE(-p[k],P[k]) \dot{-} G[k]\EE(-q[k],Q[k])\right) \]
and
\[ A^{-1}[k]\left(\EE(y_c[k+1],\overline{Y}_l^-[k+1]) \oplus
B[k]\EE(-p[k],P[k]) \dot{-} G[k]\EE(-q[k],Q[k])\right) \]
for direction $l[k]$ from (\ref{bcklk}) as described in section 2.2.5.

Similarly, with boundary conditions
\[ y_c[k_1]=y_1, ~~~ \underline{Y}_l^+[k_1] = \underline{Y}_l^-[k_1] = Y_1, \]
$\EE(y_c[k],\underline{Y}_l^+[k])$ and
$\EE(y_c[k],\underline{Y}_l^-[k])$ are computed as external and internal
ellipsoidal approximations of
\[ A^{-1}[k]\left(\EE(y_c[k+1],\underline{Y}_l^+[k+1]) \dot{-}
G[k]\EE(-q[k],Q[k]) \oplus B[k]\EE(-p[k],P[k])\right) \]
and
\[ A^{-1}[k]\left(\EE(y_c[k+1],\underline{Y}_l^-[k+1]) \dot{-}
G[k]\EE(-q[k],Q[k]) \oplus B[k]\EE(-p[k],P[k])\right) \]
for direction $l[k]$ from (\ref{bcklk}) as described in section 2.2.4.





\chapter{Installation}
\section{Additional Software}
Some routines of the {\it Ellipsoidal Toolbox}, namely,
\begin{itemize}
\item {\tt distance}
\item {\tt intersect}
\item {\tt intersection\_ia}
\item {\tt isinside}
\end{itemize}
require solving semidefinite programming (SDP) problems.
We use YALMIP (\cite{yalmip}, \cite{yalmiphp}) as an
interface to an external SDP solver. YALMIP supports a large variety of SDP
packages. One of them, SeDuMi (\cite{sedumi}, \cite{sedumihp}) is distributed
along with {\it ET}. The user is free to choose any other SDP solver so long
as it is supported by YALMIP. The list of supported SDP solvers can be
obtained from \cite{yalmiphp}.

Both YALMIP and SeDuMi are included in the {\it ET} distribution, so you
do not need to download them separately. However, if you have them already
installed, or wish to install them independently of {\it ET}, you should
download the lite version of {\it ET}.


\section{Installation and Quick Start}
\begin{enumerate}
\item Go to
\newline
{\tt http://www.eecs.berkeley.edu/\~{ }akurzhan/ellipsoids}
\newline
and download the {\it Ellipsoidal Toolbox} or its lite version stripped
of YALMIP and SeDuMi.
\item Unzip the distribution file into the directory where you would like
the toolbox to be.
\item Read the copyright notice.
\item In MATLAB command window change the working directory to the one where
you unzipped the toolbox and type
\newline
{\tt >> install}
\item At this point, the directory tree of the {\it Ellipsoidal Toolbox} is
added to the MATLAB path list. In order to save the updated path list,
in your MATLAB window menu go to {\tt File} $\rightarrow$ {\tt Set Path...} and
click {\tt Save}.
\item To get an idea of what the toolbox is about, type
\newline
{\tt >> ell\_demo1}
\newline
This will produce a demo of basic {\it ET} functionality: how to create
and manipulate ellipsoids.
\newline
Type
\newline
{\tt >> ell\_demo2}
\newline
to learn how to plot ellipsoids and hyperplanes in 2 and 3D.
\newline
For a quick tutorial on how to use the toolbox for reachability analysis
and verification, type
\newline
{\tt >> ell\_demo3}
\end{enumerate}





\chapter{Implementation}
\section{Operations with Ellipsoids}
In the {\it Ellipsoidal Toolbox} we define a new class {\tt ellipsoid} inside
the MATLAB programming environment. The following three commands
define the same ellipsoid $\EE(q,Q)$, with $q\in{\bf R}^n$ and
$Q\in{\bf R}^{n\times n}$ being symmetric positive semidefinite:

{\tt >> E = ellipsoid(q, Q);}
\newline
{\tt >> E = ellipsoid(Q) + q;}
\newline
{\tt >> E = sqrtm(Q)*ell\_unitball(size(Q, 1)) + q;}

For the {\tt ellipsoid} class we overload the following functions and operators:
\begin{itemize}
\item {\tt isempty(E)} - checks if {\tt E} is an empty ellipsoid.
\item {\tt display(E)} - displays the details of ellipsoid $\EE(q,Q)$, namely,
its center $q$ and the shape matrix $Q$.
\item {\tt plot(E)} - plots ellipsoid $\EE(q,Q)$ if its dimension is not greater
than 3.
\item {\tt E1 == E2} - checks if ellipsoids $\EE(q_1,Q_1)$ and
$\EE(q_2,Q_2)$ are equal.
\item {\tt E1 \~{ }= E2} - checks if ellipsoids $\EE(q_1,Q_1)$ and
$\EE(q_2,Q_2)$ are not equal.
\item {\tt [ , ]} - concatenates the ellipsoids into the horizontal array, e.g.
{\tt EE = [E1 E2 E3]}.
\item {\tt [ ; ]} - concatenates the ellipsoids into the vertical array, e.g.
{\tt EE = [E1 E2; E3 E4]} defines $2\times 2$ array of ellipsoids.
\item {\tt E1 >= E2} - checks if the ellipsoid $\EE(q_1,Q_1)$ is bigger than
the ellipsoid $\EE(q_2,Q_2)$, or equivalently $\EE(0,Q_1)\subseteq\EE(0,Q_2)$.
\item {\tt E1 <= E2} - checks if $\EE(0,Q_2)\subseteq\EE(0,Q_1)$.
\item {\tt -E} - defines ellipsoid $\EE(-q,Q)$.
\item {\tt E + b} - defines ellipsoid $\EE(q+b,Q)$.
\item {\tt E - b} - defines ellipsoid $\EE(q-b,Q)$.
\item {\tt A * E} - defines ellipsoid $\EE(q,AQA^T)$.
\item {\tt inv(E)} - inverts the shape matrix of the ellipsoid: $\EE(q,Q^{-1})$.
\end{itemize}
All the listed operations can be applied to a single ellipsoid as well as to
a two-dimensional array of ellipsoids.
For example,
{\tt \begin{verbatim}
>> E1 = ellipsoid([2; -1], [9 -5; -5 4]);  % nondegenerate ellipsoid in R^2
>> E2 = polar(E1);  % E2 is polar ellipsoid for E1
>> E3 = inv(E2);  % E3 is generated from E2 by inverting its shape matrix
>> EE = [E1 E2; E3 ellipsoid([1; 1], eye(2))];  % 2x2 array of ellipsoids
>> EE <= E1  % check if E1 is bigger than each of the ellipsoids in EE

ans =

     1     0
     1     0
\end{verbatim} }
To access individual elements of the array, the usual MATLAB subindexing
is used:
{\tt \begin{verbatim}
>> A = [0 1; -2 0]; b = [3; 0];  % A - 2x2 real matrix, b - vector in R^2
>> AT = A * EE(:, 2) + b;  % affine transformation of ellipsoids in the second column of EE
\end{verbatim} }
Sometimes it may be useful to modify the shape of the ellipsoid without
affecting its center. Say, we would like to bloat or squeeze the ellipsoid:
{\tt \begin{verbatim}
>> BLT = shape(E1, 2);  % bloats ellipsoid E1
>> SQZ = shape(E1, 0.5);  % squeezes ellipsoid E1
\end{verbatim} }
Since function {\tt shape} does not change the center of the ellipsoid,
it only accepts scalars or square matrices as its second input parameter.

Several functions  access the internal data of
the ellipsoid object:
{\tt \begin{verbatim}
>> [q, Q] = double(E2)  % get the center and the shape matrix of E2

q =

   -0.5000
   -0.1667

Q =

   0.9167     0.9167
   0.9167     1.5278

>> D = ellipsoid([42 -7 -2 4; -7 10 3 1; -2 3 5 -2; 4 1 -2 2]);  % define new ellipsoid
>> isdegenerate([EE(1, :) D])  % check if given ellipsoids are degenerate

ans =

     0     0     1

>> [n, r] = dimension([EE(1, :) D])  % get space dimensions and ranks of the shape matrices

n =

   2     2     4

r =

   2     2     3
\end{verbatim} }
One way to check if two ellipsoids intersect, is to compute
the distance between them:
{\tt \begin{verbatim}
>> distance(EE, E3)  % distance between E3 and each of the ellipsoids in EE

ans =
     -0.7761     -2.1553
     -1.3519      0.1683
\end{verbatim} }
This result indicates that the ellipsoid {\tt E3} does not intersect with
the ellipsoid {\tt EE(2, 2)}, with all the other ellipsoids in {\tt EE}
it has nonempty intersection. If the intersection of the two ellipsoids is
nonempty, it can be approximated by ellipsoids from the outside as well as
from the inside:
{\tt \begin{verbatim}
>> EA = intersection_ea(E1, E3);  % external approximation of intersection of E1 and E3
>> IA = intersection_ia(E1, E3);  % internal approximation of intersection of E1 and E3
\end{verbatim} }
It can be checked that resulting ellipsoid {\tt EA} contains the given
intersection, whereas {\tt IA} is contained in this intersection:
{\tt \begin{verbatim}
>> isinside(EA, [E1 E3], 'i')  % array [E1 E3] should be treated as intersection

ans =

     1

>> isinside([E1 E3], IA)  % check if IA belongs to the intersection of E1 and E3

ans =

     1
\end{verbatim} }
Function {\tt isinside} in general checks if the intersection of ellipsoids
in the given array contains the union or intersection of ellipsoids or
polytopes.

It is also possible to solve the feasibility problem, that is, to check
if the intersection of more than two ellipsoids is empty:
{\tt \begin{verbatim}
>> intersect(EE, EE(1, 1), 'i')  % check if the intersection of ellipsoids in EE is empty

ans =

     -1
\end{verbatim} }
In this particular example the result $-1$ indicates that the intersection
of ellipsoids in {\tt EE} is empty.
Function {\tt intersect} in general checks if an ellipsoid,
hyperplane or polytope intersects the union or the intersection
of ellipsoids in the given array:
{\tt \begin{verbatim}
>> % check if EE(2, 2) intersects the intersection of E1, E2 and E3:
>> intersect([E1 E2 E3], EE(2, 2), 'i')

ans =

     0

>> % check if E(2, 2) intersects the union of E1, E2 and E3:
>> intersect([E1 E2 E3], EE(2, 2), 'u')

ans =

     1
\end{verbatim} }
For the ellipsoids in ${\bf R}$, ${\bf R}^2$ and ${\bf R}^3$ the geometric
sum can be computed explicitely and plotted:
{\tt \begin{verbatim}
>> minksum(EE);  % compute and plot the geometric sum of ellipsoids in EE
\end{verbatim} }
If the dimension of the space in which the ellipsoids are defined exceeds $3$,
an error is returned. The result of the geometric sum operation is
not generally an ellipsoid, but it can be approximated by families
of external and internal ellipsoids parametrized by the direction vector:
{\tt \begin{verbatim}
>> % define the set of directions:
>> L = [1 0; 1 1; 0 1; -1 1; 1 3]';  % columns of matrix L are vectors in R^2
>>
>> EA = minksum_ea(EE, L)  % compute external ellipsoids for the directions in L

EA =
1x5 array of ellipsoids.

>> IA = minksum_ia(EE, L)  % compute internal ellipsoids for the directions in L

IA =
1x5 array of ellipsoids.

>> % intersection of external ellipsoids should always contain
>> % the union of internal ellipsoids:
>> isinside(EA, IA, 'u')

ans =

     1
\end{verbatim} }
Functions {\tt minksum\_ea} and {\tt minksum\_ia} work for ellipsoids of
arbitrary dimension. They should be used for general computations
whereas {\tt minksum} is there merely for visualization purposes.

If the geometric difference of two ellipsoids is not an empty set, it can
be computed explicitely and plotted for ellipsoids in ${\bf R}$,
${\bf R}^2$ and ${\bf R}^3$:
{\tt \begin{verbatim}
>> E4 = shape(EE(2, 2), 0.4);  % ellipsoid defined by squeezing the ellipsoid EE(2, 2)
>> E1 >= E4  % check if the geometric difference E1 - E4 is nonempty

ans =

     1

>> minkdiff(E1, E4);  % compute and plot this geometric difference
\end{verbatim} }
Similar to {\tt minksum}, {\tt minkdiff} is there for visualization
purpose. It works only for dimensions $1$, $2$ and $3$, and for higher
dimensions it returns an error. For arbitrary dimensions, the geometric
difference can be approximated by  families of external and internal
ellipsoids parametrized by the direction vector, provided this direction
is not bad:
{\tt \begin{verbatim}
>> isbaddirection(E1, E4, L)  % find out which of the directions in L are bad

ans =

     1     0     0     1     0

>> % two of five directions specified by L are bad,
>> % so, only three ellipsoidal approximations can be produced for this L:
>> EA = minkdiff_ea(E1, E4, L)

EA =
1x3 array of ellipsoids.

>> IA = minkdiff_ia(E1, E4, L)

IA =
1x3 array of ellipsoids.
\end{verbatim} }
Operation 'difference-sum' described in section 2.2.4 is implemented in
functions {\tt minkmp}, {\tt minkmp\_ea}, {\tt minkmp\_ia}, the first one of
which is used for visualization and works for dimensions not higher than $3$,
whereas the last two can deal with ellipsoids of arbitrary dimension.
{\tt \begin{verbatim}
>> % ellipsoidal approximations for (E1 - E3 + E2)
>> EA = minkmp_ea(E1, E3, E2, L)  % external

EA =
1x5 array of ellipsoids.

>> IA = minkmp_ia(E1, E3, E2, L)  % internal

IA =
1x5 array of ellipsoids.

>> minkmp(E1, E3, E2);  % plot the set (E1 - E3 + E2)
\end{verbatim} }
Similarly, operation 'sum-difference' described in section 2.2.5
is implemented in
functions {\tt minkpm}, {\tt minkpm\_ea}, {\tt minkpm\_ia}, the first one of
which is used for visualization and works for dimensions not higher than $3$,
whereas the last two can deal with ellipsoids of arbitrary dimension.
{\tt \begin{verbatim}
>> % ellipsoidal approximations for (E1 + E2 - E3)
>> EA = minkpm_ea([E1 E2], E3, L)  % external

EA =
1x5 array of ellipsoids.

>> IA = minkpm_ia([E1 E2], E3, L)  % internal

IA =
1x4 array of ellipsoids.

>> minkpm(E1, E2, E3);  % plot the set (E1 + E2 - E3)
\end{verbatim} }

The class {\tt hyperplane} of the {\it Ellipsoidal Toolbox} is used
to describe hyperplanes and halfspaces. The following two commands
define one and the same hyperplane but two different halfspaces:
{\tt \begin{verbatim}
>> H = hyperplane([1; 1], 1);  % defines halfspace x1 + x2 <= 1
>> H = hyperplane([-1; -1], -1);  % defines halfspace x1 + x2 >= 1
\end{verbatim} }
The following functions and operators are overloaded for the
{\tt hyperplane} class:
\begin{itemize}
\item {\tt isempty(H)} - checks if {\tt H} is an empty hyperplane.
\item {\tt display(H)} - displays the details of hyperplane $H(c,\gamma)$,
namely, its normal $c$ and the scalar $\gamma$.
\item {\tt plot(H)} - plots hyperplane $H(c,\gamma)$ if the dimension of the
space in which it is defined  is not greater than 3.
\item {\tt H1 == H2} - checks if hyperplanes $H(c_1,\gamma_1)$ and
$H(c_2,\gamma_2)$ are equal.
\item {\tt H1 \~{ }= H2} - checks if hyperplanes $H(c_1,\gamma_1)$ and
$H(c_2,\gamma_2)$ are not equal.
\item {\tt [ , ]} - concatenates the hyperplanes into the horizontal array, e.g.
{\tt HH = [H1 H2 H3]}.
\item {\tt [ ; ]} - concatenates the hyperplanes into the vertical array, e.g.
{\tt HH = [H1 H2; H3 H4]} - defines $2\times 2$ array of hyperplanes.
\item {\tt -H} - defines hyperplane $H(-c,-\gamma)$, which is the same
as $H(c,\gamma)$ but specifies different halfspace.
\end{itemize}
There are several ways to access the internal data of the {\tt hyperplane}
object:
{\tt \begin{verbatim}
>> [c, g] = double(H)  % get the normal and the scalar that define hyperplane H

c =

   -1
   -1

g =

   -1

>> dimension(H)  % get the dimension of the space where H is defined

ans =

     2

>> H0 = hyperplane([1 -1; 1 1]);  % define two hyperplanes passing through the origin
>> isparallel(H, H0)  % check which of two hyperplanes in array H0 is parallel to H

ans =

     1     0
\end{verbatim} }
All the functions of {\it Ellipsoidal Toolbox} that accept {\tt hyperplane}
object as parameter, work with single hyperplanes as well as with hyperplane
arrays. One exception is the function {\tt parameters} that allows only
single {\tt hyperplane} object.

An array of hyperplanes can be converted to the {\tt polytope} object of the
Multi-Parametric Toolbox (\cite{morari}, \cite{mpt}), and back:
{\tt \begin{verbatim}
>> define array of four hyperplanes:
>> HH = hyperplane([1 1; -1 -1; 1 -1; -1 1]', [2 2 2 2]);

HH =
1x4 array of hyperplanes.

>> P  = hyperplane2polytope(HH);  % convert array of hyperplanes to polytope
>> HP = polytope2hyperplane(P);  % covert polytope to array of hyperplanes
>> HP == HH

ans =

     1     1     1     1
\end{verbatim} }
Functions {\tt hyperplane2polytope} and {\tt polytope2hyperplane} require
the Multi-Parametric Toolbox to be installed.

We can compute distance from ellipsoids to hyperplanes and polytopes:
{\tt \begin{verbatim}
>> distance(E1, HH)  % distance from ellipsoid E1 to each of the hyperplanes in HH

ans =

     -0.5176    0.8966   -2.6841    0.1444

>> distance(EE, P)  % distance from each of the ellipsoids in EE to the polytope P

ans =

     0     0
     0     0
\end{verbatim} }
A negative distance value in the case of ellipsoid and hyperplane means that
the ellipsoid intersects the hyperplane. As we see in this example, ellipsoid
{\tt E1} intersects  hyperplanes {\tt H(1)} and {\tt H(3)} and has
no common points with {\tt H(2)} and {\tt H(4)}. When {\tt distance} function
has a polytope as a parameter, it always returns nonnegative values to be
consistent with {\tt distance} function of the Multi-Parametric Toolbox.
Here, the zero distance values mean that each ellipsoid in {\tt EE} has
nonempty intersection with polytope {\tt P}.

It can be checked if the union or intersection of given ellipsoids intersects
given hyperplanes or polytopes:
{\tt \begin{verbatim}
>> % check if the union of ellipsoids in EE intersects  hyperplanes in HH:
>> intersect(EE, HH)

ans =

     1     1     1     1

>> % check if the intersection of ellipsoids in the first column of EE
>> % intersects with hyperplanes in HH:
>> intersect(EE(:, 1), HH, 'i')

ans =

     0     0     1     0

>> % check if the intersection of ellipsoids E1, E2 and E3
>> % intersects with polytope P:
>> intersect([E1 E2 E3], P, 'i')

ans =

     1
\end{verbatim} }
The intersection of ellipsoid and hyperplane can be computed exactly:
{\tt \begin{verbatim}
>> % compute the intersections of ellipsoids in the first column of EE
>> % with hyperplane H(3):
>> I = hpintersection(EE(:, 1), H(3))

I =
2x1 array of ellipsoids.

>> isdegenerate(I)  % resulting ellipsoids should lose rank

ans =

     1
     1
\end{verbatim} }
Functions {\tt intersection\_ea} and {\tt intersection\_ia} can be used
with {\tt hyperplane} objects, which in this case define halfspaces and
{\tt polytope} objects:
{\tt \begin{verbatim}
>> % compute external and internal ellipsoidal approximations
>> % of the intersections of ellipsoids in the first column of EE
>> % with the halfspace x1 - x2 <= 2:
>> EA1 = intersection_ea(EE(:, 1), H(3))  % get external ellipsoids

EA1 =
2x1 array of ellipsoids.
>> IA1 = intersection_ia(EE(:, 1), H(3))  % get internal ellipsoids

IA1 =
2x1 array of ellipsoids.

>> % compute external and internal ellipsoidal approximations
>> % of the intersections of ellipsoids in the first column of EE
>> % with the halfspace x1 - x2 >= 2:
>> EA2 = intersection_ea(EE(:, 1), -H(3));  % get external ellipsoids
>> IA2 = intersection_ia(EE(:, 1), -H(3));  % get internal ellipsoids

>> % compute ellipsoidal approximations of the intersection
>> % of ellipsoid E1 and polytope P:
>> EA = intersection_ea(E1, P);  % get external ellipsoid
>> IA = intersection_ia(E1, P);  % get internal ellipsoid
\end{verbatim} }
Function {\tt isinside} can be used to check if a polytope or union of
polytopes is contained in the intersection of given ellipsoids:
{\tt \begin{verbatim}
>> Q = 0.5*P + [1; 1];  % polytope Q is obtained by affine transformation of P
>>
>> % check if the intersection of ellipsoids in the first column of EE
>> % contains the union of polytopes P and Q:
>> isinside(EE(:, 1), [P Q])  % equivalent to: isinside(EE(:, 1), P | Q)

ans =

     0

>> % check if ellipsoid EE(2, 2) contains the intersection of P and Q:
>> isinside(EE(2, 2), [P Q], 'i')  % equivalent to: isinside(EE(2, 2), P & Q)

ans =

     1
\end{verbatim} }
Functions {\tt distance}, {\tt intersect}, {\tt intersection\_ia} and
{\tt isinside} use the YALMIP interface (\cite{yalmip}, \cite{yalmiphp}) to the
external optimization package. The default optimization package included
in the distribution of the {\it Ellipsoidal Toolbox} is SeDuMi
(\cite{sedumi},\cite{sedumihp}). The user, however, is free to choose
any other optimization tool that solves second order cone programming (SOCP)
problems, as long as this tool is supported by YALMIP. QCQP is a special case
of SOCP.



\section{Reachability}
To compute the reach sets of the systems described in chapter 3, we define
two new classes in the {\it Ellipsoidal Toolbox}: class {\tt linsys} for the
system description, and class {\tt reach} for the reach set data.
We start by explaining how to define a system using {\tt linsys} object.
For example, description of the system
\[ \left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 & 1\\
0 & 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right], ~~~ u(t)\in\EE(p(t), P) \]
with
\[ p(t) = \left[\begin{array}{c}
\sin(t)\\
\cos(t)\end{array}\right], ~~~ P = \left[\begin{array}{cc}
9 & 0\\
0 & 2\end{array}\right], \]
is done by the following sequence of commands:
{\tt \begin{verbatim}
>> A = [0 1; 0 0]; B = eye(2);  % matrices A and B, B is identity
>> U.center = {'sin(t)'; 'cos(t)'};  % center of the ellipsoid depends on t
>> U.shape = [9 0; 0 2];  % shape matrix of the ellipsoid is static
>> sys = linsys(A, B, U);  % create linear system object
\end{verbatim} }
If matrices $A$ or $B$ depend on time, say $A(t)=\left[\begin{array}{cc}
0 & 1-\cos(2t)\\
-\frac{1}{t} & 0\end{array}\right]$, then matrix {\tt A} should be symbolic:
{\tt \begin{verbatim}
>> At = {'0' '1 - cos(2*t)'; '-1/t' '0'};  % A(t) - time-variant
>> sys_t = linsys(At, B, U);
\end{verbatim} }
To describe the system with disturbance
\[ \left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 & 1\\
0 & 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]v(t), \]
with bounds on control as before, and disturbance being $-1\leq v(t)\leq1$,
we type:
{\tt \begin{verbatim}
>> G = [0; 1];  % matrix G
>> V = ellipsoid(1);  % disturbance bounds: unit ball in R
>> sys_d = linsys(A, B, U, G, V);
\end{verbatim} }
Control and disturbance bounds {\tt U} and {\tt V} can have different types.
If the bound is constant, it should be described by {\tt ellipsoid} object.
If the bound depends on time, then it is represented by a structure with
fields {\tt center} and {\tt shape}, one or both of which are symbolic.
In system {\tt sys}, the control bound {\tt U} is defined as such a structure.
Finally, if the control or disturbance is known and fixed, it should be
defined as a vector, of type {\tt double} if constant, or symbolic, if
it depends on time.

To declare a discrete-time system
\[ \left[\begin{array}{c}
x_1[k+1]\\
x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
0 & 1\\
-1 & -0.5\end{array}\right]\left[\begin{array}{c}
x_1[k]\\
x_2[k]\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]u[k], ~~~ -1\leq u[k]\leq 1,\]
we use the same {\tt linsys} constructor:
{\tt \begin{verbatim}
>> Ad = [0 1; -1 -0.5]; Bd = [0; 1];  % matrices A and B
>> Ud  = ellipsoid(1);  % control bounds: unit ball in R
>> dtsys = linsys(Ad, Bd, Ud, [], [], [], [], 'd');  % discrete-time system
\end{verbatim} }
Once the {\tt linsys} object is created, we need to specify the set
of initial conditions, the time interval and values of the direction vector,
for which the reach set approximations must be computed:
{\tt \begin{verbatim}
>> X0 = ell_unitball(2)  % set of initial conditions
>> T = [0 10]  % time interval
>> L = [1 0; 0 1]';  % columns of L specify the directions
\end{verbatim} }
The reach set approximation is computed by calling the constructor
of the {\tt reach} object:
{\tt \begin{verbatim}
>> options.save_all = 1  % turn on save_all option (its default value is 0)
>> rs = reach(sys, X0, L, T, options);  % reach set of continuos-time system
\end{verbatim} }
The {\tt options} parameter in the {\tt reach()} call is optional.
We shall soon explain why we used it here.
At this point, variable {\tt rs} contains the reach set approximations for the
specified continuous-time system, time interval and set of initial conditions
computed for given directions. By default, both external and internal
approximations are computed. To compute only external or only internal
approximations, {\tt options} structure must contain
another field - {\tt approximation}.
For only external approximations, this field
must be set to $0$, for only internal approximations, it must be set to $1$.
The reach set approximation data can be
extracted in the form of arrays of ellipsoids:
{\tt \begin{verbatim}
>> EA = get_ea(rs)  % external approximating ellipsoids

EA =
4x200 array of ellipsoids.

>> [IA, tt] = get_ia(rs);  % internal approximating ellipsoids
\end{verbatim} }
Ellipsoidal arrays {\tt EA} and {\tt IA} have $4$ rows because we computed
the reach set approximations for $4$ directions. Each row of ellipsoids
corresponds to one direction. The number of columns in {\tt EA} and {\tt IA}
is defined by the {\tt time\_grid} parameter of the global {\tt ellOptions}
structure (see chapter 6 for details). It represents the number of time values
in our time interval, at which the approximations are evaluated. These
time values are returned in the optinal output parameter, array {\tt tt},
whose length is the same as the number of columns in {\tt EA} and {\tt IA}.
Intersection of ellipsoids in a particular column of {\tt EA} gives
external ellipsoidal approximation of the reach set at corresponding time.
Internal ellipsoidal approximation of this set at this time is given by the
union of ellipsoids in the same column of {\tt IA}.

We may be interested in the reachability data of our system in some
particular time interval, smaller than the one for which the reach set was
computed, say $3\leq t\leq5$.
This data can be extracted and returned in the form of {\tt reach}
object by the {\tt cut} function:
{\tt \begin{verbatim}
>> ct = cut(rs, [3 5]);  % reach set for the time interval [3, 5]
\end{verbatim} }
To obtain a snap shot of the reach set at given time, the same function
{\tt cut} is used:
{\tt \begin{verbatim}
>> ct = cut(rs, 5);  % reach set at time t = 5
\end{verbatim} }
It can be checked if the external or internal reach set approximation
intersects with given ellipsoids, hyperplanes or polytopes:
{\tt \begin{verbatim}
>> E = ellipsoid([-17; 0], [4 -1; -1 1]);  % define ellipsoid
>> HH = hyperplane([1 1; -1 -1; 1 -1; -1 1]', [2 2 2 2]);  % define 4 hyperplanes
>> P = hyperplane2polytope(HH) + [2; 10];  % define polytope
>> % check if ellipsoid E intersects with external approximation:
>> intersect(ct, E, 'e')

ans =

     1

>> % check if ellipsoid E intersects with internal approximation:
>> intersect(ct, E, 'i')

ans =

     0

>> % check if hyperplanes in HH intersect with internal approximation:
>> intersect(ct, HH, 'i')

ans =

     1     1     1     1

>> % check if polytope P intersects with external approximation:
>> intersect(ct, P)

ans =

     0
\end{verbatim} }
If a given set intersects with the internal approximation of the reach set,
then this set intersects with the actual reach set.
If the given set does not
intersect with external approximation, this set does not
intersect the actual reach set. There are situations, however, when the
given set intersects with the external approximation but does not intersect
with the internal one. In our example above, ellipsoid {\tt E} is such a case:
the quality of the approximation does not allow us to determine whether or not
{\tt E} intersects with the actual reach set. To improve the quality
of approximation, {\tt refine} function should be used:
{\tt \begin{verbatim}
>> L1 = [1; -1];  % define new directions, in this case one, but could be more
>> rs = refine(rs, L1);  % compute approximations for the new directions
>> ct = cut(rs, 5);  % snap shot of the reach set at time t = 5
>> intersect(ct, E, 'i')  % check if E intersects the internal approximation

ans =

     1
\end{verbatim} }
Now we are sure that ellipsoid {\tt E} intersects with the actual reach set.
Recall that when we computed reach set {\tt rs} the first time, we did it
with the option {\tt save\_all} set to $1$. This option indicated to the
{\tt reach} constructor that it should save all intermediate calculations of
data in the {\tt reach} object {\tt rs}. These data include evaluations
of matrices $A$, $B$, $G$ at specific time values (in case these
matrices depend on time) together with the control and disturbance
bounds, the state transition matrix and its inverse evaluated at
these time values.
By default, {\tt save\_all} option is set to $0$, and all these intermediate
data are not retained, which significantly reduces the memory used
by the {\tt reach} object {\tt rs}. However, to use the {\tt refine} function,
the reach set object must contain all calculated data, otherwise, an
error is returned.

Having a reach set object resulting from the {\tt reach}, {\tt cut} or
{\tt refine} operations, we can obtain the trajectory of the center
of the reach set and the good curves along which the actual reach set
is touched by its ellipsoidal approximations:
{\tt \begin{verbatim}
>> [ctr, tt] = get_center(rs);  % trajectory of the center
>> gc = get_goodcurves(rs)  % get good curves

gc =
    [2x200 double]   [2x200 double]   [2x200 double]   [2x200 double]   [2x200 double]
\end{verbatim} }
Variable {\tt ctr} here is a matrix whose columns are the points ofthe
reach set center trajectory evaluated at time values returned in the
array {\tt tt}. Variable {\tt gc} contains $4$ matrices each of which
corresponds to a good curve (columns of such matrix are points of the
good curve evaluated at time values in {\tt tt}).
The analytic expression for the control driving the system along a good
curve is given by formula (\ref{uct}).

We computed the reach set up to time $10$. It is possible to continue
the reach set computation for a longer time horizon using the reach set
data at time $10$ as initial condition.
It is also possible that the dynamics and inputs of the system change at
certain time, and from that point on the system evolves according to the new
system of differential equations. For example, starting at time $10$, our
reach set may evolve in time according to the time-variant system {\tt sys\_t}
defined above. Switched systems are a special case of this situation.
To compute the further evolution in time of the existing reach set,
function {\tt evolve} should be used:
{\tt \begin{verbatim}
>> rs2 = evolve(rs, 15);  % reach set from time 10 to 15 with the same dynamics
>> rs2 = evolve(rs, 15, sys_t);  % reach set from time 10 to 15 with new dynamics
>>
>> % not only the dynamics, but the inputs can change as well,
>> % from time 15 to 20 disturbance is added to the system:
>> rs3 = evolve(rs2, 20 sys_d);  % sys_d - system with disturbance defined above
\end{verbatim} }
Function {\tt evolve} can be viewed as an implementation of the semigroup
property.

To compute the backward reach set for some specified target set,
we declare the time interval so that the terminating time comes first:
{\tt \begin{verbatim}
>> Y = ellipsoid([8; 2], [4 1; 1 2]);  % target set in the form of ellipsoid
>> Tb = [10 5];  % backward time interval
>> brs = reach(sys, Y, L, Tb, options);  % backward reach set
>> brs = refine(brs, L1);  % refine the approximation
>> brs2 = evolve(brs, 0);  % further evolution in backward time from 5 to 0
\end{verbatim} }
Reach set and backward reach set computation for discrete-time systems and
manipulations with the resulting reach set object are performed using
the same functions as for continuous-time systems:
{\tt \begin{verbatim}
>> T = [0 100];  % represents 100 time steps from 1 to 100
>> dtrs = reach(dtsys, X0, L, T);  % reach set for 100 time steps
>> dtrs2 = evolve(dtrs, 200);  % compute next 100 time steps
>>
>> Tb = [50 0];  % backward time interval
>> dtbrs = reach(dtsys, Y, L, Tb, options)  % backward reach set
>> dtbrs = refine(dtbrs, L1);  % refine the approximation
>> [EA, tt] = get_ea(dtbrs);  % get external approximating ellipsoids and time values
>> IA = get_ia(dtbrs)  % get internal approximating ellipsoids

IA =
5x51 array of ellipsoids.
\end{verbatim} }
Number of columns in the ellipsoidal arrays {\tt EA} and {\tt IA} is $51$
because the backward reach set is computed for $50$ time steps, and the first
column of these arrays contains $5$ ellipsoids {\tt Y} - the terminating
condition.

When dealing with discrete-time systems, all functions that accept time or
time interval as an input parameter, round the time values and treat them as
integers.



\section{Visualization}
{\it Ellipsoidal Toolbox} has several plotting routines:
\begin{itemize}
\item {\tt ellipsoid/plot} - plots one or more ellipsoids, or arrays of
ellipsoids, defined in ${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minksum} - plots geometric sum of finite number of
ellipsoids defined in ${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minkdiff} - plots geometric difference
(if it is not an empty set) of two ellipsoids defined in
${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minkmp} - plots geometric (Minkowski) sum
of the geometric difference of two ellipsoids and the geometric sum of $n$
ellipsoids defined in ${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt ellipsoid/minkpm} - plots geometric (Minkowski) difference of the
geometric sum of ellipsoids and a single ellipsoid defined in
${\bf R}$, ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt hyperplane/plot} - plots one or more hyperplanes, or arrays of
hyperplanes, defined in ${\bf R}^2$ or ${\bf R}^3$.
\item {\tt reach/plot\_ea} - plots external approximation of the reach set
whose dimension is $2$ or $3$.
\item {\tt reach/plot\_ia} - plots internal approximation of the reach set
whose dimension is $2$ or $3$.
\end{itemize}
All these functions allow the user to specify the color of the plotted objects,
line width for 1D and 2D plots, and transparency level of the 3D objects.
Hyperplanes are displayed as line segments in 2D and square facets in 3D.
In the {\tt hyperplane/plot} method it is possible to specify the center
of the line segment or facet and its size.

Ellipsoids of dimensions higher than three must be
projected onto a two- or three-dimensional subspace before being plotted.
This is done by means of {\tt projection} function:
{\tt \begin{verbatim}
>> % create two 4-dimensional ellipsoids:
>> E1 = ellipsoid([14 -4 2 -5; -4 6 0 1; 2 0 6 -1; -5 1 -1 2]);
>> E2 = inv(E1);
>>
>> % specify 3-dimensional subspace by its basis:
>> BB = [1 0 0 0; 0 0 1 0; 0 1 0 1]';  % columns of BB must be orthogonal
>>
>> % get 3-dimensional projections of E1 and E2:
>> PP = projection([E1 E2], B)  % array PP contains projections of E1 and E2

PP =
1x2 array of ellipsoids.

>> plot(PP);  % plot ellipsoids in PP
\end{verbatim} }
Since the operation of projection is linear, the projection of the geometric
sum of ellipsoids equals the geometric sum of the projected ellipsoids.
The same is true for the geometric difference of two ellipsoids.

Function {\tt projection} exists also for the {\tt reach} objects:
{\tt \begin{verbatim}
>> A = [0 1 0 0; -1 0 1 0; 0 0 0 1; 0 0 -1 0];
>> B = [0; 0; 0; 1];
>> U = ellipsoid(1);
>> sys = linsys(A, B, U);  % 4-dimensional system
>> L  = [1 1 0 1; 0 -1 1 0; -1 1 1 1; 0 0 -1 1]'; % matrix of directions
>> rs = reach(sys, ell_unitball(4), L, 5);  % reach set from time 0 to 5
>> BB = [1 0 0 1; 0 1 1 0]';  % basis of 2-dimensional subspace
>> ps = projection(rs, BB);  % project reach set rs onto basis BB
>> plot_ea(ps);  % plot external approximation
>> hold on;
>> plot_ia(ps);  % plot internal approximation
\end{verbatim} }
The quality of the ellipsoid and reach set plots is controlled by the
parameters {\tt plot2d\_grid} and {\tt plot3d\_grid} of the global
{\tt ellOptions} structure (see chapter 6).





\chapter{Structures and Objects}
\section{ellOptions}
Functions of the {\it Ellipsoidal Toolbox} can be called with
user-specified values of certain global parameters. These parameters
are stored in the global structure {\tt ellOptions}, which is kept in the
MATLAB workspace as global variable. This structure is initialized with
default values of parameters upon the first call to almost any function
of the {\it ET}. Before  execution, the {\it ET} routine checks
if global structure {\tt ellOptions} already exists, and if not, it calls
the function {\tt ellipsoids\_init} that performs the initialization.

Here we list the fields of {\tt ellOptions} structure along with their
default values.
\begin{itemize}
\item {\tt version = '1.02'} - current version of {\it ET}. A this time
this parameter is harmless in the sense that it is not used by any of the
routines. In the future, however, it may be used for version compatibility.
\item {\tt verbose = 1} - if set to $0$, makes all the calls to {\it ET}
routines silent, and no information except errors is displayed. Otherwise,
it is assumed to be $1$. Currently, there are no other levels of verbosity.
\item {\tt abs\_tol = 1e-9} - absolute tolerance.
\item {\tt rel\_tol = 1e-7} - relative tolerance.
\item {\tt time\_grid = 200} - density of the time grid for the
continuous time reach set computation.
This parameter directly affects the number of ellipsoids to
be stored in the {\tt reach} object.
\item {\tt ode\_solver = 1} - specifies the ODE solver for continuous time
reach set computation: $1$ = 'RK45', $2$ = 'RK23', $3$ = 'Adams'.
\item {\tt norm\_control = 'on'} - switches on and off the norm control
in the ODE solver. When turned on, it slows down the computation, but improves
the accuracy.
\item {\tt ode\_solver\_options = 0} - when set to $0$, calls the ODE solver
without any additional options like norm control. It makes the computation
faster but less accurate. Otherwise, it is assumed to be $1$, and only in this
case the previous option makes a difference.
\item {\tt nlcp\_solver = 0} - specifies which gradient method implementation
to use. If set to $0$, it is {\tt ell\_nlfnlc}, which comes with {\it ET};
if set to $1$, it is {\tt fmincon}, which is part of MATLAB Optimization Toolbox.
\item {\tt plot2d\_grid = 200} - specifies number of points used to plot a
2D ellipsoid. This parameter also affects the quality of 2D reach tube
and reach set plots.
\item {\tt plot3d\_grid = 200} - the number of points used to plot
a 3D ellipsoid is calculated as $\frac{{\tt plot3d\_grid}^2}{2}$.
This parameter also affects the quality of 3D reach set plots.
\item {\tt sdpsettings} - the settings used by YALMIP optimization toolbox.
\end{itemize}
These parameters can be modified by editing {\it ellipsoids/ellipsoids\_init.m}
file. After you finished editing, for changes to take effect, type

{\tt >> clear global ellOptions;}

If you would like to change certain parameters temporarily, without
modifying the {\it ellipsoids\_init.m} file, say, turn the verbosity off,
you should type

{\tt >> global ellOptions;
\newline
>> ellOptions.verbose = 0;}

and proceed with your work. Before you modify {\tt ellOptions} structure
this way however, make sure it is initialized.



\section{ellipsoid}
The main object of the {\it Ellipsoidal Toolbox}, {\tt ellipsoid}, is
very simple. In accordance with definition \ref{ellipsoiddef}, it contains
two fields:
\begin{itemize}
\item {\tt center} - $n$-dimensional vector specifying the center
of the ellipsoid;
\item {\tt shape} - $(n\times n)$-dimensional symmetric positive
semidefinite matrix.
\end{itemize}
These fields cannot be accessed by the user directly. Their values
can be obtained through {\tt ellipsoid/parameters} function, but they cannot
be modified except by some allowed operation with the {\tt ellipsoid}
object. For the list of {\tt ellipsoid} methods, see appendix A.1.



\section{hyperplane}
According to  definition \ref{hyperplanedef}, the hyperplane object
contains two fields:
\begin{itemize}
\item {\tt normal} - $n$-dimensional vector specifying the normal to
the hyperplane ($c$ in \ref{hyperplane});
\item {\tt shift} - the scalar ($\gamma$ in \ref{hyperplane}).
\end{itemize}
These fields cannot be accessed by the user directly. Their values
can be obtained through {\tt hyperplane/parameters} function, but they cannot
be modified other than by some allowed operation with the {\tt hyperplane}
object. For the list of {\tt hyperplane} methods, see appendix A.2.

In some {\it ET} functions, for example, in {\tt ellipsoid/intersection\_ea}
and {\tt ellipsoid/intersection\_ia}, the hyperplane specifies the halfspace.
It is assumed that the halfspace is
\[ \{ x\in{\bf R}^n ~|~ \langle{\tt normal},x\rangle\leq{\tt shift}\}. \]



\section{linsys}
{\it Ellipsoidal Toolbox}  supports both types of linear (affine)
dynamical systems: continuous-time,
\begin{eqnarray*}
\dot{x}(t) & = & A(t)x(t) + B(t)u(t) + G(t)v(t),\\
y(t) & = & C(t)x(t) + D(t)u(t) + w(t);
\end{eqnarray*}
and discrete-time,
\begin{eqnarray*}
x[k+1] & = & A[k]x[k] + B[k]u[k] + G[k]v[k], \\
y[k] & = & C[k]x[k] + D[k]u[k] + w[k].
\end{eqnarray*}
Both can be time-invariant (have constant matrices $A$, $B$, $G$, $C$, $D$)
or time-variant.
\newline
The {\tt linsys} object contains the fields:
\begin{itemize}
\item {\tt A} - $(n\times n)$-dimensional matrix $A$ of type {\tt double}
if constant, or {\tt cell} to symbolically represent $A(t)$ or $A[k]$.
\item {\tt B} - $(n\times m)$-dimensional matrix $B$, {\tt double} if constant,
{\tt cell} if symbolic.
\item {\tt control} - ellipsoidal bounds on control $u$,
either an {\tt ellipsoid}
object of dimension $m$, or structure {\tt U} with fields {\tt U.center} and
{\tt U.shape} to represent the ellipsoid that depends on time. For example,
\newline
{\tt >> U.center = [0; 1];}
\newline
{\tt >> U.shape = \{'4' 'cos(t)'; 'cos(t)' '1'\};}
\newline
defines ellipsoid $\EE(p, P(t))$ with $p=\left[\begin{array}{c}
0\\
1\end{array}\right]$ and $P(t) = \left[\begin{array}{cc}
4 & \cos(t)\\
\cos(t) & 1\end{array}\right]$.
\item {\tt G} - $(n\times d)$-dimensional matrix $G$ of type {\tt double}
if constant, or {\tt cell} if symbolic. Can be empty if the system has
no disturbance or affine term.
\item {\tt disturbance} - ellipsoidal bounds on disturbance $v$, either an
{\tt ellipsoid} object of dimension $d$, or structure {\tt V} with
fields {\tt V.center} and {\tt V.shape} for symbolic representation of
ellipsoid, similar to the {\tt control} field.
This field can be also a single $d$-dimensional vector - constant or symbolic -
to represent an affine term.
\item {\tt C} - $(r\times n)$-dimensional matrix $C$ of type {\tt double}
if constant, or {\tt cell} if symbolic.
\item {\tt D} - $(r\times m)$-dimensional matrix $D$ of type {\tt double}
if constant, or {\tt cell} if symbolic. Can be empty.
\item {\tt noise} - ellipsoidal bounds on the noise $w$, either an
{\tt ellipsoid} object of dimension $r$, or structure {\tt W} with
fields {\tt W.center} and {\tt W.shape} for symbolic representation of
ellipsoid, similar to the {\tt control} and {\tt disturbance} fields.
\newline
This field can be also a single $r$-dimensional vector, constant or symbolic,
to represent an affine term.
\item {\tt lti} - $1$ if the system is time-invariant, $0$ - otherwise.
\item {\tt dt} - $1$ if the system is discrete-time, $0$ - otherwise.
\item {\tt constantbounds} - indicates if the bounds on control, disturbance
and noise are constant.
\end{itemize}
The fields of {\tt linsys} object can be accessed but cannot be modified
directly by the user. The only way to modify these fields is through
{\tt linsys/linsys} constructor.
For the list of {\tt linsys} methods, see appendix A.3.



\section{reach}
The {\tt reach} object represents the reach (or backward reach)
set of an affine system. It contains the fields:
\begin{itemize}
\item {\tt system} - the description of the system, for which the reach set
is computed, in the form of {\tt linsys} object.
\item {\tt t0} - initial time value.
\item {\tt X0} - the set of initial (or terminating, in case of backward
reachability) conditions in the form of {\tt ellipsoid}
object.
\item {\tt initial\_directions} - matrix whose columns represent the values
of direction vector $l$ (see chapter 3), for which the ellipsoidal
approximations of the reach set are computed.
\item {\tt time\_values} - time interval, for which the reach set is computed,
is split into the number of segments specified by the global
{\tt ellOptions.time\_grid} parameter. This field contains the values
of the time grid. If the last value of this array is less than the value
of {\tt t0}, then the reach set is in fact backward reach set.
\item {\tt center\_values} - matrix whose columns are values of the reach set
center trajectory evaluated at times specified by {\tt time\_values}.
\item {\tt l\_values} - array of directions vectors evaluated at times
specified by {\tt time\_values}.
\item {\tt ea\_values} - array of the shape matrices of the external ellipsoids
evaluated at times specified by {\tt time\_values}.
\item {\tt ia\_values} - array of the shape matrices of the internal ellipsoids
evaluated at times specified by {\tt time\_values}.
\item {\tt projection\_basis} - if the reach set is projected onto the given
orthonormal basis, the columns of this field are the basis vectors, otherwise,
this field is empty.
\item {\tt calc\_data} - this field is empty unless the reach set is computed
with the {\tt save\_all} option set to $1$. This field then contains the
intermediate calculation data, which can be used for the approximation
refinement. For more detail, see description of the function
{\tt refine} in appendix A.4.
\end{itemize}
These fields can be accessed and modified only through {\tt reach} methods.
For the list of {\tt reach} methods, see appendix A.4.





\chapter{Examples}
\section{Ellipsoids vs. Polytopes}
Depending on the particular dynamical system, certain methods of
reach set computation may be more suitable than others.
Even for a simple 2-dimensional discrete-time linear time-invariant
system, application of ellipsoidal methods may be more effective
than using polytopes.

Consider the system from chapter 1:
\[ \left[\begin{array}{c}
x_1[k+1]\\
x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
\cos(1) & \sin(1)\\
-\sin(1) & \cos(1)\end{array}\right]\left[\begin{array}{c}
x_1[k]\\
x_2[k]\end{array}\right] + \left[\begin{array}{c}\
u_1[k]\\
u_2[k]\end{array}\right], ~~~ x[0]\in\XX_0, ~~~ u[k]\in U, ~~~ k\geq0, \]
where $\XX_0$ is the set of initial conditions, and $U$ is the control set.

Let $\XX_0$ and $U$ be unit boxes in ${\bf R}^2$, and compute the reach set
using the polytope method implemented in MPT (\cite{mpt}). With every time step
the number of vertices of the reach set polytope increases by $4$.
The complexity of the
convex hull computation increases exponentially with number of vertices.
In figure \ref{ellpolyfig}, the time required to compute the reach set
for different time steps using polytopes is shown in red.

To compute the reach set of the system using {\it Ellipsoidal Toolbox},
we assume $\XX_0$ and $U$ to be unit balls in ${\bf R}^2$, fix any number
of initial direction values that corresponds to the number of ellipsoidal
approximations, and obtain external and internal ellipsoidal approximations
of the reach set:
{\tt \begin{verbatim}
>> A = [cos(1) sin(1); -sin(1) cos(1)];
>> U = ell_unitball(2);  % control bounds
>>
>> % define linear discrete-time system:
>> lsys = linsys(A, eye(2), U, [], [], [], [], 'd');
>>
>> X0 = ell_unitball(2);  % set of initial conditions
>> L0 = [cos(0:0.1:pi); sin(0:0.1:pi)];  % 32 initial directions
>> N  = 100;  % number of time steps
>>
>> % compute the reach set:
>> rs = reach(lsys, X0, L0, N);
\end{verbatim}}
In figure \ref{ellpolyfig}, the time required to compute both external
and internal ellipsoidal approximations, with $32$ ellipsoids each,
for different number of time steps is shown in blue.

\begin{figure}[htbp]
\centerline{
\includegraphics[height=8 cm]{ellpoly.eps}}
\caption{Reach set computation performance comparison:
ellipsoids (blue) vs. polytopes (red).}
\label{ellpolyfig}
\end{figure}

Figure \ref{ellpolyfig}  illustrates  the fact that the
complexity of polytope method grows exponentially with number of time
steps, whereas the complexity of ellipsoidal method grows linearly.



\section{System with Disturbance}
The mechanical system presented in figure \ref{springmassfig}, is described
by the following system of equations:
\begin{eqnarray}
m_1\ddot{x}_1+(k_1+k_2)x_1-k_2x_2 & = & u_1, \label{spmass1}\\
m_2\ddot{x}_2-k_2x_1+(k_1+k_2)x_2 & = & u_2 . \label{spmass2}
\end{eqnarray}
\begin{figure}[htbp]
\centerline{
\includegraphics[height=5 cm]{springmass.eps}}
\caption{Spring-mass system.}
\label{springmassfig}
\end{figure}
Here $u_1$ and $u_2$ are the forces applied to masses $m_1$ and $m_2$,
and we shall assume $[u_1 ~~ u_2]^T\in\EE(0,I)$.
The initial conditions can be taken as $x_1(0)=0$, $x_2(0)=2$.
Defining $x_3=\dot{x}_1$ and $x_4=\dot{x}_2$, we can rewrite
(\ref{spmass1}-\ref{spmass2}) as a linear system in standard form:
\begin{equation}
\left[\begin{array}{c}
\dot{x}_1 \\
\dot{x}_2 \\
\dot{x}_3 \\
\dot{x}_4 \end{array}\right] = \left[\begin{array}{cccc}
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1\\
-\frac{k_1+k_2}{m_1} & \frac{k_2}{m_1} & 0 & 0\\
\frac{k_2}{m_2} & -\frac{k_1+k_2}{m_2} & 0 & 0\end{array}\right]
\left[\begin{array}{c}
x_1 \\
x_2 \\
x_3 \\
x_4 \end{array}\right] + \left[\begin{array}{cc}
0 & 0\\
0 & 0\\
\frac{1}{m_1} & 0\\
0 & \frac{1}{m_2}\end{array}\right]\left[\begin{array}{c}
u_1\\
u_2\end{array}\right]. \label{spmassls}
\end{equation}
Now we can compute the reach set of system (\ref{spmass1}-\ref{spmass2})
for given time by computing the reach set of the linear system (\ref{spmassls})
and taking its projection onto $(x_1, x_2)$ subspace.
{\tt \begin{verbatim}
>> % specify parameters k1, k2 and masses m1, m2:
>> k1 = 24;  k2 = 32;
>> m1 = 1.5; m2 = 1;
>>
>> % define matrices A, B, and control bounds U:
>> A = [0 0 1 0; 0 0 0 1; -(k1+k2)/m1 k2/m1 0 0; k2/m2 -(k1+k2)/m2 0 0];
>> B = [0 0; 0 0; 1/m1 0; 0 1/m2];
>> U = ell_unitball(2);
>>
>> lsys = linsys(A, B, U);  % linear system
>> T = [0 4];  % time interval
>>
>> % initial conditions:
>> X0 = [0 2 0 0]' + ellipsoid([0.01 0 0 0; 0 0.01 0 0; 0 0 eps 0; 0 0 0 eps]);
>>
>> % initial directions (some random vectors in R^4):
>> L0 = [1 0 1 0; 1 -1 0 0; 0 -1 0 1; 1 1 -1 1 -1 1 1 0; -2 0 1 1]';
>>
>> rs = reach(lsys, X0, L0, T);  % reach set
>>
>> BB = [1 0 0 0; 0 1 0 0]';  % orthogonal basis of (x1, x2) subspace
>> ps = projection(rs, BB);  % reach set projection
>>
>> % plot projection of reach set external approximation:
>> subplot(2, 2, 1);
>> plot_ea(ps, 'g');  % plot the whole reach tube
>> subplot(2, 2, 2);
>> plot_ea(cut(ps, 4), 'g');  % plot reach set approximation at time t = 4
\end{verbatim}}
Figure \ref{mechreachfig}(a) shows the reach set of the system
(\ref{spmass1}-\ref{spmass2}) evolving in time from $t=0$ to $t=4$.
Figure \ref{mechreachfig}(b) presents a snapshot of this reach set at time
$t=4$.
\begin{figure}%[htbp]
\centerline{
\includegraphics[height=10 cm]{reachmech.eps}}
\caption{Spring-mass system without disturbance:
(a) reach tube for time $t\in[0,4]$; (b) reach set at time $t=4$.
Spring-mass system with disturbance:
(c) reach tube for time $t\in[0,4]$; (d) reach set at time $t=4$.}
\label{mechreachfig}
\end{figure}

So far we considered an ideal system without any disturbance, such as friction.
We introduce disturbance to (\ref{spmass1}-\ref{spmass2}) by adding extra
terms, $v_1$ and $v_2$,
\begin{eqnarray}
m_1\ddot{x}_1+(k_1+k_2)x_1-k_2x_2 & = & u_1 + v_1, \label{smdist1}\\
m_2\ddot{x}_2-k_2x_1+(k_1+k_2)x_2 & = & u_2 + v_2, \label{smdist2}
\end{eqnarray}
which results in equation (\ref{spmassls}) getting an extra term
\[ \left[\begin{array}{cc}
0 & 0\\
0 & 0\\
1 & 0\\
0 & 1\end{array}\right]\left[\begin{array}{c}
v_1\\
v_2\end{array}\right]. \]
Assuming that $[v_1 ~~ v_2]^T$ is unknown but bounded by ellipsoid
$\EE(0, \frac{1}{4}I)$, we can compute the closed-loop reach set of the system
with disturbance.
{\tt \begin{verbatim}
>> % define disturbance:
>> G = [0 0; 0 0; 1 0; 0 1];
>> V = 0.5*ell_unitball(2);
>>
>> lsysd = linsys(A, B, U, G, V);  % linear system with disturbance
>>
>> rsd = reach(lsysd, X0, L0, T);  % reach set
>> psd = projection(rsd, BB);  % reach set projection onto (x1, x2)
>>
>> % plot projection of reach set external approximation:
>> subplot(2, 2, 3);
>> plot_ea(ps);  % plot the whole reach tube
>> subplot(2, 2, 4);
>> plot_ea(cut(ps, 4));  % plot reach set approximation at time t = 4
\end{verbatim}}
Figure \ref{mechreachfig}(c) shows the reach set of the system
(\ref{smdist1}-\ref{smdist2}) evolving in time from $t=0$ to $t=4$.
Figure \ref{mechreachfig}(d) presents a snapshot of this reach set at time
$t=4$.



\section{Switched System}
By {\it switched systems} we mean systems whose dynamics
changes at known times. Consider the RLC circuit shown in figure \ref{rlcfig}.
It has two inputs - the voltage ($v$) and current ($i$) sources.
Define
\begin{itemize}
\item $x_1$ - voltage across capacitor $C_1$, so $C_1\dot{x}_1$ is
the corresponding current;
\item $x_2$ - voltage across capacitor $C_2$, so the corresponding
current is $C_2\dot{x}_2$.
\item $x_3$ - current through the inductor $L$, so the voltage across
the inductor is $L\dot{x}_3$.
\end{itemize}
\begin{figure}[htbp]
\centerline{
\includegraphics[height=5 cm]{rlc.eps}}
\caption{RLC circuit with two inputs.}
\label{rlcfig}
\end{figure}
Applying Kirchoff current and voltage laws we arrive at the linear system,
\begin{equation}
\left[\begin{array}{c}
\dot{x}_1\\
\dot{x}_2\\
\dot{x}_3\end{array}\right] = \left[\begin{array}{ccc}
-\frac{1}{R_1C_1} & 0 & -\frac{1}{C_1}\\
0 & 0 & \frac{1}{C_2}\\
\frac{1}{L} & -\frac{1}{L} & -\frac{R_2}{L}\end{array}\right]
\left[\begin{array}{c}
x_1\\
x_2\\
x_3\end{array}\right] + \left[\begin{array}{cc}
\frac{1}{R_1C_1} & \frac{1}{C_1}\\
0 & 0\\
0 & 0\end{array}\right]\left[\begin{array}{c}
v\\
i\end{array}\right]. \label{rlceq}
\end{equation}
The parameters $R_1$, $R_2$, $C_1$, $C_2$ and $L$, as well as the inputs,
may depend on time. Suppose, for time $0\leq t<2$, $R_1=2$ Ohm, $R_2=1$ Ohm,
$C_1=3$ F, $C_2=7$ F, $L=2$ H, both inputs, $v$ and $i$ are present and
bounded by ellipsoid $\EE(0,I)$; and for time $t\geq 2$,
$R_1=R_2=2$ Ohm, $C_1=C_2=3$ F, $L=6$ H, the current source is turned off,
and $|v|\leq 1$. Then, system (\ref{rlceq}) can be rewritten as
\begin{equation}
\left[\begin{array}{c}
\dot{x}_1\\
\dot{x}_2\\
\dot{x}_3\end{array}\right] = \left\{\begin{array}{ll}
\left[\begin{array}{ccc}
-\frac{1}{6} & 0 & -\frac{1}{3}\\
0 & 0 & \frac{1}{7}\\
\frac{1}{2} & -\frac{1}{2} & -\frac{1}{2}\end{array}\right]
\left[\begin{array}{c}
x_1\\
x_2\\
x_3\end{array}\right] + \left[\begin{array}{cc}
\frac{1}{6} & \frac{1}{3}\\
0 & 0\\
0 & 0\end{array}\right]\left[\begin{array}{c}
v\\
i\end{array}\right], & 0\leq t< 2, \\
\left[\begin{array}{ccc}
-\frac{1}{6} & 0 & -\frac{1}{3}\\
0 & 0 & \frac{1}{3}\\
\frac{1}{6} & -\frac{1}{6} & -\frac{1}{3}\end{array}\right]
\left[\begin{array}{c}
x_1\\
x_2\\
x_3\end{array}\right] + \left[\begin{array}{c}
\frac{1}{6} \\
0 \\
0 \end{array}\right]v, & 2\leq t. \end{array}\right.
\label{rlceq2}
\end{equation}
We can compute the reach set of (\ref{rlceq2}) for some time $t>2$, say, $t=3$.
{\tt \begin{verbatim}
>> % define system 1:
>> A1 = [-1/6 0 -1/3; 0 0 1/7; 1/2 -1/2 -1/2];
>> B1 = [1/6 1/3; 0 0; 0 0];
>> U1 = ellipsoid(eye(2));
>> s1 = linsys(A1, B1, U1);
>>
>> % define system 2:
>> A2 = [-1/6 0 -1/3; 0 0 1/3; 1/6 -1/6 -1/3];
>> B2 = [1/6; 0; 0];
>> U2 = ellipsoid(1);
>> s2 = linsys(A2, B2, U2);
>>
>> X0 = ellipsoid(0.01*eye(3));  % set of initial states
>> L0 = eye(3);  % 3 initial directions
>> TS = 2;  % time of switch
>> T = 3;  % terminating time
>>
>> % compute the reach set:
>> rs1 = reach(s1, X0, L0, TS);  % reach set of the first system
>> % computation of the second reach set starts
>> % where the first left off
>> rs2 = evolve(rs1, T, s2);
>>
>> % obtain projections onto (x1, x2) subspace:
>> BB = [1 0 0; 0 1 0]';  % (x1, x2) subspace basis
>> ps1 = projection(rs1, BB);
>> ps2 = projection(rs2, BB);
>>
>> % plot the results:
>> subplot(2, 2, 1);
>> plot_ea(ps1, 'r');  % external apprx. of reach set 1 (red)
>> hold on;
>> plot_ia(ps1, 'g');  % internal apprx. of reach set 1 (green)
>> plot_ea(ps2, 'y');  % external apprx. of reach set 2 (yellow)
>> plot_ia(ps2, 'b');  % internal apprx. of reach set 2 (blue)
>>
>> % plot the 3-dimensional reach set at time t = 3:
>> subplot(2, 2, 2);
>> plot_ea(cut(rs2, 3), 'y');
>> hold on;
>> plot_ia(cut(rs2, 3), 'b');
\end{verbatim}}
Figure \ref{rlcreachfig}(a) shows how the reach set projection
onto $(x_1, x_2)$ of system (\ref{rlceq2})
evolves in time from $t=0$  to $t=3$. The external reach set approximation
for the first dynamics is in red, the internal approximation is in green.
The dynamics switches at $t=2$.
The external reach set approximation for the second dynamics is in yellow,
its internal approximation is in blue.
The full three-dimensional external (yellow) and internal (blue)
approximations of the reach set are shown in figure \ref{rlcreachfig}(b).
\begin{figure}[htbp]
\centerline{
\includegraphics[height=10 cm]{rlcreach.eps}}
\caption{Forward and backward reach sets of the switched system
(external and internal approximations).
The dynamics switches at $t=2$.
\newline
(a) Forward reach set for the time interval $0\leq t\leq3$ projected onto
$(x_1,x_2)$ subspace.
\newline
(b) Forward reach set at $t=3$ in ${\bf R}^3$.
\newline
(c) Backward reach set evolving from $t=3$ to $t=0$ projected onto
$(x_1,x_2)$ subspace.
\newline
(d) Backward reach set at $t=0$ in ${\bf R}^3$.}
\label{rlcreachfig}
\end{figure}

To find out where the system should start at time $t=0$ in order to reach
a neighborhood {\tt M} of the origin at time $t=3$,
we compute the backward reach set from $t=3$ to $t=0$.
{\tt \begin{verbatim}
>> M  = ellipsoid(0.01*eye(3));  % terminating set
>> TT = 3;  % terminating time
>>
>> % compute backward reach set:
>> % compute the reach set:
>> brs2 = reach(s2, M, L0, [TT TS]);  % second system comes first
>> brs1 = evolve(brs2, 0, s1);  % then the first system
>>
>> % obtain projections onto (x1, x2) subspace:
>> bps1 = projection(brs1, BB);
>> bps2 = projection(brs2, BB);
>>
>> % plot the results:
>> subplot(2, 2, 3);
>> plot_ea(bps1, 'r');  % external apprx. of backward reach set 1 (red)
>> hold on;
>> plot_ia(bps1, 'g');  % internal apprx. of backward reach set 1 (green)
>> plot_ea(bps2, 'y');  % external apprx. of backward reach set 2 (yellow)
>> plot_ia(bps2, 'b');  % internal apprx. of backward reach set 2 (blue)
>>
>> % plot the 3-dimensional backward reach set at time t = 0:
>> subplot(2, 2, 4);
>> plot_ea(cut(brs1, 0), 'r');
>> hold on;
>> plot_ia(cut(brs1, 0), 'g');
\end{verbatim}}
Figure \ref{rlcreachfig}(c) presents the evolution of the reach set
projection onto $(x_1, x_2)$ in backward time.
Again, external and internal approximations corresponding
to the first dynamics are shown in red and green, and
to the second dynamics in yellow and blue. The
full dimensional backward reach set external and internal
approximations of system (\ref{rlceq2})
at time $t=0$ is shown in figure \ref{rlcreachfig}(d).



\section{Hybrid System}
There is no explicit implementation of the reachability analysis for hybrid
systems in the {\it Ellipsoidal Toolbox}.
Nonetheless, the operations of intersection available in the toolbox allow us
to work with certain class of hybrid systems, namely,
hybrid systems with affine continuous dynamics whose guards are
ellipsoids, hyperplanes, halfspaces or polytopes.

We  consider the {\it switching-mode model} of highway traffic
presented in \cite{xiaotian}. The highway segment is divided into $N$ cells
as shown in figure \ref{hwfig}. In this particular case, $N=4$.
The traffic density in cell $i$ is  $x_i$ vehicles per mile, $i=1,2,3,4$.
\begin{figure}[htbp]
\centerline{
\includegraphics[height=5 cm]{hw.eps}}
\caption{Highway model. Adapted from \cite{xiaotian}.}
\label{hwfig}
\end{figure}

Define
\begin{itemize}
\item $v_i$ - average  speed in mph,
in the $i$-th cell, $i=1,2,3,4$;
\item $w_i$ - backward congestion wave propagation speed in mph,
in the $i$-th highway cell, $i=1,2,3,4$;
\item $x_{Mi}$ - maximum allowed density in the $i$-th cell;
when this velue is reached, there is a traffic jam, $i=1,2,3,4$;
\item $d_i$ - length of $i$-th cell in miles, $i=1,2,3,4$;
\item $T_s$ - sampling time in hours;
\item $b$ - split ratio for the off-ramp;
\item $u_1$ - traffic flow coming into the highway segment,
in vehicles per hour (vph);
\item $u_2$ - traffic flow coming out of the highway segment (vph);
\item $u_3$ - on-ramp traffic flow (vph).
\end{itemize}
Highway traffic operates in two modes: {\it free-flow} in normal operation;
and {\it congested} mode, when there is a jam.
Traffic flow in free-flow mode is described by
\begin{eqnarray}
\left[\begin{array}{c}
x_1[t+1]\\
x_2[t+1]\\
x_3[t+1]\\
x_4[t+1]\end{array}\right] & = & \left[\begin{array}{cccc}
1-\frac{v_1T_s}{d_1} & 0 & 0 & 0\\
\frac{v_1T_s}{d_2} & 1-\frac{v_2T_s}{d_2} & 0 & 0\\
0 & \frac{v_2T_s}{d_3} & 1-\frac{v_3T_s}{d_3} & 0\\
0 & 0 & (1-b)\frac{v_3T_s}{d_4} & 1-\frac{v_4T_s}{d_4}\end{array}\right]
\left[\begin{array}{c}
x_1[t]\\
x_2[t]\\
x_3[t]\\
x_4[t]\end{array}\right] \nonumber\\
& + & \left[\begin{array}{ccc}
\frac{v_1T_s}{d_1} & 0 & 0\\
0 & 0 & \frac{v_2T_s}{d_2}\\
0 & 0 & 0\\
0 & 0 & 0\end{array}\right]\left[\begin{array}{c}
u_1\\
u_2\\
u_3\end{array}\right]. \label{fflow}
\end{eqnarray}
The equation for the congested mode is
\begin{eqnarray}
\left[\begin{array}{c}
x_1[t+1]\\
x_2[t+1]\\
x_3[t+1]\\
x_4[t+1]\end{array}\right] & = & \left[\begin{array}{cccc}
1-\frac{w_1T_s}{d_1} & \frac{w_2T_s}{d_1} & 0 & 0\\
0 & 1-\frac{w_2T_s}{d_2} & \frac{w_3T_s}{d_2} & 0\\
0 & 0 & 1-\frac{w_3T_s}{d_3} & \frac{1}{1-b}\frac{w_4T_s}{d_3}\\
0 & 0 & 0 & 1-\frac{w_4T_s}{d_4}\end{array}\right]
\left[\begin{array}{c}
x_1[t]\\
x_2[t]\\
x_3[t]\\
x_4[t]\end{array}\right] \nonumber\\
& + & \left[\begin{array}{ccc}
0 & 0 & \frac{w_1T_s}{d_1}\\
0 & 0 & 0\\
0 & 0 & 0\\
0 & -\frac{w_4T_s}{d_4} & 0\end{array}\right]\left[\begin{array}{c}
u_1\\
u_2\\
u_3\end{array}\right] \nonumber\\
& + & \left[\begin{array}{cccc}
\frac{w_1T_s}{d_1} & -\frac{w_2T_s}{d_1} & 0 & 0\\
0 & \frac{w_2T_s}{d_2} & -\frac{w_3T_s}{d_2} & 0\\
0 & 0 & \frac{w_3T_s}{d_3} & -\frac{1}{1-b}\frac{w_4T_s}{d_3}\\
0 & 0 & 0 & \frac{w_4T_s}{d_4}\end{array}\right]
\left[\begin{array}{c}
x_{M1}\\
x_{M2}\\
x_{M3}\\
x_{M4}\end{array}\right]. \label{cflow}
\end{eqnarray}
The switch from the free-flow to the congested mode occurs when the density
 $x_2$ reaches $x_{M2}$. In other words, the hyperplane
$H([0 ~ 1 ~ 0 ~ 0]^T, x_{M2})$ is the guard.

We indicate how to implement the reach set computation of this hybrid system.
We first define the two linear systems and the guard.
{\tt \begin{verbatim}
>> % assign parameter values:
>> v1 = 65; v2 = 60; v3 = 63; v4 = 65;  % mph
>> w1 = 10; w2 = 10; w3 = 10; w4 = 10;  % mph
>> d1 = 2; d2 = 3; d3 = 4; d4 = 2;  % miles
>> Ts = 2/3600;  % sampling time in hours
>> xM1 = 200; xM2 = 200; xM3 = 200; xM4 = 200;  % vehicles per lane
>> b = 0.4;
>>
>> A1 = [(1-(v1*Ts/d1)) 0 0 0
         (v1*Ts/d2) (1-(v2*Ts/d2)) 0 0
         0 (v2*Ts/d3) (1-(v3*Ts/d3)) 0
         0 0 ((1-b)*(v3*Ts/d4)) (1-(v4*Ts/d4))];
>> B1 = [v1*Ts/d1 0 0; 0 0 v2*Ts/d2; 0 0 0; 0 0 0];
>> U1 = ellipsoid([180; 150; 50], [100 0 0; 0 100 0; 0 0 25]);
>>
>> A2 = [(1-(w1*Ts/d1)) (w2*Ts/d1) 0 0
         0 (1-(w2*Ts/d2)) (w3*Ts/d2) 0
         0 0 (1-(w3*Ts/d3)) ((1/(1-b))*(w4*Ts/d3))
         0 0 0 (1-(w4*Ts/d4))];
>> B2 = [0 0 w1*Ts/d1; 0 0 0; 0 0 0; 0 -w4*Ts/d4 0];
>> U2 = U1;
>> G2 = [(w1*Ts/d1) (-w2*Ts/d1) 0 0
         0 (w2*Ts/d2) (-w3*Ts/d2) 0
         0 0 (w3*Ts/d3) ((-1/(1-b))*(w4*Ts/d3))
         0 0 0 (w4*Ts/d4)];
>> V2 = [xM1; xM2; xM3; xM4];
>>
>> % define linear systems:
>> s1 = linsys(A1, B1, U1, [], [], [], [], 'd');  % free-flow mode
>> s2 = linsys(A2, B2, U2, G2, V2, [], [], 'd');  % congestion mode
>>
>> % define guard:
>> GRD = hyperplane([0; 1; 0; 0], xM2);
\end{verbatim}}

We assume that initially the system is in free-flow mode.
Given a set of initial conditions, we  compute the reach set according
to dynamics (\ref{fflow}) for certain number of time steps.
We will consider the external approximation of the reach set by a single
ellipsoid.
{\tt \begin{verbatim}
>> initial conditions:
>> X0 = [170; 180; 175; 170] + 10*ell_unitball(4);
>
>> L0 = [1; 0; 0; 0];  % single initial direction
>> N = 100;  % number of time steps
>>
>> ffrs = reach(s1, X0, L0, N);  % free-flow reach set
>> EA = get_ea(ffrs);  % 101x1 array of external ellipsoids
\end{verbatim}}
Having obtained the ellipsoidal array {\tt EA} representing the reach set
evolving in time, we  determine the  ellipsoids in the array that
intersect the guard.
{\tt \begin{verbatim}
>> I = hpintersection(EA, GRD);  % some of the intersections are empty
>> D = find(~isempty(I));  % determine nonempty intersections
>> min(D)

ans =

      19

>> max(D)

ans =

      69
\end{verbatim}}
Analyzing the values in array {\tt D}, we conclude that the free-flow reach set
has nonempty intersection with hyperplane {\tt GRD} at $t=18$
for the first time, and at $t=68$ for the last time.
Between $t=18$ and
$t=68$ it crosses the guard. Figure \ref{hwreachfig}(a) shows the
free-flow reach set projection onto $(x_1,x_2,x_3)$ subspace for $t=10$,
before the guard crossing; figure \ref{hwreachfig}(b) for $t=50$,
during the guard crossing; and figure \ref{hwreachfig}(c) for $t=80$,
after the guard was crossed.
\begin{figure}[htbp]
\centerline{
\includegraphics[height=10 cm]{hwreach.eps}}
\caption{Reach set of the free-flow system is blue, reach set of the congested
system is green, the guard is red.
\newline
(a) Reach set of the free-flow system at $t = 10$, before reaching the guard
(projection onto $(x_1,x_2,x_3)$).
\newline
(b) Reach set of the free-flow system at $t = 50$, crossing the guard.
(projection onto $(x_1,x_2,x_3)$).
\newline
(c) Reach set of the free-flow system at $t = 80$, after the guard is crossed.
(projection onto $(x_1,x_2,x_3)$).
\newline
(d) Reach set trace from $t=0$ to $t=100$, free-flow system in blue,
congested system in green; bounds of initial conditions are marked with magenta
(projection onto $(x_1,x_2)$).  }
\label{hwreachfig}
\end{figure}

For each time step that the intersection of the free-flow reach set and the
guard is nonempty, we establish a new initial time and a set of initial
conditions for the reach set computation according to dynamics (\ref{cflow}).
The initial time is the array index minus one, and the set of initial
conditions is the intersection of the free-flow reach set with the guard.
{\tt \begin{verbatim}
>> crs = [];
>> for i = 1:size(D, 2)
     rs = reach(s2, I(D(i)), L0, [(D(i)-1) N]);
     crs = [crs rs];
   end
\end{verbatim}}
The union of reach sets in array {\tt crs} forms the reach set for
the congested dynamics.

A summary of
 the reach set computation of the
linear hybrid system (\ref{fflow}-\ref{cflow}) for $N=100$ time steps
with one guard crossing is given in figure \ref{hwreachfig}(d),
which shows the projection of the reach set trace onto $(x_1,x_2)$ subspace.
The system starts evolving in time in free-flow mode from a set of
initial conditions at $t=0$, whose boundary is shown in magenta.
The free-flow reach set evolving from $t=0$ to $t=100$ is shown in blue.
Between  $t=18$ and $t=68$ the free-flow reach set crosses the guard.
The guard is shown in red.
For each  nonempty intersection of the free-flow reach set and the guard,
the congested mode reach set starts evolving in time until $t=100$.
All the congested mode reach sets are shown in green.
Observe that in the congested mode, the density $x_2$ in the congested part
 decreases slightly, while the density $x_1$ upstream of the congested part
 increases.
The blue  set above the guard is not actually reached,
because the state evolves according to the green region.





\chapter{Summary and Outlook}
Although some of the operations with ellipsoids are present in the
commercial Geometric Bounding Toolbox \cite{gbt1, gbt2}, the
ellipsoid-related functionality of that toolbox is rather limited.

{\it Ellipsoidal Toolbox} is the first free MATLAB package that
implements ellipsoidal calculus and uses ellipsoidal methods
for reachability analysis of continuous- and discrete-time affine
systems, continuous-time linear systems with disturbances and switched
systems, whose dynamics changes at known times.
The reach set computation for hybrid systems whose guards are hyperplanes
or polyhedra is not implemented explicitly, but the tool for such computation
exists, namely, the operations of intersection of ellipsoid with hyperplane
and ellipsoid with halfspace.





\chapter*{Acknowledgement}
\addcontentsline{toc}{chapter}{Acknowledgement}
The authors would like to thank Alexander B. Kurzhanski,
Manfred Morari, Johan L{\"o}fberg, Michal Kvasnica and Goran Frehse
for their support of this work by useful advice and encouragement.



\begin{thebibliography}{XX}
\addcontentsline{toc}{chapter}{Bibliography}
\bibitem{toolbox} Ellipsoidal Toolbox homepage:
{\it www.eecs.berkeley.edu/\~{ }akurzhan/ellipsoids}
\bibitem{kurvalyi} A.B.Kurzhanski, I.V\'{a}lyi (1997). {\it Ellipsoidal
Calculus for Estimation and Control}. Birkh\"{a}user, Boston, ser. SCFA.
\bibitem{kurvar} A.B.Kurzhanski, P.Varaiya (2000). {\it On ellipsoidal
techniques for reachability analysis}. In: {\it Optimization Methods and
Software}, Vol.17, pp.177-237, Taylor \& Francis.
\bibitem{kurvar1} A.B.Kurzhanski, P.Varaiya (2002). {\it On reachability
under uncertainty}, In {\it SIAM Journal on Control and Optimization},
Vol.41(1), pp.181-216.
\bibitem{kurvar2} A.B.Kurzhanski, P.Varaiya (2001). {\it Reachability analysis
for uncertain systems - the ellipsoidal technique}.
In: {\it Dynamics of Continuous, Discrete and Impulsive Systems Series B:
Applications and Algorithms}, Vol.9, pp.347-367.
\bibitem{pvak} A.A.Kurzhanskiy, P.Varaiya (2005).
{\it Ellipsoidal Techniques for Reachability Analysis of Discrete-Time
Linear Systems}. Submitted to IEEE Transactions on Automatic Control.
\bibitem{varaiya} P.Varaiya (1998). {\it Reach set computation
using optimal control}. In: {\it Proc. of KIT Workshop on Verification
on Hybrid Systems}. Verimag, Grenoble.
\bibitem{varaiya2} P.Varaiya. {\it Lecture notes on optimization}.
({\it www.eecs.berkeley.edu/\~{ }varaiya/papers\_ps.dir/NOO.pdf}).
\bibitem{vazhen} A.Yu.Vazhentsev (1999). {\it On Internal Ellipsoidal
Approximations for Problems of Control Synthesis with Bounded Coordinates}.
In: {\it Izvestia Rossiiskoi Akademii Nauk. Teoriya i Systemy Upravleniya.}
\bibitem{fusion} L.Ros, A.Sabater, F.Thomas (2002).
{\it An Ellipsoidal Calculus Based on Propagation and Fusion}. In:
{\it IEEE Transactions on Systems, Man and Cybernetics - Part B: Cybernetics},
Vol.32, N.4.
\bibitem{ect} Robust Ellipsoidal Calculus homepage:
{\it www-iri.upc.es/people/ros/ellipsoids.html}
\bibitem{morari} M.Kvasnica, P.Grieder, M.Baoti\'{c}, M.Morari (2004).
{\it Multi-Parametric Toolbox (MPT)}. In: R.Alur and G.J.Pappas, editors,
{\it Hybrid Systems: Computation and Control}, Vol.2993 of
{\it Lecture Notes in Computer Science}, pp.448-462. Springer-Verlag.
\bibitem{mpt} Multi-Parametric Toolbox homepage:
{\it control.ee.ethz.ch/\~{ }mpt}
\bibitem{yalmip} J.L{\"o}fberg (2004).
{\it A Toolbox for Modeling and Optimization in MATLAB}. In: Proceedings
of CACSD Conference, Taipei, Taiwan.
\bibitem{yalmiphp} YALMIP homepage:
{\it control.ee.ethz.ch/\~{ }joloef/yalmip.php}.
\bibitem{sedumi} J.F.Sturm (1999). {\it Using SeDuMi 1.02, A MATLAB Toolbox
for Optimization over Symmetric Cones}. In: {\it Optimization Methods
and Software}, Vol.11-12, pp.625-653, Taylor \& Francis.
\bibitem{sedumihp} SeDuMi homepage:
{\it sedumi.mcmaster.ca}
\bibitem{mitchell} I.Mitchell, C.Tomlin (2000). {\it Level set methods for
computation in hybrid systems}, In: N.Lynch and B.H.Krogh, editors,
{\it Hybrid Systems: Computation and Control}, Vol.1790 of
{\it Lecture Notes in Computer Science}. Springer-Verlag.
\bibitem{levelset} Level Set Toolbox homepage:
{\it www.cs.ubc.ca/\~{ }mitchell/ToolboxLS}
\bibitem{krogh} O.Stursberg, B.H.Krogh (2003). {\it Efficient representation
and computation of reachable sets for hybrid systems}, In: O.Maler and A.Pnueli,
editors, {\it Hybrid Systems: Computation and Control}, Vol.2623 of
{\it Lecture Notes in Computer Science}, pp.482-497. Springer-Verlag.
\bibitem{checkmate} CheckMate homepage:
{\it www.ece.cmu.edu/\~{ }webk/checkmate}
\bibitem{maler} E.Asarin, O.Bournez, T.Dang, O.Maler (2000). {\it Approximate
reachability analysis of piecewise linear dynamical systems},
In: N.Lynch and B.H.Krogh, editors,
{\it Hybrid Systems: Computation and Control}, Vol.1790 of
{\it Lecture Notes in Computer Science}, pp.21-31. Springer-Verlag.
\bibitem{ddt} $d/dt$ homepage:
{\it www-verimag.imag.fr/\~{ }tdang/ddt.html}
\bibitem{girard} A.Girard (2005). {\it Reachability of uncertain linear
systems using zonotopes}. In: M.Morari and L.Thiele, editors,
{\it Hybrid Systems: Computation and Control}, Vol.3414 of
{\it Lecture Notes in Computer Science}, pp 291-305. Springer-Verlag.
\bibitem{leguernic} A.Girard, C.Le Guernic, O.Maler (2006).
{\it Computation of reachable sets of linear
time-invariant systems with inputs}, In: J.Hespanha and A.Tiwari, editors,
{\it Hybrid Systems: Computation and Control}, Vol.3927 of
{\it Lecture Notes in Computer Science}, pp.257-271. Springer-Verlag.
\bibitem{matisse} MATISSE homepage:
{\it www.seas.upenn.edu/\~{ }agirard/Software/MATISSE}
\bibitem{zonotool} Zonotope methods on Wolfgang K\"{u}hn homepage:
{\it www.decatur.de}
\bibitem{motzkin} T.S.Motzkin, H.Raiffa, G.L.Thompson, R.M.Thrall (1953).
{\it The Double Description Method}. In: H.W.Kuhn and A.W.Tucker, editors,
{\it Conttributions to theory of games}, Vol.2. Princeton University Press.
\bibitem{cdd} CDD/CDD+ homepage:
{\it www.cs.mcgill.ca/\~{ }fukuda/soft/cdd\_home/cdd.html}
\bibitem{avis} D.Avis, D.Bremner, R.Seidel (1997). {\it How good are convex
hull algorithms?} In: {\it Computational Geometry: Theory and Applications}
No.7, pp.265-301. ELSEVIER.
\bibitem{yovine} G.Lafferriere, G.J.Pappas, S.Yovine (2001). {\it Symbolic
Reachability Computation for Families of Linear Vector Fields}. In:
{\it Journal of Symbolic Computation} No.32, pp.231-253, Academic Press.
\bibitem{requiem} Requiem homepage:
{\it www.seas.upenn.edu/\~{ }hybrid/requiem/requiem.html}
\bibitem{gbt1} S.M.Veres, A.V.Kuntsevich, I.V\'{a}lyi, S.Hermsmeyer,
D.S.Wall (2001). {\it Geometric Bounding toolbox for MATLAB}. In:
{\it MATLAB/Simulink Connections Catalogue}. Natick, MA: MathWorks Inc.
\bibitem{gbt2} Geometric Bounding Toolbox homepage:
{\it www.sysbrain.com/gbt}
\bibitem{kostousova} E.K.Kostousova (2001). {\it Control synthesis via
parallelotopes: optimization and parallel computations}.
In: {\it Optimization Methods and Software}, Vol.14, N.4, pp.267-310,
Taylor \& Francis.
\bibitem{xiaotian} L.Mu\~{n}oz, X.Sun, R.Horowitz, L.Alvarez (2003).
{\it Traffic density estimation with the cell transmission model},
In: {\it Proceedings of the American Control Conference},
Denver, Colorado, USA, pp.3750-3755.
\bibitem{boyd} S.Boyd, L.El Ghaoui, E.Feron, V.Balakrishnan (1994).
{\it Linear Matrix Inequalities in System and Control Theory}. SIAM.
\bibitem{boyd2} S.Boyd, L.Vandenberghe (2004).
{\it Convex Optimization}. Cambridge University Press.
\bibitem{gant} F.R.Gantmacher (1960). {\it Matrix theory, I-II}.
Chelsea Pub., NY.
\bibitem{golub} G.H.Golub, C.F.Van Loan (1996). {\it Matrix Computations},
3rd Edn. The Johns Hopkins University Press.
\bibitem{rockafellar} R.T.Rockafellar (1999). {\it Convex Analysis}, 2nd Edn.
Princeton University Press.
\end{thebibliography}





\appendix
\chapter{Function Reference}
\section{ellipsoid Methods}
{\Large {\tt dimension}} - returns the dimension of the space in which
the ellipsoid is defined and the rank of its shape matrix.

Parameters:
\begin{itemize}
\item {\tt E} - single ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt n} - dimension of the space.
\item {\tt r} - rank of the ellipsoid's shape matrix. This output parameter
is optional.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E1 = ellipsoid;
>> A = [3 1; 0 1; -2 1]; E2 = ellipsoid([1; -1; 1], A*A');
>> E3 = ellipsoid(eye(2));
>> E4 = ellipsoid(0);
>> [n, r] = dimension([E1 E2; E3 E4])

n =

   0     3
   2     1

r =

   0     2
   2     0
\end{verbatim} }

\newpage

{\Large {\tt display}} - displays the details of the ellipsoid object.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}
This function is rarely used explicitely. It is called automatically
for the object {\tt E} when semicolon does not terminate the statement.

\newpage

{\Large {\tt distance}} - computes the distance from the given ellipsoid
to the specified object - vector, ellipsoid, hyperplane or polytope.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\item {\tt X} - in case of vectors, it is a matrix, whose columns represent
the vectors to which the distance is measured, number of columns must match
the number of ellipsoids in the array {\tt E};\\
in case of ellipsoids, it is array of ellipsoids whose size must match the
size of {\tt E};\\
in case of hyperplanes, it is array of hyperplanes whose size must match the
size of {\tt E};\\
in case of polytopes, it is polytope array whose length must match
the number of ellipsoids in the array {\tt E}.
\item {\tt F} - this flag if set to $1$ indicates that the distance should
be computed in the metric of ellipsoids in {\tt E}. This parameter is optional,
its default value is $0$, and the distance is computed in the Euclidean metric.
This parameter makes no difference for the distance computation
between ellipsoids and polytopes.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt D} - distance or array of distances.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> V = [1 1; 1 -1; -1 1; -1 -1]';
>> distance(E, V)

ans =

     2.3428    1.0855    1.3799    -0.4402
\end{verbatim} }

\newpage

{\Large {\tt double}} - returns parameters of the ellipsoid, its center
and shape matrix.

Parameters:
\begin{itemize}
\item {\tt E} - single ellipsoid.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt q} - center of the ellipsoid. It is optional output parameter.
\item {\tt Q} - shape matrix of the ellipsoid.
\end{itemize}

\newpage

{\Large {\tt ellipsoid}} - constructor for the ellipsoid object.
If called without parameters, returns empty ellipsoid.

Parameters:
\begin{itemize}
\item {\tt q} - center of the ellipsoid, vector in ${\bf R}^n$.
This parameter is optional, and if omitted, it is assumed that the ellipsoid
is centered at the origin.
\item {\tt Q} - shape matrix of the ellipsoid, matrix in ${\bf R}^{n\times n}$,
symmetric positive semidefinite.
\end{itemize}
Returns:
\begin{itemize}
\item {\tt E} - object of type {\tt ellipsoid class}.
\end{itemize}
Example:
{\tt \begin{verbatim}
>> E = ellipsoid([1 0 -1 6]', 9*eye(4));
\end{verbatim} }
creates a ball of radius $3$ in ${\bf R}^4$ centered at $[1 ~ 0 ~ -1 ~ 6]^T$.

\newpage

{\Large {\tt eq}} - overloaded operator {\tt '=='},
it checks if two ellipsoids are equal.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\end{itemize}

Returns $1$ if two ellipsoids are equal, $0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> E == [E ellipsoid(eye(2))]

ans =

     1     0
\end{verbatim} }

\newpage

{\Large {\tt ge}}, {\Large {\tt gt}} - checks if the first ellipsoid is bigger
than the second one.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\end{itemize}

Returns $1$ if {\tt E1} contains {\tt E2} when both have the same center,
$0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> E > E

ans =

     1
\end{verbatim} }
illustrates the fact that an ellipsoid is always bigger than itself.

\newpage

{\Large {\tt hpintersection}} - computes the ellipsoid which results from
intersection of given ellipsoid with given hyperplane.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\item {\tt H} - hyperplane or array of hyperplanes.
\end{itemize}
If {\tt E} and {\tt H} are arrays, then their sizes must match.

Returns:
\begin{itemize}
\item {\tt I} - ellipsoid or array of ellipsoids that are intersections of
ellipsoids in {\tt E} with hyperplanes in {\tt H}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> H = [hyperplane([0 -1; -1 0]', 1); hyperplane([0 1; 1 0]', 1)];
>> I = hpintersection(E, H)

I =
2x2 array of ellipsoids.
\end{verbatim} }

\newpage

{\Large {\tt intersect}} - checks if the union or intersection of ellipsoids
intersects given ellipsoid, hyperplane or polytope.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids whose union or intersection
is considered.
\item {\tt X} - can be single or array of ellipsoids, hyperplanes or polytopes.
\item {\tt s} - if {\tt 'u'}, {\tt E} should be treated as union of ellipsoids,
if {\tt 'i'}, {\tt E} should be treated as intersection of ellipsoids.
This parameter is optional, its default value is {\tt 'u'}.
\end{itemize}

Returns $-1$ in case parameter {\tt s} is set to {\tt 'i'} and the
intersection of ellipsoids in {\tt E} is empty,\\
$0$ if the union or intersection of ellipsoids in {\tt E} does not intersect
the object in {\tt X},\\
$1$ if the union or intersection of ellipsoids in {\tt E} and the object
in {\tt X} have nonempty intersection.

Example:
{\tt \begin{verbatim}
>> E1 = ellipsoid([-2; -1], [4 -1; -1 1]);
>> E2 = E1 + [5; 5];
>> H  = hyperplane([1; -1]);
>> intersect([E1 E2], H)

ans =

     1

>> intersect([E1 E2], H, 'i')

ans =

    -1
\end{verbatim} }
Here two ellipsoids {\tt E1} and {\tt E2} do not intersect but both are
intersected by hyperplane {\tt H}.

\newpage

{\Large {\tt intersection\_ea}} - computes the external ellipsoidal
approximation of the intersection of the ellipsoid with given ellipsoid,
halfspace or polytope.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\item {\tt X} - can be single or array of ellipsoids, hyperplanes or polytopes.
\end{itemize}
If {\tt E} and {\tt X} are arrays, then their sizes must match.

Returns:
\begin{itemize}
\item {\tt EA} - ellipsoid or array of ellipsoids that externally approximate
the intersection.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E1 = ellipsoid([-2; -1], [4 -1; -1 1]);
>> E2 = E1 + [5; 5];
>> B  = ell_unitball(2);
>> EA = intersection_ea([E1 E2], B)

EA =
1x2 array of ellipsoids.
\end{verbatim} }

\newpage

{\Large {\tt intersection\_ia}} - computes the internal ellipsoidal
approximation of the intersection of the ellipsoid with given ellipsoid,
halfspace or polytope.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\item {\tt X} - can be single or array of ellipsoids, hyperplanes or polytopes.
\end{itemize}
If {\tt E} and {\tt X} are arrays, then their sizes must match.

Returns:
\begin{itemize}
\item {\tt IA} - ellipsoid or array of ellipsoids that internally approximate
the intersection.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E1 = ellipsoid([-2; -1], [4 -1; -1 1]);
>> E2 = E1 + [5; 5];
>> B  = ell_unitball(2);
>> IA = intersection_ia([E1 E2], B)

IA =
1x2 array of ellipsoids.
\end{verbatim} }

\newpage

{\Large {\tt inv}} - inverts the shape matrix of the ellipsoid if it is
nonsingular.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt I} - ellipsoid or array of ellipsoids with inverted shape matrices.
\end{itemize}

\newpage

{\Large {\tt isbaddirection}} - checks if ellipsoidal approximations of
the geometric difference of two ellipsoids can be computed for given
directions.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\item {\tt L} - matrix whose columns are direction vectors that need to be
checked.
\end{itemize}

Returns $1$ if given direction is bad and ellipsoidal approximation cannot
be computed for it, $0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = 3*ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> isbaddirection(B, E, L)

ans =

     0     1     1     0}
\end{verbatim} }
means that for vectors $[1 ~ 1]^T$ and $[0 ~ 1]^T$ the ellipsoidal approximation
of the geometric difference ${\tt B}\dot{-}{\tt E}$ cannot be computed.

\newpage

{\Large {\tt isdegenerate}} - checks if given ellipsoid is degenerate.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns $1$ if the ellipsoid is degenerate, $0$ - otherwise.

\newpage

{\Large {\tt isempty}} - checks if given ellipsoid is an empty object.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns $1$ if empty, $0$ - otherwise.

\newpage

{\Large {\tt isinside}} - checks if the intersection of ellipsoids contains
the union or intersection of given ellipsoids or polytopes.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids whose intersection contains
or not the union or intersection of other given objects.
\item {\tt X} - can be array of ellipsoids or polytopes whose union or
intersection belongs or not to the intersection {\tt E}.
\item {\tt s} - if {\tt 'u'}, {\tt X} should be treated as union,
if {\tt 'i'}, {\tt X} should be treated as intersection. This parameter
is optional, its default value is {\tt 'u'}.
\end{itemize}

Returns $-1$ if parameter {\tt s} is set to {\tt 'i'} and the intersection
of ellipsoids or polytopes in {\tt X} is empty,\\
$0$ - if the intersection {\tt E} does not cover {\tt X},\\
$1$ - if {\tt E} contains {\tt X}.

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = ell_unitball(2);
>> isinside(E, [E B], 'i')

ans =

     1
\end{verbatim} }
illustrates the fact that any ellipsoid contains its intersection with
another ellipsoid.

\newpage

{\Large {\tt isinternal}} - checks if the union or intersection of ellipsoids
contains given vectors.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids whose intersection contains
or not given vectors or polytopes.
\item {\tt X} - can be matrix whose columns represent vectors to be checked.
\item {\tt s} - if {\tt 'u'}, {\tt E} should be treated as union,
if {\tt 'i'}, {\tt E} should be treated as intersection. This parameter
is optional, its default value is {\tt 'u'}.
\end{itemize}

Returns $1$ if vector in {\tt X} belongs to union or intersection {\tt E},
$0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> E1 = ellipsoid([-2; -1], [4 -1; -1 1]);
>> E2 = E1 + [5; 5];
>> isinternal([E1 E2], [2 7; -1 4], 'i')

ans =

     0     0

>> isinternal([E1 E2], [2 7; -1 4])

ans =

     1     1
\end{verbatim} }
Here the intersection of {\tt E1} and {\tt E2} is empty, and thus, cannot
contain any points. The union, on the other hand, contains centers
of both ellipsoids.

\newpage

{\Large {\tt le}}, {\Large {\tt lt}} - checks if the second ellipsoid is bigger
than the first one.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\end{itemize}

Returns $1$ if {\tt E2} contains {\tt E1} when both have the same center,
$0$ - otherwise.

This operation is the mirror of {\tt ge}, {\tt gt}.

\newpage

{\Large {\tt maxeig}} - returns the biggest eigenvalue of the ellipsoid.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt a} - largest eigenvalue or array of largest eigenvalues of
ellipsoids in {\tt E}.
\end{itemize}

\newpage

{\Large {\tt mineig}} - returns the smallest eigenvalue of the ellipsoid.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt a} - smallest eigenvalue or array of smallest eigenvalues of
ellipsoids in {\tt E}.
\end{itemize}

\newpage

{\Large {\tt minkdiff}} - computes and plots the geometric difference of
two ellipsoids in 2D and 3D.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\item {\tt o} - options structure whose fields describe how the geometric
difference must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt show\_all} - if set to $1$, also displays the ellipsoids
{\tt E1} and {\tt E2};
\item {\tt newfigure} - if set to $1$, each plot command will open a new
figure window;
\item {\tt fill} - if set to $1$, the resulting set and the ellipsoids,
if plotted in 2D, will be filled with color;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt x} - center of the resulting set.
\item {\tt X} - matrix whose columns represent the boundary points of the
resulting set. The number of points is defined by parameters
{\tt plot2d\_grid} for 2D plots and {\tt plot3d\_grid} for 3D plots of the
global {\tt ellOptions} structure.
\end{itemize}
Both output parameters are optional.

\newpage

{\Large {\tt minkdiff\_ea}} - computes external ellipsoidal approximations
of the geometric difference of two ellipsoids of arbitrary dimension
for given directions, if these directions are not bad.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt EA} - array of computed external ellipsoids. Can be empty, if
all the directions specified in {\tt L} are bad.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = 3*ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> EA = minkdiff_ea(B, E, L)

EA =
1x2 array of ellipsoids.
\end{verbatim} }
The resulting array {\tt EA} contains only two ellipsoids because two
of the four directions specified in {\tt L} are bad.

\newpage

{\Large {\tt minkdiff\_ia}} - computes internal ellipsoidal approximations
of the geometric difference of two ellipsoids of arbitrary dimension
for given directions, if these directions are not bad.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt EA} - array of computed internal ellipsoids. Can be empty, if
all the directions specified in {\tt L} are bad.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = 3*ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> IA = minkdiff_ia(B, E, L)

IA =
1x2 array of ellipsoids.
\end{verbatim} }
The resulting array {\tt IA} contains only two ellipsoids because two
of the four directions specified in {\tt L} are bad.

\newpage

{\Large {\tt minkmp}} - computes and plots geometric (Minkowski) sum of the
geometric difference of two ellipsoids and the geometric sum of $n$ ellipsoids
in 2D or 3D.

Parameters:
\begin{itemize}
\item {\tt E0} - first ellipsoid.
\item {\tt E} - second ellipsoid.
\item {\tt EE} - array of ellipsoids whose geometric sum needs to be computed.
\item {\tt o} - options structure whose fields describe how the geometric
difference must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt show\_all} - if set to $1$, also displays the ellipsoids
{\tt E1} and {\tt E2};
\item {\tt newfigure} - if set to $1$, each plot command will open a new
figure window;
\item {\tt fill} - if set to $1$, the resulting set and the ellipsoids,
if plotted in 2D, will be filled with color;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt x} - center of the resulting set.
\item {\tt X} - matrix whose columns represent the boundary points of the
resulting set. The number of points is defined by parameters
{\tt plot2d\_grid} for 2D plots and {\tt plot3d\_grid} for 3D plots of the
global {\tt ellOptions} structure.
\end{itemize}
Both output parameters are optional.

\newpage

{\Large {\tt minkmp\_ea}} - computes external ellipsoidal approximations
of the geometric (Minkowski) sum of the geometric difference of two ellipsoids
and the geometric sum of $n$ ellipsoids.

Parameters:
\begin{itemize}
\item {\tt E0} - first ellipsoid.
\item {\tt E} - second ellipsoid.
\item {\tt EE} - array of ellipsoids whose geometric sum needs to be computed.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt EA} - array of computed external ellipsoids. Can be empty, if
all the directions specified in {\tt L} are bad.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> EA = minkmp_ea(3*B, E, [B E] L)

EA =
1x2 array of ellipsoids.
\end{verbatim} }
The resulting array {\tt EA} contains only two ellipsoids because two
of the four directions specified in {\tt L} are bad.

\newpage

{\Large {\tt minkmp\_ia}} - computes internal ellipsoidal approximations
of the geometric (Minkowski) sum of the geometric difference of two ellipsoids
and the geometric sum of $n$ ellipsoids.

Parameters:
\begin{itemize}
\item {\tt E0} - first ellipsoid.
\item {\tt E} - second ellipsoid.
\item {\tt EE} - array of ellipsoids whose geometric sum needs to be computed.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt IA} - array of computed internal ellipsoids. Can be empty, if
all the directions specified in {\tt L} are bad.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> IA = minkmp_ia(3*B, E, [B E] L)

IA =
1x2 array of ellipsoids.
\end{verbatim} }
The resulting array {\tt IA} contains only two ellipsoids because two
of the four directions specified in {\tt L} are bad.

\newpage

{\Large {\tt minkpm}} - computes and plots geometric (Minkowski) difference of
the geometric sum of ellipsoids and a single ellipsoid in 2D or 3D.

Parameters:
\begin{itemize}
\item {\tt EE} - array of ellipsoids whose geometric sum needs to be computed.
\item {\tt E} - single ellipsoid.
\item {\tt o} - options structure whose fields describe how the geometric
difference must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt show\_all} - if set to $1$, also displays the ellipsoids
{\tt E1} and {\tt E2};
\item {\tt newfigure} - if set to $1$, each plot command will open a new
figure window;
\item {\tt fill} - if set to $1$, the resulting set and the ellipsoids,
if plotted in 2D, will be filled with color;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt x} - center of the resulting set.
\item {\tt X} - matrix whose columns represent the boundary points of the
resulting set. The number of points is defined by parameters
{\tt plot2d\_grid} for 2D plots and {\tt plot3d\_grid} for 3D plots of the
global {\tt ellOptions} structure.
\end{itemize}
Both output parameters are optional.

\newpage

{\Large {\tt minkpm\_ea}} - computes external ellipsoidal approximations
of the geometric (Minkowski) difference of the geometric sum of ellipsoids
and a single ellipsoid.

Parameters:
\begin{itemize}
\item {\tt EE} - array of ellipsoids whose geometric sum needs to be computed.
\item {\tt E} - single ellipsoid.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt EA} - array of computed external ellipsoids. Can be empty, if
all the directions specified in {\tt L} are bad.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E1 = ellipsoid([2; -1], [9 -5; -5 4]);
>> E2 = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> EA = minkpm_ea([B E1], E2 L)

EA =
1x4 array of ellipsoids.
\end{verbatim} }

\newpage

{\Large {\tt minkpm\_ia}} - computes internal ellipsoidal approximations
of the geometric (Minkowski) difference of the geometric sum of ellipsoids
and a single ellipsoid.

Parameters:
\begin{itemize}
\item {\tt EE} - array of ellipsoids whose geometric sum needs to be computed.
\item {\tt E} - single ellipsoid.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt IA} - array of computed internal ellipsoids. Can be empty, if
all the directions specified in {\tt L} are bad.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E1 = ellipsoid([2; -1], [9 -5; -5 4]);
>> E2 = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> IA = minkpm_ia([B E1], E2 L)

IA =
1x2 array of ellipsoids.
\end{verbatim} }
The resulting array {\tt IA} contains only two ellipsoids because two
of the four directions specified in {\tt L} are bad.

\newpage

{\Large {\tt minksum}} - computes and plots the geometric sum of finite
number of ellipsoids in 2D and 3D.

Parameters:
\begin{itemize}
\item {\tt E} - array of ellipsoids whose geometric sum needs to be computed.
\item {\tt o} - options structure whose fields describe how the geometric
sum must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt show\_all} - if set to $1$, also displays the ellipsoids in the
array {\tt E};
\item {\tt newfigure} - if set to $1$, each plot command will open a new
figure window;
\item {\tt fill} - if set to $1$, the resulting set and the ellipsoids,
if plotted in 2D, will be filled with color;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt x} - center of the resulting set.
\item {\tt X} - matrix whose columns represent the boundary points of the
resulting set. The number of points is defined by parameters
{\tt plot2d\_grid} for 2D plots and {\tt plot3d\_grid} for 3D plots of the
global {\tt ellOptions} structure.
\end{itemize}
Both output parameters are optional.

\newpage

{\Large {\tt minksum\_ea}} - computes external ellipsoidal approximations
of the geometric sum of finite number of ellipsoids of arbitrary dimension
for given directions.

Parameters:
\begin{itemize}
\item {\tt E} - array of ellipsoids whose geometric sum needs to be
approximated.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt EA} - array of computed external ellipsoids whose length is the same
as the number of columns of matrix {\tt L}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> EA = minkdiff_ea([E B inv(E)] L)

EA =
1x4 array of ellipsoids.
\end{verbatim} }

\newpage

{\Large {\tt minksum\_ia}} - computes internal ellipsoidal approximations
of the geometric sum of finite number of ellipsoids of arbitrary dimension
for given directions.

Parameters:
\begin{itemize}
\item {\tt E} - array of ellipsoids whose geometric sum needs to be
approximated.
\item {\tt L} - matrix whose columns specify the directions for which
the approximations should be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt IA} - array of computed internal ellipsoids whose length is the same
as the number of columns of matrix {\tt L}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> B = ell_unitball(2);
>> L = [1 0; 1 1; 0 1; -1 1]';
>> IA = minkdiff_ia([E B inv(E)] L)

IA =
1x4 array of ellipsoids.
\end{verbatim} }

\newpage

{\Large {\tt minus}} - overloaded operator {\tt '-'}.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids defined in ${\bf R}^n$.
\item {\tt b} - vector in ${\bf R}^n$ or matrix in ${\bf R}^{n\times m}$,
where $m$ equals the number of ellipsoids in the array {\tt E}.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt E1} - ellipsoid or array of ellipsoids with same shapes as {\tt E},
but with centers shifted by vectors in {\tt -b}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E  = [ellipsoid([-2; -1], [4 -1; -1 1]) ell_unitball(2)];
>> E1 = E - [1; 1];
>> E1(1)

ans =

Center:
    -3
    -2

Shape:
     4    -1
    -1     1

Nondegenerate ellipsoid in R^2.

>> E1(2)

ans =

Center:
    -1
    -1

Shape:
     1     0
     0     1

Nondegenerate ellipsoid in R^2.
\end{verbatim} }

\newpage

{\Large {\tt move2origin}} - moves given ellipsoids to the origin.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt O} - the same ellipsoid or array of ellipsoids as {\tt E},
but all centered at the origin.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> O = move2origin(E)

O =

Center:
     0
     0

Shape:
     4    -1
    -1     1

Nondegenerate ellipsoid in R^2.
\end{verbatim} }

\newpage

{\Large {\tt mtimes}} - overloaded operator {\tt '*'}.

Parameters:
\begin{itemize}
\item {\tt A} - scalar, or matrix in ${\bf R}^{m\times n}$.
\item {\tt E} - ellipsoid or array of ellipsoids defined in ${\bf R}^n$.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt E1} - ellipsoid or array of ellipsoids resulting from linear
transformation of {\tt E}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> A = [0 1; -1 0];
>> A*E

ans =

Center:
    -1
     2

Shape:
     1     1
     1     4

Nondegenerate ellipsoid in R^2.
\end{verbatim} }

\newpage

{\Large {\tt ne}} - overloaded operator {\tt '\~{ }='},
it checks if two ellipsoids are not equal.

Parameters:
\begin{itemize}
\item {\tt E1} - first ellipsoid.
\item {\tt E2} - second ellipsoid.
\end{itemize}

Returns $1$ if two ellipsoids are not equal, $0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> E \~{ }= [E ellipsoid(eye(2))]

ans =

     0     1
\end{verbatim} }

\newpage

{\Large {\tt parameters}} - returns parameters of the ellipsoid, its center
and shape matrix.

Parameters:
\begin{itemize}
\item {\tt E} - single ellipsoid.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt q} - center of the ellipsoid. It is optional output parameter.
\item {\tt Q} - shape matrix of the ellipsoid.
\end{itemize}

{\bf Remark.} This function is obsolete. Use {\tt double} instead.

\newpage

{\Large {\tt plot}} - plots ellipsoids in 1D, 2D and 3D.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\item {\tt c} - specifies the color:
\begin{itemize}
\item {\tt 'b'} - blue;
\item {\tt 'c'} - cyan;
\item {\tt 'g'} - green;
\item {\tt 'k'} - black;
\item {\tt 'm'} - magenta;
\item {\tt 'r'} - red;
\item {\tt 'w'} - white;
\item {\tt 'y'} - yellow.
\end{itemize}
This parameter is optional.
\item {\tt o} - options structure whose fields describe how the ellipsoids
must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt newfigure} - if set to $1$, each plot command will open a new
figure window;
\item {\tt fill} - if set to $1$, the resulting set and the ellipsoids,
if plotted in 2D, will be filled with color;
\item {\tt width} - specifies line width for 1D and 2D plots;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns: None.

\newpage

{\Large {\tt plus}} - overloaded operator {\tt '+'}.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids defined in ${\bf R}^n$.
\item {\tt b} - vector in ${\bf R}^n$ or matrix in ${\bf R}^{n\times m}$,
where $m$ equals the number of ellipsoids in the array {\tt E}.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt E1} - ellipsoid or array of ellipsoids with same shapes as {\tt E},
but with centers shifted by vectors in {\tt b}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E  = [ellipsoid([-2; -1], [4 -1; -1 1]) ell_unitball(2)];
>> E1 = E + [1; 1];
>> E1(1)

ans =

Center:
    -1
     0

Shape:
     4    -1
    -1     1

Nondegenerate ellipsoid in R^2.

>> E1(2)

ans =

Center:
     1
     1

Shape:
     1     0
     0     1

Nondegenerate ellipsoid in R^2.
\end{verbatim} }

\newpage

{\Large {\tt polar}} - computes polars for ellipsoids which contain the origin.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt P} - polar ellipsoid or array of polar ellipsoids for those
in {\tt E}.
\end{itemize}

For ellipsoids that do not contain the origin, this function returns empty
ellipsoid.

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([4 -1; -1 1]);
>> polar(E) == inv(E)

ans =

     1
\end{verbatim} }
illustrates the fact that polar set of an ellipsoid centered at the origin
equals to inverse of this ellipsoid.

\newpage

{\Large {\tt projection}} - computes projection of ellipsoids onto given
orthogonal basis.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids defined in ${\bf R}^n$.
\item {\tt B} - matrix in ${\bf R}^{n\times m}$ whose columns are orthogonal.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt P} - array of projected ellipsoids.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1; 4], [4 -1 0; -1 1 0; 0 0 9]);
>> B = [0 1 0; 0 0 1]';
>> P = projection(E, B)

P =

Center:
    -1
     4

Shape:
     1     0
     0     9

Nondegenerate ellipsoid in R^2.
\end{verbatim} }

\newpage

{\Large {\tt rho}} - computes the support function of the ellipsoids for
given directions and corresponding boundary points.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids defined in ${\bf R}^n$.
\item {\tt L} - vector in ${\bf R}^n$ if {\tt E} is an array of ellipsoids,
otherwise, if {\tt E} is a single ellipsoid, it can be matrix in
${\bf R}^{n\times m}$ whose columns represent the directions for which
the support function needs to be computed.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt R} - array of support function values.
\item {\tt X} - matrix whose columns are boundary points corresponding
to the directions in {\tt L}. This output parameter is optional.
\end{itemize}

\newpage

{\Large {\tt shape}} - has the same functionality as {\tt mtimes} but
modifies only the shape matrix of the ellipsoid leaving its center as is.

Parameters:
\begin{itemize}
\item {\tt A} - scalar, or matrix in ${\bf R}^{m\times n}$.
\item {\tt E} - ellipsoid or array of ellipsoids defined in ${\bf R}^n$.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt E1} - ellipsoid or array of ellipsoids resulting from modification
of the shape matrices of ellipsoids in {\tt E}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([-2; -1], [4 -1; -1 1]);
>> A = [0 1; -1 0];
>> shape(E, A)

ans =

Center:
    -2
    -1

Shape:
     1     1
     1     4

Nondegenerate ellipsoid in R^2.
\end{verbatim} }

\newpage

{\Large {\tt trace}} - computes trace of given ellipsoids.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt T} - array of trace values whose size matches the size of {\tt E}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([4 -1; -1 1]);
>> B = ell_unitball(2);
>> T = trace([E B])

V =

    5     2
\end{verbatim} }

\newpage


{\Large {\tt uminus}} - overloaded operation unitary minus.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt E1} - array of the same ellipsoids as in {\tt E}, whose centers
are multilied by $-1$.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = -ellipsoid([-2; -1], [4 -1; -1 1])

E =

Center:
     2
     1

Shape:
     4    -1
    -1     1

Nondegenerate ellipsoid in R^2.
\end{verbatim} }

\newpage

{\Large {\tt volume}} - computes volume of given ellipsoids.

Parameters:
\begin{itemize}
\item {\tt E} - ellipsoid or array of ellipsoids.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt V} - array of volume values whose size matches the size of {\tt E}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> E = ellipsoid([4 -1; -1 1]);
>> B = ell_unitball(2);
>> V = volume([E B])

V =

    5.4414     3.1416
\end{verbatim} }

\newpage

\section{hyperplane Methods}
{\Large {\tt contains}} - checks if the hyperplanes contain given vectors.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane or array of hyperplanes.
\item {\tt X} - matrix whose columns represent the vectors needed to be checked.
The number of columns must match the number of hyperplanes in {\tt H}.
\end{itemize}

Returns $1$ if the vector in {\tt X} belongs to the hyperplane in {\tt H},
$0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> H = hyperplane([-1; 1]);
>> X = [100 -1 2; 100 1 2];
>> contains(H, X)

ans =

     1     0     1
\end{verbatim} }

\newpage

{\Large {\tt dimension}} - returns the dimension of the space in which
the hyperplane is defined.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane or array of hyperplanes.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt D} - array of dimension values of the same size as {\tt H}.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> H1 = hyperplane([-1; 1]);
>> H2 = hyperplane([-1; 1; 8; -2; 3], 7);
>> H3 = hyperplane([1; 2; 0], -1);
>> D  = dimension([H1 H2 H3]);

D =

   2     5     3
\end{verbatim} }

\newpage

{\Large {\tt display}} - displays the details of the hyperplane object.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane or array of hyperplanes.
\end{itemize}
This function is rarely used explicitely. It is called automatically
for the object {\tt H} when semicolon does not terminate the statement.

\newpage

{\Large {\tt double}} - returns parameters of the hyperplane object,
its normal and scalar.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane object.
\end{itemize}

Parameters:
\begin{itemize}
\item {\tt v} - normal vector.
\item {\tt c} - scalar. This output parameter is optional.
\end{itemize}

\newpage

{\Large {\tt eq}} - overloaded operator {\tt '=='}.
it checks if two hyperplanes are equal.

Parameters:
\begin{itemize}
\item {\tt H1} - first hyperplane.
\item {\tt H2} - second hyperplane.
\end{itemize}

Returns $1$ if two hyperplanes are equal, $0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> H1 = hyperplane([-1; 1]);
>> H2 = hyperplane([-1; 1; 8; -2; 3], 7);
>> H3 = hyperplane([1; 2; 0], -1);
>> H2 == [H1 H2 H3]

ans =

     0     1     0
\end{verbatim} }

\newpage

{\Large {\tt hyperplane}} - constructor for the hyperplane object.
If called without parameters, returns empty hyperplane.

Parameters:
\begin{itemize}
\item {\tt V} - vector in ${\bf R}^n$ or matrix in ${\bf R}^{n\times m}$ whose
columns define the normals to the hyperplanes that need to be created.
\item {\tt C} - scalar value, or, in case {\tt V} has $m$ columns, it can be
array with $m$ values.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt H} - hyperplane, or, if {\tt V} has more than one column,
array of hyperplanes.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> V = [1 1 1; 1 1 1];
>> C = [1 -5 0];
>> H = hyperplane(V, C);
\end{verbatim} }
defines three parallel hyperplanes and returns them in the array {\tt H}.

\newpage

{\Large {\tt isempty}} - checks if the hyperplane object is empty.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane or array of hyperplanes.
\end{itemize}

Returns: $1$ if the hyperplane object is empty, $0$ - otherwise.

\newpage

{\Large {\tt isparallel}} - checks if the hyperplanes are parallel.

Parameters:
\begin{itemize}
\item {\tt H1} - first hyperplane.
\item {\tt H2} - second hyperplane.
\end{itemize}

Returns $1$ if two hyperplanes are equal, $0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> H = hyperplane([-1 1; 1 1; 1 1], [2 1 0]);
>> isparallel(H, H(2))

ans =

     0     1     1
\end{verbatim} }

\newpage

{\Large {\tt ne}} - overloaded operator {\tt '\~{ }='},
it checks if two hyperplanes are not equal.

Parameters:
\begin{itemize}
\item {\tt H1} - first hyperplane.
\item {\tt H2} - second hyperplane.
\end{itemize}

Returns $1$ if two hyperplanes are not equal, $0$ - otherwise.

Example:
{\tt \begin{verbatim}
>> H1 = hyperplane([-1; 1]);
>> H2 = hyperplane([-1; 1; 8; -2; 3], 7);
>> H3 = hyperplane([1; 2; 0], -1);
>> [H2 H1 H3] == [H1 H2 H3]

ans =

     0     0     1
\end{verbatim} }

\newpage

{\Large {\tt parameters}} - returns parameters of the hyperplane object,
its normal and scalar.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane object.
\end{itemize}

Parameters:
\begin{itemize}
\item {\tt v} - normal vector.
\item {\tt c} - scalar. This output parameter is optional.
\end{itemize}

{\bf Remark.} This function is obsolete. Use {\tt double} instead.

\newpage

{\Large {\tt plot}} - plots hyperplanes in 2D and 3D.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane or array of hyperplanes.
\item {\tt c} - specifies the color:
\begin{itemize}
\item {\tt 'b'} - blue;
\item {\tt 'c'} - cyan;
\item {\tt 'g'} - green;
\item {\tt 'k'} - black;
\item {\tt 'm'} - magenta;
\item {\tt 'r'} - red;
\item {\tt 'w'} - white;
\item {\tt 'y'} - yellow.
\end{itemize}
This parameter is optional.
\item {\tt o} - options structure whose fields describe how the hyperplanes
must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt newfigure} - if set to $1$, each plot command will open a new
figure window;
\item {\tt size} - length of the line segment in 2D or square diagonal in 3D.
\item {\tt center} - center of the line segment in 2D or square diagonal in 3D.
\item {\tt width} - specifies line width for 2D plots;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns: None.

\newpage

{\Large {\tt uminus}} - overloaded operator unitary minus. It does not change
the hyperplane, and affects only the halfspace this hyperplane defines.

Parameters:
\begin{itemize}
\item {\tt H} - hyperplane or array of hyperplanes.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt H1} - array of the same hyperplanes as in {\tt H} whose normals and
scalars are multiplied by $-1$.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> H = -hyperplane([-1; 1], 1)

H =

Normal:
     1
    -1

Shift:
    -1

Hyperplane in R^2.
\end{verbatim} }

\newpage

\section{linsys Methods}
{\Large {\tt dimension}} - returns dimensions of state, input, output and
disturbance input spaces.

Parameters:
\begin{itemize}
\item {\tt LSYS} - linear system or array of linear systems.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt N} - state space dimension.
\item {\tt I} - dimension of the input space.
\item {\tt O} - dimension of the output space.
\item {\tt D} - dimension of the disturbance input space.
\end{itemize}

\newpage

{\Large {\tt display}} - displays the details of the linear system object.

Parameters:
\begin{itemize}
\item {\tt LSYS} - linear system or array of linear systems.
\end{itemize}
This function is rarely used explicitely. It is called automatically
for the object {\tt LSYS} when semicolon does not terminate the statement.

\newpage

{\Large {\tt hasdisturbance}} - checks if given linear system is the system
with disturbance.

Parameters:
\begin{itemize}
\item {\tt LSYS} - linear system or array of linear systems.
\end{itemize}

Returns $1$ if it is system with disturbance, $0$ - otherwise.

\newpage

{\Large {\tt hasnoise}} - checks if given linear system has noise at the
output.

Parameters:
\begin{itemize}
\item {\tt LSYS} - linear system or array of linear systems.
\end{itemize}

Returns $1$ if it is system with noise, $0$ - otherwise.

\newpage

{\Large {\tt isdiscrete}} - checks if given linear system is discrete-time.

Parameters:
\begin{itemize}
\item {\tt LSYS} - linear system or array of linear systems.
\end{itemize}

Returns $1$ if the system is discrete-time, $0$ - otherwise.

\newpage

{\Large {\tt isempty}} - checks if given linear system is an empty object.

Parameters:
\begin{itemize}
\item {\tt LSYS} - linear system or array of linear systems.
\end{itemize}

Returns $1$ if {\tt LSYS} is an empty object, $0$ - otherwise.

\newpage

{\Large {\tt islti}} - checks if given linear system is time invariant.

Parameters:
\begin{itemize}
\item {\tt LSYS} - linear system or array of linear systems.
\end{itemize}

Returns $1$ if the system is time invariant, $0$ - otherwise.

\newpage

{\Large {\tt linsys}} - constructor for the linear system object.
If called without parameters, creates an empty object.

Parameters:
\begin{itemize}
\item {\tt A} - matrix $A\in{\bf R}^{n\times n}$, can be symbolic if it
depends on time ($t$ - in continuous case, $k$ - in discrete case).
\item {\tt B} - matrix $B\in{\bf R}^{n\times m}$, can by symbolic if it
depends on time.
\item {\tt U} - defines control bounds: it can be ellipsoid object with
dimension $m$; or structure with fields {\tt center} - symbolic vector,
and {\tt shape} - symbolic matrix, if the ellipsoidal bounds depend on time;
or, if the control is fixed, it can be single vector of type {\it double}
or symbolic.
\item {\tt G} - matrix $G\in{\bf R}^{n\times d}$, can by symbolic if it
depends on time. This parameter is optional.
\item {\tt V} - defines disturbance bounds: it can be ellipsoid object with
dimension $d$; or structure with fields {\tt center} - symbolic vector,
and {\tt shape} - symbolic matrix, if the ellipsoidal bounds depend on time;
or, if the control is fixed, it can be single vector of type {\it double}
or symbolic. This parameter is optional.
\item {\tt C} - matrix $C\in{\bf R}^{o\times n}$, can by symbolic if it
depends on time. This parameter is optional.
\item {\tt W} - defines noise bounds: it can be ellipsoid object with
dimension $o$; or structure with fields {\tt center} - symbolic vector,
and {\tt shape} - symbolic matrix, if the ellipsoidal bounds depend on time;
or, if the control is fixed, it can be single vector of type {\it double}
or symbolic. This parameter is optional.
\item {\tt s} - if set to {\tt 'd'}, indicates that the system is discrete-time.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt LSYS} - linear system object.
\end{itemize}

Example:
{\tt \begin{verbatim}
>> A = {'0' '1 + cos(pi*k/2)'; '-2' '0'};
>> B = [0; 1];
>> U = ellipsoid(4);
>> G = [1; 0];
>> V = 1/(k+1);
>> C = [1 0];
>> lsys = linsys(A, B, U, G, V, C, [], 'd');
\end{verbatim} }

defines the following affine discrete-time system:
\begin{eqnarray*}
\left[\begin{array}{c}
x_1[k+1]\\
x_2[k+1]\end{array}\right] & = & \left[\begin{array}{cc}
0 & 1 + \cos(\frac{\pi k}{2})\\
-2 & 0\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]u[k] + \left[\begin{array}{c}
\frac{1}{k+1}\\
0\end{array}\right], ~~~ -2\leq u[k]\leq2\\
y[k] & = & [1 ~~ 0]\left[\begin{array}{c}
x_1[k]\\
x_2[k]\end{array}\right], ~~~ k\geq0.
\end{eqnarray*}

\newpage

\section{reach Methods}
{\Large {\tt cut}} - extracts a segment of the reach tube from the given start
time to the given end time.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\item {\tt T} - time interval of interest in the form {\tt [t1 t2]}.
If {\tt T} is a single scalar, then the reach set for this particular time
value is returned.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt CRS} - the resulting reach set object.
\end{itemize}

\newpage

{\Large {\tt dimension}} - returns the dimension of the reach set and
the dimension of the state space for which the reach set was originally
computed.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt d} - dimension of the reach set.
\item {\tt n} - dimension of the state space for which the reach set was
originally computed. Values of {\tt d} and {\tt n} can be different if
the reach set object is a result of {\tt projection} operation.
This parameter is optional.
\end{itemize}

\newpage

{\Large {\tt display}} - displays the details of the reach set object.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}
This function is rarely used explicitely. It is called automatically
for the object {\tt LSYS} when semicolon does not terminate the statement.

\newpage

{\Large {\tt evolve}} - computes further evolution in time of the already
existing reach set.

Parameters:
\begin{itemize}
\item {\tt CRS} - existing reach set.
\item {\tt T} - new time horizon.
\item {\tt LSYS} - linear system object that describes new dynamics.
This parameter is optional.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

\newpage

{\Large {\tt get\_center}} - returns trajectory of the center of the reach set.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt X} - matrix whose columns represent the position of the center
at times specified in the second output parameter, {\tt T}.
\item {\tt T} - array of time values at which the trajectory of the reach set
center is evaluated. This output parameter is optional.
\end{itemize}
The number of columns in {\tt X} and values in {\tt T}
is specified by the parameter
{\tt time\_grid} of the {\tt ellOptions} structure.

\newpage

{\Large {\tt get\_directions}} - returns the trajectories of the direction
vectors for which the ellipsoidal approximations were computed.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt X} - array of cells where each cell represents a trajectory
of the direction vector, for which the ellipsoidal approximations of the
reach set were computed.
\item {\tt T} - array of time values at which these trajectories
are evaluated. This output parameter is optional.
\end{itemize}
The number of columns in cells of {\tt X} and values in {\tt T} is specified by
the parameter {\tt time\_grid} of the {\tt ellOptions} structure.

\newpage

{\Large {\tt get\_ea}} - returns array of ellipsoids that represent the
external approximation of the reach set.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt E} - array of ellipsoids that externally approximate the reach set.
The intersection of ellipsoids in the given column of this array is
the external approximation of the reach set at the time spacified by the
corresponding value in the array {\tt T}.
\item {\tt T} - array of time values at which the approximations
are evaluated. This output parameter is optional.
\end{itemize}
The number of columns in {\tt E} and values in {\tt T} is specified by
the parameter {\tt time\_grid} of the {\tt ellOptions} structure.

\newpage

{\Large {\tt get\_goodcurves}} - returns the trajectories along which
the ellipsoidal approximations are touching the actual reach set.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt X} - array of cells where each cell represents a good trajectory
along which one of the computed ellipsoidal approximations touches the
reach set.
\item {\tt T} - array of time values at which the good trajectories
are evaluated. This output parameter is optional.
\end{itemize}
The number of columns in cells of {\tt X} and values in {\tt T} is specified by
the parameter {\tt time\_grid} of the {\tt ellOptions} structure.

\newpage

{\Large {\tt get\_ia}} - returns array of ellipsoids that represent the
internal approximation of the reach set.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt E} - array of ellipsoids that internally approximate the reach set.
The union of ellipsoids in the given column of this array is
the internal approximation of the reach set at the time specified by the
corresponding value in the array {\tt T}.
\item {\tt T} - array of time values at which the approximations
are evaluated. This output parameter is optional.
\end{itemize}
The number of columns in {\tt E} and values in {\tt T} is specified by
the parameter {\tt time\_grid} of the {\tt ellOptions} structure.

\newpage

{\Large {\tt get\_system}} - returns the linear system object for which
the reach set was computed.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt LSYS} - the linear system object, which was used for the reach
set computation.
\end{itemize}

\newpage

{\Large {\tt intersect}} - checks if the external or internal approximation
of the reach set intersects with given ellipsoids, hyperplanes or
polytopes.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\item {\tt X} - can be array of ellipsoids, hyperplanes or polytopes.
\item {\tt s} - if set to {\tt 'i'}, indicates that internal approximation
should be checked, if set to {\tt 'e'} - external. This input parameter
is optional, its default value is {\tt 'e'}.
\end{itemize}

Returns $1$ if the intersection is nonempty, $0$ - otherwise.

\newpage

{\Large {\tt iscut}} - checks if the given reach set object resulted
from {\tt cut} operation.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns $1$ if {\tt RS} is a result of {\tt cut} operation, $0$ - otherwise.

\newpage

{\Large {\tt isempty}} - checks if the given reach set object is empty.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns $1$ if it is an empty object, $0$ - otherwise.

\newpage

{\Large {\tt isprojection}} - checks if the given reach set is a result
of {\tt projection} operation.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

Returns $1$ if {\tt RS} is a projection, $0$ - otherwise.

\newpage

{\Large {\tt plot\_ea}} - plots external approximation of the reach set
in 2D and 3D.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\item {\tt c} - specifies the color:
\begin{itemize}
\item {\tt 'b'} - blue;
\item {\tt 'c'} - cyan;
\item {\tt 'g'} - green;
\item {\tt 'k'} - black;
\item {\tt 'm'} - magenta;
\item {\tt 'r'} - red;
\item {\tt 'w'} - white;
\item {\tt 'y'} - yellow.
\end{itemize}
This parameter is optional.
\item {\tt o} - options structure whose fields describe how the reach set
must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt width} - specifies line width for 2D plots;
\item {\tt fill} - if set to $1$, the set, if plotted in 2D,
will be filled with color;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns: None.

\newpage

{\Large {\tt plot\_ia}} - plots internal approximation of the reach set
in 2D and 3D.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object.
\item {\tt c} - specifies the color:
\begin{itemize}
\item {\tt 'b'} - blue;
\item {\tt 'c'} - cyan;
\item {\tt 'g'} - green;
\item {\tt 'k'} - black;
\item {\tt 'm'} - magenta;
\item {\tt 'r'} - red;
\item {\tt 'w'} - white;
\item {\tt 'y'} - yellow.
\end{itemize}
This parameter is optional.
\item {\tt o} - options structure whose fields describe how the reach set
must be plotted. The fields of this structure are
\begin{itemize}
\item {\tt width} - specifies line width for 2D plots;
\item {\tt fill} - if set to $1$, the set, if plotted in 2D,
will be filled with color;
\item {\tt color} - specifies the color of the plot in the RGB format:
{\tt [x y z]};
\item {\tt shade} - the level of transparency for 3D plots, takes values
between $0$ and $1$ ($0$ - transparent, $1$ - opaque).
\end{itemize}
This parameter is optional.
\end{itemize}

Returns: None.

\newpage

{\Large {\tt projection}} - projects the reach set onto the given orthogonal
basis.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object with dimension $n$.
\item {\tt B} - matrix in ${\bf R}^{n\times m}$ whose columns are orthogonal,
they represent the basis vectors.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt PRS} - reach set object with the projected reach set.
\end{itemize}

\newpage

{\Large {\tt reach}} - constructor for the reach set object and the main
function that computes the reach set.

Parameters:
\begin{itemize}
\item {\tt LSYS} - the linear system object with state space dimension $n$.
\item {\tt X0} - ellipsoid object with dimension $n$, it represents
the set of initial conditions.
\item {\tt L0} - matrix in ${\bf R}^{n\times m}$ whose columns represent the
directions for which the new approximations need to be computed.
\item {\tt T} - time interval in the form {\tt [t0 t1]}. If {\tt t1} is
smaller than {\tt t0}, then the backward reach set should be computed.
If {\tt T} is a scalar, then it is assumed that {\tt t0 = 0}.
\item {\tt o} - options structure with fields
\begin{itemize}
\item {\tt approximation} - if set to $0$, then only external approximation
is computed, if set to $1$, then only internal approximation is computed,
if set to $2$ (default value), then both approximations are computed.
\item {\tt save\_all} - if set to $0$ (default value), then the intermediate
calculation data should not be saved, $1$ indicates the opposite.
\item {\tt minmax} - for discrete-time systems, if set to $0$ (default value),
then maxmin reach set must be computed, $1$ indicates that minmax reach set is
to be computed; for continuous-time systems - ignored.
\end{itemize}
This parameter is optional.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt RS} - reach set object.
\end{itemize}

\newpage

{\Large {\tt refine}} - adds new approximations for the specified directions
to the given reach set object, thus improving the overall approximation.

Parameters:
\begin{itemize}
\item {\tt RS} - reach set object with dimension $n$. This object must
contain the intermediate calculation data, otherwise, the refinement
is not possible.
\item {\tt L0} - matrix in ${\bf R}^{n\times m}$ whose columns represent the
directions for which the new approximations need to be computed.
\item {\tt o} - options structure with fields
\begin{itemize}
\item {\tt approximation} - if set to $0$, then only external approximation
is computed, if set to $1$, then only internal approximation is computed,
if set to $2$ (default value), then both approximations are computed.
\item {\tt save\_all} - if set to $0$, then the intermediate calculation
data should not be saved, $1$ (default value) indicates the opposite.
\end{itemize}
This parameter is optional.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt RRS} - reach set object with refined approximation.
\end{itemize}

\newpage

\section{Miscellaneous Functions}
{\Large {\tt ell\_simdiag}} - computes the orthogonal transformation matrix
that simultaneously diagonalizes two symmetric matrices.

Parameters:
\begin{itemize}
\item {\tt A} - symmetric positive definite matrix in ${\bf R}^{n\times n}$.
\item {\tt B} - symmetric positive semidefinite matrix in ${\bf R}^{n\times n}$.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt T} - orthogonal matrix in ${\bf R}^{n\times n}$, such that
$TAT^T$ is identity matrix, and $TBT^T$ is diagonal martrix.
\end{itemize}

\newpage

{\Large {\tt ell\_unitball}} - creates the ellipsoid object that represents
a unit ball of the given dimension.

Parameters:
\begin{itemize}
\item {\tt n} - dimension of the space in which the unit ball is defined.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt B} - ellipsoid object with identity shape matrix centered at the
origin.
\end{itemize}

\newpage

{\Large {\tt ell\_valign}} - computes the orthogonal matrix that aligns two
vectors.

Parameters:
\begin{itemize}
\item {\tt w} - vector in ${\bf R}^n$.
\item {\tt v} - vector in ${\bf R}^n$ that needs to be rotated to be parallel
to {\tt w}.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt S} - orthogonal matrix in ${\bf R}^{n\times n}$, such that
$Sv = \frac{\|v\|_2}{\|w\|_2}w$.
\end{itemize}

\newpage

{\Large {\tt hyperplane2polytope}} - converts array of hyperplanes of the
same dimension into the polytope object of the Multi-Parametric Toolbox.

Parameters:
\begin{itemize}
\item {\tt H} - array of hyperplanes, all of which must have the same dimension.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt P} - polytope object as defined in the Multi-Parametric Toolbox.
\end{itemize}

\newpage

{\Large {\tt polytope2hyperplane}} - converts the polytope object of the
Multi-Parametric Toolbox into the array of hyperplanes.

Parameters:
\begin{itemize}
\item {\tt P} - polytope object as defined in the Multi-Parametric Toolbox.
\end{itemize}

Returns:
\begin{itemize}
\item {\tt H} - array of hyperplanes.
\end{itemize}



\end{document}

