<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementation &mdash; Ellipsoidal Toolbox 2.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Ellipsoidal Toolbox 2.0.1 documentation" href="index.html" />
    <link rel="next" title="Examples" href="chap_examples.html" />
    <link rel="prev" title="Installation" href="chap_install.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="chap_examples.html" title="Examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="chap_install.html" title="Installation"
             accesskey="P">previous</a> |</li>
        <li><a href="main_manual.html">Ellipsoidal Toolbox 2.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="implementation">
<h1>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="operations-with-ellipsoids">
<h2>Operations with ellipsoids<a class="headerlink" href="#operations-with-ellipsoids" title="Permalink to this headline">¶</a></h2>
<p>In the <em>Ellipsoidal Toolbox</em> we define a new class ellipsoid inside the
MATLAB programming environment. The following three commands define the
same ellipsoid <img class="math" src="_images/math/86a01c7a751f2a781e9911f4c77c750f24a671e6.png" alt="{\mathcal E}(q,Q)"/>, with <img class="math" src="_images/math/bc268c6c9b845f28350ebb76180e9bbf577dc873.png" alt="q\in{\bf R}^n"/> and
<img class="math" src="_images/math/fcce825c4d68c51a628ca139c15c09cf17f9ab91.png" alt="Q\in{\bf R}^{n\times n}"/> being symmetric positive semidefinite:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre> <span class="n">centVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>
 <span class="n">shMat</span> <span class="p">=</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
 <span class="n">ellObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="n">centVec</span><span class="p">,</span> <span class="n">shMat</span><span class="p">);</span>
 <span class="n">ellObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="n">shMat</span><span class="p">)</span> <span class="o">+</span> <span class="n">centVec</span><span class="p">;</span>
 <span class="n">ellObj</span> <span class="p">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">shMat</span><span class="p">)</span><span class="o">*</span><span class="n">ell_unitball</span><span class="p">(</span><span class="nb">size</span><span class="p">(</span><span class="n">shMat</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">centVec</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>For the ellipsoid class we overload the following functions and
operators:</p>
<ul class="simple">
<li>isEmpty(ellObj) - checks if <img class="math" src="_images/math/86a01c7a751f2a781e9911f4c77c750f24a671e6.png" alt="{\mathcal E}(q,Q)"/> is an empty
ellipsoid.</li>
<li>display(ellObj) - displays the details of ellipsoid
<img class="math" src="_images/math/86a01c7a751f2a781e9911f4c77c750f24a671e6.png" alt="{\mathcal E}(q,Q)"/>, namely, its center <img class="math" src="_images/math/23f1b45408e5b4130c0f940fcbfcec54492cbdcd.png" alt="q"/> and the shape
matrix <img class="math" src="_images/math/7b1816c51f7d31275cd3ad400208fb7b3ce136a0.png" alt="Q"/>.</li>
<li>plot(ellObj) - plots ellipsoid <img class="math" src="_images/math/86a01c7a751f2a781e9911f4c77c750f24a671e6.png" alt="{\mathcal E}(q,Q)"/> if its
dimension is not greater than 3.</li>
<li>firstEllObj == secEllObj - checks if ellipsoids
<img class="math" src="_images/math/1de5034d4c6f3bda7f6ef4bf9d1f8525de7b3d46.png" alt="{\mathcal E}(q_1,Q_1)"/> and <img class="math" src="_images/math/7c03b9994bef648279d675ca186661da592fd155.png" alt="{\mathcal E}(q_2,Q_2)"/> are
equal.</li>
<li>firstEllObj ~= secEllObj - checks if ellipsoids
<img class="math" src="_images/math/1de5034d4c6f3bda7f6ef4bf9d1f8525de7b3d46.png" alt="{\mathcal E}(q_1,Q_1)"/> and <img class="math" src="_images/math/7c03b9994bef648279d675ca186661da592fd155.png" alt="{\mathcal E}(q_2,Q_2)"/> are
not equal.</li>
<li>[ , ] - concatenates the ellipsoids into the horizontal array, e.g. ellVec
= [firstEllObj secEllObj thirdEllObj].</li>
<li>[ ; ] - concatenates the ellipsoids into the vertical array, e.g. ellMat =
[firstEllObj secEllObj; thirdEllObj fourthEllObj] defines
<img class="math" src="_images/math/986ad48db02dcaf802568dee2460269916229fdf.png" alt="2\times 2"/> array of ellipsoids.</li>
<li>firstEllObj &gt;= secEllObj - checks if the ellipsoid firstEllObj is
bigger than the ellipsoid secEllObj, or equivalently
<img class="math" src="_images/math/7871c7c9c0c0635f6db6b850c4b5c289603bc07b.png" alt="{\mathcal E}(0,Q_1)\subseteq{\mathcal E}(0,Q_2)"/>.</li>
<li>firstEllObj &lt;= secEllObj - checks if
<img class="math" src="_images/math/e30a04da6f369ae2157711a1d706a40c13262f70.png" alt="{\mathcal E}(0,Q_2)\subseteq{\mathcal E}(0,Q_1)"/>.</li>
<li>-ellObj - defines ellipsoid <img class="math" src="_images/math/be0f8e0459ac2816cd0d8b3b0ab1198e0b05c820.png" alt="{\mathcal E}(-q,Q)"/>.</li>
<li>ellObj + bScal - defines ellipsoid <img class="math" src="_images/math/f7a7aca625fde43728041be211a3413e11e33194.png" alt="{\mathcal E}(q+b,Q)"/>.</li>
<li>ellObj - bScal - defines ellipsoid <img class="math" src="_images/math/5c3e01f8539c871d622584cc30750504793b95bb.png" alt="{\mathcal E}(q-b,Q)"/>.</li>
<li>aMat * ellObj - defines ellipsoid <img class="math" src="_images/math/e2b5a2670bb30e7cc12702ea6b67000358512f82.png" alt="{\mathcal E}(q,AQA^T)"/>.</li>
<li>ellObj.inv() - inverts the shape matrix of the ellipsoid:
<img class="math" src="_images/math/d3a55918d9c861ad74c44436d7d8475fdf01d5f0.png" alt="{\mathcal E}(q,Q^{-1})"/>.</li>
</ul>
<p>All the listed operations can be applied to a single ellipsoid as well
as to a two-dimensional array of ellipsoids. For example,</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% nondegenerate ellipsoid in R^2</span>
<span class="n">firstEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">2</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span> <span class="o">-</span><span class="mi">5</span> <span class="mi">4</span><span class="p">]);</span> 
<span class="n">secEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">polar</span><span class="p">();</span><span class="c">% secEll is polar ellipsoid for firstEllObj</span>
<span class="c">% thirdEllObj is generated from secEllObj by inverting its shape matrix</span>
<span class="n">thirdEllObj</span> <span class="p">=</span> <span class="n">secEllObj</span><span class="p">.</span><span class="n">getInv</span><span class="p">();</span> 
<span class="c">% 2x2 array of ellipsoids</span>
<span class="n">ellMat</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span><span class="p">;</span> <span class="n">thirdEllObj</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">))];</span> 
<span class="c">% check if firstEllObj is bigger than each of the ellipsoids in ellMat</span>
<span class="n">ellMat</span> <span class="o">&lt;</span><span class="p">=</span> <span class="n">firstEllObj</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     0</span>
<span class="c">%      1     0</span>
</pre></div>
</td></tr></table></div>
<p>To access individual elements of the array, the usual MATLAB subindexing is used:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">aMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">0</span><span class="p">];</span>  <span class="c">% aMat - 2x2 real matrix</span>
<span class="n">bVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">;</span> <span class="mi">0</span><span class="p">];</span> <span class="c">% bVec - vector in R^2</span>
<span class="c">% affine transformation of ellipsoids in the second column of ellMat</span>
<span class="n">aTransMat</span> <span class="p">=</span> <span class="n">aMat</span> <span class="o">*</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">bVec</span><span class="p">;</span>  
</pre></div>
</td></tr></table></div>
<p>Sometimes it may be useful to modify the shape of the ellipsoid without
affecting its center. Say, we would like to bloat or squeeze the
ellipsoid:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bltEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">getShape</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c">% bloats ellipsoid firstEllObj</span>
<span class="n">sqzEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">getShape</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span>  <span class="c">% squeezes ellipsoid firstEllObj</span>
</pre></div>
</td></tr></table></div>
<p>Since function shape does not change the center of the
ellipsoid, it only accepts scalars or square matrices as its second
input parameter. Several functions access the internal data of the
ellipsoid object:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">[</span><span class="n">centVec</span><span class="p">,</span> <span class="n">shMat</span><span class="p">]</span> <span class="p">=</span> <span class="n">secEllObj</span><span class="p">.</span><span class="n">double</span><span class="p">()</span>
<span class="c">% centVec =</span>
<span class="c">% </span>
<span class="c">%    -0.5000</span>
<span class="c">%    -0.1667</span>
<span class="c">% </span>
<span class="c">% shMat =</span>
<span class="c">% </span>
<span class="c">%    0.9167     0.9167</span>
<span class="c">%    0.9167     1.5278</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define new ellipsoid</span>
<span class="n">fourthEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">42</span> <span class="o">-</span><span class="mi">7</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">4</span><span class="p">;</span> <span class="o">-</span><span class="mi">7</span> <span class="mi">10</span> <span class="mi">3</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="mi">4</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">2</span><span class="p">]);</span>  
<span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">:)</span> <span class="n">fourthEllObj</span><span class="p">];</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">isdegenerate</span><span class="p">()</span> <span class="c">% check if given ellipsoids are degenerate</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0     0     1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">:)</span> <span class="n">fourthEllObj</span><span class="p">];</span>
<span class="p">[</span><span class="n">dimVec</span><span class="p">,</span> <span class="n">rankVec</span><span class="p">]</span> <span class="p">=</span> <span class="n">bufEllVec</span><span class="p">.</span><span class="n">dimension</span><span class="p">()</span> 


<span class="c">% dimVec =</span>
<span class="c">% </span>
<span class="c">%    2     2     4</span>
<span class="c">% </span>
<span class="c">% rankVec =</span>
<span class="c">% </span>
<span class="c">%    2     2     3</span>
</pre></div>
</td></tr></table></div>
<p>One way to check if two ellipsoids intersect, is to
compute the distance between them (<a class="reference internal" href="#stanhp" id="id1">[STANHP]</a>, <a class="reference internal" href="#lin2002" id="id2">[LIN2002]</a>):</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% distance between thirdEllObj and each of the ellipsoids in ellMat</span>
<span class="n">ellMat</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">)</span> 

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%          0         0</span>
<span class="c">%          0    0.1683</span>
</pre></div>
</td></tr></table></div>
<p>This result indicates that the ellipsoid
thirdEllObj does not intersect with the ellipsoid ellMat(2, 2), with all
the other ellipsoids in ellMat it has nonempty intersection. If the
intersection of the two ellipsoids is nonempty, it can be approximated
by ellipsoids from the outside as well as from the inside. See
<a class="reference internal" href="chap_ellcalc.html#ros2002" id="id3">[ROS2002]</a>
for more information about these methods.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% external approximation of intersection of firstEllObj and thirdEllObj</span>
<span class="n">externalEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">intersection_ea</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">);</span> 
<span class="c">% internal approximation of intersection of firstEllObj and thirdEllObj</span>
<span class="n">internalEllObj</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">intersection_ia</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">);</span> 
</pre></div>
</td></tr></table></div>
<p>It can be checked that
resulting ellipsoid externalEllObj contains the given intersection,
whereas internalEllObj is contained in this intersection:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% array [firstEllObj secEllObj] should be treated as intersection</span>
<span class="n">externalEllObj</span><span class="p">.</span><span class="n">doesIntersectionContain</span><span class="p">([</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span><span class="p">],</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">thirdEllObj</span><span class="p">]</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">doesIntersectionContain</span><span class="p">(</span><span class="n">internalEllObj</span><span class="p">)</span> 

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Function
isInside in general checks if the intersection of ellipsoids in the
given array contains the union or intersection of ellipsoids or
polytopes.</p>
<p>It is also possible to solve the feasibility problem, that is, to check
if the intersection of more than two ellipsoids is empty:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      -1</span>
</pre></div>
</td></tr></table></div>
<p>In this
particular example the result <img class="math" src="_images/math/80d842c5b7aabdb4c23f00d2074915d876e294f2.png" alt="-1"/> indicates that the intersection
of ellipsoids in ellMat is empty. Function intersect in general checks
if an ellipsoid, hyperplane or polytope intersects the union or the
intersection of ellipsoids in the given array:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span> <span class="n">thirdEllObj</span><span class="p">]</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span> <span class="n">thirdEllObj</span><span class="p">];</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="s">&#39;u&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>For the ellipsoids in
<img class="math" src="_images/math/fdbe9b4214da88518dfbb7be23a10bc0fc6eedb8.png" alt="{\bf R}"/>, <img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> and <img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/> the geometric
sum can be computed explicitely and plotted:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">.</span><span class="n">minksum</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<div class="figure" id="minksumpic">
<a class="reference internal image-reference" href="_images/chapter05_section01_minksum.png"><img alt="minksum" src="_images/chapter05_section01_minksum.png" style="width: 40%;" /></a>
<p class="caption">Figure 8: The geometric sum of ellipsoids.</p>
</div>
<p><a href="#minksumpic">Figure  8</a> displays the geometric sum of ellipsoids. If
the dimension of the space in which the ellipsoids are defined exceeds
<img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/>, an error is returned. The result of the geometric sum
operation is not generally an ellipsoid, but it can be approximated by
families of external and internal ellipsoids parametrized by the
direction vector:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define the set of directions:</span>
<span class="c">% columns of matrix dirsMat are vectors in R^2</span>
<span class="n">dirsMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>
<span class="c">% compute external ellipsoids for the directions in dirsMat</span>
<span class="n">externalEllVec</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">.</span><span class="n">minksum_ea</span><span class="p">(</span><span class="n">dirsMat</span><span class="p">)</span> 

<span class="c">% externalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% compute internal ellipsoids for the directions in dirsMat</span>
<span class="n">internalEllVec</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">.</span><span class="n">minksum_ia</span><span class="p">(</span><span class="n">dirsMat</span><span class="p">)</span>  

<span class="c">% internalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% intersection of external ellipsoids should always contain </span>
<span class="c">% the union of internal ellipsoids:</span>
<span class="n">externalEllVec</span><span class="p">.</span><span class="n">doesIntersectionContain</span><span class="p">(</span><span class="n">internalEllVec</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">)</span> 
<span class="c">% </span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Functions minksum_ea and minksum_ia work for
ellipsoids of arbitrary dimension. They should be used for general
computations whereas minksum is there merely for visualization purposes.</p>
<p>If the geometric difference of two ellipsoids is not an empty set, it
can be computed explicitely and plotted for ellipsoids in
<img class="math" src="_images/math/fdbe9b4214da88518dfbb7be23a10bc0fc6eedb8.png" alt="{\bf R}"/>, <img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> and <img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/>:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% ellipsoid defined by squeezing the ellipsoid ellMat(2, 2)</span>
<span class="n">fourthEllObj</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="n">getShape</span><span class="p">(</span><span class="mf">0.4</span><span class="p">);</span>  
<span class="c">% check if the geometric difference firstEllObj - fourthEllObj is nonempty</span>
<span class="n">firstEllObj</span> <span class="o">&gt;</span><span class="p">=</span> <span class="n">fourthEllObj</span>  
<span class="c">% </span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>

<span class="c">% compute and plot this geometric difference</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkdiff</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="figure" id="minkdiffpic">
<a class="reference internal image-reference" href="_images/chapter05_section01_minkdiff.png"><img alt="minkdiff" src="_images/chapter05_section01_minkdiff.png" style="width: 40%;" /></a>
<p class="caption">Figure 9: The geometric difference of ellipsoids.</p>
</div>
<p><a href="#minkdiffpic">Figure  9</a> shows the geometric difference of ellipsoids.</p>
<p>Similar to minksum, minkdiff is there for visualization purpose. It
works only for dimensions <img class="math" src="_images/math/123e375e88da91240024aaf085abee194c4a2d06.png" alt="1"/>, <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/> and <img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/>, and for
higher dimensions it returns an error. For arbitrary dimensions, the
geometric difference can be approximated by families of external and
internal ellipsoids parametrized by the direction vector, provided this
direction is not bad:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">absTol</span> <span class="p">=</span> <span class="n">getAbsTol</span><span class="p">(</span><span class="n">firstEllObj</span><span class="p">);</span>
<span class="c">% find out which of the directions in dirsMat are bad</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">isbaddirection</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">absTol</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     0     0     1     0 </span>


<span class="c">% two of five directions specified by dirsMat are bad,</span>
<span class="c">% so, only three ellipsoidal approximations </span>
<span class="c">% can be produced for this dirsMat:</span>
<span class="n">externalEllVec</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkdiff_ea</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span> 

<span class="c">% externalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x3</span>

<span class="n">internalEllVec</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkdiff_ia</span><span class="p">(</span><span class="n">fourthEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>

<span class="c">% internalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x3</span>
</pre></div>
</td></tr></table></div>
<p>Operation ’difference-sum’ described in section
2.2.4 is implemented in functions minkmp, minkmp_ea, minkmp_ia, the
first one of which is used for visualization and works for dimensions
not higher than <img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/>, whereas the last two can deal with ellipsoids
of arbitrary dimension.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% ellipsoidal approximations for (firstEllObj - thirdEllObj + secEllObj)</span>

<span class="c">% external</span>
<span class="n">externalEllVec</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkmp_ea</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">secEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span> 
<span class="c">% externalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% internal</span>
<span class="n">internalEllVec</span> <span class="p">=</span> <span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkmp_ia</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">secEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>
<span class="c">% internalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="c">% plot the set (firstEllObj - thirdEllObj + secEllObj)</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkmp</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">secEllObj</span><span class="p">,</span> <span class="s">&#39;newfigure&#39;</span><span class="p">,</span> <span class="n">true</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="figure" id="minkpic">
<a class="reference internal image-reference" href="_images/chapter05_section01_minkpmminkmp.png"><img alt="minkpmminkmp" src="_images/chapter05_section01_minkpmminkmp.png" style="width: 100%;" /></a>
<p class="caption">Figure 10: Implementation of operations &#8216;sum-difference&#8217; and &#8216;difference-sum&#8217;.</p>
</div>
<p>Figure <a href="#minkpic"> 10</a> displays results of
the implementation of minkpm and minkmp operations.</p>
<p>Similarly, operation ’sum-difference’ described in section <a class="reference internal" href="chap_ellcalc.html#sum-diff-label"><em>Geometric Sum-Difference</em></a> is implemented in functions
minkpm, minkpm_ea, minkpm_ia, the first one of which is used for
visualization and works for dimensions not higher than <img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/>,
whereas the last two can deal with ellipsoids of arbitrary dimension.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% ellipsoidal approximations for (firstEllObj + secEllObj - thirdEllObj)</span>
<span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span><span class="p">];</span>
<span class="n">externalEllVec</span> <span class="p">=</span> <span class="n">bufEllVec</span><span class="p">.</span><span class="n">minkpm_ea</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>  <span class="c">% external</span>

<span class="c">% externalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x5</span>

<span class="n">internalEllVec</span> <span class="p">=</span> <span class="n">bufEllVec</span><span class="p">.</span><span class="n">minkpm_ia</span><span class="p">(</span><span class="n">thirdEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">)</span>  <span class="c">% internal</span>

<span class="c">% internalEllVec =</span>
<span class="c">% Array of ellipsoids with dimensionality 1x4</span>

<span class="c">% plot the set (firstEllObj + secEllObj - thirdEllObj)</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">minkpm</span><span class="p">(</span><span class="n">secEllObj</span><span class="p">,</span> <span class="n">thirdEllObj</span><span class="p">,</span> <span class="s">&#39;newfigure&#39;</span><span class="p">,</span> <span class="n">true</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="operations-with-hyperplanes">
<h2>Operations with hyperplanes<a class="headerlink" href="#operations-with-hyperplanes" title="Permalink to this headline">¶</a></h2>
<p>The class hyperplane of the <em>Ellipsoidal Toolbox</em> is used to describe
hyperplanes and halfspaces. The following two commands define one and
the same hyperplane but two different halfspaces:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">firstHypObj</span> <span class="p">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>  <span class="c">% defines halfspace x1 + x2 &lt;= 1</span>
<span class="n">firstHypObj</span> <span class="p">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>  <span class="c">% defines halfspace x1 + x2 &gt;= 1</span>
</pre></div>
</td></tr></table></div>
<p>The following functions and operators are overloaded for the hyperplane
class:</p>
<ul class="simple">
<li>isempty(hypObj) &#8211; checks if hypObj is an empty hyperplane.</li>
<li>display(hypObj) &#8211; displays the details of hyperplane
<img class="math" src="_images/math/a8ccfc826288cb180dd6b82fe5641d1e17995bc5.png" alt="H(c,\gamma)"/>, namely, its normal <img class="math" src="_images/math/65868d23a5bfe5b3b2d819386b19c14fa36af134.png" alt="c"/> and the scalar
<img class="math" src="_images/math/0ebb67342b546ca42a1c634b1ef03c893c4cdedb.png" alt="\gamma"/>.</li>
<li>plot(hypObj) &#8211; plots hyperplane <img class="math" src="_images/math/a8ccfc826288cb180dd6b82fe5641d1e17995bc5.png" alt="H(c,\gamma)"/> if the dimension
of the space in which it is defined is not greater than 3.</li>
<li>firstHypObj == secHypObj &#8211; checks if hyperplanes
<img class="math" src="_images/math/dd608894607e38d2e5c957a0ecbc3d3b92fcb3fc.png" alt="H(c_1,\gamma_1)"/> and <img class="math" src="_images/math/d37385ce263f2dd9adf034a5e763594f0fdc011e.png" alt="H(c_2,\gamma_2)"/> are equal.</li>
<li>firstHypObj = secHypObj &#8211; checks if hyperplanes
<img class="math" src="_images/math/dd608894607e38d2e5c957a0ecbc3d3b92fcb3fc.png" alt="H(c_1,\gamma_1)"/> and <img class="math" src="_images/math/d37385ce263f2dd9adf034a5e763594f0fdc011e.png" alt="H(c_2,\gamma_2)"/> are not equal.</li>
<li>[ , ] &#8211; concatenates the hyperplanes into the horizontal array, e.g. hypVec
= [firstHypObj secHypObj thirdHypObj].</li>
<li>[ ; ] &#8211; concatenates the hyperplanes into the vertical array, e.g. hypMat =
[firstHypObj secHypObj; thirdHypObj fourthHypObj] &#8211; defines
<img class="math" src="_images/math/986ad48db02dcaf802568dee2460269916229fdf.png" alt="2\times 2"/> array of hyperplanes.</li>
<li>-hypObj &#8211; defines hyperplane <img class="math" src="_images/math/4be558bcd2105996f20789c263e00c388c9a5719.png" alt="H(-c,-\gamma)"/>, which is the same
as <img class="math" src="_images/math/a8ccfc826288cb180dd6b82fe5641d1e17995bc5.png" alt="H(c,\gamma)"/> but specifies different halfspace.</li>
</ul>
<p>There are several ways to access the internal data of the hyperplane
object:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">[</span><span class="n">normVec</span><span class="p">,</span> <span class="n">hypScal</span><span class="p">]</span> <span class="p">=</span> <span class="n">firstHypObj</span><span class="p">.</span><span class="n">double</span><span class="p">()</span>

<span class="c">% normVec =</span>
<span class="c">% </span>
<span class="c">%    -1</span>
<span class="c">%    -1</span>
<span class="c">% </span>
<span class="c">% hypScal =</span>
<span class="c">% </span>
<span class="c">%    -1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">firstHypObj</span><span class="p">.</span><span class="n">dimension</span><span class="p">()</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      2</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define two hyperplanes passing through the origin</span>
<span class="n">secHypObj</span> <span class="p">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]);</span> 
<span class="n">firstHypObj</span><span class="p">.</span><span class="n">isparallel</span><span class="p">(</span><span class="n">secHypObj</span><span class="p">)</span> 

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     0</span>
</pre></div>
</td></tr></table></div>
<p>All the functions of <em>Ellipsoidal Toolbox</em> that accept
hyperplane object as parameter, work with single hyperplanes as well as
with hyperplane arrays. One exception is the function parameters that
allows only single hyperplane object.</p>
<p>An array of hyperplanes can be converted to the polytope object of the
Multi-Parametric Toolbox (<a class="reference internal" href="#kvas2004" id="id4">[KVAS2004]</a>, <a class="reference internal" href="chap_install.html#mpthp" id="id5">[MPTHP]</a>), and back:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">%define array of four hyperplanes:</span>
<span class="n">hypVec</span> <span class="p">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">]</span><span class="o">&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">])</span>

<span class="c">% array of hyperplanes: </span>
<span class="c">% size: [1 4]</span>
<span class="c">% </span>
<span class="c">% Element: [1 1]</span>
<span class="c">% Normal:</span>
<span class="c">%      1</span>
<span class="c">%      1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>
<span class="c">% </span>
<span class="c">% </span>
<span class="c">% Element: [1 2]</span>
<span class="c">% Normal:</span>
<span class="c">%     -1</span>
<span class="c">%     -1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>
<span class="c">% </span>
<span class="c">% </span>
<span class="c">% Element: [1 3]</span>
<span class="c">% Normal:</span>
<span class="c">%      1</span>
<span class="c">%     -1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>
<span class="c">% </span>
<span class="c">% </span>
<span class="c">% Element: [1 4]</span>
<span class="c">% Normal:</span>
<span class="c">%     -1</span>
<span class="c">%      1</span>
<span class="c">% </span>
<span class="c">% Shift:</span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="c">% Hyperplane in R^2.</span>

<span class="c">% convert array of hyperplanes to polytope</span>
<span class="n">firstPolObj</span>  <span class="p">=</span> <span class="n">hyperplane2polytope</span><span class="p">(</span><span class="n">hypVec</span><span class="p">);</span>
<span class="c">% covert polytope to array of hyperplanes  </span>
<span class="n">convertedHypVec</span> <span class="p">=</span> <span class="n">polytope2hyperplane</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">);</span>  
<span class="n">convertedHypVec</span> <span class="o">==</span> <span class="n">hypVec</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     1     1     1</span>
</pre></div>
</td></tr></table></div>
<p>Functions hyperplane2polytope and
polytope2hyperplane require the Multi-Parametric Toolbox to be
installed.</p>
<p>We can compute distance from ellipsoids to hyperplanes and polytopes:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% distance from ellipsoid firstEllObj to each of the hyperplanes in hypVec</span>
<span class="n">firstEllObj</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">hypVec</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      -0.5176    0.8966   -2.6841    0.1444</span>

<span class="c">% distance from each of the ellipsoids in ellMat to the polytope</span>
<span class="c">% firstPolObj</span>
<span class="n">ellMat</span><span class="p">.</span><span class="n">distance</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0     0</span>
<span class="c">%      0     0</span>
</pre></div>
</td></tr></table></div>
<p>A negative distance value in the case of ellipsoid and hyperplane means
that the ellipsoid intersects the hyperplane. As we see in this example,
ellipsoid firstEllObj intersects hyperplanes hypVec(1) and hypVec(3) and
has no common points with hypVec(2) and hypVec(4). When distance
function has a polytope as a parameter, it always returns nonnegative
values to be consistent with distance function of the Multi-Parametric
Toolbox. Here, the zero distance values mean that each ellipsoid in
ellMat has nonempty intersection with polytope firstPolObj.</p>
<p>It can be checked if the union or intersection of given ellipsoids
intersects given hyperplanes or polytopes:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">hypVec</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     1     1     1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersect</span><span class="p">(</span><span class="n">hypVec</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0     0     1     0</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">bufEllVec</span> <span class="p">=</span> <span class="p">[</span><span class="n">firstEllObj</span> <span class="n">secEllObj</span> <span class="n">thirdEllObj</span><span class="p">];</span>
<span class="n">bufEllVec</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>The intersection of ellipsoid and hyperplane can be computed exactly:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% compute the intersections of ellipsoids in the second column of ellMat</span>
<span class="c">% with hyperplane firstHypObj: </span>

<span class="n">intersectEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">2</span><span class="p">).</span><span class="n">hpintersection</span><span class="p">(</span><span class="n">firstHypObj</span><span class="p">)</span>

<span class="c">% intersectEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 2x1</span>

<span class="n">intersectEllMat</span><span class="p">.</span><span class="n">isdegenerate</span><span class="p">()</span>  <span class="c">% resulting ellipsoids should lose rank</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Functions intersection_ea and intersection_ia can be used with
hyperplane objects, which in this case define halfspaces and polytope
objects:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% compute external and internal ellipsoidal approximations</span>
<span class="c">% of the intersections of ellipsoids in the first column of ellMat</span>
<span class="c">% with the halfspace x1 - x2 &lt;= 2:</span>

<span class="c">% get external ellipsoids</span>
<span class="n">firstExternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ea</span><span class="p">(</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>  
<span class="c">% firstExternalEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 2x1</span>

<span class="c">% get internal ellipsoids</span>
<span class="n">firstInternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ia</span><span class="p">(</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>  
<span class="c">% firstInternalEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 2x1</span>

<span class="c">% compute external and internal ellipsoidal approximations</span>
<span class="c">% of the intersections of ellipsoids in the first column of ellMat</span>
<span class="c">% with the halfspace x1 - x2 &gt;= 2:</span>

<span class="c">% get external ellipsoids</span>
<span class="n">secExternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ea</span><span class="p">(</span><span class="o">-</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  
<span class="c">% get internal ellipsoids</span>
<span class="n">secInternalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ia</span><span class="p">(</span><span class="o">-</span><span class="n">firstHypObj</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>  
<span class="c">% compute ellipsoidal approximations of the intersection</span>
<span class="c">% of ellipsoid firstEll and polytope firstPol:</span>

<span class="c">% get external ellipsoid</span>
<span class="n">externalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ea</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">);</span>
<span class="c">% get internal ellipsoid</span>
<span class="n">internalEllMat</span> <span class="p">=</span> <span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">intersection_ia</span><span class="p">(</span><span class="n">firstPolObj</span><span class="p">);</span> 
</pre></div>
</td></tr></table></div>
<p>Function isInside can be used to check if a polytope or union of
polytopes is contained in the intersection of given ellipsoids:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% polytope secPolObj is obtained by affine transformation of firstPolObj</span>
<span class="n">secPolObj</span> <span class="p">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">firstPolObj</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>  

<span class="c">% check if the intersection of ellipsoids in the first column of ellMat</span>
<span class="c">% contains the union of polytopes firstPolObj and secPolObj:</span>

<span class="c">% equivalent to: doesIntersectionContain(ellMat(:, 1), firstPolObj | secPolObj)</span>
<span class="n">ellMat</span><span class="p">(:,</span> <span class="mi">1</span><span class="p">).</span><span class="n">doesIntersectionContain</span><span class="p">([</span><span class="n">firstPolObj</span> <span class="n">secPolObj</span><span class="p">])</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% equivalent to: doesIntersectionContain(ellMat(2, 2),...</span>
<span class="c">%                                  firstPolObj &amp; secPolObj)</span>
<span class="n">ellMat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">).</span><span class="n">doesIntersectionContain</span><span class="p">([</span><span class="n">firstPolObj</span> <span class="n">secPolObj</span><span class="p">],</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Functions distance, intersect, intersection_ia and isInside use the CVX
interface (<a class="reference internal" href="chap_install.html#cvxhp" id="id6">[CVXHP]</a>) to the external optimization package. The
default optimization package included in the distribution of the
<em>Ellipsoidal Toolbox</em> is SeDuMi (<a class="reference internal" href="chap_install.html#stur1999" id="id7">[STUR1999]</a>, <a class="reference internal" href="chap_install.html#sdmhp" id="id8">[SDMHP]</a>).</p>
</div>
<div class="section" id="operations-with-ellipsoidal-tubes">
<span id="section-label"></span><h2>Operations with ellipsoidal tubes<a class="headerlink" href="#operations-with-ellipsoidal-tubes" title="Permalink to this headline">¶</a></h2>
<p>There are several classes in <em>Ellipsoidal Toolbox</em> for operations with
ellipsoidal tubes. The class gras.ellapx.smartdb.rels.EllTube is used to
describe ellipsoidal tubes. The class
gras.ellapx.smartdb.rels.EllUnionTube is used to store tubes by the
instant of time:</p>
<div class="math" id="equation-ellUnion">
<span id="union-label"></span><p><span class="eqno">(1)</span><img src="_images/math/53ca07410d079433f63db3afd5fd5ba975724616.png" alt="{\mathcal X}_{U}[t]=\bigcup \limits_{\tau\leqslant t}{\mathcal X}[\tau],"/></p>
</div><p>where <img class="math" src="_images/math/456d10b00ec6c948f7306d194e252da674e291d1.png" alt="{\mathcal X}[\tau]"/> is single ellipsoidal tube. The class
gras.ellapx.smartdb.rels.EllTubeProj is used to describe the projection
of the ellipsoidal tubes onto time dependent subspaces.There are two
types of projection: static and dynamic. Also there is class
gras.ellapx.smartdb.rels.EllUnionTubeStaticProj for description of the
projection on static plane tubes by the instant of time. Next we provide
some examples of the operations with ellipsoidal tubes.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">nPoints</span><span class="p">=</span><span class="mi">5</span><span class="p">;</span>
<span class="n">absTol</span><span class="p">=</span><span class="mf">0.001</span><span class="p">;</span>
<span class="n">relTol</span><span class="p">=</span><span class="mf">0.001</span><span class="p">;</span>
<span class="n">approxSchemaDescr</span><span class="p">=</span><span class="n">char</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">approxSchemaName</span><span class="p">=</span><span class="n">char</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">nDims</span><span class="p">=</span><span class="mi">3</span><span class="p">;</span>
<span class="n">nTubes</span><span class="p">=</span><span class="mi">1</span><span class="p">;</span>
<span class="n">lsGoodDirVec</span><span class="p">=[</span><span class="mi">1</span><span class="p">;</span><span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">];</span>
<span class="n">aMat</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="n">nDims</span><span class="p">,</span><span class="n">nPoints</span><span class="p">);</span>
<span class="n">timeVec</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">nPoints</span><span class="p">;</span>
<span class="n">sTime</span><span class="p">=</span><span class="n">nPoints</span><span class="p">;</span>
<span class="n">approxType</span><span class="p">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">enums</span><span class="p">.</span><span class="n">EApproxType</span><span class="p">.</span><span class="n">Internal</span><span class="p">;</span>
<span class="n">qArrayList</span><span class="p">=</span><span class="nb">repmat</span><span class="p">({</span><span class="nb">repmat</span><span class="p">(</span><span class="nb">diag</span><span class="p">([</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">nPoints</span><span class="p">])},</span><span class="mi">1</span><span class="p">,</span><span class="n">nTubes</span><span class="p">);</span>
<span class="n">ltGoodDirArray</span><span class="p">=</span><span class="nb">repmat</span><span class="p">(</span><span class="n">lsGoodDirVec</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="n">nTubes</span><span class="p">,</span><span class="n">nPoints</span><span class="p">]);</span>
<span class="n">fromMatEllTube</span><span class="p">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">smartdb</span><span class="p">.</span><span class="n">rels</span><span class="p">.</span><span class="n">EllTube</span><span class="p">.</span><span class="n">fromQArrays</span><span class="p">(</span><span class="n">qArrayList</span><span class="p">,</span><span class="c">...</span>
                <span class="n">aMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">,</span><span class="n">ltGoodDirArray</span><span class="p">,</span> <span class="n">sTime</span><span class="p">,</span> <span class="n">approxType</span><span class="p">,</span><span class="c">...</span>
                <span class="n">approxSchemaName</span><span class="p">,</span> <span class="n">approxSchemaDescr</span><span class="p">,</span> <span class="n">absTol</span><span class="p">,</span> <span class="n">relTol</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellArray</span><span class="p">(</span><span class="n">nPoints</span><span class="p">)</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">();</span>
<span class="n">approxType</span><span class="p">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">enums</span><span class="p">.</span><span class="n">EApproxType</span><span class="p">.</span><span class="n">Internal</span><span class="p">;</span>
<span class="n">sTime</span><span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">for</span> <span class="n">iElem</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">nPoints</span>
   <span class="n">ellArray</span><span class="p">(</span><span class="n">iElem</span><span class="p">)</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="c">...</span>
   <span class="n">aMat</span><span class="p">(:,</span><span class="n">iElem</span><span class="p">),</span> <span class="n">qArrayList</span><span class="p">{</span><span class="mi">1</span><span class="p">}(:,:,</span><span class="n">iElem</span><span class="p">));</span> 
<span class="k">end</span>
<span class="n">fromEllArrayEllTube</span> <span class="p">=</span> <span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">smartdb</span><span class="p">.</span><span class="n">rels</span><span class="p">.</span><span class="n">EllTube</span><span class="p">.</span><span class="n">fromEllArray</span><span class="p">(</span><span class="c">...</span>
                <span class="n">ellArray</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">,</span><span class="n">ltGoodDirArray</span><span class="p">,</span> <span class="n">sTime</span><span class="p">,</span> <span class="n">approxType</span><span class="p">,</span><span class="c">...</span>
                <span class="n">approxSchemaName</span><span class="p">,</span><span class="n">approxSchemaDescr</span><span class="p">,</span> <span class="n">absTol</span><span class="p">,</span> <span class="n">relTol</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>We may be
interested in the data about ellipsoidal tube in some particular time
interval, smaller than the one for which the ellipsoidal tube was
computed, say <img class="math" src="_images/math/a362cc9f47273ec127c97021aaafee3be60fc645.png" alt="2\leqslant t\leqslant4"/>. This data can be extracted
by the cut function:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">cutTimeVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
<span class="n">cutEllTube</span> <span class="p">=</span> <span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">cut</span><span class="p">(</span><span class="n">cutTimeVec</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre>function example
   aMat = [0 1; 0 0]; bMat = eye(2);  
   SUBounds = struct();
   SUBounds.center = {&#39;sin(t)&#39;; &#39;cos(t)&#39;};  
   SUBounds.shape = [9 0; 0 2]; 
   sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
   x0EllObj = ell_unitball(2);
   timeVec = [0 10]; 
   dirsMat = [1 0; 0 1]&#39;;  
   rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
   ellTubeObj = rsObj.getEllTubeRel();
   projSpaceList = {[1 0;0 1]};
   projType = gras.ellapx.enums.EProjType.Static;
   statEllTubeProj = ellTubeObj.project(projType,projSpaceList,...
      @fGetProjMat);
   projType = gras.ellapx.enums.EProjType.DynamicAlongGoodCurve;
   dynEllTubeProj=ellTubeObj.project(projType,projSpaceList,...
      @fGetProjMat);
   plObj=smartdb.disp.RelationDataPlotter();
   statEllTubeProj.plot(plObj);
   dynEllTubeProj.plot(plObj);

end

function [projOrthMatArray,projOrthMatTransArray]=fGetProjMat(projMat,...
    timeVec,varargin)
  nTimePoints=length(timeVec);
  projOrthMatArray=repmat(projMat,[1,1,nTimePoints]);
  projOrthMatTransArray=repmat(projMat.&#39;,[1,1,nTimePoints]);
 end
</pre></div>
</td></tr></table></div>
<p id="goto-label">We can compute the projection of the ellipsoidal
tube onto time-dependent subspace.</p>
<div class="figure" id="statdyn-proj">
<a class="reference internal image-reference" href="_images/chapter05_section03_reachTubeStatProjreachTubeDynProj.png"><img alt="reachTubeStatProjreachTubeDynProj" src="_images/chapter05_section03_reachTubeStatProjreachTubeDynProj.png" style="width: 100%;" /></a>
<p class="caption">Figure 11: Static and dynamic projections of the ellipsoidal tube.</p>
</div>
<p>Figure <a href="#statdyn-proj"> 11</a> displays static and dynamic projections.
Also we can see projections of good directions for ellipsoidal tubes.</p>
<p>We can compute tubes by the instant of time using methodfromEllTubes:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre>function example
   aMat = [0 1; 0 0]; bMat = eye(2);  
   SUBounds = struct();
   SUBounds.center = {&#39;sin(t)&#39;; &#39;cos(t)&#39;};  
   SUBounds.shape = [9 0; 0 2]; 
   sys = elltool.linsys.LinSysContinuous(aMat, bMat, SUBounds);
   x0EllObj = ell_unitball(2);
   timeVec = [0 10]; 
   dirsMat = [1 0; 0 1]&#39;;  
   rsObj = elltool.reach.ReachContinuous(sys, x0EllObj, dirsMat, timeVec);
   ellTubeObj = rsObj.getEllTubeRel();
   unionEllTube = ...
    gras.ellapx.smartdb.rels.EllUnionTube.fromEllTubes(ellTubeObj);
   projSpaceList = {[1 0;0 1]};
   projType = gras.ellapx.enums.EProjType.Static;
   statEllTubeProj = unionEllTube.project(projType,projSpaceList,...
      @fGetProjMat);
   plObj=smartdb.disp.RelationDataPlotter();
   statEllTubeProj.plot(plObj);
end

function [projOrthMatArray,projOrthMatTransArray]=fGetProjMat(projMat,...
    timeVec,varargin)
  nTimePoints=length(timeVec);
  projOrthMatArray=repmat(projMat,[1,1,nTimePoints]);
  projOrthMatTransArray=repmat(projMat.&#39;,[1,1,nTimePoints]);
 end
</pre></div>
</td></tr></table></div>
<div class="figure" id="uniontubestatproj">
<a class="reference internal image-reference" href="_images/chapter05_section03_unionTubeStatProj.png"><img alt="unionTubeStatProj" src="_images/chapter05_section03_unionTubeStatProj.png" style="width: 70%;" /></a>
<p class="caption">Figure 12: Ellipsoidal tubes by the instant of time.</p>
</div>
<p><a href="#uniontubestatproj">Figure  12</a> shows projection of ellipsoidal
tubes by the instant of time.</p>
<p>Also we can get initial data from the resulting tube:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">approxType</span><span class="p">=</span><span class="n">gras</span><span class="p">.</span><span class="n">ellapx</span><span class="p">.</span><span class="n">enums</span><span class="p">.</span><span class="n">EApproxType</span><span class="p">.</span><span class="n">Internal</span><span class="p">;</span>
<span class="n">ellArray</span> <span class="p">=</span> <span class="n">fromEllArrayEllTube</span><span class="p">.</span><span class="n">getEllArray</span><span class="p">(</span><span class="n">approxType</span><span class="p">)</span>

<span class="c">% ellArray =</span>
<span class="c">% Array of ellipsoids with dimensionality 5x1</span>
</pre></div>
</td></tr></table></div>
<p>There is a method
to display a content of ellipsoidal tubes.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">aMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span> <span class="n">bMat</span> <span class="p">=</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  
<span class="n">SUBounds</span> <span class="p">=</span> <span class="n">struct</span><span class="p">();</span>
<span class="n">SUBounds</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="p">{</span><span class="s">&#39;sin(t)&#39;</span><span class="p">;</span> <span class="s">&#39;cos(t)&#39;</span><span class="p">};</span>  
<span class="n">SUBounds</span><span class="p">.</span><span class="n">shape</span> <span class="p">=</span> <span class="p">[</span><span class="mi">9</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">];</span> 
<span class="n">sys</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysContinuous</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">);</span>
<span class="n">x0EllObj</span> <span class="p">=</span> <span class="n">ell_unitball</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">timeVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">10</span><span class="p">];</span> 
<span class="k">for</span> <span class="n">iElem</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">5</span>
    <span class="n">dirInitial</span><span class="p">=</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
    <span class="n">dirInitial</span> <span class="p">=</span> <span class="n">dirInitial</span> <span class="o">./</span> <span class="n">norm</span><span class="p">(</span><span class="n">dirInitial</span><span class="p">);</span>
    <span class="n">dirsMat</span><span class="p">(:,</span> <span class="n">iElem</span><span class="p">)</span> <span class="p">=</span> <span class="n">dirInitial</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">rsObj</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachContinuous</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">x0EllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">);</span>
<span class="n">ellTubeObj</span> <span class="p">=</span> <span class="n">rsObj</span><span class="p">.</span><span class="n">getEllTubeRel</span><span class="p">();</span>
<span class="n">ellTubeObj</span><span class="p">.</span><span class="n">dispOnUI</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<div class="figure" id="disppic">
<a class="reference internal image-reference" href="_images/chapter05_section03_dispPic.png"><img alt="disp" src="_images/chapter05_section03_dispPic.png" style="width: 50%;" /></a>
<p class="caption">Figure 13: Content of the ellipsoidal tube.</p>
</div>
<p><a href="#disppic">Figure  13</a>
displays all fields of the ellipsoidal tube.</p>
<p>There are several methods to find the tubes with necessary parameters.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">newEllTube</span> <span class="p">=</span> <span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuplesFilteredBy</span><span class="p">(</span><span class="s">&#39;sTime&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">newEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="c">%</span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
<span class="c">% </span>
<span class="n">newEllTube</span> <span class="p">=</span> <span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuplesFilteredBy</span><span class="p">(</span><span class="s">&#39;sTime&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">newEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="c">%</span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0</span>
<span class="c">% </span>
</pre></div>
</td></tr></table></div>
<p>Also you can use the method display to see the result of the method’s
work.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="c">%</span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
<span class="c">% </span>
<span class="n">fromEllArrayEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="c">%</span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
<span class="c">% </span>
<span class="n">origFromMatEllTube</span><span class="p">=</span><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getCopy</span><span class="p">();</span>
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">unionWith</span><span class="p">(</span><span class="n">fromEllArrayEllTube</span><span class="p">);</span>
<span class="c">%</span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      2</span>
<span class="c">% </span>
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getNTuples</span><span class="p">()</span>
<span class="n">isOk</span><span class="p">=</span><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuples</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">isEqual</span><span class="p">(</span><span class="n">origFromMatEllTube</span><span class="p">)</span>
<span class="c">%</span>
<span class="c">% isOk =</span>
<span class="c">%</span>
<span class="c">%     1</span>

<span class="n">isOk</span><span class="p">=</span><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">getTuples</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">isEqual</span><span class="p">(</span><span class="n">fromEllArrayEllTube</span><span class="p">)</span>

<span class="c">%</span>
<span class="c">% isOk =</span>
<span class="c">%</span>
<span class="c">%     1</span>
</pre></div>
</td></tr></table></div>
<p>We can sort our tubes by certain fields:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">sortBy</span><span class="p">(</span><span class="s">&#39;sTime&#39;</span><span class="p">);</span>
<span class="n">fromMatEllTube</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="reachability">
<h2>Reachability<a class="headerlink" href="#reachability" title="Permalink to this headline">¶</a></h2>
<p>To compute the reach sets of the systems described in chapter 3, we
define few new classes in the <em>Ellipsoidal Toolbox</em>: class
LinSysContinuous for the continuous-time system description, class
LinSysDiscrete for the discrete-time system description and classes
ReachContinuous<img class="math" src="_images/math/d068bdce9fdb2b4d38f0e2e575e55208f06e2b57.png" alt="\backslash"/>ReachDiscrete for the reach set
data. We start by explaining how to define a system using
LinSysContinuous object. Also we can use LinSysFactory class for the
description of this system. Through it’s method create user can get
LinSysContinuous or LinSysDiscrete object. For example, description of
the system</p>
<div class="math">
<p><img src="_images/math/b0af0118992b1d96f54dee81d0a8db0ea5f99e5d.png" alt="\left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 &amp; 1\\
0 &amp; 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right], ~~~ u(t)\in{\mathcal E}(p(t), P)"/></p>
</div><p>with</p>
<div class="math">
<p><img src="_images/math/9c916c53b1e7ef1d576998bd08de918790ec7770.png" alt="p(t) = \left[\begin{array}{c}
\sin(t)\\
\cos(t)\end{array}\right], ~~~ P = \left[\begin{array}{cc}
9 &amp; 0\\
0 &amp; 2\end{array}\right],"/></p>
</div><p>is done by the following sequence of commands:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">aMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">];</span> <span class="n">bMat</span> <span class="p">=</span> <span class="nb">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c">% matrices A and B, B is identity</span>
<span class="n">SUBounds</span> <span class="p">=</span> <span class="n">struct</span><span class="p">();</span>
<span class="c">% center of the ellipsoid depends on t</span>
<span class="n">SUBounds</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="p">{</span><span class="s">&#39;sin(t)&#39;</span><span class="p">;</span> <span class="s">&#39;cos(t)&#39;</span><span class="p">};</span>  
<span class="n">SUBounds</span><span class="p">.</span><span class="n">shape</span> <span class="p">=</span> <span class="p">[</span><span class="mi">9</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">];</span> <span class="c">% shape matrix of the ellipsoid is static</span>
<span class="c">% create linear system object</span>
<span class="n">sys</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysContinuous</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">);</span> 
<span class="c">% is equal to sys = elltool.linsys.LinSysFactory.create(aMat, bMat, SUBounds)</span>
</pre></div>
</td></tr></table></div>
<p>If matrices <img class="math" src="_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> or
<img class="math" src="_images/math/83956e92fcc80dee17fce864543216939a3c9da7.png" alt="B"/> depend on time, say <img class="math" src="_images/math/eec5acb8455659ea4d7044850d9494b15a460658.png" alt="A(t)=\left[\begin{array}{cc}
0 &amp; 1-\cos(2t)\\
-\frac{1}{t} &amp; 0\end{array}\right]"/>, then matrix aMat should be
symbolic:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">atMat</span> <span class="p">=</span> <span class="p">{</span><span class="s">&#39;0&#39;</span> <span class="s">&#39;1 - cos(2*t)&#39;</span><span class="p">;</span> <span class="s">&#39;-1/t&#39;</span> <span class="s">&#39;0&#39;</span><span class="p">};</span>  
<span class="n">sys_t</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysFactory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">atMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>To describe the system with disturbance</p>
<div class="math">
<p><img src="_images/math/41225beced2d5270cd3d2e7ec57ad88e66576a6d.png" alt="\left[\begin{array}{cc}
\dot{x}_1\\
\dot{x}_2\end{array}\right] = \left[\begin{array}{cc}
0 &amp; 1\\
0 &amp; 0\end{array}\right]\left[\begin{array}{c}
x_1\\
x_2\end{array}\right] + \left[\begin{array}{c}
u_1(t)\\
u_2(t)\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]v(t),"/></p>
</div><p>with bounds on control as before, and disturbance being
<img class="math" src="_images/math/0ccc3dfa36dd8c42a867ed936e732256a548090c.png" alt="-1\leqslant v(t)\leqslant1"/>, we type:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">gMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>  <span class="c">% matrix G</span>
<span class="n">vEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c">% disturbance bounds: unit ball in R</span>
<span class="n">sys_d</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysContinuous</span><span class="p">(</span><span class="n">aMat</span><span class="p">,</span> <span class="n">bMat</span><span class="p">,</span> <span class="n">SUBounds</span><span class="p">,</span><span class="c">...</span>
    <span class="n">gMat</span><span class="p">,</span> <span class="n">vEllObj</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Control and disturbance
bounds SUBounds and vEllObj can have different types. If the bound is
constant, it should be described by ellipsoid object. If the bound
depends on time, then it is represented by a structure with fields
center and shape, one or both of which are symbolic. In system sys, the
control bound SUBounds is defined as such a structure. Finally, if the
control or disturbance is known and fixed, it should be defined as a
vector, of type double if constant, or symbolic, if it depends on time.</p>
<p>To declare a discrete-time system</p>
<div class="math">
<p><img src="_images/math/da2c3d0815dc2cf770cf3c1c7aa0b91fe0da37ab.png" alt="\left[\begin{array}{c}
x_1[k+1]\\
x_2[k+1]\end{array}\right] = \left[\begin{array}{cc}
0 &amp; 1\\
-1 &amp; -0.5\end{array}\right]\left[\begin{array}{c}
x_1[k]\\
x_2[k]\end{array}\right] + \left[\begin{array}{c}
0\\
1\end{array}\right]u[k], ~~~ -1\leqslant u[k]\leqslant1,"/></p>
</div><p>we use LinSysDiscrete constructor:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">adMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">];</span> <span class="n">bdMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">];</span>  <span class="c">% matrices A and B</span>
<span class="n">udBoundsEllObj</span>  <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c">% control bounds: unit ball in R</span>
<span class="c">% discrete-time system</span>
<span class="n">dtsys</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">linsys</span><span class="p">.</span><span class="n">LinSysDiscrete</span><span class="p">(</span><span class="n">adMat</span><span class="p">,</span> <span class="n">bdMat</span><span class="p">,</span> <span class="n">udBoundsEllObj</span><span class="p">);</span> 
<span class="c">% is equal to dtsys = elltool.linsys.LinSysFactory.create(adMat, bdMat,...</span>
<span class="c">%         udBoundsEllObj,...[], [], [], [], &#39;d&#39;); </span>
</pre></div>
</td></tr></table></div>
<p>Once the LinSysDiscrete object is
created, we need to specify the set of initial conditions, the time
interval and values of the direction vector, for which the reach set
approximations must be computed:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">x0EllObj</span> <span class="p">=</span> <span class="n">ell_unitball</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>  <span class="c">% set of initial conditions</span>
<span class="n">timeVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">10</span><span class="p">];</span>  <span class="c">% time interval</span>
<span class="n">dirsMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span><span class="o">&#39;</span><span class="p">;</span>  <span class="c">% columns of L specify the directions</span>
</pre></div>
</td></tr></table></div>
<p>The reach set approximation is computed
by calling the constructor of the ReachContinuous object:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% reach set of continuos-time system</span>
<span class="n">firstRsObj</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachContinuous</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">x0EllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">);</span> 
</pre></div>
</td></tr></table></div>
<p>At this point,
variable firstRsObj contains the reach set approximations for the
specified continuous-time system, time interval and set of initial
conditions computed for given directions. Both external and internal
approximations are computed. The reach set approximation data can be
extracted in the form of arrays of ellipsoids:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">externallEllMat</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_ea</span><span class="p">()</span>  <span class="c">% external approximating ellipsoids</span>

<span class="c">% externallEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 2x100</span>

<span class="c">% internal approximating ellipsoids</span>
<span class="p">[</span><span class="n">internalEllMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">]</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_ia</span><span class="p">();</span>  
</pre></div>
</td></tr></table></div>
<p>Ellipsoidal arrays externallEllMat and internalEllMat have <img class="math" src="_images/math/51a8d7e791ab9e463af82a4075edb04ef8028dcf.png" alt="4"/>
rows because we computed the reach set approximations for <img class="math" src="_images/math/51a8d7e791ab9e463af82a4075edb04ef8028dcf.png" alt="4"/>
directions. Each row of ellipsoids corresponds to one direction. The
number of columns in externallEllMat and internalEllMat is defined by
the nTimeGridPoints parameter, which is available from
elltool.conf.Properties static class (see chapter 6 for details). It
represents the number of time values in our time interval, at which the
approximations are evaluated. These time values are returned in the
optinal output parameter, array timeVec, whose length is the same as the
number of columns in externallEllMat and internalEllMat. Intersection of
ellipsoids in a particular column of externallEllMat gives external
ellipsoidal approximation of the reach set at corresponding time.
Internal ellipsoidal approximation of this set at this time is given by
the union of ellipsoids in the same column of internalEllMat.</p>
<p>We may be interested in the reachability data of our system in some
particular time interval, smaller than the one for which the reach set
was computed, say <img class="math" src="_images/math/be49058197a821742ddab708eeb2ddb3b8700b6c.png" alt="3\leqslant t\leqslant5"/>. This data can be
extracted and returned in the form of ReachContinuous object by the cut
function:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">cutObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">cut</span><span class="p">([</span><span class="mi">3</span> <span class="mi">5</span><span class="p">]);</span>  <span class="c">% reach set for the time interval [3, 5]</span>
</pre></div>
</td></tr></table></div>
<p>To obtain a snap shot of the reach set at given time, the same function
cut is used:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">cutObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>  <span class="c">% reach set at time t = 5</span>
</pre></div>
</td></tr></table></div>
<p>It can be checked if the external or internal reach set
approximation intersects with given ellipsoids, hyperplanes or
polytopes:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ellObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="o">-</span><span class="mi">17</span><span class="p">;</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">]);</span>  <span class="c">% define ellipsoid</span>
<span class="c">% define 4 hyperplanes</span>
<span class="n">hypVec</span> <span class="p">=</span> <span class="n">hyperplane</span><span class="p">([</span><span class="mi">1</span> <span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">1</span><span class="p">]</span><span class="o">&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]);</span> 
<span class="n">polObj</span> <span class="p">=</span> <span class="n">hyperplane2polytope</span><span class="p">(</span><span class="n">hypVec</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">10</span><span class="p">];</span>  <span class="c">% define polytope</span>
<span class="c">% check if ellipsoid ell intersects with external approximation:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellObj</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% check if ellipsoid ellObj intersects with internal approximation:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellObj</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>

<span class="c">% </span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% check if hyperplanes in hypVec intersect with internal approximation:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">hypVec</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1     1     1     1</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% check if polytope polObj intersects with external approximation:</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">polObj</span><span class="p">)</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      0</span>
</pre></div>
</td></tr></table></div>
<p>If a given set intersects with the internal approximation of the reach
set, then this set intersects with the actual reach set. If the given
set does not intersect with external approximation, this set does not
intersect the actual reach set. There are situations, however, when the
given set intersects with the external approximation but does not
intersect with the internal one. In our example above, ellipsoid ellObj
is such a case: the quality of the approximation does not allow us to
determine whether or not ellObj intersects with the actual reach set. To
improve the quality of approximation, refine function should be used:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% define new directions, in this case one, but could be more</span>
<span class="n">newDirsMat</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="c">% compute approximations for the new directions</span>
<span class="n">firstRsObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="n">newDirsMat</span><span class="p">);</span>
<span class="c">% snap shot of the reach set at time t = 5</span>
<span class="n">cutObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">cut</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="c">% check if ellObj intersects the internal approximation</span>
<span class="n">cutObj</span><span class="p">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">ellObj</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span>  

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%      1</span>
</pre></div>
</td></tr></table></div>
<p>Now we are sure that ellipsoid ellObj intersects with the actual reach
set. However, to use the refine function, the reach set object must
contain all calculated data, otherwise, an error is returned.</p>
<p>Having a reach set object resulting from the ReachContinuous, cut or
refine operations, we can obtain the trajectory of the center of the
reach set and the good curves along which the actual reach set is
touched by its ellipsoidal approximations:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">[</span><span class="n">ctrMat</span><span class="p">,</span> <span class="n">ttVec</span><span class="p">]</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_center</span><span class="p">();</span> <span class="c">% trajectory of the center</span>
<span class="n">gcCVec</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">get_goodcurves</span><span class="p">()</span>  <span class="c">% get good curves</span>

<span class="c">% gcCVec =</span>
<span class="c">% [2x100 double] [2x100 double] [2x100 double] </span>
</pre></div>
</td></tr></table></div>
<p>Variable ctrMat here is a matrix whose columns are the points ofthe
reach set center trajectory evaluated at time values returned in the
array ttVec. Variable gcCMat contains <img class="math" src="_images/math/51a8d7e791ab9e463af82a4075edb04ef8028dcf.png" alt="4"/> matrices each of which
corresponds to a good curve (columns of such matrix are points of the
good curve evaluated at time values in ttVec). The analytic expression
for the control driving the system along a good curve is given by
<a class="reference internal" href="chap_reach.html#uct-label"><em>formula</em></a>.</p>
<p>We computed the reach set up to time <img class="math" src="_images/math/1984d1a61055b785e860b105bc14f1f2221f3476.png" alt="10"/>. It is possible to
continue the reach set computation for a longer time horizon using the
reach set data at time <img class="math" src="_images/math/1984d1a61055b785e860b105bc14f1f2221f3476.png" alt="10"/> as initial condition. It is also
possible that the dynamics and inputs of the system change at certain
time, and from that point on the system evolves according to the new
system of differential equations. For example, starting at time
<img class="math" src="_images/math/1984d1a61055b785e860b105bc14f1f2221f3476.png" alt="10"/>, our reach set may evolve in time according to the
time-variant system sys_t defined above. Switched systems are a special
case of this situation. To compute the further evolution in time of the
existing reach set, function evolve should be used:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% reach set from time 10 to 14 with the same dynamics</span>
<span class="n">secRsObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span> 
<span class="c">% reach set from time 10 to 12 with new dynamics</span>
<span class="n">secRsObj</span> <span class="p">=</span> <span class="n">firstRsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">sys_t</span><span class="p">);</span>  

<span class="c">% not only the dynamics, but the inputs can change as well,</span>
<span class="c">% from time 12 to 13 disturbance is added to the system:</span>

<span class="c">% sys_d - system with disturbance defined above</span>
<span class="n">thirdRsObj</span> <span class="p">=</span> <span class="n">secRsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">sys_d</span><span class="p">);</span>  
</pre></div>
</td></tr></table></div>
<p>Function evolve can
be viewed as an implementation of the semigroup property.</p>
<p>To compute the backward reach set for some specified target set, we
declare the time interval so that the terminating time comes first:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">% target set in the form of ellipsoid</span>
<span class="n">yEllObj</span> <span class="p">=</span> <span class="n">ellipsoid</span><span class="p">([</span><span class="mi">8</span><span class="p">;</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">1</span><span class="p">;</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]);</span>
<span class="n">tbTimeVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span> <span class="mi">5</span><span class="p">];</span>  <span class="c">% backward time interval</span>
<span class="c">% backward reach set</span>
<span class="n">firstBrsObj</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachContinuous</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="n">yEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span><span class="c">...</span>
        <span class="n">tbTimeVec</span><span class="p">);</span>  
<span class="n">firstBrsObj</span> <span class="p">=</span> <span class="n">firstBrsObj</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="n">newDirsMat</span><span class="p">);</span>  <span class="c">% refine the approximation</span>
<span class="c">% further evolution in backward time from 5 to 0; </span>
<span class="n">secBrsObj</span> <span class="p">=</span> <span class="n">firstBrsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
</pre></div>
</td></tr></table></div>
<p>Reach set and backward reach set computation for discrete-time systems
and manipulations with the resulting reach set object are performed
using the same functions as for continuous-time systems:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">timeVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">100</span><span class="p">];</span>  <span class="c">% represents 100 time steps from 1 to 100</span>
<span class="c">% reach set for 100 time steps</span>
<span class="n">secDtrsObj</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachDiscrete</span><span class="p">(</span><span class="n">dtsys</span><span class="p">,</span> <span class="n">x0EllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">);</span> 
<span class="n">secDtrsObj</span> <span class="p">=</span> <span class="n">secDtrsObj</span><span class="p">.</span><span class="n">evolve</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>  <span class="c">% compute next 100 time steps</span>

<span class="n">tbTimeVec</span> <span class="p">=</span> <span class="p">[</span><span class="mi">50</span> <span class="mi">0</span><span class="p">];</span>  <span class="c">% backward time interval</span>
<span class="c">% backward reach set</span>
<span class="n">dtbrsObj</span> <span class="p">=</span> <span class="n">elltool</span><span class="p">.</span><span class="n">reach</span><span class="p">.</span><span class="n">ReachDiscrete</span><span class="p">(</span><span class="n">dtsys</span><span class="p">,</span> <span class="n">yEllObj</span><span class="p">,</span> <span class="n">dirsMat</span><span class="p">,</span> <span class="n">tbTimeVec</span><span class="p">);</span>  
<span class="n">dtbrsObj</span> <span class="p">=</span> <span class="n">dtbrsObj</span><span class="p">.</span><span class="n">refine</span><span class="p">(</span><span class="n">newDirsMat</span><span class="p">);</span>  <span class="c">% refine the approximation</span>
<span class="c">% get external approximating ellipsoids and time values</span>
<span class="p">[</span><span class="n">externallEllMat</span><span class="p">,</span> <span class="n">timeVec</span><span class="p">]</span> <span class="p">=</span> <span class="n">dtbrsObj</span><span class="p">.</span><span class="n">get_ea</span><span class="p">();</span>
<span class="c">% get internal approximating ellipsoids</span>
<span class="n">internalEllMat</span> <span class="p">=</span> <span class="n">dtbrsObj</span><span class="p">.</span><span class="n">get_ia</span><span class="p">()</span>

<span class="c">% internalEllMat =</span>
<span class="c">% Array of ellipsoids with dimensionality 3x51</span>
</pre></div>
</td></tr></table></div>
<p>Number of columns in the ellipsoidal arrays externalEllMat and
internalEllMat is <img class="math" src="_images/math/ea971c407f445a917182eceed585a0e4b620d5ff.png" alt="51"/> because the backward reach set is computed
for <img class="math" src="_images/math/51b8e5689d1f0c700e2ab941078f6dcd9f8da2c4.png" alt="50"/> time steps, and the first column of these arrays contains
<img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/> ellipsoids yEllObj - the terminating condition.</p>
<p>When dealing with discrete-time systems, all functions that accept time
or time interval as an input parameter, round the time values and treat
them as integers.</p>
</div>
<div class="section" id="properties">
<h2>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h2>
<p>Functions of the <em>Ellipsoidal Toolbox</em> can be called with user-specified
values of certain global parameters. System of the parameters are
configured using xml files, which available from a set of command-line
utilities:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">elltool</span><span class="p">.</span><span class="n">setconf</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>Here we list system parameters available from the ’default’
configuration:</p>
<ol class="arabic simple">
<li>version = ’1.4dev’ - current version of <em>ET</em>.</li>
<li>isVerbose = false - makes all the calls to <em>ET</em> routines silent, and
no information except errors is displayed.</li>
<li>absTol = 1e-7 - absolute tolerance.</li>
<li>relTol = 1e-5 - relative tolerance.</li>
<li>nTimeGridPoints = 200 - density of the time grid for the continuous
time reach set computation. This parameter directly affects the
number of ellipsoids to be stored in the
ReachContinuous<img class="math" src="_images/math/d068bdce9fdb2b4d38f0e2e575e55208f06e2b57.png" alt="\backslash"/>ReachDiscrete object.</li>
<li>ODESolverName = ode45 - specifies the ODE solver for continuous time
reach set computation.</li>
<li>isODENormControl = ’on’ - switches on and off the norm control in the
ODE solver. When turned on, it slows down the computation, but
improves the accuracy.</li>
<li>isEnabledOdeSolverOptions = false - when set to false, calls the ODE
solver without any additional options like norm control. It makes the
computation faster but less accurate. Otherwise, it is assumed to be
true, and only in this case the previous option makes a difference.</li>
<li>nPlot2dPoints = 200 - the number of points used to plot a 2D
ellipsoid. This parameter also affects the quality of 2D reach tube
and reach set plots.</li>
<li>nPlot3dPoints = 200 - the number of points used to plot a 3D
ellipsoid. This parameter also affects the quality of 3D reach set
plots.</li>
</ol>
<p>Once the configuration is loaded, the system parameters are available
through elltool.conf.Properties. elltool.conf.Properties is a static
class, providing emulation of static properties for toolbox. It has two
function types: setters and getters. Using getters we obtain system
parameters.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">elltool</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">Properties</span><span class="p">.</span><span class="n">getAbsTol</span><span class="p">()</span>
<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%    1.0000e-07</span>

<span class="n">elltool</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">Properties</span><span class="p">.</span><span class="n">getNPlot2dPoints</span><span class="p">()</span>

<span class="c">% ans =</span>
<span class="c">% </span>
<span class="c">%    200</span>
</pre></div>
</td></tr></table></div>
<p>Some of the parameters can be changed in run-time via
setters.</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">elltool</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">Properties</span><span class="p">.</span><span class="n">setNTimeGridPoints</span><span class="p">(</span><span class="mi">250</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p><em>Ellipsoidal Toolbox</em> has several plotting routines:</p>
<ul class="simple">
<li>ellipsoid/plot - plots one or more ellipsoids, or arrays of
ellipsoids, defined in <img class="math" src="_images/math/fdbe9b4214da88518dfbb7be23a10bc0fc6eedb8.png" alt="{\bf R}"/>, <img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> or
<img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/>.</li>
<li>ellipsoid/minksum - plots geometric sum of finite number of
ellipsoids defined in <img class="math" src="_images/math/fdbe9b4214da88518dfbb7be23a10bc0fc6eedb8.png" alt="{\bf R}"/>, <img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> or
<img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/>.</li>
<li>ellipsoid/minkdiff - plots geometric difference (if it is not an
empty set) of two ellipsoids defined in <img class="math" src="_images/math/fdbe9b4214da88518dfbb7be23a10bc0fc6eedb8.png" alt="{\bf R}"/>,
<img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> or <img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/>.</li>
<li>ellipsoid/minkmp - plots geometric (Minkowski) sum of the geometric
difference of two ellipsoids and the geometric sum of <img class="math" src="_images/math/413f8a8e40062a9090d9d50b88bc7b551b314c26.png" alt="n"/>
ellipsoids defined in <img class="math" src="_images/math/fdbe9b4214da88518dfbb7be23a10bc0fc6eedb8.png" alt="{\bf R}"/>, <img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> or
<img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/>.</li>
<li>ellipsoid/minkpm - plots geometric (Minkowski) difference of the
geometric sum of ellipsoids and a single ellipsoid defined in
<img class="math" src="_images/math/fdbe9b4214da88518dfbb7be23a10bc0fc6eedb8.png" alt="{\bf R}"/>, <img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> or <img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/>.</li>
<li>hyperplane/plot - plots one or more hyperplanes, or arrays of
hyperplanes, defined in <img class="math" src="_images/math/0798dced39715ef937fb976226ba2ae17f50367e.png" alt="{\bf R}^2"/> or <img class="math" src="_images/math/8bbda0690471f568c090c4d283e9bb5a511fa55a.png" alt="{\bf R}^3"/>.</li>
<li>reach/plot_ea - plots external approximation of the reach set whose
dimension is <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/> or <img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/>.</li>
<li>reach/plot_ia - plots internal approximation of the reach set whose
dimension is <img class="math" src="_images/math/15c663954a3e059d1f876bc8a4621de376038c96.png" alt="2"/> or <img class="math" src="_images/math/b9b358d9bbdf54c3d9aef7554638822d996c21ea.png" alt="3"/>.</li>
</ul>
<p>All these functions allow the user to specify the color of the plotted
objects, line width for 1D and 2D plots, and transparency level of the
3D objects. Hyperplanes are displayed as line segments in 2D and square
facets in 3D. In the hyperplane/plot method it is possible to specify
the center of the line segment or facet and its size.</p>
<p>Ellipsoids of dimensions higher than three must be projected onto a two-
or three-dimensional subspace before being plotted. This is done by
means of projection function:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre>% create two 4-dimensional ellipsoids:
firstEllObj = ellipsoid([14 -4 2 -5; -4 6 0 1; 2 0 6 -1; -5 1 -1 2]);
secEllObj = firstEllObj.getInv();

% specify 3-dimensional subspace by its basis:

% columns of basisMat must be orthogonal
basisMat = [1 0 0 0; 0 0 1 0; 0 1 0 1].&#39;; 

% get 3-dimensional projections of firstEllObj and secEllObj:
bufEllVec = [firstEllObj secEllObj];
% array ellVec contains projections of firstEllObj and secEllObj
ellVec = bufEllVec.projection(basisMat)  

% ellVec =
% Array of ellipsoids with dimensionality 1x2

ellVec.plot();  % plot ellipsoids in ellVec
</pre></div>
</td></tr></table></div>
<p>Since the operation of projection is linear, the projection of the
geometric sum of ellipsoids equals the geometric sum of the projected
ellipsoids. The same is true for the geometric difference of two
ellipsoids.</p>
<p>Function projection exists also for the
ReachContinuous<img class="math" src="_images/math/d068bdce9fdb2b4d38f0e2e575e55208f06e2b57.png" alt="\backslash"/>ReachDiscrete objects:</p>
<div class="highlight-matlab"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre>aMat = [0 1 0 0; -1 0 1 0; 0 0 0 1; 0 0 -1 0];
bMat = [0; 0; 0; 1];
uBoundsEllObj = ellipsoid(1);
% 4-dimensional system
sys = elltool.linsys.LinSysFactory.create(aMat, bMat, uBoundsEllObj);
dirsMat  = [1 1 0 1; 0 -1 1 0; -1 1 1 1; 0 0 -1 1].&#39;; % matrix of directions
% reach set from time 0 to 5
rsObj = elltool.reach.ReachContinuous(sys, ell_unitball(4), dirsMat,...
    [0 5], &#39;isRegEnabled&#39;, true, &#39;isJustCheck&#39;, false, &#39;regTol&#39;, 1e-4);
basisMat = [1 0 0 1; 0 1 1 0].&#39;;  % basis of 2-dimensional subspace

% project reach set rs onto basis basisMat
psObj = rsObj.projection(basisMat);
psObj.plotByEa();  % plot external approximation
hold on;
psObj.plotByIa();  % plot internal approximation
</pre></div>
</td></tr></table></div>
<p>The quality of the ellipsoid and reach set plots is controlled by the
parameters nPlot2dPoints and nPlot3dPoints, which are available from
getters of ellipsoid class.</p>
<h2>References</h2><table class="docutils citation" frame="void" id="stanhp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[STANHP]</a></td><td>Stanley Chan Article Homepage. <a class="reference external" href="http://videoprocessing.ucsd.edu/~stanleychan/publication/unpublished/Ellipse.pdf">http://videoprocessing.ucsd.edu/~stanleychan/publication/unpublished/Ellipse.pdf</a>.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="lin2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[LIN2002]</a></td><td>Lin A., and S. Han. 2002. On the Distance Between Two Ellipsoids.
<em>SIAM Journal on Optimization</em> 13 (1): 298–308.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="kvas2004" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[KVAS2004]</a></td><td>M. Kvasnica, P. Grieder, M. Baotic, and M. Morari. Multi-Parametric Toolbox (MPT). In
R. Alur and G. J. Pappas, editors, <em>Hybrid Systems: Computation and Control</em>, volume 2993 of
<em>Lecture Notes in Computer Science</em>, pages 448–462. Springer, 2004.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="main_manual.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementation</a><ul>
<li><a class="reference internal" href="#operations-with-ellipsoids">Operations with ellipsoids</a></li>
<li><a class="reference internal" href="#operations-with-hyperplanes">Operations with hyperplanes</a></li>
<li><a class="reference internal" href="#operations-with-ellipsoidal-tubes">Operations with ellipsoidal tubes</a></li>
<li><a class="reference internal" href="#reachability">Reachability</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="chap_install.html"
                        title="previous chapter">Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="chap_examples.html"
                        title="next chapter">Examples</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/chap_implement.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="chap_examples.html" title="Examples"
             >next</a> |</li>
        <li class="right" >
          <a href="chap_install.html" title="Installation"
             >previous</a> |</li>
        <li><a href="main_manual.html">Ellipsoidal Toolbox 2.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2014 Moscow State University, Faculty of Computational Mathematics and Computer Science, System Analysis Department, 2004-2011 The Regents of the University of California.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>