Before choosing a method and a tool for reachability analysis, one should answer the following questions to specify the requirements.
\begin{enumerate}
\item Do you really need to compute reach sets, or it is enough to perform
a safety check, e.g., to ensure that trajectories of a system
never enter a given target set, or never leave a given initial set?
Barrier functions or invariant sets, described in the end of this
section, may be sufficient for safety checking.

\item Do you need to compute reach sets exactly, or will approximations, external
and internal, be enough?
Except for very specific classes of systems, exact reach set computation
is not possible, and approximation techniques are required.
Unless a reach set has simple structure, its exact representation is
possible only for low state space dimension.
Hence, the next question.

\item What is the dimension of your system?
The higher is the system dimension, the rougher is the reach set approximation.
\end{enumerate}
Another important quality of a computational method for reach sets is
the preservation of the semigroup property.
It is highly desirable that the semigroup property is maintained by the
algorithm as well as by its software implementation.











\subsection{Level set method}\label{subsec_levelset}
We start the overview of computational techniques for reach sets with the
\emph{level set} method as it points out the essence of the
reachability problem, and 
has been used in practice for specific nonlinear systems.
The idea is to solve the Hamilton-Jacobi-Bellman-Isaacs (HJBI) partial
differential equation
\[ \frac{\partial V}{\partial t} +
\max_u\left\langle\frac{\partial V}{\partial x}, f(t, x, u)\right\rangle = 0,\]
with initial condition
\[ V(t_0, x) = {\bf dist}(x, \XX_0), \]
for $t>t_0$, and then to find the reach set $\XX(t, t_0, \XX_0)$ as the subzero level
set of the solution $V(t, x)$,
\[ \XX(t, t_0, \XX_0) = \left\{x\in{\bf R}^n ~|~ V(t, x) \leq 0\right\} .\]
This \emph{forward} HJBI equation was introduced in \cite{leitmann82}.
For systems with disturbances, the HJBI equation is
\[ \frac{\partial \underline{V}}{\partial t} +
\min_v\max_u\left\langle\frac{\partial \underline{V}}{\partial x},
f(t, x, u, v)\right\rangle = 0 \]
in the maxmin case, and
\[ \frac{\partial \overline{V}}{\partial t} +
\max_u\min_v\left\langle\frac{\partial \overline{V}}{\partial x},
f(t, x, u, v)\right\rangle = 0 \]
in the minmax case.

For backward reach sets, the HJBI equation is solved in backward time,
\[ \frac{\partial V_b}{\partial t} +
\min_u\left\langle\frac{\partial V_b}{\partial x}, f(t, x, u)\right\rangle ,\]
with boundary condition
\[ V_b(t_1, x) = {\bf dist}(x, \YY_1) ,\]
for $t<t_1$.
For systems with disturbances, the backward HJBI is
\[ \frac{\partial \underline{V}_b}{\partial t} +
\max_v\min_u\left\langle\frac{\partial \underline{V}_b}{\partial x},
f(t, x, u, v)\right\rangle = 0 \]
in the maxmin case, and
\[ \frac{\partial \overline{V}_b}{\partial t} +
\min_u\max_v\left\langle\frac{\partial \overline{V}_b}{\partial x},
f(t, x, u, v)\right\rangle = 0 \]
in the minmax case.

Computation of reach sets as level sets of HJBI solutions was introduced
in \cite{kurvalyi, kurzhanski98, kurvar01} with special emphasis on linear
systems.
In \cite{mitchell} the authors applied the level set method to reachability
analysis of hybrid systems.
The level set method is implemented in the \emph{Level Set Toolbox}
\cite{levelset}, which
uses  numerical algorithms for time-dependent HJBI
equations and structured grids.
Work is under way to implement fast marching methods.  These are effective
numerical schemes that work for time-independent HJBI, but whose major
restriction is the need for the control to have the same dimension as the state.
Level Set Toolbox tries to compute the surface of the reach set exactly
with accuracy dependent on the choice of the grid.
This, plus the exponential growth of computational complexity with the
system dimension makes the level set method impractical for systems
with dimension larger than three.

Level Set Toolbox deals with continuous-time systems.
To use the level set method in discrete-time case, one has to solve
Bellman equation under the condition that the right hand side of system
\ref{dtds1} is invertible,
\[ V(t+1, x) = \min_u(V(t, f^{-1}(t, x, u))) \]
with initial condition
\[ V(t_0, x) = {\bf dist}(x, \XX_0) \]
for $t>t_0$, and then find the forward reach set
\[ \XX(t, t_0, \XX_0) = \{x\in{\bf R}^n ~|~ V(t, x)\leq0\}. \]
The backward reach set is the subzero level set of the value function $V_b(t, x)$
obtained from the backward Bellman equation,
\[ V_b(t-1, x) = \min_u(V_b(t, f(t-1, x, u))), \]
with boundary condition
\[ V_b(t_1, x) = {\bf dist}(x, \YY_1), \]
for $t<t_1$.
For systems with disturbances $\min_u$ is substituted with $\max_v\min_u$
or with $\min_u\max_v$ in both forward and backward Bellman equations,
and the functions $f$ and $f^{-1}$, whose existence is required, depend on
an additional parameter $v$.

Even though in discrete-time case the computation of the value function
does not involve solving a PDE, it is still very burdensome, especially
for nonlinear systems whose reach sets are nonconvex.
Computing the distance function for such sets and minimizing it over $u$ may be
difficult.
Even more difficult it is to search for maxmin or minmax.

The conclusion is that although the level set method handles nonlinear
systems, it is computationally costly,
and the need to maintain a grid with the value function values, which
must be rather dense to ensure proper accuracy, makes it practical
only for low dimensional dynamical systems.

















\subsection{Quantifier elimination}\label{subsec_quantifiers}
For some classes of systems the reach sets can be computed symbolically
using \emph{quantifier elimination}.
Quantifier elimination is the removal of all quantifiers (the universal
quantifier $\forall$ and the existential quantifier $\exists$)
from a quantified system.
Each quantified formula is substituted with quantifier-free expression
with operations $+$, $\times$, $=$ and $<$.
For example,
consider the discrete-time linear system \ref{dtds1}, (\ref{linearrhs}),
with $A(t)=A=\left[\begin{array}{cc}
0 & 1\\
0 & 0\end{array}\right]$ and $B(t)=B=\left[\begin{array}{c}
0\\
1\end{array}\right]$.
For initial conditions $x_0\in\{x\in {\bf R}^2 ~|~ \|x\|_{\infty} \leq 1\}$
and controls $u(t)\in\{u\in {\bf R} ~|~ -1\leq u\leq1\}$,
the reach set for  $t\geq0$ is given by the quantified formula
\begin{eqnarray*}
\Big{\{} x\in{\bf R}^2 ~|~ \exists x_0, ~~ \exists t\geq 0, ~~
\exists u(\tau), ~ 0\leq\tau<t: \\
x = A^tx_0+\sum_{\tau=0}^{t-1}A^{t-\tau-1}Bu(\tau) \Big{\}},
\end{eqnarray*}
which is equivalent to the quantifier-free expression
\[ -1\leq[1 ~~ 0]x\leq1 ~ \wedge ~ -1\leq[0 ~~ 1]x\leq1. \]
It is proved in \cite{yovine01} that if $A$ is constant and nilpotent or
is diagonalizable with rational real or purely imaginary eigenvalues,
the quantifier elimination package returns a quantifier free formula
describing the reach set.
This class of systems is evidently rather limited.

Requiem \cite{requiem} is a Mathematica notebook which, given a linear system,
the set of initial conditions and control bounds, symbolically computes
the exact reach set, using the experimental quantifier elimination package.
















\subsection{Polytope method}\label{subsec_polytopes}
\bd[Hyperplane]
The hyperplane $H(c,\gamma)$ in ${\bf R}^n$ is the set
\[ H = \{x\in{\bf R}^n ~|~ \langle c, x\rangle = \gamma\} ,\]
with fixed $c\in{\bf R}^n$ and $\gamma\in{\bf R}$.
\label{def_hyperplane}
\ed
A hyperplane defines two (closed) {\it halfspaces},
\[ {\bf S}_1 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \leq \gamma\}, \]
and
\[ {\bf S}_2 = \{x\in{\bf R}^n ~|~ \langle c, x\rangle \geq \gamma\}. \]
\bd[Polytope]
The polytope $P(C,g)$ is the  intersection of a finite number
of closed halfspaces:
\[ P = \{x\in{\bf R}^n ~|~ Cx\leq g\}, \]
with fixed $C=[c_1 ~ \cdots ~ c_m]^T\in{\bf R}^{m\times n}$ and
$g=[\gamma_1 ~ \cdots ~ \gamma_m]^T\in{\bf R}^m$.
\label{def_polytope}
\ed
For linear discrete-time systems \ref{dtds2}, (\ref{linearrhsdist}),
with $\XX_0$, $\UU(t)$ and $\VV(t)$, $t\geq t_0$, being polytopes in
${\bf R}^n$, ${\bf R}^m$ and ${\bf R}^d$ respectively, the reach sets
$\OXCL(t, t_0, \XX_0)$ and $\UXCL(t, t_0, \XX_0)$ are also polytopes,
because the polytope structure is closed under the operations of affine
transformation, geometric sum and geometric difference.  (For continuous-time systems
the reach sets need not be polytopes.)
Starting with initial condition
\[ \OXCL(t_0, t_0, \XX_0) = \UXCL(t_0, t_0, \XX_0) = \XX_0, \]
for time step $t>t_0$ these reach sets are computed \emph{exactly} as
\[ \OXCL(t, t_0, \XX_0) = A(t-1)\XX(t-1, t_0, \XX_0) \oplus
B(t-1)\UU(t-1) \dot{-} G(t-1)\VV(t-1), \]
and
\[ \UXCL(t, t_0, \XX_0) = A(t-1)\XX(t-1, t_0, \XX_0) \dot{-}
G(t-1)\VV(t-1) \oplus B(t-1)\UU(t-1). \]
A similar procedure works for backward reach sets if the matrices $A(t)$, $t<t_1$
are nondegenerate.

As we see, the polytope method consists in sequential computation
of affine transformations of polytopes, geometric sum of two polytopes, and
geometric difference of two polytopes (or, geometric difference first,
then geometric sum for minmax CLRS).
In the absence of disturbances the term $G(t-1)\VV(t-1)$ vanishes and
no geometric difference operation is performed.
Each operation of geometric sum or geometric difference for two polytopes
consists in finding the vertices of the resulting
polytope and calculating its convex hull.

This method is implemented in the \emph{Multi-Parametric Toolbox} (MPT) for
MATLAB \cite{morari04, mpt}.
Among its advantages are its simplicity, the fact that the reach sets
are computed exactly, and that it is easy to compute the distance between
two polytopes and to check whether two or more polytopes intersect, or whether
a polytope intersects a hyperplane or a halfspace.

However, the polytope method has its limitations.
The convex hull algorithm employed by MPT is based on the Double Description
method \cite{motzkin} and implemented in the \emph{CDD/CDD+} package \cite{cdd}.
Its complexity is $K^n$, where $K$ is the number of vertices and $n$ is the
state space dimension.
Hence, the use of MPT in general, is practical only for low dimensional systems,
or for systems with very special structure of matrices $A$, $B$ and $G$ that
ensure that the number of polytope vertices does not grow too much
with each time step.
But even in low dimensional systems the number of vertices in the reach set
polytope can grow very large with the number of time steps.
For example, consider the discrete-time linear time-invariant system
with $A(t)=A=\left[\begin{array}{cc}
\cos 1 & -\sin 1\\
\sin 1 & \cos 1\end{array}\right]$, $B(t)=I$, $G(t)=0$
$u_k \in \{u\in {\bf R}^2 ~|~ \|u\|_{\infty}\leq 1\}$, and
$x_0 \in \{x\in {\bf R}^2 ~|~ \|x\|_{\infty}\leq 1\}$.
Starting with a rectangular initial set, the number of vertices
of the reach set polytope is $4t + 4$ at the $t$-th step.












\subsection{d/dt}\label{subsec_ddt}
In $d/dt$ \cite{ddt}, the reach set of a discrete-time linear system
is approximated by unions of rectangular polytopes \cite{maler00}.
The algorithm works as follows.
First, given the set of initial conditions $\XX_0$ defined as a polytope
at time $t_0$, the evolution in time of the polytope's extreme points
is computed $\XX(\tau_1, t_0, \XX_0)$.
Second, the algorithm computes the convex hull of vertices of both,
the initial polytope $\XX_0$ and $\XX(\tau_1, t_0, \XX_0)$.
The resulting polytope is then bloated (magnified) to include
$\bigcup_{t_0\leq\tau\leq\tau_1}\XX(\tau, t_0, \XX_0)$.
Finally, this overapproximating polytope is in its
turn overapproximated by the union of rectangles.
The same procedure is repeated for the next time interval $[\tau_1, \tau_2]$,
and the union of both rectangular approximations is taken, and so on.

Rectangular polytopes are easy to represent and the number
of facets grows linearly with dimension, but a large number of rectangles
must be used to assure the approximation is not overly conservative.
Besides, the important part of this method is again the convex hull
calculation whose implementation relies on the same CDD/CDD+
library. This limits the dimension of the system and time interval
for which it is feasible to calculate the reach set.

$d/dt$ is implemented in C.













\subsection{Zonotope method}\label{subsec_zonotopes}
Polytopes can give arbitrarily close approximations to any convex set, but
the number of vertices can grow prohibitively large and, as
shown in \cite{avis}, the computation of a polytope by its convex hull becomes
intractable for large number of vertices in high dimensions.
Symmetric polytopes, called zonotopes \cite{zonotool}, could be a solution.

\bd[Zonotope]
A zonotope is a special class of polytopes of the form,
\[Z=\left\{x \in {\bf R}^n ~|~
x=c+\sum_{i=1}^k\alpha_ig_i,~ -1\leq\alpha_i\leq1\right\},\]
wherein $c$ and $g_1, ..., g_k$ are vectors in ${\bf R}^n$.
\label{def_zonotope}
\ed
Thus, a zonotope $Z$ is compactly represented by its center $c$ and
generator vectors $g_1, ..., g_k$.
The value $k/n$ is called the order of the zonotope.

The zonotope method for external approximation of reach sets of
discrete-time linear systems was introduced in \cite{girard05},
implemented in the \emph{MATISSE} package for MATLAB \cite{matisse},
and further discussed in \cite{girard06}.
In \cite{girard06} the authors introduce computational tricks that
work only for \emph{time-invariant} linear systems.
The advantage of zonotopes is that they are closed under the operations
of affine transformation and geometric sum, hence, the reach set
of a discrete-time linear system \ref{dtds1}, (\ref{linearrhs}), with
$\XX_0$ and $\UU(t)$, $t\geq t_0$, being zonotopes, is also zonotope.
Similar properties hold for the backward reach set.

The problem with using zonotopes is that with every time step the order of
the approximating zonotope increases by $k/n$.
This difficulty can be averted by limiting the number of generator vectors,
and overapproximating zonotopes whose number of generator vectors exceeds
this limit by lower order zonotopes.
This may affect the accuracy of the reach set approximation and
potentially destroy the semigroup property that is inherently present
in the zonotope method.

Further limitations of zonotopes are that geometric difference of two
zonotopes, intersections of zonotopes or zonotopes with hyperplanes or
halfspaces, are not zonotopes.
That presents a difficulty for the computation of reach sets for systems
with disturbances and hybrid systems.
Effective zonotope approximation algorithms for the geometric difference
and intersections are needed.
Currently, MATISSE does not provide a zonotope library in which these
operations are implemented.











\subsection{CheckMate}\label{subsec_checkmate}
CheckMate \cite{checkmate} is a MATLAB toolbox that
can evaluate specifications for trajectories starting from the
set of initial (continuous) states corresponding to the parameter values at
the vertices of the parameter set.
This provides preliminary insight into whether the specifications
will be true for all parameter values.
The method of oriented rectangluar polytopes for external approximation
of reach sets is introduced in \cite{krogh03}.
The basic idea is to construct an oriented rectangular hull of the reach set
for every time step, whose orientation is determined by the singular value
decomposition of the sample covariance matrix for the states reachable
from the vertices of the initial polytope.
The limitation of CheckMate
and the method of oriented rectangles is that only autonomous
(i.e., there is no control) systems are allowed, and only an external approximation
of the reach set is provided.

Currently, the development of CheckMate is discontinued.
Therefore, we refer the reader to \emph{PHAVer} \cite{phaver},
the newly developed verification tool that uses \emph{Parma Polyhedra
Library} (PPL) \cite{ppl} for its polyhedral computations.


















\subsection{Ellipsoidal method}\label{subsec_ellipsoids}
All the geometric methods for reach set computation described above,
namely polytopes, zonotopes, rectangular hulls and oriented rectangles
employ the notion of time step.
At every time step a certain algorithm runs producing a new reach set
for that time step.
This can work only for discrete-time systems.  The
ellipsoidal method  offers a different approach that works
for continuous- and discrete-time linear systems with disturbances,
with ellipsoidal constraints on the initial or target set, controls
and disturbances.
\bd[Ellipsoid]
The ellipsoid $\EE(q,Q)$ in ${\bf R}^n$ with  center $q$
and  shape matrix $Q$ is the set
\[\EE(q,Q) = \left\{ x \in {\bf R}^n
~|~ \langle (x-q), Q^{-1}(x-q)\rangle\leq1 \right\}, \]
wherein  $Q$ is positive definite ($Q=Q^T$ and $\langle x, Qx\rangle>0$
for all nonzero $x\in{\bf R}^n$).
\label{def_ellipsoid}
\ed
\bd[Support function]
The support function of a set $\XX\subseteq{\bf R}^n$ is
\[ \rho(l~|~\XX) = \sup_{x\in\XX} \langle l,x\rangle. \]
\label{def_supportfunction}
\ed
In particular, the support function of an ellipsoid is
\begin{equation}
\rho(l~|~\EE(q,Q)) = \langle l, q\rangle + \langle l, Ql\rangle^{1/2}.
\label{ellsupportfunction}
\end{equation}
We say that the ellipsoid $\EE$ \emph{tightly overapproximates} a
given convex set $\XX$ if there exist $l\in{\bf R}^n$ such that
\[ \rho(\pm l ~|~ \EE) = \rho(\pm l ~|~ \XX) \;\; \mbox{ and } \;\;
\XX \subseteq \EE. \]
We say that ellipsoid $\EE$ \emph{tightly underapproximates}
given convex set $\XX$ if there exist $l\in{\bf R}^n$ such that
\[ \rho(\pm l ~|~ \EE) = \rho(\pm l ~|~ \XX) \;\; \mbox{ and } \;\;
\EE \subseteq \XX. \]
The equality $\rho(\pm l ~|~ \EE) = \rho(\pm l ~|~ \XX)$ means that the
boundaries of $\EE$ and $\XX$ touch in directions $l$ and $-l$.

In \cite{kurvar00} the authors introduce parametrized families of external
and internal ellipsoids that tightly overapproximate and underapproximate
the reach set and derive the differential equations that
govern the evolution in time of the center and the shape matrices of
these ellipsoids.
The reach set is represented as the intersection of tight external
and as the union of tight internal ellipsoids.
In \cite{kurvar07} this result is extended to the discrete-time case
with special emphasis on systems with degenerate matrices $A(t)$.
In the next Section we present the equations that describe ellipsoidal
overapproximation and underapproximation of reach sets.

The ellipsoidal method provides the following benefits:
\begin{itemize}
\item Approximating the reach set of an $n$-dimensional discrete-time
linear system by $L$ ellipsoids over $t$ time steps requires
$t[L(8n^3 + 4n^2 + 2n) + 2n^2]$ scalar multiplications.
The computational complexity grows polynomially with the system dimension,
in contrast with the exponential growth of the polytope method complexity.
\item It is possible to refine the reach set approximation as much as needed
by adding more ellipsoids to the parameterized family.
Theoretically, it is possible to exactly represent the reach set of
linear system through both external and internal ellipsoids.
\item It is possible to single out individual external and internal
approximating ellipsoids that are optimal for a given criterion (e.g., trace,
volume, diameter), or a combination of such criteria.
\item For systems with no disturbance,
there are simple analytical expressions for control
sequences that steer the state to a desired target.
\end{itemize}
\emph{Ellipsoidal Toolbox} (ET) for MATLAB \cite{toolbox} implements
the reach set computations described here.











\subsection{Parallelotope method}\label{subsec_parallelotopes}
The parallelotope\footnote{Parallelotope is a zonotope with $n$
generator vectors in ${\bf R}^n$.} method \cite{kostousova01}
employs the idea of the ellipsoidal method to compute the reach sets
of linear systems.
The reach set is represented as the intersection of a parametrized family
of tight external, and the union of a parametrized family of tight internal
parallelotopes.
The evolution equations for the centers and
orientation matrices of both external and internal parallelotopes are
provided.
This method also finds controls that can drive the system to
the boundary points of the reach set, similarly to \cite{varaiya}
and \cite{kurvar00}.
The computation to solve the evolution equations for tight approximating
parallelotopes, however, is more involved than the one for ellipsoids, and in
the case of discrete-time systems this method does not deal with singular state
transition matrices.












\subsection{Other methods}\label{subsec_othermethods}
As was mentioned above, for certain verification problems computation
of reach sets can be avoided.
For example,
it may be enough ensure that for given set of initial conditions $\XX_0$,
the trajectories of system (\ref{ctds1}) never enter a given target set $\YY_1$.
In this case, the method of \emph{barrier certificates} \cite{prajna06}
may help.
The idea as well as the main difficulty is to find a Liapunov-like function
$C(x)$ such that
\begin{enumerate}
\item $C(x)>0$ in $\YY_1$;
\item $C(x)\leq0$ in $\XX_0$; and
\item $\langle D_xC(x), f(t, x, u)\rangle\leq0$ where $C(x)=0$.
\end{enumerate}
If such a function exists, system (\ref{ctds1}) is `safe' with respect to
the initial set $\XX_0$ and the target set $\YY_1$, i.e.,
system trajectories emanating from $\XX_0$ never reach $\YY_1$.

Another example for which reach sets need not be computed exactly occurs when
it is possible to ensure that for given initial set $\XX_0$ there
exist system trajectories that never leave $\XX_0$.
The set $\XX_0$ is said to be \emph{invariant} with respect
to those trajectories.

In \cite{racovic08} the authors show that for certain classes of
discrete-time dynamical systems with disturbances \ref{dtds2} and
certain initial sets $\XX_0$, convex constraints on controls and disturbances,
for every disturbance there exist closed-loop control strategies that 
keep the state of the system inside $\XX_0$.

For more information about invariant sets, we refer the reader to
the survey paper \cite{blanchini99} and references therein.



